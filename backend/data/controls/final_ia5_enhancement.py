#!/usr/bin/env python3
"""
Final comprehensive enhancement for IA-5(9) through IA-5(18).
Ensures all controls have >800 character guidance.
"""

import json
import datetime

def finalize_all_controls():
    """Complete enhancement of all IA-5 controls."""

    input_file = r"C:\Users\eclip\Desktop\nist-compliance-app-main\backend\data\controls\fixed\IA-5.json"
    with open(input_file, 'r', encoding='utf-8') as f:
        controls = json.load(f)

    timestamp = datetime.datetime.now(datetime.timezone.utc).isoformat()
    control_map = {c['control_id']: c for c in controls}

    # IA-5(13): Expiration of Cached Authenticators (if not already comprehensive)
    if len(control_map['IA-5.13']['non_technical_guidance']) < 800:
        control_map['IA-5.13'].update({
            "official_text": "Prohibit the use of cached authenticators after [Assignment: organization-defined time period].",
            "plain_english_explanation": "Systems sometimes cache authentication credentials (like Kerberos tickets or cached password hashes) to allow offline login or reduce authentication server load. This control requires configuring maximum lifetime for cached credentials to limit the window of vulnerability if a device is lost, stolen, or compromised.",
            "example_implementation": "Configure cached authenticator expiration: (1) Windows Group Policy: Maximum cached logons = 4, (2) Linux SSSD: offline_credentials_expiration = 1 day, (3) Kerberos: maximum ticket lifetime 10 hours, (4) Mobile MDM: offline authentication limit 8 hours, (5) Web sessions: token expiration 2-12 hours, (6) VPN: re-authentication every 12 hours.",
            "non_technical_guidance": "To comply with IA-5(13) Expiration of Cached Authenticators:\n1. Define expiration periods based on risk: HIGH systems 4-8 hours, MODERATE 12-24 hours, LOW 2-7 days.\n2. Configure credential caching timeouts on all platforms (Windows cached logons, Linux offline credentials, Kerberos tickets, VPN sessions).\n3. Balance security vs usability—shorter expiration provides better security but requires more frequent re-authentication.\n4. Consider operational scenarios: Mobile workers may require longer offline periods (24 hours) vs office workers (8 hours).\n5. Configure grace period notifications to warn users before cache expiration.\n6. Implement different timeouts by privilege level: Privileged accounts 4 hours maximum, standard users 24 hours.\n7. Test offline functionality to ensure users can work during cache validity period.\n8. Monitor for cache exploitation patterns (offline credential usage on stolen devices).\n9. For zero trust architectures: Minimize or eliminate credential caching entirely through always-on connectivity requirements.",
            "is_technical": True,
            "metadata": {"status": "implemented", "last_updated": timestamp, "has_scripts": False}
        })

    # IA-5(14): Managing Content of PKI Trust Stores
    if len(control_map['IA-5.14']['non_technical_guidance']) < 800:
        control_map['IA-5.14'].update({
            "official_text": "For PKI-based authentication, employ an organization-wide methodology for managing the content of PKI trust stores installed across all platforms, including networks, operating systems, browsers, and applications.",
            "plain_english_explanation": "Organizations using certificates for authentication must centrally manage which Certificate Authorities (CAs) are trusted across all systems. Uncontrolled trust store management leads to security risks—users might trust fraudulent certificates, expired CAs, or compromise CAs. Centralized trust store management ensures only approved CAs are trusted organization-wide, reducing certificate-based attacks.",
            "example_implementation": "Implement centralized PKI trust store management: (1) Deploy enterprise root CA certificates via Group Policy (Windows) or configuration management (Linux/Ansible). (2) Remove unauthorized public CAs from trust stores (browsers ship with 100+ CAs—prune to organizational requirements). (3) Configure automatic CRL/OCSP checking to detect revoked certificates. (4) Deploy certificate transparency monitoring to detect mis-issued certificates for organizational domains. (5) Use managed browser configurations (Chrome Enterprise, Firefox ESR with policy.json) to enforce trust store baselines. (6) Implement certificate pinning for critical applications (mobile apps, internal web services). (7) Monitor for trust store modifications via endpoint detection (EDR/SIEM alerts on certificate store changes).",
            "non_technical_guidance": "To comply with IA-5(14) Managing Content of PKI Trust Stores:\n1. Establish authoritative list of approved Certificate Authorities: Federal PKI root, organizational root CA, approved public CAs (DigiCert, IdenTrust for Let's Encrypt, Entrust).\n2. Deploy approved CA certificates to all platforms: Windows trust store via GPO, Linux ca-certificates package, macOS Keychain, mobile device trust stores via MDM.\n3. Remove unauthorized CAs from default trust stores: Operating systems ship with 100+ public CAs—many unnecessary for organizational use—prune to reduce attack surface.\n4. Implement centralized management tools: Microsoft Certificate Services, certmonger, or MDM certificate deployment.\n5. Configure automatic certificate validation: Enable CRL checking, deploy OCSP responders, configure certificate revocation checking in applications.\n6. Monitor for rogue certificates: Deploy certificate transparency monitoring (Google CT logs) to detect unauthorized certificates issued for organizational domains.\n7. Establish trust store change control: No unauthorized addition of CA certificates (malware often installs rogue root CAs for man-in-the-middle attacks).\n8. Document trust store baseline in system security plans.\n9. Audit trust stores quarterly: Scan endpoints for unauthorized CA certificates, verify approved CAs are present, check for expired certificates in trust stores.",
            "is_technical": True,
            "metadata": {"status": "implemented", "last_updated": timestamp, "has_scripts": False}
        })

    # IA-5(15): GSA-approved Products and Services
    if len(control_map['IA-5.15']['non_technical_guidance']) < 800:
        control_map['IA-5.15'].update({
            "official_text": "Use only General Services Administration-approved products and services for identity, credential, and access management.",
            "plain_english_explanation": "Federal agencies must use identity and access management products that have been evaluated and approved by GSA. This control applies primarily to federal government organizations and ensures procurement of vetted, secure identity solutions from the GSA Schedule 70 or other approved acquisition vehicles. Private sector organizations can interpret this as requiring formally evaluated/certified products (Common Criteria, FIPS 140, FIDO Certified).",
            "example_implementation": "For federal agencies: Procure identity solutions from GSA-approved sources: (1) GSA Schedule 70 for commercial identity products (Okta, Ping Identity, Microsoft licensing). (2) USAccess for PIV card enrollment and lifecycle services. (3) LOGIN.GOV for public-facing authentication services. (4) MAX.GOV Federal PKI Bridge CA for certificate services. (5) FedRAMP-authorized cloud identity services (Azure AD Government, AWS GovCloud IAM). For private sector: Use certified products (6) FIPS 140-2/140-3 validated cryptographic modules for credential storage, (7) FIDO Certified authenticators for phishing-resistant authentication, (8) Common Criteria evaluated IAM platforms.",
            "non_technical_guidance": "To comply with IA-5(15) GSA-approved Products and Services:\n1. For federal agencies: Consult GSA Schedule 70 (IT Schedule) for approved identity and access management vendors and products.\n2. Verify products are on GSA contract vehicles before procurement: Check GSA eBuy, GSA Advantage for product listings.\n3. For PIV/CAC credentials: Use USAccess shared service or approved PIV Service Providers (SPPs).\n4. For citizen authentication: Leverage LOGIN.GOV rather than building custom authentication infrastructure.\n5. For cloud services: Ensure FedRAMP authorization at appropriate impact level (Low/Moderate/High).\n6. Private sector interpretation: Procure products with formal security certifications (FIPS 140 cryptographic validation, Common Criteria EAL4+, FIDO Certification, PCI compliance for payment systems).\n7. Document procurement decisions in security authorization packages.\n8. Avoid custom-developed authentication systems—leverage commercial or government shared services where possible.\n9. For exceptions: Document risk acceptance if operational requirements necessitate non-approved products, implement compensating controls.",
            "is_technical": False,
            "metadata": {"status": "implemented", "last_updated": timestamp, "has_scripts": False}
        })

    # IA-5(16): In-person or Trusted External Party Authenticator Issuance
    if len(control_map['IA-5.16']['non_technical_guidance']) < 800:
        control_map['IA-5.16'].update({
            "official_text": "Require that the issuance of [Assignment: organization-defined types of and/or specific authenticators] be conducted [Assignment: organization-defined registration authority] with authorization by [Assignment: organization-defined personnel or roles].",
            "plain_english_explanation": "High-assurance authenticators (PIV cards, code signing certificates, privileged account credentials) require formal issuance procedures with in-person identity verification, designated registration authority approval, and authorization by appropriate officials. This prevents unauthorized individuals from obtaining powerful authenticators through social engineering or falsified documentation.",
            "example_implementation": "Establish formal authenticator issuance procedures: (1) PIV/CAC cards: In-person identity proofing with two forms of government-issued ID (passport + driver license), biometric capture, background check verification, security officer authorization. (2) Code signing certificates: Documented business justification, manager approval, registration authority verification, certificate pinned to specific developer identity. (3) Privileged account credentials: Formal access request ticket, role-based authorization workflow, least privilege review, time-limited issuance with automatic expiration. (4) Hardware tokens for executives: In-person issuance by IT security, signed acknowledgment of responsibility, inventory tracking. (5) All issuance events logged in centralized identity management system with approver details.",
            "non_technical_guidance": "To comply with IA-5(16) In-person or Trusted External Party Authenticator Issuance:\n1. Define authenticator types requiring formal issuance: PIV/CAC cards, code signing certificates, privileged account credentials, hardware security tokens, biometric enrollment.\n2. Designate registration authorities (RAs): Typically HR for employee credentials, IT security for privileged access, designated security personnel for contractors.\n3. Establish identity proofing requirements based on authenticator risk: High-value authenticators require in-person verification with two government-issued IDs, biometric enrollment, background check validation.\n4. Define authorization roles: Privileged credentials require CISO or designee approval, standard credentials require manager approval, temporary credentials require sponsor authorization.\n5. Implement issuance procedures: Scheduled appointments for in-person proofing, video verification acceptable for remote workers with notarized documentation, all issuance logged with approver identity.\n6. Create registration authority training program: RAs must understand identity proofing techniques, fraud detection, proper documentation.\n7. For remote/distributed workforce: Use trusted third-party identity proofing services (NIST AAL3-compliant services, notary services, approved partners).\n8. Implement compensating controls when in-person issuance impractical: Video verification with document authentication, biometric liveness checks, trusted introducer model.\n9. Audit issuance processes quarterly: Review authorization decisions, verify identity proofing documentation retained, check for policy violations.",
            "is_technical": False,
            "metadata": {"status": "implemented", "last_updated": timestamp, "has_scripts": False}
        })

    # IA-5(17): Presentation Attack Detection
    if len(control_map['IA-5.17']['non_technical_guidance']) < 800:
        control_map['IA-5.17'].update({
            "official_text": "Employ presentation attack detection mechanisms for biometric-based authentication.",
            "plain_english_explanation": "Biometric systems must include liveness detection to prevent spoofing attacks using photos, videos, masks, fake fingers, or other presentation attacks. Without liveness detection, an attacker could bypass facial recognition with a printed photo or fingerprint scanner with a gelatin fake finger. Presentation attack detection (PAD) verifies that the biometric sample comes from a live person present at authentication time.",
            "example_implementation": "Implement presentation attack detection for biometric systems: (1) Facial recognition: Deploy systems with certified liveness detection (Apple Face ID with infrared dot projector, Windows Hello with 3D cameras detecting depth). Require eye blink or random facial movement challenges. (2) Fingerprint: Use capacitive sensors detecting electrical properties of live skin (not optical sensors vulnerable to fake fingers). Require pulse detection or temperature sensing. (3) Iris recognition: Deploy systems with near-infrared illumination detecting live pupil response. (4) Voice biometrics: Implement challenge-response with random passphrases to prevent playback attacks. (5) Procure only PAD-certified biometric systems: FIPS 201 certified for federal PIV, iBeta Level 1/2 PAD certification for commercial systems.",
            "non_technical_guidance": "To comply with IA-5(17) Presentation Attack Detection for Biometric Authenticators:\n1. Procure biometric systems with certified presentation attack detection capabilities: FIPS 201 Appendix A certification for federal systems, iBeta PAD Level 1 or 2 certification for commercial systems.\n2. Configure liveness detection settings: Enable active challenges (eye blink, facial movement) not just passive liveness, require multiple biometric samples from different angles.\n3. Define PAD test requirements for vendor evaluation: Test against realistic attack vectors (printed photos, video playback, 3D masks, fake fingers), require demonstrated resistance to NIST-published attack techniques.\n4. Implement multimodal biometrics for high-security scenarios: Combine face + fingerprint to increase attack difficulty.\n5. Train users on proper biometric presentation: Correct positioning, adequate lighting, removal of accessories (glasses for some facial systems).\n6. Monitor for PAD failures: Excessive failed liveness checks may indicate attack attempts, trigger security alerts.\n7. Establish PAD testing cadence: Re-evaluate systems annually as new attack techniques emerge, update systems with latest PAD firmware.\n8. Plan for PAD false rejects: Legitimate users occasionally fail liveness checks—implement fallback authentication (PIN, backup biometric modality) without compromising security.\n9. Document PAD capabilities in security authorization packages: Specify PAD technique (active vs passive), certification level, tested attack resistance.",
            "is_technical": True,
            "metadata": {"status": "implemented", "last_updated": timestamp, "has_scripts": False}
        })

    # IA-5(18): Password Managers
    if len(control_map['IA-5.18']['non_technical_guidance']) < 800:
        control_map['IA-5.18'].update({
            "official_text": "For password-based authentication:\n(a) Employ [Assignment: organization-defined automated password managers]; and\n(b) Protect the passwords in the password managers using [Assignment: organization-defined safeguards].",
            "plain_english_explanation": "Organizations must provide approved password manager tools to help users create, store, and manage strong unique passwords for each system. Password managers eliminate the need to remember dozens of complex passwords, reducing password reuse and weak password selection. The master password or encryption keys protecting the password manager must be strongly safeguarded to prevent compromise of all stored credentials.",
            "example_implementation": "Deploy enterprise password manager with strong safeguards: (1) Procure enterprise-grade solution: 1Password Business/Enterprise, Bitwarden Enterprise, Keeper Enterprise, LastPass Enterprise. (2) Configure master password requirements: Minimum 16 characters, passphrase recommended, complexity enforced, no reuse of previous master passwords. (3) Enable MFA for password vault access: Hardware token (YubiKey) or biometric required in addition to master password. (4) Implement zero-knowledge architecture: Ensure vendor cannot access password vault contents (end-to-end encryption with client-side key derivation). (5) Configure password generation policies: Minimum 16 characters, random generation, avoid patterns. (6) Enable emergency access procedures: Designated recovery contacts, time-delayed access, approval workflows. (7) Deploy browser extensions and mobile apps with secure auto-fill configured. (8) Monitor vault access: Log all password retrievals, alert on anomalous access patterns.",
            "non_technical_guidance": "To comply with IA-5(18) Password Managers:\n1. Procure approved enterprise password manager: Evaluate 1Password, Bitwarden, Keeper, LastPass for enterprise features (centralized administration, audit logging, MFA enforcement, emergency access, SCIM provisioning).\n2. Define master password/passphrase requirements: Minimum 16-20 characters, recommend passphrase method (correct horse battery staple), enforce unique master password not used elsewhere.\n3. Mandate MFA for password vault access: Require hardware token (YubiKey) or biometric authentication in addition to master password, prohibit SMS-based MFA.\n4. Implement vault encryption safeguards: Verify zero-knowledge architecture (vendor cannot decrypt vaults), client-side key derivation (PBKDF2 100,000+ iterations or Argon2), AES-256 encryption.\n5. Train users on password manager usage: Generate random passwords for all accounts, enable auto-fill for convenience, never bypass password manager for important accounts, use secure password sharing feature for team credentials.\n6. Configure password complexity policies in manager: Auto-generated passwords minimum 16 characters, configurable per-site (some sites have maximum length limits).\n7. Implement emergency access procedures: Designate trusted contacts with time-delayed vault access (24-48 hours), require approval workflow, log all emergency access events.\n8. Monitor password manager adoption and usage: Track license utilization, identify users not using password manager, conduct training for low adoption teams.\n9. Plan for master password compromise: Implement rapid password rotation procedures, require immediate change of all passwords in vault if master password suspected compromised.",
            "is_technical": True,
            "metadata": {"status": "implemented", "last_updated": timestamp, "has_scripts": False}
        })

    # Additional enrichments for previously updated controls
    # IA-5(9): Federated Credential Management
    if len(control_map['IA-5.9']['non_technical_guidance']) < 800:
        control_map['IA-5.9'].update({
            "plain_english_explanation": "Instead of maintaining separate user accounts in every system, establish trust relationships with external identity providers to allow single sign-on across organizational boundaries. Users authenticate once with their home organization and can access resources at partner organizations without separate accounts.",
            "example_implementation": "Implement SAML/OIDC federation: (1) Azure AD Federation for Microsoft 365 and SaaS apps, (2) Okta/Ping Federation for third-party services, (3) InCommon/eduGAIN for research collaborations, (4) LOGIN.GOV for citizen services. Configure trust relationships, attribute release policies, step-up authentication rules.",
            "non_technical_guidance": "To comply with IA-5(9) Federated Credential Management:\n1. Identify business need for federation (partner collaborations, SaaS applications, inter-agency access).\n2. Vet external organizations before establishing trust: Assess security controls, review federation agreements, verify compliance certifications.\n3. Define approved external organizations for federation: Document specific partners and identity providers authorized for trust relationships.\n4. Establish federation technical standards: SAML 2.0 or OpenID Connect protocols, minimum AAL2 authentication assurance, certificate validation requirements.\n5. Configure identity provider (IdP) settings: Define user populations eligible for federation, attribute release policies (what user data is shared), session timeout configurations.\n6. Configure service provider (SP) settings: Trust only approved IdPs, validate digital signatures on assertions, implement appropriate authorization based on federated attributes.\n7. Document federation relationships in system security plans: List partners, data flows, security dependencies.\n8. Monitor federation audit logs: Track authentication events, detect anomalous patterns, alert on trust violations.\n9. Establish procedures for revoking federation trust: Response protocols if partner security is compromised, emergency trust termination processes.",
            "is_technical": True,
            "metadata": {"status": "implemented", "last_updated": timestamp, "has_scripts": False}
        })

    # IA-5(10): Dynamic Credential Binding
    if len(control_map['IA-5.10']['non_technical_guidance']) < 800:
        control_map['IA-5.10'].update({
            "plain_english_explanation": "Dynamically adjust authentication requirements based on context rather than using static authentication methods. Require stronger authentication (biometrics, hardware tokens) for high-risk scenarios (unknown device, suspicious location, sensitive data access) while allowing simpler authentication for low-risk contexts (known device, trusted network, routine operations).",
            "example_implementation": "Deploy adaptive authentication: Azure AD Conditional Access evaluates risk (impossible travel, leaked credentials, anonymous IP) and dynamically requires step-up authentication. Configure policies: Known device + corporate network = password only; Unknown device = password + hardware token + biometric. Integrate UEBA for anomaly detection.",
            "non_technical_guidance": "To comply with IA-5(10) Dynamic Credential Binding:\n1. Define risk-based authentication rules: Specify contexts requiring enhanced authentication (accessing PII, financial transactions, privileged operations, connections from untrusted networks).\n2. Implement adaptive authentication platform: Deploy Azure AD Conditional Access, Okta Adaptive MFA, Ping Intelligent SSO, or ForgeRock Intelligent Access.\n3. Configure contextual policies: Baseline authentication (password), Elevated risk (password + OTP), High risk (password + hardware token + biometric), Critical systems (smart card required).\n4. Integrate contextual signals: Device trust status (corporate-managed vs BYOD), network location (on-premises, VPN, public internet), user risk score (normal vs anomalous behavior), data classification (public, internal, confidential, restricted).\n5. Communicate dynamic authentication to users: Educate that additional authentication factors may be required based on access context.\n6. Tune policies based on telemetry: Monitor false positive rates (legitimate users blocked), false negative rates (risky access permitted), adjust thresholds to balance security and usability.\n7. Establish override procedures: Define processes for legitimate high-risk scenarios (executive international travel, emergency access during incidents).\n8. Document binding rules in security policies: Clearly specify what contexts trigger what authentication requirements.\n9. Implement continuous authentication: For zero trust environments, periodically re-evaluate user context during sessions and force re-authentication when risk changes.",
            "is_technical": True,
            "metadata": {"status": "implemented", "last_updated": timestamp, "has_scripts": False}
        })

    # IA-5(11): Hardware Token-based Authentication
    if len(control_map['IA-5.11']['non_technical_guidance']) < 800:
        control_map['IA-5.11'].update({
            "plain_english_explanation": "Use physical hardware authentication devices that meet quality standards for cryptographic strength and tamper resistance. Hardware tokens provide stronger security than passwords or software tokens because private keys cannot be extracted through malware or phishing attacks.",
            "example_implementation": "Deploy FIPS 140-2 Level 2 validated hardware tokens: YubiKey 5 Series for PIV and FIDO2, Titan Security Keys for FIDO U2F, PIV/CAC smart cards for federal systems, RSA SecurID for legacy OTP. Configure privileged accounts to require hardware token authentication, implement secure token lifecycle management.",
            "non_technical_guidance": "To comply with IA-5(11) Hardware Token-based Authentication:\n1. Define token quality requirements: FIPS 140-2 Level 2 minimum for cryptographic validation, FIPS 201 for federal PIV credentials, FIDO Certified for WebAuthn tokens.\n2. Procure certified hardware tokens: YubiKeys, Titan Keys, Feitian tokens, PIV-compliant smart cards from approved vendors.\n3. Establish secure issuance procedures: In-person identity verification before token distribution, signed user acknowledgment of responsibility, inventory tracking in asset management system.\n4. Deploy supporting infrastructure: Smart card readers on workstations, FIDO2-compatible browsers and applications, certificate enrollment services for PKI tokens.\n5. Configure authentication policies: Mandatory hardware tokens for privileged administrative accounts, remote access (VPN, SSH), systems processing HIGH confidentiality data.\n6. Train users on hardware token usage: Physical insertion/removal procedures, PIN entry security, protection from physical theft, immediate reporting of lost/stolen tokens.\n7. Implement redundancy: Issue two tokens per user (primary and backup), define secure backup token storage, enable backup authentication methods for token unavailability.\n8. Define token lifecycle: Validity periods (certificates typically 1-3 years), renewal procedures before expiration, revocation processes for lost/stolen/compromised tokens.\n9. Monitor for token anomalies: Detect suspicious usage patterns (token used from geographically impossible locations simultaneously suggests cloning attack), investigate authentication failures.",
            "is_technical": True,
            "metadata": {"status": "implemented", "last_updated": timestamp, "has_scripts": False}
        })

    # IA-5(12): Biometric Authentication Performance
    if len(control_map['IA-5.12']['non_technical_guidance']) < 800:
        control_map['IA-5.12'].update({
            "plain_english_explanation": "Biometric authentication systems must meet minimum accuracy thresholds balancing security (low false acceptance—system rarely accepts impostors) and usability (low false rejection—system rarely rejects legitimate users). Organizations define acceptable error rates based on system security requirements.",
            "example_implementation": "Deploy biometrics with defined performance: Windows Hello FAR ≤1:100,000 (one false accept per 100,000 attempts). iOS Face ID FAR 1:1,000,000. High-security iris scanners FAR 1:1,000,000. Configure liveness detection. Combine biometric + PIN for sensitive operations. Store templates in secure hardware (TPM, Secure Enclave).",
            "non_technical_guidance": "To comply with IA-5(12) Biometric Authentication Performance:\n1. Define biometric quality requirements by system classification: LOW systems FAR 1:10,000, MODERATE FAR 1:100,000, HIGH FAR 1:1,000,000 or better.\n2. Procure biometric systems meeting requirements: Verify vendor FAR/FRR specifications, require FIPS 201 compliance for federal systems, confirm independent testing results.\n3. Configure matching thresholds: Balance security (stricter matching = lower FAR but higher FRR = more false rejections) vs usability based on operational requirements.\n4. Implement liveness detection: Require certified presentation attack detection preventing photos/videos/masks/spoofs from defeating authentication.\n5. Establish enrollment procedures: Ensure high-quality biometric capture (proper lighting for facial recognition, clean fingers for fingerprint), capture multiple samples, provide user guidance on correct positioning.\n6. Consider multimodal biometrics for critical systems: Combine two or more biometric modalities (fingerprint AND face) to dramatically reduce FAR while maintaining acceptable FRR.\n7. Implement template protection: Store biometric templates encrypted in hardware security modules, never in cleartext software databases, protect transmission with TLS.\n8. Address privacy and consent: Obtain user consent for biometric collection, implement data minimization (store templates not raw images), define retention periods, provide opt-out alternatives.\n9. Plan for biometric compromise response: Unlike passwords, biometrics cannot be changed—establish revocation procedures, maintain alternative authentication methods, consider multimodal fallback if one modality compromised.",
            "is_technical": True,
            "metadata": {"status": "implemented", "last_updated": timestamp, "has_scripts": False}
        })

    return controls

def main():
    """Execute final enhancement."""
    controls = finalize_all_controls()

    output_file = r"C:\Users\eclip\Desktop\nist-compliance-app-main\backend\data\controls\fixed\IA-5.json"
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(controls, f, indent=2, ensure_ascii=False)

    # Statistics
    total = len(controls)
    with_scripts = sum(1 for c in controls if c['metadata']['has_scripts'])
    guidance_800 = sum(1 for c in controls if len(c.get('non_technical_guidance', '')) >= 800)
    guidance_500 = sum(1 for c in controls if len(c.get('non_technical_guidance', '')) >= 500)

    print(f"\n[COMPLETE] IA-5 Authenticator Management Family")
    print(f"  Total controls: {total}")
    print(f"  With implementation scripts: {with_scripts}")
    print(f"  With 800+ char guidance: {guidance_800}/{total}")
    print(f"  With 500+ char guidance: {guidance_500}/{total}")
    print(f"\n  Output: {output_file}")

    # Detailed breakdown
    print("\n  Control breakdown:")
    for c in controls:
        scripts_status = "FULL SCRIPTS" if c['metadata']['has_scripts'] else "GUIDANCE"
        guidance_len = len(c.get('non_technical_guidance', ''))
        print(f"    {c['control_id']:8} {guidance_len:4} chars  {scripts_status}")

if __name__ == "__main__":
    main()
