[
  {
    "control_id": "SR-1",
    "control_name": "Policy and Procedures",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "a. Develop, document, and disseminate to [Assignment: organization-defined personnel or roles]: 1. [Selection (one or more): organization-level; mission/business process-level; system-level] supply chain risk management policy that: (a) Addresses purpose, scope, roles, responsibilities, management commitment, coordination among organizational entities, and compliance; and (b) Is consistent with applicable laws, executive orders, directives, regulations, policies, standards, and guidelines; and 2. Procedures to facilitate the implementation of the supply chain risk management policy and the associated supply chain risk management controls; b. Designate an [Assignment: organization-defined official] to manage the development, documentation, and dissemination of the supply chain risk management policy and procedures; and c. Review and update the current supply chain risk management: 1. Policy [Assignment: organization-defined frequency] and following [Assignment: organization-defined events]; and 2. Procedures [Assignment: organization-defined frequency] and following [Assignment: organization-defined events].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "intent": "Establish documented policies and procedures to govern organizational supply chain risk management activities and ensure consistent implementation across all systems.",
    "rationale": "Supply chain risks represent a critical threat vector that can compromise the confidentiality, integrity, and availability of organizational systems through counterfeit components, malicious insertions, or compromised suppliers. Documented policies ensure consistent risk management approaches and clear accountability.",
    "ai_guidance": "Implementing SR-1 requires a structured approach to supply chain governance. Begin by drafting a comprehensive SCRM policy that defines the organizational risk tolerance for supply chain activities, establishes clear roles including a designated SCRM program manager, and specifies coordination requirements between acquisition, security, legal, and technical teams. The policy should address all lifecycle phases: research and development, design, manufacturing, acquisition, delivery, integration, operations, maintenance, and disposal. Develop supporting procedures that operationalize the policy, including supplier qualification processes, component verification requirements, incident response protocols for supply chain compromises, and documentation standards. Establish review cycles aligned with organizational risk assessment schedules, typically annually for policy and semi-annually for procedures. Ensure procedures address Software Bill of Materials (SBOM) requirements, supplier security assessment criteria, and integration with existing risk management frameworks. Map policy requirements to specific controls in the SR family and supply chain-related controls across other families such as SA-4, SA-9, and SA-12.",
    "plain_english_explanation": "This control requires organizations to create and maintain written rules about managing supply chain security. Think of it as establishing the ground rules for how your organization handles vendors, suppliers, and any external sources of software or hardware. The policy should explain who is responsible for supply chain security, what processes must be followed, and how the organization will ensure compliance. Procedures provide step-by-step instructions for implementing these rules. A designated official oversees the entire program, and everything must be reviewed and updated regularly or when significant changes occur.",
    "example_implementation": "Develop a Supply Chain Risk Management Policy document that covers purpose, scope, roles and responsibilities, and compliance requirements. Create accompanying procedures for supplier vetting, component verification, and incident response. Assign a Supply Chain Risk Management Officer and establish an annual review cycle.",
    "non_technical_guidance": "To implement SR-1: 1) Draft a comprehensive SCRM policy document addressing organizational supply chain security requirements; 2) Define clear roles and responsibilities for supply chain risk management; 3) Develop procedures for supplier assessment, component verification, and ongoing monitoring; 4) Designate an official responsible for the SCRM program; 5) Establish review cycles for policy (at least annually) and procedures (semi-annually recommended); 6) Coordinate with procurement, legal, security, and IT teams; 7) Ensure alignment with applicable regulations such as FAR, DFARS, and EO 14028.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "PM-9",
      "PM-30",
      "PS-8",
      "SI-12",
      "SA-4",
      "SA-9",
      "SA-12",
      "RA-3"
    ],
    "supplemental_guidance": "Supply chain risk management policy and procedures address controls in the SR family as well as supply chain-related controls in other families. Risk management strategy organizational policies and procedures are described in PM-9 and PM-30. Supply chain risk management strategy is described in PM-30. Organizations can use a common policy to address aspects of security and privacy policy, with clear identification of the scope, security/privacy point of contact, and compliance requirements. Organizations consider federal and organizational policy requirements when developing supply chain risk management policy. Security and privacy programs collaborate on the development of supply chain risk management policy. Events that may precipitate an update to supply chain risk management policy and procedures include assessment or audit findings, security incidents or breaches, or changes in applicable laws, executive orders, directives, regulations, policies, standards, and guidelines.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "stig_mappings": [],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires organizational policy documentation and procedures. No technical automation available. SR controls are new in NIST SP 800-53 Rev 5 and primarily governance-focused."
    }
  },
  {
    "control_id": "SR-2",
    "control_name": "Supply Chain Risk Management Plan",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "a. Develop a plan for managing supply chain risks associated with the research and development, design, manufacturing, acquisition, delivery, integration, operations and maintenance, and disposal of the following systems, system components, or system services: [Assignment: organization-defined systems, system components, or system services]; b. Review and update the supply chain risk management plan [Assignment: organization-defined frequency] or as required, to address threat, organizational, or environmental changes; and c. Protect the supply chain risk management plan from unauthorized disclosure and modification.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "intent": "Establish a comprehensive plan for identifying, assessing, responding to, and monitoring supply chain risks throughout the system development lifecycle.",
    "rationale": "Organizations increasingly depend on external providers for systems, components, and services, creating complex supply chains with multiple potential threat vectors. A documented SCRM plan ensures systematic identification and mitigation of risks from counterfeits, tampering, malicious insertions, and compromised manufacturing processes.",
    "ai_guidance": "Developing an effective SCRM plan requires addressing risks across all lifecycle phases. Structure the plan to include: (1) Scope definition identifying critical systems and components requiring SCRM coverage based on mission impact analysis; (2) Risk identification processes including threat modeling for supply chain attack vectors such as counterfeits, tampering, unauthorized production, poor manufacturing practices, intellectual property theft, and malicious code insertion; (3) Risk assessment methodologies quantifying likelihood and impact using organizational risk criteria; (4) Risk response strategies including avoidance, mitigation, transfer, and acceptance criteria with documented justifications; (5) Supplier tier analysis identifying critical dependencies, single points of failure, and geographic concentration risks; (6) SBOM requirements for all software components with vulnerability tracking integration; (7) Integration with enterprise risk management and acquisition processes including FAR/DFARS compliance; (8) Monitoring and continuous assessment procedures with defined metrics and reporting cadence; (9) Incident response protocols for supply chain compromises with notification requirements. The plan should express organizational risk tolerance, define acceptable supplier security requirements, and establish performance metrics. Protect the plan appropriately as it reveals organizational vulnerabilities and risk acceptance decisions. Align with NIST SP 800-161 C-SCRM guidance and applicable executive orders.",
    "plain_english_explanation": "This control requires a written plan specifically for managing risks from your supply chain - meaning all the vendors, suppliers, and contractors who provide software, hardware, or services to your organization. The plan should cover every phase from initial design through final disposal. It identifies which systems need the most protection, describes how you will assess suppliers for security risks, explains what you will do if a supply chain problem is discovered, and sets up ongoing monitoring. The plan must be kept current and protected since it contains sensitive information about your organization's vulnerabilities and risk decisions.",
    "example_implementation": "Create an SCRM Plan document that identifies critical systems, establishes supplier risk assessment procedures, defines acceptable supplier security requirements, specifies SBOM requirements, and outlines response procedures for supply chain incidents. Review and update the plan at least annually or when significant changes occur.",
    "non_technical_guidance": "To implement SR-2: 1) Identify all systems, components, and services requiring SCRM coverage based on criticality; 2) Document risk identification processes covering counterfeits, tampering, malicious code insertion, and manufacturing defects; 3) Establish risk assessment criteria and acceptable risk thresholds; 4) Define response strategies for identified risks; 5) Specify supplier security requirements and assessment procedures; 6) Integrate SBOM requirements for software acquisitions; 7) Establish monitoring and continuous assessment processes; 8) Define incident response procedures for supply chain compromises; 9) Classify and protect the SCRM plan appropriately; 10) Establish review cycles tied to threat environment changes.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "SR-2.1",
        "title": "Establish SCRM Team",
        "official_text": "Establish a supply chain risk management team consisting of [Assignment: organization-defined personnel, roles, and responsibilities] to lead and support the following SCRM activities: [Assignment: organization-defined supply chain risk management activities]."
      }
    ],
    "related_controls": [
      "CA-2",
      "CP-4",
      "IR-4",
      "MA-2",
      "MA-6",
      "PE-16",
      "PL-2",
      "PM-9",
      "PM-30",
      "RA-3",
      "RA-7",
      "SA-8",
      "SI-4"
    ],
    "supplemental_guidance": "The dependence on products, systems, and services from external providers, as well as the nature of the relationships with those providers, present an increasing level of risk to an organization. Threat actions that may increase security or privacy risks include unauthorized production, tampering or theft, insertion of counterfeits, and poor manufacturing and development practices in the supply chain. Supply chain risks can be endemic or systemic within a system element or component, a system, an organization, a sector, or the Nation. Managing supply chain risk is a complex, multifaceted undertaking that requires a coordinated effort across an organization, building trust relationships and communicating with internal and external stakeholders. Supply chain risk management (SCRM) activities include identifying and assessing risks, determining appropriate risk response actions, developing SCRM plans to document response actions, and monitoring performance against plans. The SCRM plan is tailored to the individual program, organization, and operational contexts. Supply chain risk assessments may be conducted at the organization level, mission/business level, or system level. NIST SP 800-161 provides guidance on supply chain risk management.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "stig_mappings": [],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires development of a comprehensive SCRM plan. Reference NIST SP 800-161 for detailed C-SCRM guidance. No technical automation available."
    }
  },
  {
    "control_id": "SR-2.1",
    "control_name": "Establish SCRM Team",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "parent_control": "SR-2",
    "official_text": "Establish a supply chain risk management team consisting of [Assignment: organization-defined personnel, roles, and responsibilities] to lead and support the following SCRM activities: [Assignment: organization-defined supply chain risk management activities].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "intent": "Create a dedicated cross-functional team with defined roles and responsibilities to coordinate and execute supply chain risk management activities.",
    "rationale": "Effective SCRM requires coordination across multiple organizational functions including acquisition, security, legal, engineering, and operations. A dedicated team ensures consistent application of SCRM practices and provides focal points for internal and external stakeholders.",
    "ai_guidance": "Establishing an effective SCRM team requires careful selection of personnel from key organizational functions and clear definition of roles. Include representatives from: acquisition/procurement (supplier relationships and contract management), information security (threat assessment and security requirements), legal/compliance (regulatory requirements and contract terms), systems engineering (technical evaluation and requirements), operations/maintenance (ongoing monitoring and incident response), and executive leadership (risk acceptance decisions). Define specific responsibilities including: conducting supplier risk assessments, developing and maintaining supplier security requirements, monitoring threat intelligence relevant to supply chain, coordinating incident response for supply chain compromises, maintaining SBOM repositories and vulnerability monitoring, and reporting to leadership on SCRM posture. The team should meet regularly (monthly recommended for high-criticality environments) and have clear escalation paths to executive decision-makers. Document team charter, membership, meeting cadence, and decision-making authority. Consider establishing tiered membership with core members and subject matter experts consulted as needed.",
    "plain_english_explanation": "This enhancement requires organizations to form a dedicated team responsible for managing supply chain security. The team should include people from different departments - procurement, security, legal, engineering, and management - since supply chain risks touch all these areas. Each team member should have clear responsibilities, such as reviewing supplier security practices, monitoring for supply chain threats, or coordinating responses when problems are discovered. The team works together to make sure supply chain security gets proper attention and that decisions are coordinated across the organization.",
    "example_implementation": "Establish an SCRM Team with representation from procurement, security, legal, engineering, and operations. Define team charter specifying roles, responsibilities, meeting frequency (monthly), and escalation procedures. Assign specific activities including supplier risk assessments, threat monitoring, SBOM management, and incident coordination.",
    "non_technical_guidance": "To implement SR-2.1: 1) Identify key organizational functions requiring representation on the SCRM team; 2) Select personnel with appropriate expertise and authority; 3) Define specific roles and responsibilities for each team member; 4) Document team charter including purpose, membership, meeting cadence, and decision authority; 5) Establish meeting schedule and communication protocols; 6) Define SCRM activities the team will lead such as supplier assessments, threat monitoring, and incident response; 7) Create escalation procedures to executive leadership; 8) Integrate team activities with enterprise risk management processes.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "PM-30",
      "SA-9",
      "SR-2",
      "SR-3"
    ],
    "supplemental_guidance": "Supply chain risk management teams may include personnel from acquisition, legal, supply chain management, security, privacy, engineering, information technology, system owners, and other organizational elements. Teams are tailored to specific programs, organizations, and operational contexts. The SCRM team serves as the focal point for supply chain risk management activities and coordinates with internal stakeholders and external partners including suppliers and service providers.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "stig_mappings": [],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control enhancement requires establishing a cross-functional SCRM team. No technical automation available."
    }
  },
  {
    "control_id": "SR-3",
    "control_name": "Supply Chain Controls and Processes",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "a. Establish a process or processes to identify and address weaknesses or deficiencies in the supply chain elements and processes of [Assignment: organization-defined systems or system components] in coordination with [Assignment: organization-defined supply chain personnel]; b. Employ the following controls to protect against supply chain risks to the system, system component, or system service and to limit the harm or consequences from supply chain-related events: [Assignment: organization-defined supply chain controls]; and c. Document the selected and implemented supply chain processes and controls in [Selection: security and privacy plans; supply chain risk management plan; [Assignment: organization-defined document]].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "intent": "Implement operational controls and processes to identify supply chain vulnerabilities, protect against supply chain risks, and document protective measures.",
    "rationale": "Supply chain elements span research, development, design, manufacturing, acquisition, delivery, integration, operations, maintenance, and disposal. Each phase presents opportunities for adversaries to introduce vulnerabilities or compromise components. Operational controls and processes provide active protection throughout the lifecycle.",
    "ai_guidance": "Implementing SR-3 requires establishing operational processes for supply chain protection. Key processes include: (1) Supplier qualification and continuous assessment - develop security questionnaires, require certifications (SOC 2, ISO 27001), and conduct periodic reviews; (2) Component verification - implement SBOM requirements, verify software signatures, validate hardware authenticity through authorized distributors; (3) Secure acquisition - use approved procurement channels, specify security requirements in contracts, require vulnerability disclosure; (4) Delivery verification - establish secure delivery protocols, verify package integrity, document chain of custody; (5) Integration controls - scan software for vulnerabilities before deployment, verify component configurations, test for malicious functionality; (6) Ongoing monitoring - subscribe to vendor security bulletins, monitor CVE databases for component vulnerabilities, maintain SBOM inventories for rapid impact assessment; (7) Incident response - define procedures for supply chain compromise notification and response. Document all controls in system security plans or dedicated SCRM documentation. Coordinate processes with procurement, security operations, and system owners.",
    "plain_english_explanation": "This control requires organizations to set up practical processes for protecting their supply chain. This means having methods to identify problems with suppliers or components, implementing specific security measures to reduce supply chain risks, and writing down what you are doing. For example, you might require suppliers to complete security questionnaires, verify that software has not been tampered with before installing it, or establish procedures for what to do if a supplier reports a security breach. Everything you do for supply chain protection needs to be documented so auditors can verify compliance and staff know what procedures to follow.",
    "example_implementation": "Establish supplier assessment processes including security questionnaires and certification requirements. Implement SBOM collection for all software acquisitions. Deploy software composition analysis tools to identify vulnerable components. Document all supply chain controls in the System Security Plan.",
    "non_technical_guidance": "To implement SR-3: 1) Identify critical supply chain elements for each system; 2) Develop supplier qualification criteria and assessment processes; 3) Establish component verification procedures (software signing, hardware authenticity); 4) Specify security requirements in acquisition contracts; 5) Implement SBOM requirements for software acquisitions; 6) Deploy vulnerability monitoring for acquired components; 7) Define secure delivery and integration procedures; 8) Establish incident response procedures for supply chain compromises; 9) Document all controls in security plans or SCRM documentation; 10) Coordinate with SCRM team and supply chain personnel.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "SR-3.1",
        "title": "Diverse Supply Base",
        "official_text": "Employ a diverse set of sources for the following system components and services: [Assignment: organization-defined system components and services]."
      },
      {
        "id": "SR-3.2",
        "title": "Limitation of Harm",
        "official_text": "Employ the following controls to limit harm from potential adversaries identifying and targeting the organizational supply chain: [Assignment: organization-defined controls]."
      },
      {
        "id": "SR-3.3",
        "title": "Sub-tier Flow Down",
        "official_text": "Ensure that the controls included in the contracts of prime contractors are also included in the contracts of subcontractors."
      }
    ],
    "related_controls": [
      "CA-2",
      "MA-2",
      "MA-6",
      "PE-3",
      "RA-3",
      "RA-7",
      "SA-2",
      "SA-3",
      "SA-4",
      "SA-5",
      "SA-8",
      "SA-9",
      "SA-10",
      "SA-15",
      "SC-7",
      "SC-29",
      "SC-30",
      "SC-38",
      "SI-7",
      "SR-2",
      "SR-4",
      "SR-5",
      "SR-6",
      "SR-9",
      "SR-10",
      "SR-11"
    ],
    "supplemental_guidance": "Supply chain elements include organizations, entities, or tools employed for the research and development, design, manufacturing, acquisition, delivery, integration, operations and maintenance, and disposal of systems, system components, or system services. Supply chain processes include hardware, software, and firmware development processes; shipping and handling procedures; personnel security and physical security programs; configuration management tools, techniques, and measures to maintain provenance; or other programs, processes, or procedures associated with the development, acquisition, maintenance and disposal of systems, system components, or system services. Supply chain elements and processes may be provided by organizations, system integrators, or external providers. Weaknesses or deficiencies in supply chain elements or processes represent potential vulnerabilities that can be exploited by adversaries to cause harm to the organization, organizational missions or business functions, individuals, other organizations, or the Nation. Supply chain personnel are individuals with roles and responsibilities in the supply chain.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "stig_mappings": [],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires establishing operational supply chain protection processes. Some aspects may benefit from technical tools such as SBOM analysis and vulnerability scanning."
    }
  },
  {
    "control_id": "SR-3.1",
    "control_name": "Diverse Supply Base",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "parent_control": "SR-3",
    "official_text": "Employ a diverse set of sources for the following system components and services: [Assignment: organization-defined system components and services].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Reduce single points of failure in the supply chain by maintaining multiple qualified suppliers for critical components and services.",
    "rationale": "Dependence on a single supplier creates concentration risk that can be exploited by adversaries or result in availability impacts from supplier failures, geopolitical events, or natural disasters. Diverse supply sources provide resilience and reduce leverage adversaries may gain from compromising a single supplier.",
    "ai_guidance": "Implementing supply chain diversity requires strategic planning and ongoing supplier management. Begin by identifying critical components and services where single-source dependency creates unacceptable risk - focus on components where compromise would have severe confidentiality, integrity, or availability impacts. For each critical item, identify and qualify alternative suppliers meeting security and quality requirements. Consider geographic diversity to mitigate regional risks (natural disasters, geopolitical events). Evaluate supplier independence - ensure alternative suppliers do not share common sub-tier dependencies that would negate diversity benefits. Maintain active relationships with multiple suppliers rather than paper qualifications that may not be exercisable when needed. Balance diversity benefits against increased complexity and potential cost impacts. Document supplier diversity strategy and qualification status. For software components, consider open source alternatives that reduce proprietary vendor lock-in. For hardware, evaluate domestic manufacturing options for highest-criticality components. Regularly reassess diversity posture as supplier landscapes evolve.",
    "plain_english_explanation": "This enhancement requires organizations to use multiple suppliers for critical components instead of depending on just one source. Think of it like not putting all your eggs in one basket. If you rely on a single vendor for critical software or hardware and that vendor gets compromised, goes out of business, or faces supply disruptions, your entire organization could be impacted. By qualifying and maintaining relationships with multiple suppliers, you create backup options and reduce the impact if any single supplier has problems. This is especially important for components that are critical to your mission.",
    "example_implementation": "Identify critical system components with single-source dependencies. Qualify and maintain relationships with at least two suppliers for each critical component category. Document supplier diversity strategy including qualification criteria and relationship maintenance requirements.",
    "non_technical_guidance": "To implement SR-3.1: 1) Inventory critical components and services currently sourced from single suppliers; 2) Assess risks from single-source dependencies including supply disruption and targeted compromise; 3) Identify and qualify alternative suppliers meeting security requirements; 4) Consider geographic diversity for regional risk mitigation; 5) Verify alternative suppliers do not share common sub-tier dependencies; 6) Establish and maintain active relationships with multiple qualified suppliers; 7) Balance diversity benefits against complexity and cost considerations; 8) Document supplier diversity strategy and qualification status; 9) Periodically reassess diversity posture as supplier landscapes change.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "RA-3",
      "RA-9",
      "SA-4",
      "SR-3"
    ],
    "supplemental_guidance": "Employing a diverse set of sources for system components and services can reduce single points of failure in the supply chain and provide flexibility when supply chain risks emerge. Organizations can establish diverse supply arrangements with the same supplier at different geographic locations or use different suppliers for the same critical component. Single points of failure can arise from development practices, manufacturing processes, shipping and handling procedures, personnel security, and physical security programs. Analysis of supply chain dependencies can help organizations identify single points of failure.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "stig_mappings": [],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control enhancement requires strategic supplier diversification. No technical automation available."
    }
  },
  {
    "control_id": "SR-3.2",
    "control_name": "Limitation of Harm",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "parent_control": "SR-3",
    "official_text": "Employ the following controls to limit harm from potential adversaries identifying and targeting the organizational supply chain: [Assignment: organization-defined controls].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Implement operational security measures to prevent adversaries from identifying and targeting organizational supply chain dependencies.",
    "rationale": "Adversaries conduct reconnaissance to identify supply chain dependencies as attack vectors. By limiting visibility into organizational supply chains and implementing protective measures, organizations reduce the likelihood of targeted supply chain attacks and limit impact when attacks occur.",
    "ai_guidance": "Limiting harm from supply chain targeting requires operational security (OPSEC) measures combined with technical and procedural controls. OPSEC measures include: limiting public disclosure of supplier relationships and critical dependencies; using non-attributable procurement channels for sensitive acquisitions; protecting acquisition planning documents and supplier contracts; limiting access to SCRM plans and supplier risk assessments. Technical controls include: segmenting networks to contain impact of compromised components; implementing defense-in-depth with multiple independent security layers; deploying integrity monitoring to detect tampering; using diverse vendors for security controls to prevent common-mode failures. Procedural controls include: compartmentalizing supply chain knowledge across organizational elements; varying procurement patterns to avoid predictability; establishing decoy procurement activities for highly targeted organizations. Impact limitation measures include: maintaining spare components from diverse sources; establishing rapid replacement capabilities; pre-positioning response resources; developing playbooks for supply chain compromise scenarios. Balance security measures against operational efficiency - excessive secrecy can impair coordination with legitimate partners.",
    "plain_english_explanation": "This enhancement focuses on making it harder for attackers to find and exploit your supply chain. It involves two aspects: hiding information about your suppliers and dependencies so adversaries cannot easily target them, and putting controls in place to limit damage if an attack does occur. For example, you might limit who knows about critical suppliers, use secure procurement methods that do not reveal sensitive relationships, segment your networks so a compromised component cannot access everything, and have backup plans ready in case a supplier is compromised. The goal is to make your supply chain a harder target and reduce the impact of any successful attacks.",
    "example_implementation": "Implement OPSEC measures limiting disclosure of critical supplier relationships. Segment networks to contain potential supply chain compromises. Deploy integrity monitoring on critical components. Maintain spare components from diverse sources for rapid replacement capability.",
    "non_technical_guidance": "To implement SR-3.2: 1) Identify supply chain information requiring protection from adversary reconnaissance; 2) Implement OPSEC measures limiting public disclosure of supplier relationships; 3) Protect procurement planning documents and supplier contracts; 4) Limit access to SCRM plans and supplier assessments on need-to-know basis; 5) Consider non-attributable procurement channels for sensitive acquisitions; 6) Segment networks to contain impact of compromised components; 7) Implement defense-in-depth with multiple independent security layers; 8) Maintain spare components and rapid replacement capabilities; 9) Develop response playbooks for supply chain compromise scenarios; 10) Balance security measures against operational coordination requirements.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "CP-2",
      "PL-8",
      "PM-30",
      "RA-3",
      "RA-9",
      "SA-8",
      "SC-7",
      "SC-29",
      "SC-30",
      "SC-38",
      "SR-3",
      "SR-7"
    ],
    "supplemental_guidance": "Controls to limit harm from potential adversaries identifying and targeting the organizational supply chain include limiting information exposure, establishing physical barriers, and employing deceptive techniques to obscure the supply chain. Organizations consider trade-offs between operational efficiency and supply chain security when determining which controls to employ.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "stig_mappings": [],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control enhancement requires OPSEC measures and harm limitation controls. May benefit from technical controls such as network segmentation and integrity monitoring."
    }
  },
  {
    "control_id": "SR-3.3",
    "control_name": "Sub-tier Flow Down",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "parent_control": "SR-3",
    "official_text": "Ensure that the controls included in the contracts of prime contractors are also included in the contracts of subcontractors.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Extend supply chain security requirements throughout the entire supplier hierarchy by requiring prime contractors to flow security requirements down to their subcontractors.",
    "rationale": "Modern supply chains involve multiple tiers of suppliers, with prime contractors often relying on subcontractors for components and services. Security requirements that only apply to prime contractors leave organizations exposed to risks from uncontrolled sub-tier suppliers. Flow-down requirements ensure consistent security throughout the supply chain.",
    "ai_guidance": "Implementing sub-tier flow-down requires contractual mechanisms and verification processes. Contract requirements should: explicitly require prime contractors to flow all security requirements to subcontractors handling covered systems or components; specify that flow-down applies to all tiers, not just immediate subcontractors; require prime contractors to maintain documentation of subcontractor compliance; grant organizational right to audit subcontractor compliance either directly or through prime contractor; require notification when prime contractors add new subcontractors to covered work; specify consequences for non-compliance including contract termination. Verification measures include: requiring prime contractors to certify subcontractor compliance periodically; reserving right to request evidence of subcontractor security controls; including subcontractor assessment in supplier risk evaluations; monitoring for unauthorized subcontracting. Consider practical limitations - excessive flow-down requirements may increase costs, limit competition, or be impractical for commodity components. Focus flow-down requirements on critical components and services where sub-tier risks are significant. Align with regulatory requirements such as DFARS 252.204-7012 which requires flow-down of cybersecurity requirements.",
    "plain_english_explanation": "This enhancement ensures that the security requirements you place on your direct suppliers also apply to their suppliers. In complex supply chains, your prime contractor might use dozens of subcontractors who actually make or handle sensitive components. If your security requirements only apply to the prime contractor, those subcontractors could introduce vulnerabilities. By requiring flow-down, you ensure that anyone touching your systems or data throughout the supply chain must meet the same security standards. This is especially important for defense and government contracts where regulations often mandate flow-down of specific security requirements.",
    "example_implementation": "Include contract clauses requiring prime contractors to flow security requirements to all subcontractors handling covered systems or components. Require prime contractors to maintain documentation of subcontractor compliance and provide access for verification. Reserve audit rights over subcontractor security practices.",
    "non_technical_guidance": "To implement SR-3.3: 1) Review current contracts for flow-down requirements; 2) Develop standard contract language requiring flow-down of security controls to subcontractors; 3) Specify that flow-down applies to all tiers, not just immediate subcontractors; 4) Require prime contractors to maintain subcontractor compliance documentation; 5) Reserve audit rights over subcontractor security practices; 6) Require notification when prime contractors add new subcontractors; 7) Define consequences for non-compliance with flow-down requirements; 8) Align with regulatory requirements such as DFARS cybersecurity flow-down clauses; 9) Focus flow-down on critical components where sub-tier risks are significant; 10) Balance comprehensive flow-down against cost and competitive impacts.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "SA-4",
      "SA-9",
      "SR-3",
      "SR-5",
      "SR-6"
    ],
    "supplemental_guidance": "The requirement to flow down supply chain controls to subcontractors ensures consistent application of supply chain security requirements throughout the supplier hierarchy. Organizations consider the nature of the products or services being acquired and the corresponding risk when determining appropriate flow-down requirements. Flow-down may be limited to specific security requirements most critical to organizational risk management. Organizations align flow-down requirements with applicable laws, regulations, and contractual requirements such as FAR and DFARS clauses.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "stig_mappings": [],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control enhancement requires contractual flow-down mechanisms. No technical automation available. Align with FAR/DFARS requirements as applicable."
    }
  },
  {
    "control_id": "SR-4",
    "control_name": "Provenance",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Document, monitor, and maintain valid provenance of the following systems, system components, and associated data: [Assignment: organization-defined systems, system components, and associated data].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Establish comprehensive tracking of the origin, development, ownership, and changes to systems and components throughout their lifecycle.",
    "rationale": "Provenance documentation enables organizations to verify the authenticity and integrity of system components, detect unauthorized modifications, and trace the chain of custody from manufacture through deployment. This is critical for identifying counterfeit or compromised components.",
    "ai_guidance": "Implement a comprehensive provenance tracking system that captures the complete lifecycle of system components from initial acquisition through final disposal. Establish formal procedures for documenting the origin of each component including manufacturer identity, supplier chain intermediaries, and delivery path verification. Maintain version control repositories and detailed change logs for all software components with timestamps and responsible parties. Deploy cryptographic hashing mechanisms such as SHA-256 to create immutable records of component states at key lifecycle transition points. Integrate with Software Bill of Materials (SBOM) generation tools like CycloneDX and SPDX to automate dependency tracking and provide machine-readable provenance data. For hardware assets, maintain serial number databases cross-referenced with manufacturer records and document chain of custody at each transfer point. Implement automated monitoring and alerting when provenance documentation is incomplete, inconsistent, or fails validation checks. Review provenance records systematically during security assessments, compliance audits, and incident investigations. Ensure procurement contracts with suppliers explicitly include provenance documentation requirements with specific deliverables. Establish data retention policies that preserve provenance records for the full component lifecycle plus applicable regulatory retention periods.",
    "plain_english_explanation": "Keep detailed records of where your systems, components, and data came from, who has handled them, and any changes made along the way. Think of it like a chain of custody for your IT assets - you should be able to trace any component back to its origin and document every hand it passed through.",
    "example_implementation": "Use version control systems and asset management databases to track changes and updates to your systems, components, and data, ensuring that you always have a valid record of their provenance. Implement SBOM generation for software dependencies.",
    "non_technical_guidance": "To comply with the Provenance control, establish a process for documenting, monitoring, and maintaining valid provenance of systems, system components, and associated data. This includes: 1) Documenting the origin, ownership, and history of all components. 2) Implementing change tracking for who made changes and when. 3) Regular reviews to ensure accuracy. 4) Access controls for change authorization. 5) Staff training on provenance importance.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "SR-4.1",
        "title": "Identity",
        "official_text": "Establish and maintain unique identification of the following supply chain elements, processes, and personnel associated with the identified system and critical system components: [Assignment: organization-defined supply chain elements, processes, and personnel]."
      },
      {
        "id": "SR-4.2",
        "title": "Track and Trace",
        "official_text": "Establish and maintain unique identification of the following systems and critical system components for tracking through the supply chain: [Assignment: organization-defined systems and critical system components]."
      },
      {
        "id": "SR-4.3",
        "title": "Validate as Genuine and Not Altered",
        "official_text": "Employ the following controls to validate that the system or system component received is genuine and has not been altered: [Assignment: organization-defined controls]."
      },
      {
        "id": "SR-4.4",
        "title": "Supply Chain Integrity - Pedigree",
        "official_text": "Employ [Assignment: organization-defined controls] and conduct [Assignment: organization-defined analysis] to ensure the integrity of the system and system components by validating the internal composition and provenance of critical or mission-essential technologies, products, and services."
      }
    ],
    "related_controls": [
      "CM-8",
      "IA-2",
      "IA-8",
      "MA-2",
      "MA-6",
      "PE-16",
      "SA-3",
      "SA-8",
      "SR-9",
      "SR-10",
      "SR-11"
    ],
    "supplemental_guidance": "Provenance encompasses the chronology of the origin, development, ownership, location, and changes to a system or system component and associated data. Organizations should establish procedures for allocating provenance responsibilities, transferring documentation between entities, and preventing unauthorized changes. The control addresses lifecycle integration and contractual incorporation of provenance tracking.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires organizational processes for provenance documentation. Technical tools like SBOM generators and asset management systems support implementation."
    }
  },
  {
    "control_id": "SR-4.1",
    "control_name": "Identity",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Establish and maintain unique identification of the following supply chain elements, processes, and personnel associated with the identified system and critical system components: [Assignment: organization-defined supply chain elements, processes, and personnel].",
    "parent_control": "SR-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Enable precise tracking and accountability throughout the supply chain by establishing unique identifiers for all relevant elements.",
    "rationale": "Unique identification of supply chain elements, processes, and personnel creates accountability and enables accurate tracking of components from origin to deployment. Without unique identifiers, organizations cannot effectively detect anomalies, investigate incidents, or verify the authenticity of components.",
    "ai_guidance": "Implement a comprehensive identification scheme covering all supply chain participants including suppliers, manufacturers, distributors, logistics providers, and internal personnel involved in acquisition and deployment. Assign globally unique identifiers to all procurement processes, contracts, purchase orders, and delivery events for complete traceability. Maintain a centralized registry linking each identifier to detailed records including contact information, security certifications, insurance coverage, and historical performance metrics. Adopt standardized identifier formats compatible with industry practices such as DUNS numbers for organizations, manufacturer part numbers for components, and employee identifiers with role designations for personnel. Integrate identification data with enterprise asset management, procurement systems, and configuration management databases to enable cross-functional visibility. Establish robust verification procedures when onboarding new supply chain participants including identity verification, background checks, and capability assessments. Document the identifier assignment process thoroughly including governance, approval workflows, and change management procedures. Maintain comprehensive audit trails of all identifier assignments, modifications, and deactivations. Coordinate identification schemes with key supply chain partners to ensure interoperability across organizational boundaries. Implement periodic audits to verify identifier accuracy and completeness.",
    "plain_english_explanation": "Give unique IDs to everyone and everything involved in your supply chain - suppliers, shipping processes, procurement staff, components, etc. This way you can precisely track who handled what, when, and where, making it easier to investigate if something goes wrong.",
    "example_implementation": "Implement a supply chain identity management system that assigns unique identifiers to all suppliers (using DUNS or similar), personnel (employee IDs with role designations), and processes (procurement order numbers, receiving ticket IDs).",
    "non_technical_guidance": "Create and maintain a master registry of all supply chain participants with unique identifiers. Document the identifier assignment process, ensure consistent use across all documentation, and regularly audit for completeness and accuracy.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "CM-8",
      "IA-2",
      "IA-4",
      "PE-16",
      "SA-4",
      "SR-4"
    ],
    "supplemental_guidance": "Unique identification enables accountability and traceability throughout the supply chain lifecycle. Organizations should coordinate identification schemes with supply chain partners to ensure interoperability.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires organizational processes for identity management within the supply chain. Asset management and procurement systems support implementation."
    }
  },
  {
    "control_id": "SR-4.2",
    "control_name": "Track and Trace",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Establish and maintain unique identification of the following systems and critical system components for tracking through the supply chain: [Assignment: organization-defined systems and critical system components].",
    "parent_control": "SR-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Enable end-to-end visibility of systems and components as they move through the supply chain from manufacture to deployment.",
    "rationale": "Track and trace capabilities allow organizations to verify the path taken by components through the supply chain, detect diversions or unauthorized handling, and support incident investigation. This is essential for detecting supply chain attacks and counterfeit components.",
    "ai_guidance": "Implement robust component tracking using persistent identifiers such as serial numbers, unique component identifiers, QR codes, or RFID tags that remain associated with components throughout their supply chain lifecycle from manufacture to deployment. Create a centralized tracking database or platform that records real-time location, custody transfers, and status changes for each tracked component with full audit capability. Establish mandatory check-in procedures at all receiving points and internal transfer points to update tracking records with timestamps and responsible parties. For software components and dependencies, implement Software Bill of Materials tracking using industry-standard tools like Syft, CycloneDX, or SPDX to document all direct and transitive dependencies with their exact versions and origins. Integrate tracking data with Configuration Management Databases to maintain accurate, up-to-date records of all deployed components. Implement automated alerting for anomalous tracking patterns such as unexpected locations, unauthorized custody changes, extended transit times, or missing check-ins. Retain tracking records for the complete component lifecycle plus applicable retention period to support audits and incident investigations. Consider implementing blockchain or distributed ledger technology for tamper-evident tracking records where high assurance is required. Establish clear escalation procedures when tracking anomalies are detected.",
    "plain_english_explanation": "Keep tabs on your critical systems and components as they move through the supply chain - from the manufacturer, through distributors, to your receiving dock. Use serial numbers, barcodes, or digital tracking to record each handoff so you always know where things came from and who handled them.",
    "example_implementation": "Implement barcode or RFID tracking for hardware components with check-in at each supply chain node. For software, generate SBOMs that track all dependencies from source through build to deployment.",
    "non_technical_guidance": "Establish tracking procedures for all critical components including receiving verification, custody documentation, and status updates. Train receiving personnel on tracking requirements and conduct regular audits of tracking records.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "CM-8",
      "PE-16",
      "SA-4",
      "SR-4",
      "SR-4.1"
    ],
    "supplemental_guidance": "Methods for uniquely identifying systems and components include labels or tags, and the tracking information includes the component location within the supply chain and custody transfers.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# SR-4.2: Track and Trace - SBOM Generation for Linux\n# Generates Software Bill of Materials for tracking software components\n\nset -euo pipefail\n\necho \"[SR-4.2] Track and Trace - SBOM Generation\"\necho \"============================================\"\n\n# Check for SBOM generation tools\nSBOM_TOOL=\"\"\nif command -v syft &>/dev/null; then\n    SBOM_TOOL=\"syft\"\nelif command -v cyclonedx-bom &>/dev/null; then\n    SBOM_TOOL=\"cyclonedx\"\nfi\n\nif [[ -z \"$SBOM_TOOL\" ]]; then\n    echo \"[WARNING] No SBOM generation tool found.\"\n    echo \"Install syft: curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin\"\n    echo \"Or cyclonedx-bom: pip install cyclonedx-bom\"\n    exit 1\nfi\n\n# Generate SBOM for installed packages\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\nOUTPUT_DIR=\"/var/log/sbom\"\nmkdir -p \"$OUTPUT_DIR\"\n\nif [[ \"$SBOM_TOOL\" == \"syft\" ]]; then\n    echo \"[INFO] Generating SBOM using Syft...\"\n    syft packages dir:/ -o cyclonedx-json > \"$OUTPUT_DIR/system_sbom_$TIMESTAMP.json\"\n    syft packages dir:/ -o spdx-json > \"$OUTPUT_DIR/system_sbom_$TIMESTAMP.spdx.json\"\n    echo \"[PASS] SBOM generated at $OUTPUT_DIR/system_sbom_$TIMESTAMP.json\"\nelif [[ \"$SBOM_TOOL\" == \"cyclonedx\" ]]; then\n    echo \"[INFO] Generating SBOM using CycloneDX...\"\n    if command -v pip &>/dev/null; then\n        cyclonedx-py environment -o \"$OUTPUT_DIR/python_sbom_$TIMESTAMP.json\" --format json 2>/dev/null || true\n    fi\n    echo \"[PASS] Python SBOM generated if pip packages exist\"\nfi\n\n# Track system package provenance\necho \"[INFO] Documenting package provenance...\"\nif command -v dpkg &>/dev/null; then\n    dpkg-query -W -f='${Package}\\t${Version}\\t${Maintainer}\\n' > \"$OUTPUT_DIR/dpkg_packages_$TIMESTAMP.txt\"\n    echo \"[PASS] Debian package list exported\"\nelif command -v rpm &>/dev/null; then\n    rpm -qa --queryformat '%{NAME}\\t%{VERSION}\\t%{VENDOR}\\n' > \"$OUTPUT_DIR/rpm_packages_$TIMESTAMP.txt\"\n    echo \"[PASS] RPM package list exported\"\nfi\n\necho \"[SR-4.2] Track and Trace documentation complete\"",
        "ansible": "---\n# SR-4.2: Track and Trace - Ansible Playbook\n# Implements software component tracking through SBOM generation\n\n- name: SR-4.2 Track and Trace Implementation\n  hosts: all\n  become: yes\n  vars:\n    sbom_output_dir: /var/log/sbom\n    timestamp: \"{{ ansible_date_time.iso8601_basic_short }}\"\n\n  tasks:\n    - name: Create SBOM output directory\n      file:\n        path: \"{{ sbom_output_dir }}\"\n        state: directory\n        mode: '0750'\n        owner: root\n        group: root\n\n    - name: Check if syft is installed\n      command: which syft\n      register: syft_check\n      ignore_errors: yes\n      changed_when: false\n\n    - name: Install syft if not present\n      shell: |\n        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin\n      when: syft_check.rc != 0\n\n    - name: Generate CycloneDX SBOM\n      shell: syft packages dir:/ -o cyclonedx-json > {{ sbom_output_dir }}/system_sbom_{{ timestamp }}.json\n      when: syft_check.rc == 0 or syft_check is changed\n\n    - name: Generate SPDX SBOM\n      shell: syft packages dir:/ -o spdx-json > {{ sbom_output_dir }}/system_sbom_{{ timestamp }}.spdx.json\n      when: syft_check.rc == 0 or syft_check is changed\n\n    - name: Document Debian packages (if applicable)\n      shell: dpkg-query -W -f='${Package}\\t${Version}\\t${Maintainer}\\n' > {{ sbom_output_dir }}/dpkg_packages_{{ timestamp }}.txt\n      when: ansible_os_family == 'Debian'\n      ignore_errors: yes\n\n    - name: Document RPM packages (if applicable)\n      shell: rpm -qa --queryformat '%{NAME}\\t%{VERSION}\\t%{VENDOR}\\n' > {{ sbom_output_dir }}/rpm_packages_{{ timestamp }}.txt\n      when: ansible_os_family == 'RedHat'\n      ignore_errors: yes\n\n    - name: Set secure permissions on SBOM files\n      file:\n        path: \"{{ sbom_output_dir }}\"\n        recurse: yes\n        mode: '0640'"
      },
      "windows": {
        "powershell": "# SR-4.2: Track and Trace - Windows PowerShell\n# Generates Software Bill of Materials for tracking software components\n\n#Requires -RunAsAdministrator\n\n$ErrorActionPreference = 'Continue'\n\nWrite-Host \"[SR-4.2] Track and Trace - SBOM Generation\" -ForegroundColor Cyan\nWrite-Host \"============================================\" -ForegroundColor Cyan\n\n$Timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$OutputDir = \"C:\\ProgramData\\SBOM\"\n\nif (-not (Test-Path $OutputDir)) {\n    New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null\n}\n\n# Document installed software\nWrite-Host \"[INFO] Documenting installed software...\" -ForegroundColor Yellow\n\n$InstalledSoftware = @()\n\n# Get software from registry (64-bit)\n$RegPath64 = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\"\n$Software64 = Get-ItemProperty $RegPath64 -ErrorAction SilentlyContinue | \n    Where-Object { $_.DisplayName } |\n    Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation\n\n# Get software from registry (32-bit on 64-bit OS)\n$RegPath32 = \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\"\n$Software32 = Get-ItemProperty $RegPath32 -ErrorAction SilentlyContinue | \n    Where-Object { $_.DisplayName } |\n    Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation\n\n$InstalledSoftware = $Software64 + $Software32 | Sort-Object DisplayName -Unique\n\n# Export to JSON (SBOM-like format)\n$SBOM = @{\n    bomFormat = \"ComponentList\"\n    specVersion = \"1.0\"\n    serialNumber = [guid]::NewGuid().ToString()\n    version = 1\n    metadata = @{\n        timestamp = (Get-Date).ToString(\"o\")\n        tools = @(@{vendor = \"Microsoft\"; name = \"PowerShell\"; version = $PSVersionTable.PSVersion.ToString()})\n        component = @{\n            type = \"operating-system\"\n            name = $env:COMPUTERNAME\n            version = [System.Environment]::OSVersion.VersionString\n        }\n    }\n    components = @($InstalledSoftware | ForEach-Object {\n        @{\n            type = \"application\"\n            name = $_.DisplayName\n            version = $_.DisplayVersion\n            publisher = $_.Publisher\n            properties = @(\n                @{name = \"installDate\"; value = $_.InstallDate}\n                @{name = \"installLocation\"; value = $_.InstallLocation}\n            )\n        }\n    })\n}\n\n$SBOM | ConvertTo-Json -Depth 10 | Out-File \"$OutputDir\\system_sbom_$Timestamp.json\" -Encoding UTF8\nWrite-Host \"[PASS] SBOM exported to $OutputDir\\system_sbom_$Timestamp.json\" -ForegroundColor Green\n\n# Export CSV for easier review\n$InstalledSoftware | Export-Csv \"$OutputDir\\installed_software_$Timestamp.csv\" -NoTypeInformation\nWrite-Host \"[PASS] Software list exported to $OutputDir\\installed_software_$Timestamp.csv\" -ForegroundColor Green\n\n# Document Windows features and roles\nWrite-Host \"[INFO] Documenting Windows features...\" -ForegroundColor Yellow\nGet-WindowsOptionalFeature -Online | Where-Object { $_.State -eq 'Enabled' } |\n    Select-Object FeatureName, State | \n    Export-Csv \"$OutputDir\\windows_features_$Timestamp.csv\" -NoTypeInformation\n\nWrite-Host \"[SR-4.2] Track and Trace documentation complete\" -ForegroundColor Green",
        "ansible": "---\n# SR-4.2: Track and Trace - Windows Ansible Playbook\n\n- name: SR-4.2 Track and Trace Implementation for Windows\n  hosts: windows\n  gather_facts: yes\n  vars:\n    sbom_output_dir: C:\\ProgramData\\SBOM\n    timestamp: \"{{ ansible_date_time.iso8601_basic_short }}\"\n\n  tasks:\n    - name: Create SBOM output directory\n      win_file:\n        path: \"{{ sbom_output_dir }}\"\n        state: directory\n\n    - name: Generate software inventory\n      win_shell: |\n        $Software = Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |\n          Where-Object { $_.DisplayName } |\n          Select-Object DisplayName, DisplayVersion, Publisher, InstallDate\n        $Software | ConvertTo-Json | Out-File {{ sbom_output_dir }}\\software_inventory_{{ timestamp }}.json\n      register: software_result\n\n    - name: Generate Windows features list\n      win_shell: |\n        Get-WindowsOptionalFeature -Online | Where-Object { $_.State -eq 'Enabled' } |\n          Select-Object FeatureName | ConvertTo-Json | \n          Out-File {{ sbom_output_dir }}\\windows_features_{{ timestamp }}.json"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Technical implementation through SBOM generation tools (Syft, CycloneDX) combined with organizational tracking procedures."
    }
  },
  {
    "control_id": "SR-4.3",
    "control_name": "Validate as Genuine and Not Altered",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Employ the following controls to validate that the system or system component received is genuine and has not been altered: [Assignment: organization-defined controls].",
    "parent_control": "SR-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Detect counterfeit or tampered components before they are integrated into systems.",
    "rationale": "Supply chain attacks often involve substituting counterfeit components or altering genuine components during transit. Validation controls including cryptographic hash verification and signature checking enable organizations to detect tampering before deployment, preventing compromised components from entering the operational environment.",
    "ai_guidance": "Implement comprehensive cryptographic validation for all software components using strong checksums such as SHA-256 or SHA-512 combined with digital signature verification before deployment. Verify all software downloads against official hashes published on vendor websites or in signed manifest files before installation or integration. For packages from distribution repositories, ensure GPG or equivalent signature verification is enabled and enforced with no exceptions for unauthenticated packages. Implement mandatory code signing requirements for all internally developed software using trusted certificate authorities and validate signatures as part of automated deployment pipelines. For hardware components, establish receiving inspection procedures that verify serial numbers against manufacturer databases, check for tamper-evident seal integrity, and inspect for physical signs of modification. Develop and maintain quarantine procedures for any components that fail validation checks with documented escalation paths for security review. Integrate validation checks into CI/CD pipelines and infrastructure-as-code deployment processes to ensure consistent enforcement. Document all validation activities, results, and exceptions with appropriate approval workflows for any validation overrides. Implement Software Composition Analysis tools to continuously validate component integrity and detect unauthorized modifications post-deployment. Establish supplier requirements for providing validation artifacts.",
    "plain_english_explanation": "Before installing any software or integrating hardware into your systems, verify that it is the genuine article and has not been tampered with. Check cryptographic signatures and hashes against known-good values from the vendor, and inspect hardware for signs of physical tampering.",
    "example_implementation": "Verify file hashes using SHA-256 checksums against vendor-published values. Enable GPG signature verification for package managers. Implement code signing for internal applications and validate signatures during deployment.",
    "non_technical_guidance": "Establish receiving inspection procedures that include verification of component authenticity. Document acceptable validation methods, train personnel on verification procedures, and maintain records of all validation activities.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "CM-8",
      "SA-12",
      "SI-7",
      "SR-4",
      "SR-9",
      "SR-10",
      "SR-11"
    ],
    "supplemental_guidance": "Controls for validating the authenticity of components include hash verification, digital signatures, certificates, and physical inspection. Organizations should document validation procedures and maintain records of validation activities.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# SR-4.3: Validate as Genuine and Not Altered\n# Implements cryptographic validation for software components\n\nset -euo pipefail\n\necho \"[SR-4.3] Validate as Genuine and Not Altered\"\necho \"==============================================\"\n\n# Function to verify file hash\nverify_hash() {\n    local file=\"$1\"\n    local expected_hash=\"$2\"\n    local algorithm=\"${3:-sha256}\"\n    \n    if [[ ! -f \"$file\" ]]; then\n        echo \"[FAIL] File not found: $file\"\n        return 1\n    fi\n    \n    local actual_hash\n    case \"$algorithm\" in\n        sha256) actual_hash=$(sha256sum \"$file\" | awk '{print $1}') ;;\n        sha512) actual_hash=$(sha512sum \"$file\" | awk '{print $1}') ;;\n        md5)    actual_hash=$(md5sum \"$file\" | awk '{print $1}') ;;\n        *)      echo \"[FAIL] Unknown algorithm: $algorithm\"; return 1 ;;\n    esac\n    \n    if [[ \"${actual_hash,,}\" == \"${expected_hash,,}\" ]]; then\n        echo \"[PASS] Hash verified for $file\"\n        return 0\n    else\n        echo \"[FAIL] Hash mismatch for $file\"\n        echo \"       Expected: $expected_hash\"\n        echo \"       Actual:   $actual_hash\"\n        return 1\n    fi\n}\n\n# Function to verify GPG signature\nverify_gpg_signature() {\n    local file=\"$1\"\n    local sig_file=\"${2:-$file.sig}\"\n    \n    if ! command -v gpg &>/dev/null; then\n        echo \"[WARNING] GPG not installed, skipping signature verification\"\n        return 1\n    fi\n    \n    if gpg --verify \"$sig_file\" \"$file\" 2>/dev/null; then\n        echo \"[PASS] GPG signature verified for $file\"\n        return 0\n    else\n        echo \"[FAIL] GPG signature verification failed for $file\"\n        return 1\n    fi\n}\n\n# Check package manager signature verification\necho \"[INFO] Checking package manager signature verification...\"\n\nif command -v apt-get &>/dev/null; then\n    # Debian/Ubuntu - check APT signature verification\n    if grep -rq \"^APT::Get::AllowUnauthenticated\" /etc/apt/apt.conf.d/ 2>/dev/null; then\n        echo \"[WARNING] APT signature verification may be disabled\"\n    else\n        echo \"[PASS] APT signature verification is enabled by default\"\n    fi\n    \n    # Verify repository keys\n    echo \"[INFO] Listing trusted APT keys:\"\n    apt-key list 2>/dev/null | head -20 || apt-key --keyring /etc/apt/trusted.gpg list 2>/dev/null | head -20 || echo \"[INFO] Using newer key management\"\nfi\n\nif command -v yum &>/dev/null || command -v dnf &>/dev/null; then\n    # RHEL/CentOS/Fedora - check GPG signature verification\n    GPGCHECK=$(grep -E \"^gpgcheck\\s*=\\s*1\" /etc/yum.conf 2>/dev/null || echo \"\")\n    if [[ -n \"$GPGCHECK\" ]]; then\n        echo \"[PASS] YUM/DNF GPG signature verification is enabled\"\n    else\n        echo \"[WARNING] YUM/DNF GPG verification may not be enforced globally\"\n    fi\n    \n    # Check repo configs\n    REPOS_WITHOUT_GPG=$(grep -l \"gpgcheck=0\" /etc/yum.repos.d/*.repo 2>/dev/null || echo \"\")\n    if [[ -n \"$REPOS_WITHOUT_GPG\" ]]; then\n        echo \"[WARNING] Some repositories have GPG check disabled:\"\n        echo \"$REPOS_WITHOUT_GPG\"\n    fi\nfi\n\n# Verify critical system binaries integrity\necho \"[INFO] Verifying critical binary integrity using package manager...\"\nif command -v rpm &>/dev/null; then\n    echo \"[INFO] Running RPM verification on critical packages...\"\n    rpm -V coreutils bash openssl 2>/dev/null || echo \"[INFO] Some files may have been modified (review above)\"\nfi\n\nif command -v debsums &>/dev/null; then\n    echo \"[INFO] Running debsums verification on critical packages...\"\n    debsums -c coreutils bash openssl 2>/dev/null || echo \"[INFO] Install debsums for Debian package verification\"\nfi\n\necho \"[SR-4.3] Validation checks complete\"\necho \"\"\necho \"Usage examples:\"\necho \"  verify_hash /path/to/file.tar.gz abc123... sha256\"\necho \"  verify_gpg_signature /path/to/file.tar.gz /path/to/file.tar.gz.asc\"",
        "ansible": "---\n# SR-4.3: Validate as Genuine and Not Altered - Ansible Playbook\n\n- name: SR-4.3 Component Validation Implementation\n  hosts: all\n  become: yes\n  vars:\n    validation_log_dir: /var/log/component-validation\n\n  tasks:\n    - name: Create validation log directory\n      file:\n        path: \"{{ validation_log_dir }}\"\n        state: directory\n        mode: '0750'\n\n    - name: Ensure GPG is installed\n      package:\n        name: gnupg\n        state: present\n\n    - name: Enable YUM/DNF GPG checking (RHEL/CentOS)\n      lineinfile:\n        path: /etc/yum.conf\n        regexp: '^gpgcheck='\n        line: 'gpgcheck=1'\n        state: present\n      when: ansible_os_family == 'RedHat'\n\n    - name: Enable repo_gpgcheck for YUM (RHEL/CentOS)\n      lineinfile:\n        path: /etc/yum.conf\n        regexp: '^repo_gpgcheck='\n        line: 'repo_gpgcheck=1'\n        state: present\n      when: ansible_os_family == 'RedHat'\n      ignore_errors: yes\n\n    - name: Find repos with GPG disabled\n      find:\n        paths: /etc/yum.repos.d/\n        patterns: '*.repo'\n        contains: 'gpgcheck=0'\n      register: insecure_repos\n      when: ansible_os_family == 'RedHat'\n\n    - name: Report insecure repos\n      debug:\n        msg: \"WARNING: Repository has GPG check disabled: {{ item.path }}\"\n      loop: \"{{ insecure_repos.files | default([]) }}\"\n      when: ansible_os_family == 'RedHat' and insecure_repos.files | length > 0\n\n    - name: Install debsums for package verification (Debian)\n      apt:\n        name: debsums\n        state: present\n      when: ansible_os_family == 'Debian'\n\n    - name: Run RPM verification on critical packages\n      shell: rpm -V coreutils bash openssl 2>&1 | tee {{ validation_log_dir }}/rpm_verify_{{ ansible_date_time.date }}.log\n      register: rpm_verify\n      failed_when: false\n      changed_when: false\n      when: ansible_os_family == 'RedHat'\n\n    - name: Run debsums verification on critical packages\n      shell: debsums -c 2>&1 | tee {{ validation_log_dir }}/debsums_{{ ansible_date_time.date }}.log\n      register: debsums_verify\n      failed_when: false\n      changed_when: false\n      when: ansible_os_family == 'Debian'"
      },
      "windows": {
        "powershell": "# SR-4.3: Validate as Genuine and Not Altered - Windows PowerShell\n# Implements cryptographic validation for software components\n\n#Requires -RunAsAdministrator\n\n$ErrorActionPreference = 'Continue'\n\nWrite-Host \"[SR-4.3] Validate as Genuine and Not Altered\" -ForegroundColor Cyan\nWrite-Host \"==============================================\" -ForegroundColor Cyan\n\n# Function to verify file hash\nfunction Test-FileHashMatch {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$FilePath,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$ExpectedHash,\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('SHA256','SHA384','SHA512','MD5')]\n        [string]$Algorithm = 'SHA256'\n    )\n    \n    if (-not (Test-Path $FilePath)) {\n        Write-Host \"[FAIL] File not found: $FilePath\" -ForegroundColor Red\n        return $false\n    }\n    \n    $ActualHash = (Get-FileHash -Path $FilePath -Algorithm $Algorithm).Hash\n    \n    if ($ActualHash -eq $ExpectedHash.ToUpper()) {\n        Write-Host \"[PASS] Hash verified for $FilePath\" -ForegroundColor Green\n        return $true\n    } else {\n        Write-Host \"[FAIL] Hash mismatch for $FilePath\" -ForegroundColor Red\n        Write-Host \"       Expected: $ExpectedHash\" -ForegroundColor Yellow\n        Write-Host \"       Actual:   $ActualHash\" -ForegroundColor Yellow\n        return $false\n    }\n}\n\n# Function to verify Authenticode signature\nfunction Test-AuthenticodeValid {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$FilePath\n    )\n    \n    if (-not (Test-Path $FilePath)) {\n        Write-Host \"[FAIL] File not found: $FilePath\" -ForegroundColor Red\n        return $false\n    }\n    \n    $Signature = Get-AuthenticodeSignature -FilePath $FilePath\n    \n    switch ($Signature.Status) {\n        'Valid' {\n            Write-Host \"[PASS] Valid Authenticode signature: $FilePath\" -ForegroundColor Green\n            Write-Host \"       Signer: $($Signature.SignerCertificate.Subject)\" -ForegroundColor Gray\n            return $true\n        }\n        'NotSigned' {\n            Write-Host \"[WARNING] File is not signed: $FilePath\" -ForegroundColor Yellow\n            return $false\n        }\n        default {\n            Write-Host \"[FAIL] Invalid signature ($($Signature.Status)): $FilePath\" -ForegroundColor Red\n            Write-Host \"       Message: $($Signature.StatusMessage)\" -ForegroundColor Yellow\n            return $false\n        }\n    }\n}\n\n# Verify Windows Update signature settings\nWrite-Host \"`n[INFO] Checking Windows Update signature verification...\" -ForegroundColor Yellow\ntry {\n    $WUSettings = Get-ItemProperty -Path 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate' -ErrorAction SilentlyContinue\n    if ($null -eq $WUSettings) {\n        Write-Host \"[PASS] Windows Update using default (signed) settings\" -ForegroundColor Green\n    }\n} catch {\n    Write-Host \"[PASS] Windows Update using default secure configuration\" -ForegroundColor Green\n}\n\n# Check PowerShell execution policy\nWrite-Host \"`n[INFO] Checking PowerShell execution policy...\" -ForegroundColor Yellow\n$ExecPolicy = Get-ExecutionPolicy\nswitch ($ExecPolicy) {\n    'AllSigned' {\n        Write-Host \"[PASS] PowerShell requires all scripts to be signed\" -ForegroundColor Green\n    }\n    'RemoteSigned' {\n        Write-Host \"[INFO] PowerShell requires remote scripts to be signed\" -ForegroundColor Cyan\n    }\n    'Unrestricted' {\n        Write-Host \"[WARNING] PowerShell execution policy is Unrestricted\" -ForegroundColor Yellow\n    }\n    'Bypass' {\n        Write-Host \"[WARNING] PowerShell execution policy is Bypass\" -ForegroundColor Yellow\n    }\n    default {\n        Write-Host \"[INFO] PowerShell execution policy: $ExecPolicy\" -ForegroundColor Cyan\n    }\n}\n\n# Verify critical Windows binaries\nWrite-Host \"`n[INFO] Verifying signatures on critical system files...\" -ForegroundColor Yellow\n$CriticalFiles = @(\n    \"$env:SystemRoot\\System32\\kernel32.dll\",\n    \"$env:SystemRoot\\System32\\ntdll.dll\",\n    \"$env:SystemRoot\\System32\\cmd.exe\",\n    \"$env:SystemRoot\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\"\n)\n\nforeach ($File in $CriticalFiles) {\n    if (Test-Path $File) {\n        Test-AuthenticodeValid -FilePath $File | Out-Null\n    }\n}\n\n# Check for unsigned drivers\nWrite-Host \"`n[INFO] Checking for unsigned drivers...\" -ForegroundColor Yellow\n$Drivers = Get-WmiObject Win32_PnPSignedDriver | Where-Object { $_.IsSigned -eq $false }\nif ($Drivers) {\n    Write-Host \"[WARNING] Found unsigned drivers:\" -ForegroundColor Yellow\n    $Drivers | Select-Object DeviceName, DriverVersion | Format-Table\n} else {\n    Write-Host \"[PASS] All PnP drivers are signed\" -ForegroundColor Green\n}\n\nWrite-Host \"`n[SR-4.3] Validation checks complete\" -ForegroundColor Green\nWrite-Host \"`nUsage examples:\" -ForegroundColor Cyan\nWrite-Host '  Test-FileHashMatch -FilePath \"C:\\file.exe\" -ExpectedHash \"ABC123...\" -Algorithm SHA256'\nWrite-Host '  Test-AuthenticodeValid -FilePath \"C:\\file.exe\"'",
        "ansible": "---\n# SR-4.3: Validate as Genuine and Not Altered - Windows Ansible Playbook\n\n- name: SR-4.3 Component Validation for Windows\n  hosts: windows\n  gather_facts: yes\n  vars:\n    validation_log_dir: C:\\ProgramData\\ComponentValidation\n\n  tasks:\n    - name: Create validation log directory\n      win_file:\n        path: \"{{ validation_log_dir }}\"\n        state: directory\n\n    - name: Check PowerShell execution policy\n      win_shell: Get-ExecutionPolicy\n      register: exec_policy\n      changed_when: false\n\n    - name: Report execution policy\n      debug:\n        msg: \"PowerShell execution policy is: {{ exec_policy.stdout_lines[0] }}\"\n\n    - name: Verify critical system file signatures\n      win_shell: |\n        $results = @()\n        $files = @(\n          \"$env:SystemRoot\\System32\\kernel32.dll\",\n          \"$env:SystemRoot\\System32\\ntdll.dll\",\n          \"$env:SystemRoot\\System32\\cmd.exe\"\n        )\n        foreach ($file in $files) {\n          $sig = Get-AuthenticodeSignature -FilePath $file\n          $results += [PSCustomObject]@{\n            File = $file\n            Status = $sig.Status\n            Signer = $sig.SignerCertificate.Subject\n          }\n        }\n        $results | ConvertTo-Json\n      register: sig_check\n\n    - name: Check for unsigned drivers\n      win_shell: |\n        Get-WmiObject Win32_PnPSignedDriver | \n          Where-Object { $_.IsSigned -eq $false } | \n          Select-Object DeviceName, DriverVersion | \n          ConvertTo-Json\n      register: unsigned_drivers\n      changed_when: false\n\n    - name: Report unsigned drivers\n      debug:\n        msg: \"WARNING: Unsigned drivers found\"\n      when: unsigned_drivers.stdout | length > 2"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Technical implementation through cryptographic hash verification and digital signature validation."
    }
  },
  {
    "control_id": "SR-4.4",
    "control_name": "Supply Chain Integrity - Pedigree",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Employ [Assignment: organization-defined controls] and conduct [Assignment: organization-defined analysis] to ensure the integrity of the system and system components by validating the internal composition and provenance of critical or mission-essential technologies, products, and services.",
    "parent_control": "SR-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Ensure critical systems contain only authorized, verified components by validating their complete pedigree.",
    "rationale": "Advanced supply chain attacks can compromise components at the source or during manufacture. Validating the complete pedigree - including internal composition and the full chain of custody from origin - provides defense in depth against sophisticated supply chain threats targeting mission-essential systems.",
    "ai_guidance": "Implement comprehensive Software Composition Analysis tooling to map all components within critical systems including direct dependencies, transitive dependencies, and embedded libraries with their complete provenance chain. Generate and validate Software Bills of Materials in standard formats such as CycloneDX, SPDX, or SWID tags for all deployments of mission-essential systems. Verify component origins against known-good sources and authoritative registries, checking for known vulnerabilities using databases like NVD, OSV, GitHub Advisory, and commercial vulnerability intelligence feeds. For high-assurance systems, conduct binary analysis to verify that compiled code matches expected source through techniques like reproducible builds or binary comparison. Implement build provenance verification using frameworks like SLSA to ensure code was built from expected source in trusted build environments. Establish and maintain trusted build environments with controlled access, audit logging, and verified toolchains for mission-critical software. Document the complete supply chain for all mission-essential components including all tiers of suppliers, build processes, and distribution channels. Conduct periodic audits comparing actual deployed component composition against approved baselines with automated drift detection. Integrate pedigree validation into CI/CD pipelines with gates that prevent deployment of components with incomplete or suspicious provenance.",
    "plain_english_explanation": "For your most critical systems, go beyond basic verification to validate the complete history and composition of every component. Know not just where it came from, but what is inside it, verify it matches what it should be, and confirm it has not been compromised at any point in its history.",
    "example_implementation": "Use SCA tools to generate complete SBOMs including transitive dependencies. Compare deployed components against approved baselines. Implement SLSA-compliant build processes for internally developed software.",
    "non_technical_guidance": "Establish procedures for validating the composition and pedigree of critical components. Require suppliers to provide SBOMs and build provenance documentation. Conduct regular audits comparing actual system composition against approved baselines.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "CM-8",
      "SA-10",
      "SA-12",
      "SI-7",
      "SR-4",
      "SR-4.3"
    ],
    "supplemental_guidance": "Pedigree validation ensures system integrity by verifying the internal composition and complete provenance chain. This is particularly important for critical or mission-essential technologies where supply chain compromise could have severe impact.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# SR-4.4: Supply Chain Integrity - Pedigree Validation\n# Implements comprehensive component analysis and SBOM validation\n\nset -euo pipefail\n\necho \"[SR-4.4] Supply Chain Integrity - Pedigree Validation\"\necho \"======================================================\"\n\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\nOUTPUT_DIR=\"/var/log/pedigree-validation\"\nmkdir -p \"$OUTPUT_DIR\"\n\n# Check for required tools\ncheck_tool() {\n    if command -v \"$1\" &>/dev/null; then\n        echo \"[PASS] $1 is installed\"\n        return 0\n    else\n        echo \"[WARNING] $1 is not installed\"\n        return 1\n    fi\n}\n\necho \"[INFO] Checking for pedigree validation tools...\"\ncheck_tool syft || true\ncheck_tool grype || true\ncheck_tool trivy || true\n\n# Generate comprehensive SBOM\nif command -v syft &>/dev/null; then\n    echo \"\"\n    echo \"[INFO] Generating comprehensive SBOM with Syft...\"\n    \n    # Generate CycloneDX format (industry standard)\n    syft packages dir:/ -o cyclonedx-json > \"$OUTPUT_DIR/full_system_sbom_$TIMESTAMP.cyclonedx.json\" 2>/dev/null || \\\n        echo \"[WARNING] Full system scan failed, trying /usr only\"\n    \n    syft packages dir:/usr -o cyclonedx-json > \"$OUTPUT_DIR/usr_sbom_$TIMESTAMP.cyclonedx.json\" 2>/dev/null\n    \n    # Generate SPDX format\n    syft packages dir:/usr -o spdx-json > \"$OUTPUT_DIR/usr_sbom_$TIMESTAMP.spdx.json\" 2>/dev/null\n    \n    echo \"[PASS] SBOM generated in CycloneDX and SPDX formats\"\nfi\n\n# Vulnerability scanning for pedigree validation\nif command -v grype &>/dev/null; then\n    echo \"\"\n    echo \"[INFO] Scanning SBOM for known vulnerabilities...\"\n    \n    if [[ -f \"$OUTPUT_DIR/usr_sbom_$TIMESTAMP.cyclonedx.json\" ]]; then\n        grype sbom:\"$OUTPUT_DIR/usr_sbom_$TIMESTAMP.cyclonedx.json\" -o table > \"$OUTPUT_DIR/vulnerability_report_$TIMESTAMP.txt\" 2>/dev/null || true\n        grype sbom:\"$OUTPUT_DIR/usr_sbom_$TIMESTAMP.cyclonedx.json\" -o json > \"$OUTPUT_DIR/vulnerability_report_$TIMESTAMP.json\" 2>/dev/null || true\n        echo \"[PASS] Vulnerability scan complete\"\n        \n        # Summary\n        CRITICAL=$(grep -c '\"severity\":\"Critical\"' \"$OUTPUT_DIR/vulnerability_report_$TIMESTAMP.json\" 2>/dev/null || echo \"0\")\n        HIGH=$(grep -c '\"severity\":\"High\"' \"$OUTPUT_DIR/vulnerability_report_$TIMESTAMP.json\" 2>/dev/null || echo \"0\")\n        echo \"[INFO] Found $CRITICAL Critical and $HIGH High severity vulnerabilities\"\n    fi\nfi\n\nif command -v trivy &>/dev/null; then\n    echo \"\"\n    echo \"[INFO] Running Trivy filesystem scan...\"\n    trivy fs --format json --output \"$OUTPUT_DIR/trivy_scan_$TIMESTAMP.json\" / 2>/dev/null || \\\n        trivy fs --format json --output \"$OUTPUT_DIR/trivy_scan_$TIMESTAMP.json\" /usr 2>/dev/null || \\\n        echo \"[WARNING] Trivy scan completed with warnings\"\n    echo \"[PASS] Trivy scan complete\"\nfi\n\n# Package provenance analysis\necho \"\"\necho \"[INFO] Analyzing package provenance...\"\n\nif command -v rpm &>/dev/null; then\n    echo \"[INFO] Extracting RPM package details with vendor information...\"\n    rpm -qa --queryformat '%{NAME}|%{VERSION}|%{RELEASE}|%{VENDOR}|%{PACKAGER}|%{BUILDHOST}|%{BUILDTIME:date}\\n' | \\\n        sort > \"$OUTPUT_DIR/rpm_provenance_$TIMESTAMP.txt\"\n    \n    # Check for packages from unknown vendors\n    echo \"[INFO] Checking for packages without vendor information...\"\n    awk -F'|' '$4 == \"(none)\" || $4 == \"\"' \"$OUTPUT_DIR/rpm_provenance_$TIMESTAMP.txt\" > \"$OUTPUT_DIR/rpm_unknown_vendor_$TIMESTAMP.txt\"\n    UNKNOWN_COUNT=$(wc -l < \"$OUTPUT_DIR/rpm_unknown_vendor_$TIMESTAMP.txt\")\n    if [[ \"$UNKNOWN_COUNT\" -gt 0 ]]; then\n        echo \"[WARNING] $UNKNOWN_COUNT packages have unknown vendor\"\n    else\n        echo \"[PASS] All packages have vendor information\"\n    fi\nfi\n\nif command -v dpkg &>/dev/null; then\n    echo \"[INFO] Extracting Debian package details...\"\n    dpkg-query -W -f='${Package}|${Version}|${Maintainer}|${Homepage}\\n' > \"$OUTPUT_DIR/dpkg_provenance_$TIMESTAMP.txt\"\nfi\n\n# Check for SLSA provenance (if available)\necho \"\"\necho \"[INFO] Checking for SLSA build provenance...\"\nif [[ -d \"/usr/share/doc\" ]]; then\n    find /usr/share/doc -name \"*.provenance\" -o -name \"provenance.json\" 2>/dev/null | head -20 > \"$OUTPUT_DIR/slsa_provenance_files_$TIMESTAMP.txt\" || true\n    SLSA_COUNT=$(wc -l < \"$OUTPUT_DIR/slsa_provenance_files_$TIMESTAMP.txt\" 2>/dev/null || echo \"0\")\n    echo \"[INFO] Found $SLSA_COUNT files with potential SLSA provenance\"\nfi\n\necho \"\"\necho \"[SR-4.4] Pedigree validation complete\"\necho \"Reports saved to: $OUTPUT_DIR\"",
        "ansible": "---\n# SR-4.4: Supply Chain Integrity - Pedigree Validation Ansible Playbook\n\n- name: SR-4.4 Pedigree Validation Implementation\n  hosts: all\n  become: yes\n  vars:\n    output_dir: /var/log/pedigree-validation\n    timestamp: \"{{ ansible_date_time.iso8601_basic_short }}\"\n\n  tasks:\n    - name: Create output directory\n      file:\n        path: \"{{ output_dir }}\"\n        state: directory\n        mode: '0750'\n\n    - name: Check if syft is installed\n      command: which syft\n      register: syft_installed\n      ignore_errors: yes\n      changed_when: false\n\n    - name: Install syft for SBOM generation\n      shell: |\n        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin\n      when: syft_installed.rc != 0\n\n    - name: Check if grype is installed\n      command: which grype\n      register: grype_installed\n      ignore_errors: yes\n      changed_when: false\n\n    - name: Install grype for vulnerability scanning\n      shell: |\n        curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin\n      when: grype_installed.rc != 0\n\n    - name: Generate CycloneDX SBOM\n      shell: syft packages dir:/usr -o cyclonedx-json > {{ output_dir }}/sbom_{{ timestamp }}.cyclonedx.json\n      ignore_errors: yes\n\n    - name: Generate SPDX SBOM\n      shell: syft packages dir:/usr -o spdx-json > {{ output_dir }}/sbom_{{ timestamp }}.spdx.json\n      ignore_errors: yes\n\n    - name: Scan for vulnerabilities\n      shell: grype sbom:{{ output_dir }}/sbom_{{ timestamp }}.cyclonedx.json -o json > {{ output_dir }}/vulnerabilities_{{ timestamp }}.json\n      ignore_errors: yes\n\n    - name: Extract RPM provenance (RHEL/CentOS)\n      shell: |\n        rpm -qa --queryformat '%{NAME}|%{VERSION}|%{VENDOR}|%{BUILDHOST}\\n' | sort > {{ output_dir }}/rpm_provenance_{{ timestamp }}.txt\n      when: ansible_os_family == 'RedHat'\n      ignore_errors: yes\n\n    - name: Extract Debian package provenance\n      shell: |\n        dpkg-query -W -f='${Package}|${Version}|${Maintainer}\\n' > {{ output_dir }}/dpkg_provenance_{{ timestamp }}.txt\n      when: ansible_os_family == 'Debian'\n      ignore_errors: yes\n\n    - name: Set secure permissions on reports\n      file:\n        path: \"{{ output_dir }}\"\n        recurse: yes\n        mode: '0640'"
      },
      "windows": {
        "powershell": "# SR-4.4: Supply Chain Integrity - Pedigree Validation - Windows\n# Implements comprehensive component analysis and validation\n\n#Requires -RunAsAdministrator\n\n$ErrorActionPreference = 'Continue'\n\nWrite-Host \"[SR-4.4] Supply Chain Integrity - Pedigree Validation\" -ForegroundColor Cyan\nWrite-Host \"======================================================\" -ForegroundColor Cyan\n\n$Timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$OutputDir = \"C:\\ProgramData\\PedigreeValidation\"\n\nif (-not (Test-Path $OutputDir)) {\n    New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null\n}\n\n# Comprehensive software inventory with provenance details\nWrite-Host \"`n[INFO] Generating comprehensive software inventory with provenance...\" -ForegroundColor Yellow\n\n$SoftwareInventory = @()\n\n# Get detailed software information\n$RegPaths = @(\n    \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\",\n    \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\"\n)\n\nforeach ($Path in $RegPaths) {\n    Get-ItemProperty $Path -ErrorAction SilentlyContinue | Where-Object { $_.DisplayName } | ForEach-Object {\n        $SoftwareInventory += [PSCustomObject]@{\n            Name = $_.DisplayName\n            Version = $_.DisplayVersion\n            Publisher = $_.Publisher\n            InstallDate = $_.InstallDate\n            InstallLocation = $_.InstallLocation\n            InstallSource = $_.InstallSource\n            URLInfoAbout = $_.URLInfoAbout\n            Comments = $_.Comments\n        }\n    }\n}\n\n# Generate SBOM-like output\n$SBOM = @{\n    bomFormat = \"CycloneDX-Like\"\n    specVersion = \"1.4\"\n    version = 1\n    serialNumber = \"urn:uuid:$([guid]::NewGuid().ToString())\"\n    metadata = @{\n        timestamp = (Get-Date).ToString(\"o\")\n        tools = @(@{\n            vendor = \"Microsoft\"\n            name = \"PowerShell Pedigree Validator\"\n            version = \"1.0\"\n        })\n        component = @{\n            type = \"operating-system\"\n            name = \"Windows\"\n            version = [System.Environment]::OSVersion.VersionString\n            bom_ref = $env:COMPUTERNAME\n        }\n    }\n    components = @()\n}\n\nforeach ($Software in $SoftwareInventory) {\n    $Component = @{\n        type = \"application\"\n        name = $Software.Name\n        version = $Software.Version\n        publisher = $Software.Publisher\n        purl = \"pkg:windows/$($Software.Name -replace ' ','_')@$($Software.Version)\"\n        externalReferences = @()\n    }\n    \n    if ($Software.URLInfoAbout) {\n        $Component.externalReferences += @{\n            type = \"website\"\n            url = $Software.URLInfoAbout\n        }\n    }\n    \n    $SBOM.components += $Component\n}\n\n$SBOM | ConvertTo-Json -Depth 10 | Out-File \"$OutputDir\\sbom_$Timestamp.json\" -Encoding UTF8\nWrite-Host \"[PASS] SBOM generated: $OutputDir\\sbom_$Timestamp.json\" -ForegroundColor Green\n\n# Analyze file signatures for installed applications\nWrite-Host \"`n[INFO] Analyzing application signatures (pedigree validation)...\" -ForegroundColor Yellow\n\n$SignatureReport = @()\n$ExePaths = @(\n    \"$env:ProgramFiles\",\n    \"${env:ProgramFiles(x86)}\"\n)\n\nforeach ($BasePath in $ExePaths) {\n    if (Test-Path $BasePath) {\n        Get-ChildItem -Path $BasePath -Filter \"*.exe\" -Recurse -ErrorAction SilentlyContinue | \n        Select-Object -First 100 | ForEach-Object {\n            $Sig = Get-AuthenticodeSignature -FilePath $_.FullName -ErrorAction SilentlyContinue\n            $SignatureReport += [PSCustomObject]@{\n                File = $_.FullName\n                Status = $Sig.Status\n                SignerSubject = $Sig.SignerCertificate.Subject\n                SignerIssuer = $Sig.SignerCertificate.Issuer\n                SignerThumbprint = $Sig.SignerCertificate.Thumbprint\n                TimestampValid = $Sig.TimeStamperCertificate -ne $null\n            }\n        }\n    }\n}\n\n$SignatureReport | Export-Csv \"$OutputDir\\signature_analysis_$Timestamp.csv\" -NoTypeInformation\nWrite-Host \"[PASS] Signature analysis complete: $OutputDir\\signature_analysis_$Timestamp.csv\" -ForegroundColor Green\n\n# Count unsigned applications\n$UnsignedCount = ($SignatureReport | Where-Object { $_.Status -ne 'Valid' }).Count\n$TotalCount = $SignatureReport.Count\nWrite-Host \"[INFO] Analyzed $TotalCount executables, $UnsignedCount are unsigned or have invalid signatures\" -ForegroundColor $(if ($UnsignedCount -gt 0) { 'Yellow' } else { 'Green' })\n\n# Windows component verification\nWrite-Host \"`n[INFO] Verifying Windows component integrity...\" -ForegroundColor Yellow\n\n$SFCResult = & sfc /verifyonly 2>&1\n$SFCOutput = $SFCResult -join \"`n\"\nif ($SFCOutput -match \"did not find any integrity violations\") {\n    Write-Host \"[PASS] Windows Resource Protection: No integrity violations found\" -ForegroundColor Green\n} else {\n    Write-Host \"[WARNING] Windows Resource Protection scan may have found issues\" -ForegroundColor Yellow\n}\n$SFCOutput | Out-File \"$OutputDir\\sfc_result_$Timestamp.txt\"\n\n# Driver pedigree validation\nWrite-Host \"`n[INFO] Validating driver pedigree...\" -ForegroundColor Yellow\n\n$Drivers = Get-WmiObject Win32_PnPSignedDriver | Select-Object DeviceName, DriverVersion, DriverProviderName, IsSigned, Signer\n$Drivers | Export-Csv \"$OutputDir\\driver_pedigree_$Timestamp.csv\" -NoTypeInformation\n\n$UnsignedDrivers = $Drivers | Where-Object { $_.IsSigned -eq $false }\nif ($UnsignedDrivers) {\n    Write-Host \"[WARNING] Found $($UnsignedDrivers.Count) unsigned drivers\" -ForegroundColor Yellow\n} else {\n    Write-Host \"[PASS] All drivers are signed\" -ForegroundColor Green\n}\n\nWrite-Host \"`n[SR-4.4] Pedigree validation complete\" -ForegroundColor Green\nWrite-Host \"Reports saved to: $OutputDir\" -ForegroundColor Cyan",
        "ansible": "---\n# SR-4.4: Supply Chain Integrity - Pedigree Validation - Windows Ansible\n\n- name: SR-4.4 Pedigree Validation for Windows\n  hosts: windows\n  gather_facts: yes\n  vars:\n    output_dir: C:\\ProgramData\\PedigreeValidation\n    timestamp: \"{{ ansible_date_time.iso8601_basic_short }}\"\n\n  tasks:\n    - name: Create output directory\n      win_file:\n        path: \"{{ output_dir }}\"\n        state: directory\n\n    - name: Generate software inventory with provenance\n      win_shell: |\n        $Software = Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |\n          Where-Object { $_.DisplayName } |\n          Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallSource\n        $Software | ConvertTo-Json | Out-File {{ output_dir }}\\software_inventory_{{ timestamp }}.json\n\n    - name: Analyze application signatures\n      win_shell: |\n        $Report = @()\n        Get-ChildItem \"$env:ProgramFiles\" -Filter \"*.exe\" -Recurse -ErrorAction SilentlyContinue |\n          Select-Object -First 50 | ForEach-Object {\n            $Sig = Get-AuthenticodeSignature $_.FullName -ErrorAction SilentlyContinue\n            $Report += [PSCustomObject]@{\n              File = $_.FullName\n              Status = $Sig.Status\n              Signer = $Sig.SignerCertificate.Subject\n            }\n          }\n        $Report | ConvertTo-Json | Out-File {{ output_dir }}\\signature_report_{{ timestamp }}.json\n\n    - name: Export driver pedigree information\n      win_shell: |\n        Get-WmiObject Win32_PnPSignedDriver |\n          Select-Object DeviceName, DriverVersion, DriverProviderName, IsSigned |\n          ConvertTo-Json | Out-File {{ output_dir }}\\driver_pedigree_{{ timestamp }}.json"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Technical implementation through SBOM generation, vulnerability scanning, and component signature validation."
    }
  },
  {
    "control_id": "SR-5",
    "control_name": "Acquisition Strategies, Tools, and Methods",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Employ the following acquisition strategies, contract tools, and procurement methods to protect against, identify, and mitigate supply chain risks: [Assignment: organization-defined acquisition strategies, contract tools, and procurement methods].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "intent": "Establish procurement practices that incorporate supply chain risk considerations throughout the acquisition lifecycle.",
    "rationale": "The acquisition process presents significant opportunities for supply chain compromise through counterfeit components, malicious insertions, or poor security practices by suppliers. Strategic use of acquisition methods including supplier vetting, contract security requirements, and trusted distribution channels reduces supply chain risk exposure.",
    "ai_guidance": "Develop and implement a comprehensive supply chain risk management strategy that integrates security considerations throughout the acquisition lifecycle from requirements through contract closeout. Require thorough security assessments of potential suppliers before contract award including evaluation of their security posture, incident history, and supply chain risk management capabilities. Include explicit security requirements in all procurement contracts covering secure development practices, vulnerability disclosure, incident notification, component authenticity, and SBOM delivery. Implement supplier diversity strategies for critical components to reduce single points of failure and maintain operational resilience. Use procurement techniques that protect sensitive requirements such as filtered purchasing through intermediaries, blind ordering, and purchase quantity obscuration. Require tamper-evident packaging, secure shipping methods, and chain of custody documentation for all critical hardware deliveries. Include contract clauses that prohibit counterfeit components, require component authenticity documentation, and mandate notification of security incidents or vulnerabilities. Establish ongoing supplier monitoring programs with periodic reassessment of security posture and risk levels. Train procurement personnel on supply chain risk identification, common threat patterns, and security requirements for different component categories. Maintain supplier risk registers documenting accepted risks, mitigation measures, and responsible parties.",
    "plain_english_explanation": "When buying IT products and services, use smart purchasing strategies that consider supply chain security. This includes checking out suppliers before buying from them, putting security requirements in contracts, using trusted shipping methods, and making suppliers agree to tell you about security problems.",
    "example_implementation": "When working on procurement contracts, ensure that supply chain risk management is a key consideration. Incorporate clauses requiring SBOM delivery, security incident notification, and prohibition on counterfeit components.",
    "non_technical_guidance": "Implement the following in procurement processes: 1) Conduct supplier background checks. 2) Include security requirements in RFPs and contracts. 3) Require supplier security certifications where appropriate. 4) Establish vendor risk management program. 5) Provide procurement staff training on SCRM.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "SR-5.1",
        "title": "Adequate Supply",
        "official_text": "Employ the following controls to ensure an adequate supply of [Assignment: organization-defined critical system components]: [Assignment: organization-defined controls]."
      },
      {
        "id": "SR-5.2",
        "title": "Assessments Prior to Selection, Acceptance, Modification, or Update",
        "official_text": "Assess the system, system component, or system service prior to selection, acceptance, modification, or update."
      }
    ],
    "related_controls": [
      "RA-3",
      "SA-2",
      "SA-3",
      "SA-4",
      "SA-5",
      "SA-8",
      "SA-9",
      "SA-10",
      "SA-15",
      "SI-7",
      "SR-6",
      "SR-9",
      "SR-10",
      "SR-11"
    ],
    "supplemental_guidance": "The results from a supply chain risk assessment can guide and inform the strategies, tools, and methods that are most applicable. Tools and techniques may provide protections against unauthorized production, theft, tampering, insertion of counterfeits, insertion of malicious software or backdoors, and poor development practices. Organizations also consider providing incentives for suppliers who implement controls and promote transparency.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires organizational policies and procedures for secure acquisition. Technical validation tools support implementation but the control is primarily organizational."
    }
  },
  {
    "control_id": "SR-5.1",
    "control_name": "Adequate Supply",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Employ the following controls to ensure an adequate supply of [Assignment: organization-defined critical system components]: [Assignment: organization-defined controls].",
    "parent_control": "SR-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Ensure continuity of critical system components by maintaining adequate supply through diversified sources and strategic reserves.",
    "rationale": "Supply chain disruptions from geopolitical events, natural disasters, or supplier failures can halt operations if critical components become unavailable. Proactive supply management including diversified suppliers, strategic reserves, and alternative sourcing plans ensures operational continuity.",
    "ai_guidance": "Conduct systematic identification of critical system components essential for organizational operations, mission functions, and security posture maintenance. Perform comprehensive supply chain risk assessments to identify single points of failure, geographic concentration risks, and potential chokepoints in component sourcing. Establish and maintain relationships with multiple qualified suppliers for all critical components to ensure alternative sourcing options are immediately available. Calculate appropriate strategic reserve levels for critical components based on historical consumption, lead times, supplier reliability, and business impact of stockouts. Develop detailed alternative sourcing plans documenting backup suppliers, emergency procurement procedures, and authorized substitutes for scenarios where primary suppliers cannot deliver. Implement continuous monitoring of primary supplier health indicators including financial stability, operational capacity, regulatory compliance, and geopolitical risk factors. Monitor market conditions including component availability trends, pricing volatility, and emerging supply constraints that could impact critical component access. Include explicit supply continuity requirements in contracts specifying notification thresholds, minimum inventory levels, and contingency obligations. Implement geographic diversity in supplier selection to mitigate regional disruption risks from natural disasters, conflicts, or regulatory changes. Document complete supply chain dependencies including sub-tier suppliers.",
    "plain_english_explanation": "Make sure you will not run out of critical IT components by having multiple suppliers, keeping spare parts in stock, and having backup plans if your usual suppliers cannot deliver. Do not put all your eggs in one basket.",
    "example_implementation": "Maintain a list of critical components with multiple approved suppliers for each. Establish minimum inventory levels for essential spare parts. Document alternative sourcing options in contingency plans.",
    "non_technical_guidance": "Conduct regular supply chain assessments to identify critical dependencies. Qualify multiple suppliers for critical components. Establish and maintain strategic inventory levels. Monitor supplier financial health and market conditions.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "RA-3",
      "RA-9",
      "SA-2",
      "SR-5"
    ],
    "supplemental_guidance": "Organizations may consider supplier diversification, strategic reserves, geographic distribution, and contingency planning to ensure adequate supply of critical components.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires organizational supply chain management processes. No technical automation applicable."
    }
  },
  {
    "control_id": "SR-5.2",
    "control_name": "Assessments Prior to Selection, Acceptance, Modification, or Update",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Assess the system, system component, or system service prior to selection, acceptance, modification, or update.",
    "parent_control": "SR-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Evaluate systems and components for security risks before integrating them into the operational environment.",
    "rationale": "Predeployment assessment catches security issues, vulnerabilities, and compliance gaps before systems or components are integrated into the production environment. This is more cost-effective and less disruptive than discovering issues after deployment.",
    "ai_guidance": "Establish mandatory security assessment gates in acquisition and change management processes requiring explicit approval before procurement, deployment, or modification of systems and components. Define risk-based assessment criteria and procedures with appropriate rigor levels based on component criticality, data sensitivity, and deployment scope. For software acquisitions, conduct comprehensive security testing including vulnerability scanning, static application security testing, dynamic analysis, and dependency checking before acceptance. For third-party components, systematically review available security assessments, penetration test reports, compliance certifications, and vulnerability disclosure histories. Evaluate the security implications of updates and patches before deployment using staged rollout processes with progressive exposure and automated testing in representative environments. Conduct thorough security impact analysis for all proposed modifications to identify potential risks introduced by changes to configurations, integrations, or dependent components. Document all assessment activities, findings, and acceptance decisions with clear accountability and approval chains for any identified risks. Integrate automated security assessment tooling into procurement workflows and CI/CD pipelines to ensure consistent enforcement without creating bottlenecks. Establish clear criteria for assessment escalation when automated checks identify potential issues requiring human review.",
    "plain_english_explanation": "Before you buy, install, or update any system or component, evaluate it for security risks first. Do not just trust that it is secure - test it, check for known vulnerabilities, and make sure it meets your security requirements before putting it into production.",
    "example_implementation": "Require security review approval before procurement of new systems. Conduct vulnerability scanning on all software before deployment. Test updates in a staging environment before production rollout.",
    "non_technical_guidance": "Establish approval gates requiring security assessment before procurement, deployment, and updates. Document assessment procedures and criteria. Train relevant personnel on assessment requirements.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "CA-2",
      "CA-7",
      "RA-3",
      "RA-5",
      "SA-4",
      "SA-9",
      "SA-11",
      "SR-5"
    ],
    "supplemental_guidance": "Assessment activities include security evaluations, inspections, security and penetration testing, analyses, and verification or validation activities. The assessment approach depends on the component or system criticality and organizational risk tolerance.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# SR-5.2: Pre-Selection Assessment Script\n# Performs security assessment on software components before acceptance\n\nset -euo pipefail\n\necho \"[SR-5.2] Pre-Selection Security Assessment\"\necho \"===========================================\"\n\nTARGET=\"${1:-}\"\n\nif [[ -z \"$TARGET\" ]]; then\n    echo \"Usage: $0 <target-file-or-directory>\"\n    echo \"Example: $0 /path/to/software.tar.gz\"\n    exit 1\nfi\n\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\nOUTPUT_DIR=\"/var/log/pre-selection-assessment\"\nmkdir -p \"$OUTPUT_DIR\"\n\nASSESSMENT_REPORT=\"$OUTPUT_DIR/assessment_$(basename $TARGET)_$TIMESTAMP.txt\"\n\necho \"Assessment Target: $TARGET\" | tee \"$ASSESSMENT_REPORT\"\necho \"Assessment Date: $(date)\" | tee -a \"$ASSESSMENT_REPORT\"\necho \"\" | tee -a \"$ASSESSMENT_REPORT\"\n\n# File hash for integrity baseline\necho \"[INFO] Calculating file hash...\" | tee -a \"$ASSESSMENT_REPORT\"\nif [[ -f \"$TARGET\" ]]; then\n    sha256sum \"$TARGET\" | tee -a \"$ASSESSMENT_REPORT\"\nelif [[ -d \"$TARGET\" ]]; then\n    find \"$TARGET\" -type f -exec sha256sum {} \\; 2>/dev/null | head -50 >> \"$ASSESSMENT_REPORT\"\n    echo \"[INFO] Hashes for first 50 files recorded\" | tee -a \"$ASSESSMENT_REPORT\"\nfi\necho \"\" | tee -a \"$ASSESSMENT_REPORT\"\n\n# Virus scan if available\nif command -v clamscan &>/dev/null; then\n    echo \"[INFO] Running antivirus scan...\" | tee -a \"$ASSESSMENT_REPORT\"\n    clamscan -r \"$TARGET\" 2>&1 | tee -a \"$ASSESSMENT_REPORT\"\n    echo \"\" | tee -a \"$ASSESSMENT_REPORT\"\nelse\n    echo \"[WARNING] ClamAV not installed, skipping antivirus scan\" | tee -a \"$ASSESSMENT_REPORT\"\nfi\n\n# Check for known vulnerabilities if it's a package\nif command -v trivy &>/dev/null; then\n    echo \"[INFO] Running vulnerability scan with Trivy...\" | tee -a \"$ASSESSMENT_REPORT\"\n    trivy fs \"$TARGET\" 2>&1 | tee -a \"$ASSESSMENT_REPORT\"\n    echo \"\" | tee -a \"$ASSESSMENT_REPORT\"\nfi\n\n# License compliance check\nif command -v licensee &>/dev/null && [[ -d \"$TARGET\" ]]; then\n    echo \"[INFO] Checking license compliance...\" | tee -a \"$ASSESSMENT_REPORT\"\n    licensee detect \"$TARGET\" 2>&1 | tee -a \"$ASSESSMENT_REPORT\" || true\n    echo \"\" | tee -a \"$ASSESSMENT_REPORT\"\nfi\n\necho \"[SR-5.2] Assessment complete\" | tee -a \"$ASSESSMENT_REPORT\"\necho \"Report saved to: $ASSESSMENT_REPORT\"",
        "ansible": "---\n# SR-5.2: Pre-Selection Assessment Ansible Playbook\n\n- name: SR-5.2 Pre-Selection Assessment\n  hosts: all\n  become: yes\n  vars:\n    assessment_dir: /var/log/pre-selection-assessment\n    target_path: \"{{ target | default('/opt/software-to-assess') }}\"\n\n  tasks:\n    - name: Create assessment directory\n      file:\n        path: \"{{ assessment_dir }}\"\n        state: directory\n        mode: '0750'\n\n    - name: Install assessment tools\n      package:\n        name:\n          - clamav\n          - clamav-update\n        state: present\n      ignore_errors: yes\n\n    - name: Update ClamAV database\n      command: freshclam\n      ignore_errors: yes\n      changed_when: false\n\n    - name: Calculate target hash\n      shell: sha256sum {{ target_path }} > {{ assessment_dir }}/hash_{{ ansible_date_time.date }}.txt\n      when: target_path is defined\n      ignore_errors: yes\n\n    - name: Run antivirus scan\n      shell: clamscan -r {{ target_path }} > {{ assessment_dir }}/av_scan_{{ ansible_date_time.date }}.txt 2>&1\n      when: target_path is defined\n      ignore_errors: yes\n      register: av_result\n\n    - name: Report AV scan result\n      debug:\n        msg: \"Antivirus scan completed with exit code: {{ av_result.rc | default('N/A') }}\""
      },
      "windows": {
        "powershell": "# SR-5.2: Pre-Selection Security Assessment - Windows\n\n#Requires -RunAsAdministrator\n\nparam(\n    [Parameter(Mandatory=$false)]\n    [string]$Target = \"\"\n)\n\n$ErrorActionPreference = 'Continue'\n\nWrite-Host \"[SR-5.2] Pre-Selection Security Assessment\" -ForegroundColor Cyan\nWrite-Host \"===========================================\" -ForegroundColor Cyan\n\nif ([string]::IsNullOrEmpty($Target)) {\n    Write-Host \"Usage: .\\Assess-Component.ps1 -Target 'C:\\path\\to\\software'\" -ForegroundColor Yellow\n    Write-Host \"Running general system assessment instead...\" -ForegroundColor Yellow\n}\n\n$Timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$OutputDir = \"C:\\ProgramData\\PreSelectionAssessment\"\n\nif (-not (Test-Path $OutputDir)) {\n    New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null\n}\n\n$Report = @()\n$Report += \"Pre-Selection Security Assessment Report\"\n$Report += \"=========================================\"\n$Report += \"Date: $(Get-Date)\"\n$Report += \"Target: $Target\"\n$Report += \"\"\n\n# File hash calculation\nif ($Target -and (Test-Path $Target)) {\n    Write-Host \"[INFO] Calculating file hash...\" -ForegroundColor Yellow\n    if ((Get-Item $Target).PSIsContainer) {\n        $Hashes = Get-ChildItem $Target -File -Recurse | Select-Object -First 50 | ForEach-Object {\n            $Hash = Get-FileHash $_.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue\n            if ($Hash) {\n                \"$($Hash.Hash)  $($_.FullName)\"\n            }\n        }\n        $Report += \"File Hashes (first 50 files):\"\n        $Report += $Hashes\n    } else {\n        $Hash = Get-FileHash $Target -Algorithm SHA256\n        $Report += \"SHA256: $($Hash.Hash)\"\n    }\n    $Report += \"\"\n}\n\n# Windows Defender scan\nWrite-Host \"[INFO] Running Windows Defender scan...\" -ForegroundColor Yellow\nif ($Target -and (Test-Path $Target)) {\n    try {\n        Start-MpScan -ScanPath $Target -ScanType CustomScan\n        $Report += \"[PASS] Windows Defender scan completed\"\n    } catch {\n        $Report += \"[WARNING] Could not run custom scan: $_\"\n    }\n} else {\n    $Report += \"[INFO] No target specified, skipping Defender scan\"\n}\n$Report += \"\"\n\n# Check digital signature\nif ($Target -and (Test-Path $Target) -and -not (Get-Item $Target).PSIsContainer) {\n    Write-Host \"[INFO] Checking digital signature...\" -ForegroundColor Yellow\n    $Sig = Get-AuthenticodeSignature -FilePath $Target\n    $Report += \"Digital Signature Status: $($Sig.Status)\"\n    if ($Sig.SignerCertificate) {\n        $Report += \"Signer: $($Sig.SignerCertificate.Subject)\"\n        $Report += \"Issuer: $($Sig.SignerCertificate.Issuer)\"\n    }\n    $Report += \"\"\n}\n\n# Check for known vulnerable software versions\nWrite-Host \"[INFO] Checking for known vulnerable software...\" -ForegroundColor Yellow\n$KnownVulnerable = @{\n    \"Log4j\" = \"2.14\"\n    \"OpenSSL\" = \"1.0.1\"\n    \"Apache Struts\" = \"2.5.10\"\n}\n$Report += \"Known Vulnerability Check:\"\n$Report += \"(Manual review recommended for detailed vulnerability assessment)\"\n$Report += \"\"\n\n$Report += \"[SR-5.2] Assessment Complete\"\n\n$ReportPath = \"$OutputDir\\assessment_$Timestamp.txt\"\n$Report | Out-File $ReportPath -Encoding UTF8\n\nWrite-Host \"[PASS] Assessment report saved to: $ReportPath\" -ForegroundColor Green\nWrite-Host \"`nReview the report and conduct additional manual assessment as needed.\" -ForegroundColor Cyan",
        "ansible": "---\n# SR-5.2: Pre-Selection Assessment for Windows\n\n- name: SR-5.2 Pre-Selection Assessment for Windows\n  hosts: windows\n  gather_facts: yes\n  vars:\n    assessment_dir: C:\\ProgramData\\PreSelectionAssessment\n\n  tasks:\n    - name: Create assessment directory\n      win_file:\n        path: \"{{ assessment_dir }}\"\n        state: directory\n\n    - name: Update Windows Defender definitions\n      win_shell: Update-MpSignature\n      ignore_errors: yes\n\n    - name: Run quick Defender scan\n      win_shell: Start-MpScan -ScanType QuickScan\n      async: 300\n      poll: 30\n      ignore_errors: yes\n\n    - name: Check for pending security updates\n      win_shell: |\n        Get-WindowsUpdate -IsInstalled $false -Severity Critical,Important | \n          Select-Object Title, KB, Size | ConvertTo-Json\n      register: pending_updates\n      ignore_errors: yes\n\n    - name: Report pending updates\n      debug:\n        var: pending_updates.stdout_lines\n      when: pending_updates.stdout_lines | length > 0"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Combines organizational assessment processes with technical security scanning and validation tools."
    }
  },
  {
    "control_id": "SR-6",
    "control_name": "Supplier Assessments and Reviews",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Assess and review the supply chain-related risks associated with suppliers or contractors and the system, system component, or system service they provide [Assignment: organization-defined frequency].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "intent": "Evaluate and monitor supplier security posture and supply chain risks on an ongoing basis.",
    "rationale": "Supplier security posture directly impacts organizational risk. Regular assessment and review of suppliers identifies emerging risks, ensures continued compliance with security requirements, and provides early warning of potential supply chain compromises. This is especially critical given increasing supply chain attacks targeting trusted suppliers.",
    "ai_guidance": "Establish a formal supplier assessment program with defined evaluation criteria covering security practices, supply chain risk management maturity, financial stability, regulatory compliance, and foreign ownership or influence considerations. Conduct thorough initial assessments before onboarding new suppliers using structured questionnaires, documentation review, reference checks, and where appropriate site visits or audits. Schedule periodic reassessment activities based on supplier criticality and risk level with more frequent reviews for critical or high-risk suppliers. Evaluate supplier security certifications such as SOC 2 Type II, ISO 27001, FedRAMP authorization, or industry-specific standards as evidence of security program maturity. Implement continuous monitoring of supplier security posture using threat intelligence feeds, breach notification services, and security rating platforms. Require contractual provisions enabling assessment activities including right to audit clauses, security questionnaire completion obligations, and certification maintenance requirements. Include sub-tier supplier assessment requirements in contracts requiring primary suppliers to demonstrate adequate oversight of their own supply chain. Leverage threat intelligence sources to identify supplier-related risks including data breaches, insider threats, and nation-state targeting. Document assessment results comprehensively and track remediation of identified issues through completion with verification.",
    "plain_english_explanation": "Regularly evaluate your suppliers and contractors to understand the security risks they bring. Check their security practices, monitor for problems, and make sure they are managing their own supply chain risks. Do not just assume they are secure - verify it on an ongoing basis.",
    "example_implementation": "Implement a supplier risk assessment program that includes security questionnaires, review of security certifications, and periodic reassessment. Use vendor risk management platforms to track supplier security posture.",
    "non_technical_guidance": "Develop supplier assessment criteria covering security, SCRM capability, financial stability, and regulatory compliance. Conduct initial and periodic assessments based on supplier criticality. Monitor for supplier security incidents and changes. Document assessment results and track remediation.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "SR-6.1",
        "title": "Testing and Analysis",
        "official_text": "Employ [Assignment: organization-defined forms of testing and analysis] of the following supply chain elements, processes, and actors associated with the system, system component, or system service: [Assignment: organization-defined supply chain elements, processes, and actors]."
      }
    ],
    "related_controls": [
      "CA-8",
      "RA-3",
      "RA-9",
      "SA-4",
      "SA-9",
      "SA-12",
      "SI-4",
      "SR-3",
      "SR-5"
    ],
    "supplemental_guidance": "Supplier assessments include security and supply chain risk management processes, foreign ownership considerations, and the ability to assess sub-tier suppliers. Reviews may be conducted internally or by independent third parties. Organizations use open-source information to monitor for stolen information, poor practices, or counterfeits. Assessment results may be shared with other organizations per applicable agreements.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires organizational processes for supplier assessment and monitoring. Vendor risk management platforms can support implementation."
    }
  },
  {
    "control_id": "SR-6.1",
    "control_name": "Testing and Analysis",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Employ [Assignment: organization-defined forms of testing and analysis] of the following supply chain elements, processes, and actors associated with the system, system component, or system service: [Assignment: organization-defined supply chain elements, processes, and actors].",
    "parent_control": "SR-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Apply active testing and analysis techniques to validate supplier security and supply chain integrity.",
    "rationale": "Passive assessment through documentation review and questionnaires has limitations. Active testing and analysis including penetration testing, security audits, and technical analysis provides direct evidence of security posture and can uncover issues that suppliers may not disclose or be aware of.",
    "ai_guidance": "Define testing and analysis approaches appropriate for different supplier risk levels and component criticality tiers ranging from documentation review for lower-risk suppliers to penetration testing and code audit for critical suppliers. Commission security audits and on-site inspections of supplier facilities, development environments, and security controls for suppliers providing mission-critical components or services. Require or conduct penetration testing of supplier systems and interfaces that connect to or impact organizational systems with appropriate scoping and rules of engagement. Perform or require code review and security analysis of supplier-provided software including static analysis, dynamic testing, and manual review of security-critical code paths. Conduct technical analysis of hardware components including inspection for counterfeit indicators, verification against design specifications, and testing for unexpected functionality. Review and assess supplier development processes, secure coding practices, quality assurance procedures, and incident response capabilities through documentation review and interviews. Require independent third-party security assessments for high-risk or critical suppliers with reports delivered directly to your organization. Implement rigorous receiving inspection and testing procedures for critical components before integration into production systems. Document testing methodologies, scope, results, and remediation requirements with clear timelines and verification procedures.",
    "plain_english_explanation": "Go beyond just asking suppliers about their security - actually test it. This could include security audits of their facilities, penetration testing of their systems, code review of software they provide, or technical inspection of hardware components. Verify their security rather than just trusting their word.",
    "example_implementation": "Require third-party penetration testing results from critical suppliers. Conduct code review of open source components before adoption. Implement receiving inspection procedures for hardware components.",
    "non_technical_guidance": "Define testing requirements based on supplier risk level and component criticality. Include testing requirements in contracts. Conduct or require periodic security audits for critical suppliers. Document testing results and track remediation.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "CA-2",
      "CA-8",
      "RA-5",
      "SA-11",
      "SR-3",
      "SR-5",
      "SR-6"
    ],
    "supplemental_guidance": "Testing and analysis methods include organizational analysis, independent third-party analysis, organizational testing, and independent third-party testing. The approach selected depends on the criticality of the component and organizational risk tolerance.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# SR-6.1: Supplier Testing and Analysis\n# Performs automated security analysis on supplier-provided components\n\nset -euo pipefail\n\necho \"[SR-6.1] Supplier Testing and Analysis\"\necho \"=======================================\"\n\nTARGET=\"${1:-}\"\nSUPPLIER=\"${2:-Unknown}\"\n\nif [[ -z \"$TARGET\" ]]; then\n    echo \"Usage: $0 <target-path> [supplier-name]\"\n    echo \"Example: $0 /opt/vendor-software VendorCorp\"\n    exit 1\nfi\n\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\nOUTPUT_DIR=\"/var/log/supplier-analysis\"\nmkdir -p \"$OUTPUT_DIR\"\n\nREPORT=\"$OUTPUT_DIR/supplier_${SUPPLIER}_${TIMESTAMP}.txt\"\n\necho \"Supplier Analysis Report\" | tee \"$REPORT\"\necho \"========================\" | tee -a \"$REPORT\"\necho \"Supplier: $SUPPLIER\" | tee -a \"$REPORT\"\necho \"Target: $TARGET\" | tee -a \"$REPORT\"\necho \"Date: $(date)\" | tee -a \"$REPORT\"\necho \"\" | tee -a \"$REPORT\"\n\n# Static Analysis\necho \"[INFO] Running static analysis...\" | tee -a \"$REPORT\"\n\n# Check for sensitive patterns in code\nif [[ -d \"$TARGET\" ]]; then\n    echo \"Scanning for hardcoded credentials...\" | tee -a \"$REPORT\"\n    grep -rn \"password\\s*=\\|api_key\\s*=\\|secret\\s*=\\|token\\s*=\" \"$TARGET\" 2>/dev/null | head -20 >> \"$REPORT\" || echo \"No obvious credential patterns found\" >> \"$REPORT\"\n    echo \"\" >> \"$REPORT\"\n    \n    echo \"Scanning for potential backdoors...\" | tee -a \"$REPORT\"\n    grep -rn \"eval(\\|exec(\\|system(\\|shell_exec(\" \"$TARGET\" 2>/dev/null | head -20 >> \"$REPORT\" || echo \"No obvious dangerous function patterns found\" >> \"$REPORT\"\n    echo \"\" >> \"$REPORT\"\nfi\n\n# Generate SBOM for the component\nif command -v syft &>/dev/null; then\n    echo \"[INFO] Generating component SBOM...\" | tee -a \"$REPORT\"\n    syft packages dir:\"$TARGET\" -o cyclonedx-json > \"$OUTPUT_DIR/sbom_${SUPPLIER}_${TIMESTAMP}.json\" 2>/dev/null || echo \"SBOM generation failed or not applicable\" >> \"$REPORT\"\n    echo \"SBOM saved to: $OUTPUT_DIR/sbom_${SUPPLIER}_${TIMESTAMP}.json\" | tee -a \"$REPORT\"\nfi\n\n# Vulnerability analysis\nif command -v grype &>/dev/null && [[ -f \"$OUTPUT_DIR/sbom_${SUPPLIER}_${TIMESTAMP}.json\" ]]; then\n    echo \"[INFO] Running vulnerability analysis...\" | tee -a \"$REPORT\"\n    grype sbom:\"$OUTPUT_DIR/sbom_${SUPPLIER}_${TIMESTAMP}.json\" -o table >> \"$REPORT\" 2>/dev/null || true\nfi\n\n# License compliance\necho \"\" | tee -a \"$REPORT\"\necho \"[INFO] Checking license compliance...\" | tee -a \"$REPORT\"\nfind \"$TARGET\" -name \"LICENSE*\" -o -name \"COPYING*\" -o -name \"*.license\" 2>/dev/null | while read -r f; do\n    echo \"Found license file: $f\" >> \"$REPORT\"\ndone\n\necho \"\" | tee -a \"$REPORT\"\necho \"[SR-6.1] Analysis complete\" | tee -a \"$REPORT\"\necho \"Report saved to: $REPORT\"",
        "ansible": "---\n# SR-6.1: Supplier Testing and Analysis Ansible Playbook\n\n- name: SR-6.1 Supplier Analysis Implementation\n  hosts: all\n  become: yes\n  vars:\n    analysis_dir: /var/log/supplier-analysis\n    target_path: \"{{ target | default('/opt/vendor-software') }}\"\n    supplier_name: \"{{ supplier | default('Unknown') }}\"\n\n  tasks:\n    - name: Create analysis output directory\n      file:\n        path: \"{{ analysis_dir }}\"\n        state: directory\n        mode: '0750'\n\n    - name: Install analysis tools\n      shell: |\n        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin\n        curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin\n      args:\n        creates: /usr/local/bin/syft\n      ignore_errors: yes\n\n    - name: Generate component SBOM\n      shell: syft packages dir:{{ target_path }} -o cyclonedx-json > {{ analysis_dir }}/sbom_{{ supplier_name }}_{{ ansible_date_time.date }}.json\n      when: target_path is defined\n      ignore_errors: yes\n\n    - name: Run vulnerability analysis\n      shell: grype sbom:{{ analysis_dir }}/sbom_{{ supplier_name }}_{{ ansible_date_time.date }}.json -o json > {{ analysis_dir }}/vulns_{{ supplier_name }}_{{ ansible_date_time.date }}.json\n      ignore_errors: yes\n\n    - name: Scan for credential patterns\n      shell: |\n        grep -rn 'password\\s*=\\|api_key\\s*=\\|secret\\s*=' {{ target_path }} 2>/dev/null | head -50 > {{ analysis_dir }}/credential_scan_{{ supplier_name }}.txt\n      ignore_errors: yes\n      changed_when: false"
      },
      "windows": {
        "powershell": "# SR-6.1: Supplier Testing and Analysis - Windows\n\n#Requires -RunAsAdministrator\n\nparam(\n    [Parameter(Mandatory=$false)]\n    [string]$Target = \"\",\n    \n    [Parameter(Mandatory=$false)]\n    [string]$Supplier = \"Unknown\"\n)\n\n$ErrorActionPreference = 'Continue'\n\nWrite-Host \"[SR-6.1] Supplier Testing and Analysis\" -ForegroundColor Cyan\nWrite-Host \"=======================================\" -ForegroundColor Cyan\n\n$Timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$OutputDir = \"C:\\ProgramData\\SupplierAnalysis\"\n\nif (-not (Test-Path $OutputDir)) {\n    New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null\n}\n\n$Report = @()\n$Report += \"Supplier Analysis Report\"\n$Report += \"========================\"\n$Report += \"Supplier: $Supplier\"\n$Report += \"Target: $Target\"\n$Report += \"Date: $(Get-Date)\"\n$Report += \"\"\n\n# Signature Analysis\nif ($Target -and (Test-Path $Target)) {\n    Write-Host \"[INFO] Analyzing digital signatures...\" -ForegroundColor Yellow\n    $Report += \"Digital Signature Analysis:\"\n    \n    $Files = Get-ChildItem $Target -Filter \"*.exe\" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 20\n    foreach ($File in $Files) {\n        $Sig = Get-AuthenticodeSignature $File.FullName -ErrorAction SilentlyContinue\n        $Report += \"  $($File.Name): $($Sig.Status) - Signer: $($Sig.SignerCertificate.Subject)\"\n    }\n    $Report += \"\"\n    \n    # Hash inventory\n    Write-Host \"[INFO] Creating file hash inventory...\" -ForegroundColor Yellow\n    $Report += \"File Hash Inventory:\"\n    Get-ChildItem $Target -File -Recurse -ErrorAction SilentlyContinue | Select-Object -First 50 | ForEach-Object {\n        $Hash = Get-FileHash $_.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue\n        if ($Hash) {\n            $Report += \"  $($Hash.Hash)  $($_.FullName)\"\n        }\n    }\n    $Report += \"\"\n    \n    # Windows Defender scan\n    Write-Host \"[INFO] Running malware scan...\" -ForegroundColor Yellow\n    try {\n        Start-MpScan -ScanPath $Target -ScanType CustomScan\n        $Report += \"[PASS] Windows Defender scan completed\"\n    } catch {\n        $Report += \"[WARNING] Could not complete Defender scan: $_\"\n    }\n    $Report += \"\"\n}\n\n# Software inventory for installed supplier software\nWrite-Host \"[INFO] Checking for supplier software inventory...\" -ForegroundColor Yellow\n$Report += \"Installed Software from Supplier '$Supplier':\"\n$InstalledSoftware = Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |\n    Where-Object { $_.Publisher -like \"*$Supplier*\" } |\n    Select-Object DisplayName, DisplayVersion, Publisher\n\nif ($InstalledSoftware) {\n    foreach ($sw in $InstalledSoftware) {\n        $Report += \"  $($sw.DisplayName) v$($sw.DisplayVersion)\"\n    }\n} else {\n    $Report += \"  No software found from supplier '$Supplier'\"\n}\n$Report += \"\"\n\n$Report += \"[SR-6.1] Analysis Complete\"\n\n$ReportPath = \"$OutputDir\\supplier_${Supplier}_$Timestamp.txt\"\n$Report | Out-File $ReportPath -Encoding UTF8\n\nWrite-Host \"[PASS] Report saved to: $ReportPath\" -ForegroundColor Green",
        "ansible": "---\n# SR-6.1: Supplier Testing and Analysis - Windows Ansible\n\n- name: SR-6.1 Supplier Analysis for Windows\n  hosts: windows\n  gather_facts: yes\n  vars:\n    analysis_dir: C:\\ProgramData\\SupplierAnalysis\n    target_path: \"{{ target | default('') }}\"\n    supplier_name: \"{{ supplier | default('Unknown') }}\"\n\n  tasks:\n    - name: Create analysis directory\n      win_file:\n        path: \"{{ analysis_dir }}\"\n        state: directory\n\n    - name: Analyze digital signatures\n      win_shell: |\n        $Results = @()\n        Get-ChildItem \"{{ target_path }}\" -Filter \"*.exe\" -Recurse -ErrorAction SilentlyContinue | \n          Select-Object -First 20 | ForEach-Object {\n            $Sig = Get-AuthenticodeSignature $_.FullName -ErrorAction SilentlyContinue\n            $Results += [PSCustomObject]@{\n              File = $_.Name\n              Status = $Sig.Status\n              Signer = $Sig.SignerCertificate.Subject\n            }\n          }\n        $Results | ConvertTo-Json | Out-File {{ analysis_dir }}\\signatures_{{ supplier_name }}.json\n      when: target_path | length > 0\n      ignore_errors: yes\n\n    - name: Check for installed supplier software\n      win_shell: |\n        Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |\n          Where-Object { $_.Publisher -like '*{{ supplier_name }}*' } |\n          Select-Object DisplayName, DisplayVersion, Publisher |\n          ConvertTo-Json | Out-File {{ analysis_dir }}\\installed_{{ supplier_name }}.json\n      ignore_errors: yes"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Combines organizational testing processes with automated security analysis tools for supplier-provided components."
    }
  },
  {
    "control_id": "SR-7",
    "control_name": "Supply Chain Operations Security",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Employ the following Operations Security (OPSEC) controls to protect supply chain-related information for the system, system component, or system service: [Assignment: organization-defined OPSEC controls].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "Protect supply chain information from adversary reconnaissance and exploitation by applying operational security principles to procurement and supplier relationships.",
    "rationale": "Adversaries target supply chain information to identify attack vectors, compromise suppliers, or manipulate procurement processes. OPSEC controls prevent the aggregation of seemingly innocuous data that could reveal critical supplier relationships, system configurations, or security postures. Without supply chain OPSEC, organizations inadvertently expose information that enables targeted attacks.",
    "ai_guidance": "Implement supply chain OPSEC by establishing information classification for procurement data, limiting disclosure of critical supplier identities, and controlling access to acquisition schedules. Configure procurement systems with role-based access controls that restrict visibility of vendor relationships. Use secure communication channels for supplier negotiations and contractual discussions. Establish need-to-know principles for supply chain personnel regarding system architecture, security requirements, and deployment timelines. Monitor for information leakage through public procurement notices, job postings that reveal technology stacks, or social engineering attempts targeting procurement staff. Implement data loss prevention controls on procurement documents. Use intermediary purchasing arrangements for sensitive acquisitions to obscure end-user organizations. Train acquisition personnel on OPSEC indicators and counter-surveillance techniques. Review public-facing information periodically to identify unintended disclosure of supply chain details. Establish agreements with suppliers regarding confidentiality of business relationships and technical specifications. Document OPSEC procedures in supply chain risk management plans.",
    "plain_english_explanation": "Supply Chain OPSEC means protecting information about your vendors, purchases, and technology choices from adversaries who could use this knowledge against you. Think of it like not advertising which security systems you use or which suppliers provide your critical infrastructure. If attackers know your vendors, they can target those vendors to reach you indirectly. By keeping supply chain details confidential, using secure communications with suppliers, and limiting who knows about sensitive procurements, you make it much harder for adversaries to plan attacks against your organization through your supply chain.",
    "example_implementation": "Conduct regular assessments of public information exposure related to supply chain relationships. Implement secure procurement portals with strong authentication and encryption for supplier communications.",
    "non_technical_guidance": "1. Establish information handling procedures for procurement documents that classify supplier identities and contract terms based on sensitivity.\n2. Limit the number of personnel with access to complete supply chain information using need-to-know principles.\n3. Review job postings and public announcements to ensure they do not reveal critical technology choices or supplier relationships.\n4. Use secure communication methods (encrypted email, secure portals) for all supplier negotiations.\n5. Consider using purchasing intermediaries for highly sensitive acquisitions to obscure the end-user organization.\n6. Train procurement staff to recognize social engineering attempts and information-gathering probes.\n7. Include confidentiality clauses in supplier contracts preventing disclosure of business relationships.\n8. Conduct periodic OPSEC reviews to identify potential information leakage vectors.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "SC-38",
      "SR-3",
      "SR-5",
      "SR-6"
    ],
    "supplemental_guidance": "Supply chain OPSEC expands the scope of OPSEC to include suppliers and potential suppliers. OPSEC is a process that includes identifying critical information, analyzing friendly actions attendant to operations and other activities to identify actions that can be observed by potential adversaries, determining indicators that potential adversaries might obtain that could be interpreted or pieced together to derive information in sufficient time to be useful to adversaries, implementing safeguards or countermeasures to eliminate or reduce exploitable vulnerabilities and risk to an acceptable level, and considering how aggregated information may expose users or specific uses of the supply chain. Supply chain information includes user identities; uses for systems, system components, and system services; supplier identities; security and privacy requirements; system and component configurations; supplier processes; design specifications; and testing and evaluation results. Supply chain OPSEC may require organizations to withhold mission or business information from suppliers and may include the use of intermediaries to hide the end use or users of systems, system components, or system services.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "opsec_guidance": {
      "information_protection": [
        "Classify supply chain documents containing supplier identities, pricing, and technical specifications",
        "Implement data loss prevention controls on procurement systems",
        "Use encrypted channels for all supplier communications",
        "Segment procurement networks from general corporate networks"
      ],
      "supplier_relationship_protection": [
        "Limit disclosure of critical supplier identities to essential personnel only",
        "Use code names or project identifiers instead of actual supplier names in general communications",
        "Establish non-disclosure agreements with suppliers covering the business relationship itself",
        "Consider using purchasing intermediaries for sensitive acquisitions"
      ],
      "procurement_opsec": [
        "Review public solicitations to minimize disclosure of sensitive requirements",
        "Stagger procurement timelines to obscure operational patterns",
        "Conduct supplier meetings in secure locations with controlled access",
        "Train acquisition personnel on recognizing elicitation attempts"
      ],
      "counter_reconnaissance": [
        "Monitor public sources for unauthorized disclosure of supply chain information",
        "Assess job postings and marketing materials for technology stack exposure",
        "Review social media and professional networks for supply chain indicators",
        "Conduct periodic OPSEC assessments of supply chain information exposure"
      ]
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00.000000Z",
      "has_scripts": false,
      "qa_reviewed": true,
      "qa_reviewer": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires organizational policy and procedure implementation. Technical automation focuses on DLP, access controls, and secure communications."
    }
  },
  {
    "control_id": "SR-8",
    "control_name": "Notification Agreements",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Establish agreements and procedures with entities involved in the supply chain for the system, system component, or system service for the [Assignment (one or more): notification of supply chain compromises; results of assessments or audits].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "intent": "Ensure timely notification of supply chain security incidents and assessment results from suppliers to enable rapid organizational response.",
    "rationale": "Supply chain compromises can propagate rapidly through interconnected systems. Without formal notification agreements, organizations may remain unaware of supplier breaches that directly affect their security posture. Early warning enables incident response activation, deployment of compensating controls, and informed risk decisions. Assessment and audit result sharing supports continuous supply chain risk evaluation.",
    "ai_guidance": "Establish formal notification agreements with all critical suppliers specifying required notification timeframes for security incidents, breaches, and audit findings. Define notification thresholds and severity classifications that trigger mandatory reporting. Specify communication channels and contact procedures for incident notification including primary and backup contacts. Include contractual provisions for notification of subcontractor compromises affecting your organization. Require suppliers to share relevant assessment results, penetration test findings, and audit reports affecting provided products or services. Establish procedures for receiving, processing, and acting on supplier notifications including escalation paths and response timeframes. Create templates for notification agreements that address incident types, notification windows (typically 24-72 hours for critical incidents), required information elements, and follow-up reporting requirements. Integrate supplier notification procedures with organizational incident response plans. Maintain current contact information for all supplier security teams. Conduct periodic exercises to test notification procedures effectiveness.",
    "plain_english_explanation": "Notification agreements are formal arrangements with your suppliers that require them to tell you promptly if they experience a security breach or discover vulnerabilities that could affect your organization. Think of it like having an agreement with your home security company that they must call you immediately if there is any issue with equipment they provided. Without these agreements, a supplier could be breached for months before you find out, leaving your systems exposed. These agreements should specify how quickly suppliers must notify you, what information they must provide, and who to contact. They also cover sharing security audit results so you understand how well your suppliers are protecting systems and data that connect to yours.",
    "example_implementation": "Create standardized notification agreement templates requiring suppliers to report security incidents within 24 hours of discovery and share annual security assessment results.",
    "non_technical_guidance": "1. Inventory all suppliers and contractors who provide system components, services, or have access to organizational data.\n2. Develop a standard notification agreement template addressing incident notification timeframes, required information, and communication procedures.\n3. Negotiate notification agreements with all critical suppliers, prioritizing those with access to sensitive systems or data.\n4. Establish clear points of contact within your organization for receiving supplier notifications.\n5. Define internal procedures for processing and responding to supplier notifications.\n6. Include notification requirements in procurement contracts and RFP evaluation criteria.\n7. Maintain a registry of notification agreements and contact information for all suppliers.\n8. Conduct annual reviews of notification agreements to ensure they remain current and effective.\n9. Exercise notification procedures periodically with key suppliers to verify functionality.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "IR-4",
      "IR-6",
      "IR-8",
      "SA-4",
      "SR-6"
    ],
    "supplemental_guidance": "The establishment of agreements and procedures facilitates communications among supply chain entities. Early notification of compromises and potential compromises in the supply chain that can potentially adversely affect or have adversely affected organizational systems or system components is essential for organizations to effectively respond to such incidents. The results of assessments or audits may include open-source information that contributed to a decision or result and could be used to help the supply chain entity resolve a concern or improve its processes.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00.000000Z",
      "has_scripts": false,
      "qa_reviewed": true,
      "qa_reviewer": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires contractual and procedural implementation. No direct technical automation available."
    }
  },
  {
    "control_id": "SR-9",
    "control_name": "Tamper Resistance and Detection",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Implement a tamper protection program for the system, system component, or system service.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "intent": "Protect systems and components from unauthorized modification, reverse engineering, and substitution through comprehensive tamper resistance and detection mechanisms.",
    "rationale": "Supply chain attacks frequently involve tampering with hardware or software during manufacturing, shipping, or maintenance. Without tamper protection, adversaries can insert malicious code, implant hardware backdoors, or substitute counterfeit components. Tamper resistance makes attacks more difficult and expensive, while detection enables identification of compromised components before deployment.",
    "ai_guidance": "Implement layered tamper protection combining physical and logical controls across all critical systems. Deploy file integrity monitoring using tools like AIDE, Tripwire, or OSSEC to detect unauthorized modifications to system files, configurations, and binaries. Configure secure boot with TPM attestation to verify system integrity at startup and prevent boot-level rootkits. Implement code signing verification for all software installations, updates, and patches. Use cryptographic hashing with SHA-256 or stronger algorithms to verify component authenticity before deployment. Establish baseline configurations and monitor for deviations indicating tampering using centralized security information and event management (SIEM). Implement hardware tamper-evident seals, security screws, and locked enclosures for critical components. Configure logging and real-time alerting for integrity monitoring failures, escalating to security operations. Deploy host-based intrusion detection systems to identify runtime tampering attempts. Integrate tamper detection with incident response procedures ensuring rapid containment and forensic preservation. For physical systems, implement anti-tamper enclosures, serialized component tracking, and chain of custody documentation. Conduct periodic integrity verification of deployed systems against known-good baselines. Document tamper protection requirements in acquisition specifications and vendor contracts.",
    "plain_english_explanation": "Tamper protection ensures that your systems have not been secretly modified by attackers. Imagine receiving a package in the mail - tamper-evident tape tells you if someone opened it before delivery. Similarly, tamper protection for IT systems includes both physical measures (sealed cases, security screws) and digital measures (software that detects if files have been changed). File integrity monitoring tools constantly check that system files match known-good versions and alert you if anything changes unexpectedly. Secure boot ensures your computer starts with trusted software that has not been modified. Together, these controls help detect if an adversary has inserted malicious code or replaced components with compromised versions.",
    "example_implementation": "Deploy file integrity monitoring across all critical systems and configure TPM-based secure boot verification.",
    "non_technical_guidance": "1. Develop a tamper protection policy specifying requirements for physical and logical tamper controls.\n2. Identify critical systems and components requiring tamper protection based on risk assessment.\n3. Implement physical tamper-evident controls including security seals, serialized components, and controlled access storage.\n4. Establish procedures for inspecting received equipment for signs of tampering before deployment.\n5. Configure file integrity monitoring on all production systems.\n6. Implement secure boot and code signing verification where supported.\n7. Train personnel to recognize signs of physical and logical tampering.\n8. Integrate tamper detection alerts with incident response procedures.\n9. Conduct periodic integrity audits of deployed systems and components.\n10. Document tamper incidents and near-misses for process improvement.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "SR-9.1",
        "title": "Multiple Stages of System Development Life Cycle",
        "official_text": "Employ anti-tamper technologies, tools, and techniques throughout the system development life cycle."
      }
    ],
    "related_controls": [
      "PE-3",
      "SA-3",
      "SA-15",
      "SI-4",
      "SI-7",
      "SR-3",
      "SR-4",
      "SR-5",
      "SR-10",
      "SR-11"
    ],
    "supplemental_guidance": "Anti-tamper technologies, tools, and techniques provide a level of protection for systems, system components, and services against many threats, including reverse engineering, modification, and substitution. Strong identification combined with tamper resistance and/or tamper detection is essential to protecting systems and components during distribution and when in use.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# SR-9: Tamper Resistance and Detection - Linux Implementation\n# File Integrity Monitoring Setup and Verification\n\nset -euo pipefail\n\nLOG_FILE=\"/var/log/sr9_tamper_detection.log\"\nAIDE_CONF=\"/etc/aide.conf\"\nAIDE_DB=\"/var/lib/aide/aide.db.gz\"\n\nlog_message() {\n    echo \"$(date '+%Y-%m-%d %H:%M:%S') - $1\" | tee -a \"$LOG_FILE\"\n}\n\nlog_message \"Starting SR-9 Tamper Detection Implementation\"\n\n# Check if AIDE is installed\nif ! command -v aide &> /dev/null; then\n    log_message \"Installing AIDE file integrity monitoring...\"\n    if command -v apt-get &> /dev/null; then\n        apt-get update && apt-get install -y aide aide-common\n    elif command -v yum &> /dev/null; then\n        yum install -y aide\n    elif command -v dnf &> /dev/null; then\n        dnf install -y aide\n    else\n        log_message \"ERROR: Unable to install AIDE - unsupported package manager\"\n        exit 1\n    fi\nfi\n\n# Configure AIDE for critical directories\nlog_message \"Configuring AIDE for tamper detection...\"\ncat > /etc/aide.conf.d/sr9_custom.conf << 'EOF'\n# SR-9 Tamper Detection Configuration\n# Monitor critical system directories\n\n# System binaries - detect any modification\n/bin NORMAL\n/sbin NORMAL\n/usr/bin NORMAL\n/usr/sbin NORMAL\n/usr/local/bin NORMAL\n/usr/local/sbin NORMAL\n\n# System configuration\n/etc NORMAL\n!/etc/mtab\n!/etc/.*~\n\n# Boot files - critical for secure boot verification\n/boot NORMAL\n\n# Kernel modules\n/lib/modules NORMAL\n/lib64/modules NORMAL\n\n# Security-sensitive files\n/etc/passwd NORMAL\n/etc/shadow NORMAL\n/etc/group NORMAL\n/etc/gshadow NORMAL\n/etc/sudoers NORMAL\n/etc/sudoers.d NORMAL\n\n# SSH configuration\n/etc/ssh NORMAL\n\n# PAM configuration\n/etc/pam.d NORMAL\n/etc/security NORMAL\nEOF\n\n# Initialize AIDE database if not exists\nif [ ! -f \"$AIDE_DB\" ]; then\n    log_message \"Initializing AIDE database...\"\n    aide --init\n    mv /var/lib/aide/aide.db.new.gz \"$AIDE_DB\"\n    log_message \"AIDE database initialized at $AIDE_DB\"\nfi\n\n# Run integrity check\nlog_message \"Running file integrity check...\"\nif aide --check > /tmp/aide_check.log 2>&1; then\n    log_message \"PASS: No file integrity violations detected\"\nelse\n    log_message \"WARNING: File integrity violations detected - review /tmp/aide_check.log\"\nfi\n\n# Configure automatic integrity checks via cron\ncat > /etc/cron.d/sr9_integrity_check << 'EOF'\n# SR-9 Tamper Detection - Daily integrity check\n0 3 * * * root /usr/sbin/aide --check > /var/log/aide/aide-check.log 2>&1\nEOF\n\n# Verify secure boot status if available\nlog_message \"Checking secure boot status...\"\nif [ -d /sys/firmware/efi ]; then\n    if mokutil --sb-state 2>/dev/null | grep -q \"SecureBoot enabled\"; then\n        log_message \"PASS: Secure Boot is enabled\"\n    else\n        log_message \"WARNING: Secure Boot is not enabled\"\n    fi\nelse\n    log_message \"INFO: System is not using UEFI boot\"\nfi\n\n# Check TPM availability\nif [ -c /dev/tpm0 ] || [ -c /dev/tpmrm0 ]; then\n    log_message \"PASS: TPM device detected\"\n    if command -v tpm2_getrandom &> /dev/null; then\n        log_message \"TPM2 tools available for attestation\"\n    fi\nelse\n    log_message \"INFO: No TPM device detected\"\nfi\n\nlog_message \"SR-9 Tamper Detection Implementation Complete\"",
        "ansible": "---\n# SR-9: Tamper Resistance and Detection - Ansible Implementation\n- name: SR-9 Tamper Resistance and Detection Implementation\n  hosts: all\n  become: yes\n  vars:\n    aide_db_path: /var/lib/aide/aide.db.gz\n    aide_log_dir: /var/log/aide\n    critical_directories:\n      - /bin\n      - /sbin\n      - /usr/bin\n      - /usr/sbin\n      - /etc\n      - /boot\n\n  tasks:\n    - name: Install AIDE file integrity monitoring\n      package:\n        name: aide\n        state: present\n      tags: [install, aide]\n\n    - name: Install AIDE common (Debian/Ubuntu)\n      package:\n        name: aide-common\n        state: present\n      when: ansible_os_family == 'Debian'\n      tags: [install, aide]\n\n    - name: Create AIDE log directory\n      file:\n        path: \"{{ aide_log_dir }}\"\n        state: directory\n        mode: '0750'\n        owner: root\n        group: root\n      tags: [config, aide]\n\n    - name: Deploy SR-9 AIDE custom configuration\n      copy:\n        dest: /etc/aide.conf.d/sr9_custom.conf\n        mode: '0644'\n        content: |\n          # SR-9 Tamper Detection Configuration\n          # Critical system directories\n          /bin NORMAL\n          /sbin NORMAL\n          /usr/bin NORMAL\n          /usr/sbin NORMAL\n          /usr/local/bin NORMAL\n          /usr/local/sbin NORMAL\n          /etc NORMAL\n          !/etc/mtab\n          !/etc/.*~\n          /boot NORMAL\n          /lib/modules NORMAL\n          # Security-sensitive files\n          /etc/passwd NORMAL\n          /etc/shadow NORMAL\n          /etc/group NORMAL\n          /etc/sudoers NORMAL\n          /etc/sudoers.d NORMAL\n          /etc/ssh NORMAL\n          /etc/pam.d NORMAL\n      tags: [config, aide]\n      notify: Rebuild AIDE database\n\n    - name: Check if AIDE database exists\n      stat:\n        path: \"{{ aide_db_path }}\"\n      register: aide_db\n      tags: [verify, aide]\n\n    - name: Initialize AIDE database if not exists\n      command: aide --init\n      when: not aide_db.stat.exists\n      tags: [init, aide]\n\n    - name: Move new AIDE database to production location\n      command: mv /var/lib/aide/aide.db.new.gz {{ aide_db_path }}\n      when: not aide_db.stat.exists\n      args:\n        creates: \"{{ aide_db_path }}\"\n      tags: [init, aide]\n\n    - name: Configure daily AIDE integrity check\n      cron:\n        name: \"SR-9 AIDE integrity check\"\n        minute: \"0\"\n        hour: \"3\"\n        job: \"/usr/sbin/aide --check > {{ aide_log_dir }}/aide-check.log 2>&1\"\n        user: root\n      tags: [cron, aide]\n\n    - name: Run AIDE integrity check\n      command: aide --check\n      register: aide_check\n      failed_when: false\n      changed_when: false\n      tags: [verify, aide]\n\n    - name: Report AIDE check results\n      debug:\n        msg: \"{{ 'PASS: No integrity violations' if aide_check.rc == 0 else 'WARNING: Integrity violations detected' }}\"\n      tags: [verify, aide]\n\n    - name: Check Secure Boot status\n      command: mokutil --sb-state\n      register: secureboot_status\n      failed_when: false\n      changed_when: false\n      when: ansible_facts['bios_vendor'] is defined\n      tags: [verify, secureboot]\n\n    - name: Report Secure Boot status\n      debug:\n        msg: \"Secure Boot: {{ 'ENABLED' if 'enabled' in (secureboot_status.stdout | default('')) else 'DISABLED or not available' }}\"\n      tags: [verify, secureboot]\n\n    - name: Check TPM availability\n      stat:\n        path: /dev/tpm0\n      register: tpm_device\n      tags: [verify, tpm]\n\n    - name: Report TPM status\n      debug:\n        msg: \"TPM: {{ 'AVAILABLE' if tpm_device.stat.exists else 'NOT DETECTED' }}\"\n      tags: [verify, tpm]\n\n  handlers:\n    - name: Rebuild AIDE database\n      command: aide --init\n      notify: Move rebuilt AIDE database\n\n    - name: Move rebuilt AIDE database\n      command: mv /var/lib/aide/aide.db.new.gz {{ aide_db_path }}"
      },
      "windows": {
        "powershell": "# SR-9: Tamper Resistance and Detection - Windows Implementation\n# File Integrity Monitoring and Secure Boot Verification\n\n#Requires -RunAsAdministrator\n\n$LogFile = \"C:\\Windows\\Logs\\SR9_TamperDetection.log\"\n$BaselineDir = \"C:\\ProgramData\\SR9_Integrity\"\n$BaselineFile = \"$BaselineDir\\integrity_baseline.xml\"\n\nfunction Write-Log {\n    param([string]$Message)\n    $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n    \"$timestamp - $Message\" | Tee-Object -FilePath $LogFile -Append\n}\n\nfunction Initialize-IntegrityBaseline {\n    Write-Log \"Creating integrity baseline directory...\"\n    if (-not (Test-Path $BaselineDir)) {\n        New-Item -ItemType Directory -Path $BaselineDir -Force | Out-Null\n    }\n\n    Write-Log \"Generating file integrity baseline...\"\n    \n    # Critical Windows directories to monitor\n    $CriticalPaths = @(\n        \"C:\\Windows\\System32\",\n        \"C:\\Windows\\SysWOW64\",\n        \"C:\\Windows\\System32\\drivers\",\n        \"C:\\Windows\\System32\\config\",\n        \"C:\\Program Files\",\n        \"C:\\Program Files (x86)\"\n    )\n\n    $baseline = @()\n    foreach ($path in $CriticalPaths) {\n        if (Test-Path $path) {\n            Write-Log \"Baselining: $path\"\n            $files = Get-ChildItem -Path $path -File -Recurse -ErrorAction SilentlyContinue | \n                     Where-Object { $_.Extension -match '\\.(exe|dll|sys|ps1|bat|cmd)$' }\n            \n            foreach ($file in $files) {\n                try {\n                    $hash = Get-FileHash -Path $file.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue\n                    if ($hash) {\n                        $baseline += [PSCustomObject]@{\n                            Path = $file.FullName\n                            Hash = $hash.Hash\n                            LastWriteTime = $file.LastWriteTime\n                            Size = $file.Length\n                        }\n                    }\n                } catch {\n                    # Skip files that cannot be accessed\n                }\n            }\n        }\n    }\n\n    $baseline | Export-Clixml -Path $BaselineFile\n    Write-Log \"Baseline created with $($baseline.Count) files\"\n}\n\nfunction Test-IntegrityBaseline {\n    if (-not (Test-Path $BaselineFile)) {\n        Write-Log \"ERROR: No baseline file found. Run Initialize-IntegrityBaseline first.\"\n        return $false\n    }\n\n    Write-Log \"Loading integrity baseline...\"\n    $baseline = Import-Clixml -Path $BaselineFile\n    $violations = @()\n\n    Write-Log \"Checking file integrity against baseline...\"\n    foreach ($entry in $baseline) {\n        if (Test-Path $entry.Path) {\n            try {\n                $currentHash = (Get-FileHash -Path $entry.Path -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash\n                if ($currentHash -and $currentHash -ne $entry.Hash) {\n                    $violations += [PSCustomObject]@{\n                        Path = $entry.Path\n                        Type = \"Modified\"\n                        BaselineHash = $entry.Hash\n                        CurrentHash = $currentHash\n                    }\n                }\n            } catch {\n                # Skip inaccessible files\n            }\n        } else {\n            $violations += [PSCustomObject]@{\n                Path = $entry.Path\n                Type = \"Deleted\"\n                BaselineHash = $entry.Hash\n                CurrentHash = \"N/A\"\n            }\n        }\n    }\n\n    if ($violations.Count -eq 0) {\n        Write-Log \"PASS: No integrity violations detected\"\n        return $true\n    } else {\n        Write-Log \"WARNING: $($violations.Count) integrity violations detected\"\n        $violations | Export-Csv -Path \"$BaselineDir\\violations_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv\" -NoTypeInformation\n        return $false\n    }\n}\n\nfunction Test-SecureBoot {\n    Write-Log \"Checking Secure Boot status...\"\n    try {\n        $secureBoot = Confirm-SecureBootUEFI\n        if ($secureBoot) {\n            Write-Log \"PASS: Secure Boot is ENABLED\"\n            return $true\n        } else {\n            Write-Log \"WARNING: Secure Boot is DISABLED\"\n            return $false\n        }\n    } catch {\n        Write-Log \"INFO: Unable to determine Secure Boot status (may be Legacy BIOS)\"\n        return $null\n    }\n}\n\nfunction Test-TPMStatus {\n    Write-Log \"Checking TPM status...\"\n    try {\n        $tpm = Get-Tpm\n        if ($tpm.TpmPresent) {\n            Write-Log \"PASS: TPM is present (Version: $($tpm.ManufacturerVersion))\"\n            if ($tpm.TpmReady) {\n                Write-Log \"PASS: TPM is ready for use\"\n            } else {\n                Write-Log \"WARNING: TPM is present but not ready\"\n            }\n            return $true\n        } else {\n            Write-Log \"WARNING: No TPM detected\"\n            return $false\n        }\n    } catch {\n        Write-Log \"ERROR: Unable to query TPM status\"\n        return $null\n    }\n}\n\nfunction Test-CodeSigningPolicy {\n    Write-Log \"Checking code signing enforcement...\"\n    try {\n        $policy = Get-ExecutionPolicy\n        Write-Log \"PowerShell Execution Policy: $policy\"\n        \n        # Check Windows Defender Application Control\n        $wdac = Get-CimInstance -Namespace root\\Microsoft\\Windows\\CI -ClassName MSFT_MpComputerStatus -ErrorAction SilentlyContinue\n        if ($wdac) {\n            Write-Log \"Windows Defender Application Control is configured\"\n        }\n        \n        return $true\n    } catch {\n        Write-Log \"Unable to fully assess code signing policy\"\n        return $null\n    }\n}\n\nfunction Enable-WindowsDefenderFIM {\n    Write-Log \"Enabling Windows Defender real-time monitoring...\"\n    try {\n        Set-MpPreference -DisableRealtimeMonitoring $false\n        Set-MpPreference -DisableBehaviorMonitoring $false\n        Set-MpPreference -DisableIOAVProtection $false\n        Write-Log \"PASS: Windows Defender real-time protection enabled\"\n        return $true\n    } catch {\n        Write-Log \"ERROR: Failed to configure Windows Defender\"\n        return $false\n    }\n}\n\n# Main execution\nWrite-Log \"========================================\"\nWrite-Log \"SR-9 Tamper Detection Implementation\"\nWrite-Log \"========================================\"\n\n# Run all checks\n$results = @{\n    SecureBoot = Test-SecureBoot\n    TPM = Test-TPMStatus\n    CodeSigning = Test-CodeSigningPolicy\n    DefenderFIM = Enable-WindowsDefenderFIM\n}\n\n# Initialize or verify baseline\nif (-not (Test-Path $BaselineFile)) {\n    Initialize-IntegrityBaseline\n}\n$results.IntegrityCheck = Test-IntegrityBaseline\n\n# Summary\nWrite-Log \"========================================\"\nWrite-Log \"SR-9 Implementation Summary\"\nWrite-Log \"========================================\"\nforeach ($key in $results.Keys) {\n    $status = switch ($results[$key]) {\n        $true { \"PASS\" }\n        $false { \"FAIL\" }\n        $null { \"N/A\" }\n    }\n    Write-Log \"$key`: $status\"\n}\n\nWrite-Log \"SR-9 Tamper Detection Implementation Complete\"",
        "ansible": "---\n# SR-9: Tamper Resistance and Detection - Windows Ansible Implementation\n- name: SR-9 Tamper Resistance and Detection - Windows\n  hosts: windows\n  gather_facts: yes\n  vars:\n    baseline_dir: C:\\ProgramData\\SR9_Integrity\n    log_file: C:\\Windows\\Logs\\SR9_TamperDetection.log\n\n  tasks:\n    - name: Create integrity baseline directory\n      win_file:\n        path: \"{{ baseline_dir }}\"\n        state: directory\n      tags: [setup]\n\n    - name: Check Secure Boot status\n      win_shell: |\n        try {\n          $result = Confirm-SecureBootUEFI\n          if ($result) { \"ENABLED\" } else { \"DISABLED\" }\n        } catch { \"UNAVAILABLE\" }\n      register: secureboot_result\n      changed_when: false\n      tags: [verify, secureboot]\n\n    - name: Report Secure Boot status\n      debug:\n        msg: \"Secure Boot: {{ secureboot_result.stdout | trim }}\"\n      tags: [verify, secureboot]\n\n    - name: Check TPM status\n      win_shell: |\n        $tpm = Get-Tpm\n        if ($tpm.TpmPresent -and $tpm.TpmReady) {\n          \"READY\"\n        } elseif ($tpm.TpmPresent) {\n          \"PRESENT_NOT_READY\"\n        } else {\n          \"NOT_PRESENT\"\n        }\n      register: tpm_result\n      changed_when: false\n      tags: [verify, tpm]\n\n    - name: Report TPM status\n      debug:\n        msg: \"TPM: {{ tpm_result.stdout | trim }}\"\n      tags: [verify, tpm]\n\n    - name: Enable Windows Defender Real-time Protection\n      win_shell: |\n        Set-MpPreference -DisableRealtimeMonitoring $false\n        Set-MpPreference -DisableBehaviorMonitoring $false\n      tags: [config, defender]\n\n    - name: Configure Windows Defender exploit protection\n      win_shell: |\n        Set-ProcessMitigation -System -Enable DEP,SEHOP\n      tags: [config, defender]\n\n    - name: Enable Windows Event logging for integrity\n      win_shell: |\n        auditpol /set /subcategory:\"File System\" /success:enable /failure:enable\n        auditpol /set /subcategory:\"Registry\" /success:enable /failure:enable\n      tags: [config, audit]\n\n    - name: Create scheduled task for integrity checks\n      win_scheduled_task:\n        name: SR9_IntegrityCheck\n        description: SR-9 File Integrity Monitoring\n        actions:\n          - path: C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\n            arguments: -ExecutionPolicy Bypass -File C:\\ProgramData\\SR9_Integrity\\integrity_check.ps1\n        triggers:\n          - type: daily\n            start_boundary: '2024-01-01T03:00:00'\n        username: SYSTEM\n        state: present\n        enabled: yes\n      tags: [config, scheduled_task]\n\n    - name: Verify Windows code integrity\n      win_shell: |\n        $result = Get-CimInstance -Namespace root\\Microsoft\\Windows\\CI -ClassName MSFT_MpComputerStatus -ErrorAction SilentlyContinue\n        if ($result) { \"CONFIGURED\" } else { \"NOT_CONFIGURED\" }\n      register: wdac_result\n      changed_when: false\n      tags: [verify, wdac]\n\n    - name: Report code integrity status\n      debug:\n        msg: \"Windows Code Integrity: {{ wdac_result.stdout | trim }}\"\n      tags: [verify, wdac]"
      }
    },
    "stig_mappings": [],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00.000000Z",
      "has_scripts": true,
      "qa_reviewed": true,
      "qa_reviewer": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "last_analyzed": "2025-11-22T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Technical implementation through file integrity monitoring (AIDE/Tripwire/OSSEC), TPM attestation, and secure boot verification. Organizational procedures required for tamper-evident physical controls."
    }
  },
  {
    "control_id": "SR-9.1",
    "control_name": "Multiple Stages of System Development Life Cycle",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "parent_control": "SR-9",
    "official_text": "Employ anti-tamper technologies, tools, and techniques throughout the system development life cycle.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "intent": "Ensure anti-tamper protections are integrated throughout design, development, testing, deployment, and maintenance phases rather than applied only at the end.",
    "rationale": "Adversaries can compromise systems at any stage of the development lifecycle. Applying anti-tamper measures only at deployment leaves earlier stages vulnerable to supply chain attacks during development, build processes, or distribution. Integrating tamper protection throughout the SDLC ensures continuous integrity from code inception to operational deployment.",
    "ai_guidance": "Integrate anti-tamper measures across all SDLC phases to ensure continuous integrity protection. During design, specify tamper resistance requirements in system specifications and develop threat models addressing supply chain attacks at each lifecycle stage. In development, implement mandatory code signing for all builds using GPG or enterprise PKI, use secure repositories with strict access controls and audit logging, and verify integrity of development tools and third-party dependencies through cryptographic verification. Configure CI/CD pipelines with automated cryptographic verification of artifacts at each stage, failing builds on signature validation failures. Implement software bill of materials (SBOM) generation using tools like Syft or CycloneDX and verify SBOM integrity before deployment. During testing, include tamper detection validation in security testing procedures and verify that integrity monitoring correctly identifies unauthorized modifications. For deployment, verify cryptographic signatures of all deployment packages, use signed container images with Docker Content Trust or equivalent, and implement runtime integrity monitoring. In operations, configure continuous file integrity monitoring with AIDE or Tripwire, enable secure boot verification, and deploy runtime application self-protection (RASP) where applicable. Maintain chain of custody documentation for all build artifacts throughout the pipeline. Implement separation of duties between development, build, and deployment personnel with distinct access credentials. Use hardware security modules (HSMs) for code signing key protection. Conduct quarterly assessments to verify anti-tamper controls remain effective throughout the lifecycle.",
    "plain_english_explanation": "This enhancement requires that tamper protection be built into your systems from the very beginning - not just added at the end. During design, you plan how to prevent tampering. During development, you sign your code and verify your tools have not been compromised. During testing, you check that tamper detection works. During deployment, you verify nothing has been modified. During operations, you continuously monitor for unauthorized changes. Think of it like building security into a building from the architectural plans rather than just adding locks to the doors after construction. By integrating anti-tamper measures at every stage, you prevent attackers from inserting malicious code during development, corrupting your build process, or modifying software during distribution.",
    "example_implementation": "Implement code signing throughout the CI/CD pipeline with cryptographic verification at each stage, from developer commits through production deployment.",
    "non_technical_guidance": "1. Design Phase: Include tamper resistance requirements in system specifications and threat models.\n2. Development Phase: Implement code signing, secure code repositories, and developer workstation security.\n3. Build Phase: Use secure build environments, verify dependency integrity, and sign all build artifacts.\n4. Testing Phase: Include tamper detection testing in security test plans.\n5. Deployment Phase: Verify artifact signatures before deployment, use secure distribution channels.\n6. Operations Phase: Implement continuous integrity monitoring and incident response for tamper alerts.\n7. Maintenance Phase: Apply same controls to patches, updates, and configuration changes.\n8. Document anti-tamper controls for each SDLC phase in the system security plan.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "SA-3",
      "SA-8",
      "SA-10",
      "SA-11",
      "SA-15",
      "SI-7",
      "SR-4",
      "SR-9"
    ],
    "supplemental_guidance": "Including anti-tamper technologies, tools, and techniques at multiple stages of the system development life cycle ensures that tampering cannot easily occur or that it is detected if it does occur. The application of anti-tamper technologies at each phase in the system development life cycle helps ensure the integrity of the system, system component, or system service.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# SR-9.1: SDLC Anti-Tamper Implementation - Linux\n# Code Signing and Build Integrity Verification\n\nset -euo pipefail\n\nLOG_FILE=\"/var/log/sr9_1_sdlc_tamper.log\"\nKEY_DIR=\"/etc/pki/code-signing\"\n\nlog_message() {\n    echo \"$(date '+%Y-%m-%d %H:%M:%S') - $1\" | tee -a \"$LOG_FILE\"\n}\n\nlog_message \"Starting SR-9.1 SDLC Anti-Tamper Implementation\"\n\n# Verify GPG is installed for code signing\nif ! command -v gpg &> /dev/null; then\n    log_message \"Installing GPG for code signing...\"\n    if command -v apt-get &> /dev/null; then\n        apt-get update && apt-get install -y gnupg2\n    elif command -v yum &> /dev/null; then\n        yum install -y gnupg2\n    fi\nfi\n\n# Check for code signing keys\nlog_message \"Checking code signing key availability...\"\nif gpg --list-secret-keys --keyid-format LONG 2>/dev/null | grep -q sec; then\n    log_message \"PASS: GPG signing keys are available\"\nelse\n    log_message \"INFO: No GPG signing keys found - generate keys for code signing\"\nfi\n\n# Verify git commit signing configuration\nlog_message \"Checking git commit signing configuration...\"\nif git config --global commit.gpgsign 2>/dev/null | grep -q true; then\n    log_message \"PASS: Git commit signing is enabled\"\nelse\n    log_message \"INFO: Git commit signing not enabled globally\"\nfi\n\n# Check for package signature verification\nlog_message \"Checking package signature verification...\"\nif command -v apt-get &> /dev/null; then\n    if grep -r \"APT::Get::AllowUnauthenticated\" /etc/apt/apt.conf.d/ 2>/dev/null | grep -q true; then\n        log_message \"WARNING: APT allows unauthenticated packages\"\n    else\n        log_message \"PASS: APT signature verification is enforced\"\n    fi\nelif command -v yum &> /dev/null; then\n    if grep -q \"gpgcheck=1\" /etc/yum.conf; then\n        log_message \"PASS: YUM GPG checking is enabled\"\n    else\n        log_message \"WARNING: YUM GPG checking may be disabled\"\n    fi\nfi\n\n# Verify integrity of critical development tools\nlog_message \"Verifying development tool integrity...\"\nDEV_TOOLS=(\"gcc\" \"make\" \"git\" \"docker\")\n\nfor tool in \"${DEV_TOOLS[@]}\"; do\n    if command -v \"$tool\" &> /dev/null; then\n        tool_path=$(which \"$tool\")\n        if rpm -Vf \"$tool_path\" 2>/dev/null; then\n            log_message \"PASS: $tool integrity verified via RPM\"\n        elif dpkg -S \"$tool_path\" 2>/dev/null && debsums -c \"$(dpkg -S \"$tool_path\" 2>/dev/null | cut -d: -f1)\" 2>/dev/null; then\n            log_message \"PASS: $tool integrity verified via dpkg\"\n        else\n            # Generate hash for manual verification\n            hash=$(sha256sum \"$tool_path\" | cut -d' ' -f1)\n            log_message \"INFO: $tool hash: $hash (manual verification needed)\"\n        fi\n    fi\ndone\n\n# Check container image signing (if Docker is present)\nif command -v docker &> /dev/null; then\n    log_message \"Checking Docker content trust...\"\n    if [ \"${DOCKER_CONTENT_TRUST:-0}\" == \"1\" ]; then\n        log_message \"PASS: Docker Content Trust is enabled\"\n    else\n        log_message \"INFO: Docker Content Trust not enabled - set DOCKER_CONTENT_TRUST=1\"\n    fi\nfi\n\n# Verify SBOM generation capability\nlog_message \"Checking SBOM generation tools...\"\nif command -v syft &> /dev/null; then\n    log_message \"PASS: Syft SBOM generator is available\"\nelif command -v cyclonedx &> /dev/null; then\n    log_message \"PASS: CycloneDX SBOM generator is available\"\nelse\n    log_message \"INFO: No SBOM generator detected - consider installing syft or cyclonedx-cli\"\nfi\n\nlog_message \"SR-9.1 SDLC Anti-Tamper Implementation Complete\"",
        "ansible": "---\n# SR-9.1: SDLC Anti-Tamper Implementation - Ansible\n- name: SR-9.1 SDLC Anti-Tamper Controls\n  hosts: all\n  become: yes\n  vars:\n    code_signing_dir: /etc/pki/code-signing\n    dev_tools:\n      - gcc\n      - make\n      - git\n\n  tasks:\n    - name: Install GPG for code signing\n      package:\n        name: gnupg2\n        state: present\n      tags: [install, signing]\n\n    - name: Create code signing key directory\n      file:\n        path: \"{{ code_signing_dir }}\"\n        state: directory\n        mode: '0700'\n        owner: root\n        group: root\n      tags: [config, signing]\n\n    - name: Configure package manager GPG verification (RHEL/CentOS)\n      lineinfile:\n        path: /etc/yum.conf\n        regexp: '^gpgcheck='\n        line: 'gpgcheck=1'\n      when: ansible_os_family == 'RedHat'\n      tags: [config, packages]\n\n    - name: Configure package manager GPG verification (Debian/Ubuntu)\n      copy:\n        dest: /etc/apt/apt.conf.d/99security\n        content: |\n          APT::Get::AllowUnauthenticated \"false\";\n          Acquire::AllowInsecureRepositories \"false\";\n      when: ansible_os_family == 'Debian'\n      tags: [config, packages]\n\n    - name: Enable Git commit signing globally\n      git_config:\n        name: commit.gpgsign\n        scope: system\n        value: 'true'\n      tags: [config, git]\n\n    - name: Configure Docker Content Trust\n      lineinfile:\n        path: /etc/environment\n        regexp: '^DOCKER_CONTENT_TRUST='\n        line: 'DOCKER_CONTENT_TRUST=1'\n        create: yes\n      when: ansible_facts.packages['docker-ce'] is defined or ansible_facts.packages['docker'] is defined\n      tags: [config, docker]\n\n    - name: Verify development tool package integrity (RPM)\n      command: rpm -V {{ item }}\n      loop: \"{{ dev_tools }}\"\n      register: rpm_verify\n      failed_when: false\n      changed_when: false\n      when: ansible_os_family == 'RedHat'\n      tags: [verify, tools]\n\n    - name: Report tool verification results\n      debug:\n        msg: \"{{ item.item }}: {{ 'PASS' if item.rc == 0 else 'CHECK NEEDED' }}\"\n      loop: \"{{ rpm_verify.results | default([]) }}\"\n      when: rpm_verify.results is defined\n      tags: [verify, tools]\n\n    - name: Check for SBOM generator\n      command: which syft\n      register: sbom_check\n      failed_when: false\n      changed_when: false\n      tags: [verify, sbom]\n\n    - name: Install Syft SBOM generator\n      shell: |\n        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin\n      when: sbom_check.rc != 0\n      args:\n        creates: /usr/local/bin/syft\n      tags: [install, sbom]"
      },
      "windows": {
        "powershell": "# SR-9.1: SDLC Anti-Tamper Implementation - Windows\n# Code Signing and Build Integrity Verification\n\n#Requires -RunAsAdministrator\n\n$LogFile = \"C:\\Windows\\Logs\\SR9_1_SDLC_TamperDetection.log\"\n\nfunction Write-Log {\n    param([string]$Message)\n    $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n    \"$timestamp - $Message\" | Tee-Object -FilePath $LogFile -Append\n}\n\nfunction Test-CodeSigningCertificates {\n    Write-Log \"Checking for code signing certificates...\"\n    $certs = Get-ChildItem -Path Cert:\\CurrentUser\\My -CodeSigningCert\n    if ($certs.Count -gt 0) {\n        Write-Log \"PASS: Found $($certs.Count) code signing certificate(s)\"\n        foreach ($cert in $certs) {\n            Write-Log \"  - Subject: $($cert.Subject), Expires: $($cert.NotAfter)\"\n        }\n        return $true\n    } else {\n        Write-Log \"INFO: No code signing certificates found in personal store\"\n        return $false\n    }\n}\n\nfunction Test-SignedPowerShellPolicy {\n    Write-Log \"Checking PowerShell execution policy...\"\n    $policy = Get-ExecutionPolicy\n    Write-Log \"Current Execution Policy: $policy\"\n    \n    if ($policy -eq \"AllSigned\" -or $policy -eq \"RemoteSigned\") {\n        Write-Log \"PASS: PowerShell script signing is enforced\"\n        return $true\n    } else {\n        Write-Log \"WARNING: PowerShell script signing not enforced (Policy: $policy)\"\n        return $false\n    }\n}\n\nfunction Test-WindowsDefenderApplicationControl {\n    Write-Log \"Checking Windows Defender Application Control (WDAC)...\"\n    try {\n        $cipolicies = Get-CimInstance -Namespace root\\Microsoft\\Windows\\CI -ClassName MSFT_MpComputerStatus -ErrorAction Stop\n        if ($cipolicies) {\n            Write-Log \"PASS: WDAC policies are configured\"\n            return $true\n        }\n    } catch {\n        Write-Log \"INFO: WDAC not configured or not available\"\n    }\n    return $false\n}\n\nfunction Test-DriverSigningEnforcement {\n    Write-Log \"Checking driver signing enforcement...\"\n    try {\n        $bcdedit = bcdedit /enum | Select-String \"nointegritychecks|testsigning\"\n        if ($bcdedit -match \"Yes\") {\n            Write-Log \"WARNING: Driver signing enforcement may be disabled\"\n            return $false\n        } else {\n            Write-Log \"PASS: Driver signing enforcement is active\"\n            return $true\n        }\n    } catch {\n        Write-Log \"Unable to check driver signing status\"\n        return $null\n    }\n}\n\nfunction Test-AuthenticodeSignature {\n    param([string]$FilePath)\n    \n    $signature = Get-AuthenticodeSignature -FilePath $FilePath -ErrorAction SilentlyContinue\n    if ($signature.Status -eq \"Valid\") {\n        return $true\n    }\n    return $false\n}\n\nfunction Test-CriticalBinarySignatures {\n    Write-Log \"Verifying signatures of critical Windows binaries...\"\n    \n    $criticalBinaries = @(\n        \"$env:SystemRoot\\System32\\kernel32.dll\",\n        \"$env:SystemRoot\\System32\\ntdll.dll\",\n        \"$env:SystemRoot\\System32\\cmd.exe\",\n        \"$env:SystemRoot\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\"\n    )\n    \n    $allSigned = $true\n    foreach ($binary in $criticalBinaries) {\n        if (Test-Path $binary) {\n            if (Test-AuthenticodeSignature -FilePath $binary) {\n                Write-Log \"PASS: $binary is properly signed\"\n            } else {\n                Write-Log \"FAIL: $binary signature verification failed\"\n                $allSigned = $false\n            }\n        }\n    }\n    return $allSigned\n}\n\nfunction Test-NuGetSignatureVerification {\n    Write-Log \"Checking NuGet package signature verification...\"\n    try {\n        $nugetConfig = \"$env:APPDATA\\NuGet\\NuGet.Config\"\n        if (Test-Path $nugetConfig) {\n            $content = Get-Content $nugetConfig -Raw\n            if ($content -match \"signatureValidationMode.*require\") {\n                Write-Log \"PASS: NuGet signature validation is required\"\n                return $true\n            }\n        }\n        Write-Log \"INFO: NuGet signature validation not enforced\"\n        return $false\n    } catch {\n        Write-Log \"Unable to check NuGet configuration\"\n        return $null\n    }\n}\n\n# Main execution\nWrite-Log \"========================================\"\nWrite-Log \"SR-9.1 SDLC Anti-Tamper Implementation\"\nWrite-Log \"========================================\"\n\n$results = @{\n    CodeSigningCerts = Test-CodeSigningCertificates\n    PowerShellPolicy = Test-SignedPowerShellPolicy\n    WDAC = Test-WindowsDefenderApplicationControl\n    DriverSigning = Test-DriverSigningEnforcement\n    BinarySignatures = Test-CriticalBinarySignatures\n    NuGetValidation = Test-NuGetSignatureVerification\n}\n\n# Summary\nWrite-Log \"========================================\"\nWrite-Log \"SR-9.1 Implementation Summary\"\nWrite-Log \"========================================\"\n$passCount = 0\n$failCount = 0\nforeach ($key in $results.Keys) {\n    $status = switch ($results[$key]) {\n        $true { $passCount++; \"PASS\" }\n        $false { $failCount++; \"FAIL\" }\n        $null { \"N/A\" }\n    }\n    Write-Log \"$key`: $status\"\n}\n\nWrite-Log \"Results: $passCount PASS, $failCount FAIL\"\nWrite-Log \"SR-9.1 SDLC Anti-Tamper Implementation Complete\"",
        "ansible": "---\n# SR-9.1: SDLC Anti-Tamper Implementation - Windows Ansible\n- name: SR-9.1 SDLC Anti-Tamper Controls - Windows\n  hosts: windows\n  gather_facts: yes\n\n  tasks:\n    - name: Check for code signing certificates\n      win_shell: |\n        $certs = Get-ChildItem -Path Cert:\\CurrentUser\\My -CodeSigningCert\n        $certs.Count\n      register: signing_certs\n      changed_when: false\n      tags: [verify, signing]\n\n    - name: Report code signing certificate status\n      debug:\n        msg: \"Code signing certificates: {{ signing_certs.stdout | trim }}\"\n      tags: [verify, signing]\n\n    - name: Set PowerShell execution policy to RemoteSigned\n      win_shell: Set-ExecutionPolicy RemoteSigned -Scope LocalMachine -Force\n      tags: [config, powershell]\n\n    - name: Verify driver signing enforcement\n      win_shell: |\n        $bcdedit = bcdedit /enum\n        if ($bcdedit -match \"testsigning.*Yes\") { \"DISABLED\" } else { \"ENABLED\" }\n      register: driver_signing\n      changed_when: false\n      tags: [verify, drivers]\n\n    - name: Report driver signing status\n      debug:\n        msg: \"Driver signing enforcement: {{ driver_signing.stdout | trim }}\"\n      tags: [verify, drivers]\n\n    - name: Verify critical binary signatures\n      win_shell: |\n        $binaries = @(\n          \"$env:SystemRoot\\System32\\kernel32.dll\",\n          \"$env:SystemRoot\\System32\\cmd.exe\"\n        )\n        $failed = 0\n        foreach ($b in $binaries) {\n          $sig = Get-AuthenticodeSignature -FilePath $b\n          if ($sig.Status -ne \"Valid\") { $failed++ }\n        }\n        if ($failed -eq 0) { \"ALL_VALID\" } else { \"FAILURES_DETECTED\" }\n      register: binary_sigs\n      changed_when: false\n      tags: [verify, binaries]\n\n    - name: Report binary signature status\n      debug:\n        msg: \"Binary signatures: {{ binary_sigs.stdout | trim }}\"\n      tags: [verify, binaries]"
      }
    },
    "stig_mappings": [],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00.000000Z",
      "has_scripts": true,
      "qa_reviewed": true,
      "qa_reviewer": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "last_analyzed": "2025-11-22T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Technical implementation through code signing, SBOM generation, and build pipeline integrity verification. Organizational procedures required for SDLC integration and process controls."
    }
  },
  {
    "control_id": "SR-10",
    "control_name": "Inspection of Systems or Components",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Inspect the following systems or system components [Selection (one or more): at random; at [Assignment: organization-defined frequency]; upon [Assignment: organization-defined indications of need for inspection]] to detect tampering: [Assignment: organization-defined systems or system components].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "intent": "To detect tampering with systems or system components that have been removed from organizational control or are subject to supply chain risk.",
    "rationale": "Systems and components removed from organizational control (such as during transit, maintenance, or travel) may be subject to tampering that introduces malicious code, counterfeit components, or compromised hardware. Regular inspection provides assurance that components remain authentic and unaltered.",
    "plain_english_explanation": "This control requires organizations to physically and logically inspect systems and components for signs of tampering. Inspections should occur at defined intervals, randomly, or when specific risk indicators suggest the need (such as after travel to high-risk locations, changes in supplier packaging, or alterations to specifications). The goal is to detect unauthorized modifications before compromised components are reintegrated into operational environments.",
    "example_implementation": "Implement automated inventory verification and hash-based integrity checking for firmware and software components. Establish physical inspection protocols for hardware returning from maintenance or travel. Use tamper-evident seals and maintain chain-of-custody documentation.",
    "non_technical_guidance": "To implement the Inspection of Systems or Components control:\n1. Designate responsible personnel for conducting inspections of systems and components.\n2. Establish inspection frequency based on risk assessment and component criticality.\n3. Develop detailed inspection checklists covering physical tamper indicators (altered seals, modified packaging, changed specifications) and logical integrity (firmware hashes, software signatures).\n4. Document all inspection results, including date, inspector, findings, and disposition.\n5. Define trigger conditions that warrant immediate inspection (return from high-risk travel, supplier changes, anomalous behavior).\n6. Train inspectors on tamper detection techniques for hardware, software, and firmware.\n7. Integrate inspection results into configuration management and incident response processes.",
    "ai_guidance": "When implementing SR-10 inspection capabilities, organizations should establish a risk-based inspection framework that balances thoroughness with operational efficiency. For hardware components, implement physical inspection protocols that examine tamper-evident seals, compare serial numbers against inventory records, and verify component authenticity through visual inspection of markings and packaging. For software and firmware, deploy automated integrity verification using cryptographic hash comparisons against known-good baselines stored in secure repositories. Consider implementing automated scanning tools that can detect hardware implants or modified firmware during the boot process. Inspection triggers should include: return from travel to high-risk countries (per threat intelligence), any changes in supplier or manufacturing location, packaging anomalies, unexplained performance variations, and random sampling at defined intervals. Document all inspections in a centralized tracking system that supports trend analysis and audit requirements. For high-value assets, consider implementing hardware-based attestation mechanisms that can cryptographically prove component integrity. Integrate inspection findings with your security information and event management (SIEM) system to correlate physical and logical security events.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AT-3",
      "PM-30",
      "SI-4",
      "SI-7",
      "SR-3",
      "SR-4",
      "SR-5",
      "SR-9",
      "SR-11"
    ],
    "supplemental_guidance": "The inspection of systems or systems components for tamper resistance and detection addresses physical and logical tampering and is applied to systems and system components removed from organization-controlled areas. Indications of a need for inspection include changes in packaging, specifications, factory location, or entity in which the part is purchased, and when individuals return from travel to high-risk locations.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# SR-10: System Component Inspection Script\n# Purpose: Verify integrity of system components and detect tampering\n\nLOG_FILE=\"/var/log/sr10_inspection_$(date +%Y%m%d_%H%M%S).log\"\nBASELINE_DIR=\"/etc/security/baselines\"\nRESULT=\"PASS\"\n\nlog_message() {\n    echo \"$(date '+%Y-%m-%d %H:%M:%S') - $1\" | tee -a \"$LOG_FILE\"\n}\n\nlog_message \"=== SR-10 System Component Inspection Started ===\"\n\n# 1. Hardware Inventory Verification\nlog_message \"[STEP 1] Verifying hardware inventory...\"\nDMIDECODE_HASH=$(dmidecode 2>/dev/null | sha256sum | cut -d' ' -f1)\nif [ -f \"$BASELINE_DIR/hardware_baseline.sha256\" ]; then\n    BASELINE_HASH=$(cat \"$BASELINE_DIR/hardware_baseline.sha256\")\n    if [ \"$DMIDECODE_HASH\" != \"$BASELINE_HASH\" ]; then\n        log_message \"[WARNING] Hardware configuration changed from baseline\"\n        RESULT=\"FAIL\"\n    else\n        log_message \"[OK] Hardware inventory matches baseline\"\n    fi\nelse\n    log_message \"[INFO] Creating hardware baseline...\"\n    mkdir -p \"$BASELINE_DIR\"\n    echo \"$DMIDECODE_HASH\" > \"$BASELINE_DIR/hardware_baseline.sha256\"\nfi\n\n# 2. Firmware Integrity Verification\nlog_message \"[STEP 2] Checking firmware integrity...\"\nif command -v fwupdmgr &> /dev/null; then\n    fwupdmgr get-devices 2>/dev/null | tee -a \"$LOG_FILE\"\n    fwupdmgr verify 2>/dev/null | tee -a \"$LOG_FILE\"\n    log_message \"[OK] Firmware verification completed\"\nelse\n    log_message \"[INFO] fwupd not installed - manual firmware verification required\"\nfi\n\n# 3. PCI Device Enumeration Check\nlog_message \"[STEP 3] Enumerating PCI devices...\"\nLSPCI_HASH=$(lspci -nn 2>/dev/null | sha256sum | cut -d' ' -f1)\nif [ -f \"$BASELINE_DIR/pci_baseline.sha256\" ]; then\n    BASELINE_PCI=$(cat \"$BASELINE_DIR/pci_baseline.sha256\")\n    if [ \"$LSPCI_HASH\" != \"$BASELINE_PCI\" ]; then\n        log_message \"[WARNING] PCI device configuration changed - potential hardware modification\"\n        RESULT=\"FAIL\"\n    else\n        log_message \"[OK] PCI device inventory matches baseline\"\n    fi\nelse\n    echo \"$LSPCI_HASH\" > \"$BASELINE_DIR/pci_baseline.sha256\"\n    log_message \"[INFO] PCI baseline created\"\nfi\n\n# 4. USB Device Audit\nlog_message \"[STEP 4] Auditing USB devices...\"\nlsusb 2>/dev/null | tee -a \"$LOG_FILE\"\n\n# 5. Kernel Module Verification\nlog_message \"[STEP 5] Verifying loaded kernel modules...\"\nLSMOD_HASH=$(lsmod | sort | sha256sum | cut -d' ' -f1)\nif [ -f \"$BASELINE_DIR/modules_baseline.sha256\" ]; then\n    BASELINE_MOD=$(cat \"$BASELINE_DIR/modules_baseline.sha256\")\n    if [ \"$LSMOD_HASH\" != \"$BASELINE_MOD\" ]; then\n        log_message \"[WARNING] Kernel modules changed from baseline\"\n        # List differences\n        lsmod | sort > /tmp/current_modules.txt\n        log_message \"[INFO] Current modules saved for review\"\n    else\n        log_message \"[OK] Kernel modules match baseline\"\n    fi\nfi\n\n# 6. Boot Integrity Check (if available)\nlog_message \"[STEP 6] Checking boot integrity...\"\nif [ -d \"/sys/firmware/efi\" ]; then\n    log_message \"[INFO] System booted in UEFI mode\"\n    if command -v mokutil &> /dev/null; then\n        mokutil --sb-state 2>/dev/null | tee -a \"$LOG_FILE\"\n    fi\nfi\n\n# Generate inspection report\nlog_message \"=== SR-10 Inspection Complete ===\"\nlog_message \"Overall Result: $RESULT\"\nlog_message \"Report saved to: $LOG_FILE\"\n\nexit $([ \"$RESULT\" = \"PASS\" ] && echo 0 || echo 1)",
        "ansible": "---\n# SR-10: System Component Inspection Playbook\n# Purpose: Automated inspection of systems and components for tampering detection\n\n- name: SR-10 System Component Inspection\n  hosts: all\n  become: yes\n  vars:\n    baseline_dir: /etc/security/baselines\n    log_dir: /var/log/security/inspections\n    inspection_date: \"{{ ansible_date_time.date }}\"\n  \n  tasks:\n    - name: Create baseline and log directories\n      file:\n        path: \"{{ item }}\"\n        state: directory\n        mode: '0750'\n        owner: root\n        group: root\n      loop:\n        - \"{{ baseline_dir }}\"\n        - \"{{ log_dir }}\"\n\n    - name: Collect hardware inventory hash\n      shell: dmidecode | sha256sum | cut -d' ' -f1\n      register: hardware_hash\n      changed_when: false\n      failed_when: false\n\n    - name: Check hardware baseline exists\n      stat:\n        path: \"{{ baseline_dir }}/hardware_baseline.sha256\"\n      register: hw_baseline\n\n    - name: Create hardware baseline if not exists\n      copy:\n        content: \"{{ hardware_hash.stdout }}\"\n        dest: \"{{ baseline_dir }}/hardware_baseline.sha256\"\n        mode: '0640'\n      when: not hw_baseline.stat.exists\n\n    - name: Verify hardware against baseline\n      shell: cat {{ baseline_dir }}/hardware_baseline.sha256\n      register: hw_baseline_content\n      when: hw_baseline.stat.exists\n      changed_when: false\n\n    - name: Report hardware tampering\n      debug:\n        msg: \"WARNING: Hardware configuration has changed from baseline!\"\n      when: \n        - hw_baseline.stat.exists\n        - hardware_hash.stdout != hw_baseline_content.stdout\n\n    - name: Collect PCI device inventory\n      shell: lspci -nn | sha256sum | cut -d' ' -f1\n      register: pci_hash\n      changed_when: false\n      failed_when: false\n\n    - name: Check PCI baseline exists\n      stat:\n        path: \"{{ baseline_dir }}/pci_baseline.sha256\"\n      register: pci_baseline\n\n    - name: Create PCI baseline if not exists\n      copy:\n        content: \"{{ pci_hash.stdout }}\"\n        dest: \"{{ baseline_dir }}/pci_baseline.sha256\"\n        mode: '0640'\n      when: not pci_baseline.stat.exists\n\n    - name: Verify firmware integrity with fwupd\n      shell: fwupdmgr verify 2>/dev/null || echo 'fwupd not available'\n      register: firmware_verify\n      changed_when: false\n      failed_when: false\n\n    - name: Collect USB device inventory\n      shell: lsusb\n      register: usb_devices\n      changed_when: false\n      failed_when: false\n\n    - name: Check Secure Boot status\n      shell: mokutil --sb-state 2>/dev/null || echo 'mokutil not available'\n      register: secureboot_status\n      changed_when: false\n      failed_when: false\n\n    - name: Generate inspection report\n      template:\n        src: inspection_report.j2\n        dest: \"{{ log_dir }}/inspection_{{ inspection_date }}.log\"\n        mode: '0640'\n      vars:\n        report_data:\n          date: \"{{ inspection_date }}\"\n          hostname: \"{{ ansible_hostname }}\"\n          hardware_status: \"{{ 'MATCH' if hardware_hash.stdout == hw_baseline_content.stdout | default('N/A') else 'CHANGED' }}\"\n          pci_devices: \"{{ pci_hash.stdout }}\"\n          usb_inventory: \"{{ usb_devices.stdout_lines | default([]) }}\"\n          secureboot: \"{{ secureboot_status.stdout }}\"\n          firmware: \"{{ firmware_verify.stdout }}\""
      },
      "windows": {
        "powershell": "# SR-10: System Component Inspection Script for Windows\n# Purpose: Verify integrity of system components and detect tampering\n\n$ErrorActionPreference = \"Continue\"\n$LogPath = \"C:\\SecurityLogs\\SR10_Inspection\"\n$BaselinePath = \"C:\\SecurityBaselines\"\n$Timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$LogFile = \"$LogPath\\SR10_Inspection_$Timestamp.log\"\n$Result = \"PASS\"\n\n# Create directories if they don't exist\nNew-Item -ItemType Directory -Force -Path $LogPath | Out-Null\nNew-Item -ItemType Directory -Force -Path $BaselinePath | Out-Null\n\nfunction Write-Log {\n    param([string]$Message)\n    $Entry = \"$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') - $Message\"\n    Add-Content -Path $LogFile -Value $Entry\n    Write-Host $Entry\n}\n\nWrite-Log \"=== SR-10 System Component Inspection Started ===\"\n\n# 1. Hardware Inventory Verification\nWrite-Log \"[STEP 1] Verifying hardware inventory...\"\ntry {\n    $HardwareInfo = Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object Manufacturer, Model, TotalPhysicalMemory\n    $BiosInfo = Get-CimInstance -ClassName Win32_BIOS | Select-Object Manufacturer, SMBIOSBIOSVersion, SerialNumber\n    $BaseboardInfo = Get-CimInstance -ClassName Win32_BaseBoard | Select-Object Manufacturer, Product, SerialNumber\n    \n    $HardwareHash = [System.BitConverter]::ToString(\n        [System.Security.Cryptography.SHA256]::Create().ComputeHash(\n            [System.Text.Encoding]::UTF8.GetBytes(\"$HardwareInfo$BiosInfo$BaseboardInfo\")\n        )\n    ) -replace '-',''\n    \n    $BaselineFile = \"$BaselinePath\\hardware_baseline.sha256\"\n    if (Test-Path $BaselineFile) {\n        $StoredHash = Get-Content $BaselineFile\n        if ($HardwareHash -ne $StoredHash) {\n            Write-Log \"[WARNING] Hardware configuration changed from baseline\"\n            $script:Result = \"FAIL\"\n        } else {\n            Write-Log \"[OK] Hardware inventory matches baseline\"\n        }\n    } else {\n        $HardwareHash | Out-File $BaselineFile -Encoding UTF8\n        Write-Log \"[INFO] Hardware baseline created\"\n    }\n} catch {\n    Write-Log \"[ERROR] Hardware verification failed: $_\"\n}\n\n# 2. TPM Integrity Check\nWrite-Log \"[STEP 2] Checking TPM status...\"\ntry {\n    $TPM = Get-Tpm\n    Write-Log \"[INFO] TPM Present: $($TPM.TpmPresent)\"\n    Write-Log \"[INFO] TPM Ready: $($TPM.TpmReady)\"\n    Write-Log \"[INFO] TPM Enabled: $($TPM.TpmEnabled)\"\n    if (-not $TPM.TpmReady) {\n        Write-Log \"[WARNING] TPM is not in ready state\"\n    }\n} catch {\n    Write-Log \"[INFO] TPM not available or accessible\"\n}\n\n# 3. Secure Boot Verification\nWrite-Log \"[STEP 3] Verifying Secure Boot status...\"\ntry {\n    $SecureBoot = Confirm-SecureBootUEFI\n    if ($SecureBoot) {\n        Write-Log \"[OK] Secure Boot is enabled\"\n    } else {\n        Write-Log \"[WARNING] Secure Boot is disabled - potential firmware tampering risk\"\n    }\n} catch {\n    Write-Log \"[INFO] Secure Boot verification not supported on this system\"\n}\n\n# 4. PnP Device Enumeration\nWrite-Log \"[STEP 4] Enumerating PnP devices...\"\ntry {\n    $Devices = Get-PnpDevice -Status OK | Select-Object Class, FriendlyName, InstanceId\n    $DeviceHash = [System.BitConverter]::ToString(\n        [System.Security.Cryptography.SHA256]::Create().ComputeHash(\n            [System.Text.Encoding]::UTF8.GetBytes(($Devices | ConvertTo-Json))\n        )\n    ) -replace '-',''\n    \n    $DeviceBaselineFile = \"$BaselinePath\\pnp_devices_baseline.sha256\"\n    if (Test-Path $DeviceBaselineFile) {\n        $StoredDeviceHash = Get-Content $DeviceBaselineFile\n        if ($DeviceHash -ne $StoredDeviceHash) {\n            Write-Log \"[WARNING] PnP device configuration changed - review for unauthorized hardware\"\n            $script:Result = \"FAIL\"\n        } else {\n            Write-Log \"[OK] PnP device inventory matches baseline\"\n        }\n    } else {\n        $DeviceHash | Out-File $DeviceBaselineFile -Encoding UTF8\n        Write-Log \"[INFO] PnP device baseline created\"\n    }\n} catch {\n    Write-Log \"[ERROR] PnP enumeration failed: $_\"\n}\n\n# 5. Driver Signature Verification\nWrite-Log \"[STEP 5] Verifying driver signatures...\"\ntry {\n    $UnsignedDrivers = Get-WindowsDriver -Online | Where-Object { $_.DriverSignature -ne 'Signed' }\n    if ($UnsignedDrivers) {\n        Write-Log \"[WARNING] Found unsigned drivers:\"\n        $UnsignedDrivers | ForEach-Object { Write-Log \"  - $($_.OriginalFileName)\" }\n        $script:Result = \"FAIL\"\n    } else {\n        Write-Log \"[OK] All drivers are signed\"\n    }\n} catch {\n    Write-Log \"[INFO] Driver signature verification requires elevation\"\n}\n\n# 6. BitLocker Status Check\nWrite-Log \"[STEP 6] Checking BitLocker status...\"\ntry {\n    $BitLocker = Get-BitLockerVolume -MountPoint \"C:\"\n    Write-Log \"[INFO] BitLocker Protection: $($BitLocker.ProtectionStatus)\"\n    Write-Log \"[INFO] Encryption Status: $($BitLocker.VolumeStatus)\"\n} catch {\n    Write-Log \"[INFO] BitLocker status not available\"\n}\n\n# Generate summary\nWrite-Log \"=== SR-10 Inspection Complete ===\"\nWrite-Log \"Overall Result: $Result\"\nWrite-Log \"Report saved to: $LogFile\"\n\nif ($Result -eq \"FAIL\") { exit 1 } else { exit 0 }",
        "ansible": "---\n# SR-10: System Component Inspection Playbook for Windows\n# Purpose: Automated inspection of Windows systems for tampering detection\n\n- name: SR-10 Windows System Component Inspection\n  hosts: windows\n  gather_facts: yes\n  vars:\n    baseline_path: C:\\SecurityBaselines\n    log_path: C:\\SecurityLogs\\SR10_Inspection\n  \n  tasks:\n    - name: Create baseline directory\n      win_file:\n        path: \"{{ baseline_path }}\"\n        state: directory\n\n    - name: Create log directory\n      win_file:\n        path: \"{{ log_path }}\"\n        state: directory\n\n    - name: Collect hardware information\n      win_shell: |\n        $hw = Get-CimInstance Win32_ComputerSystem | Select Manufacturer,Model\n        $bios = Get-CimInstance Win32_BIOS | Select Manufacturer,SMBIOSBIOSVersion,SerialNumber\n        $hw | ConvertTo-Json; $bios | ConvertTo-Json\n      register: hardware_info\n\n    - name: Check TPM status\n      win_shell: Get-Tpm | ConvertTo-Json\n      register: tpm_status\n      failed_when: false\n\n    - name: Verify Secure Boot\n      win_shell: Confirm-SecureBootUEFI\n      register: secure_boot\n      failed_when: false\n\n    - name: Enumerate PnP devices\n      win_shell: Get-PnpDevice -Status OK | Select Class,FriendlyName | ConvertTo-Json\n      register: pnp_devices\n\n    - name: Check for unsigned drivers\n      win_shell: |\n        $unsigned = Get-WindowsDriver -Online | Where-Object { $_.DriverSignature -ne 'Signed' }\n        if ($unsigned) { $unsigned | Select OriginalFileName | ConvertTo-Json } else { 'None' }\n      register: unsigned_drivers\n      failed_when: false\n\n    - name: Check BitLocker status\n      win_shell: Get-BitLockerVolume -MountPoint C: | Select ProtectionStatus,VolumeStatus | ConvertTo-Json\n      register: bitlocker_status\n      failed_when: false\n\n    - name: Generate inspection report\n      win_copy:\n        content: |\n          SR-10 System Component Inspection Report\n          =========================================\n          Date: {{ ansible_date_time.date }}\n          Hostname: {{ ansible_hostname }}\n          \n          Hardware Information:\n          {{ hardware_info.stdout }}\n          \n          TPM Status:\n          {{ tpm_status.stdout | default('Not available') }}\n          \n          Secure Boot: {{ secure_boot.stdout | default('Not available') }}\n          \n          Unsigned Drivers:\n          {{ unsigned_drivers.stdout | default('Check failed') }}\n          \n          BitLocker Status:\n          {{ bitlocker_status.stdout | default('Not available') }}\n        dest: \"{{ log_path }}\\\\inspection_{{ ansible_date_time.date }}.txt\""
      }
    },
    "stig_mappings": [
      {
        "stig_id": "SRG-OS-000480-GPOS-00227",
        "title": "System Integrity Verification",
        "description": "The operating system must verify the integrity of software and firmware."
      }
    ],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Implement automated hardware and firmware integrity verification using baseline comparisons and cryptographic hash validation."
    }
  },
  {
    "control_id": "SR-11",
    "control_name": "Component Authenticity",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "a. Develop and implement anti-counterfeit policy and procedures that include the means to detect and prevent counterfeit components from entering the system; and b. Report counterfeit system components to [Selection (one or more): source of counterfeit component; [Assignment: organization-defined external reporting organizations]; [Assignment: organization-defined personnel or roles]].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "intent": "To prevent counterfeit hardware, software, and firmware components from being integrated into organizational systems.",
    "rationale": "Counterfeit components may contain malicious code, have degraded performance, or fail unexpectedly. They undermine the integrity and reliability of systems and can serve as vectors for supply chain attacks. Detecting and preventing counterfeits protects both operational capability and sensitive information.",
    "plain_english_explanation": "This control requires organizations to establish formal anti-counterfeit policies and procedures. This includes implementing mechanisms to detect counterfeit components before they enter the system and reporting identified counterfeits to appropriate authorities. Sources of counterfeit components include malicious manufacturers, distributors, vendors, and contractors who substitute inferior or compromised parts for genuine ones.",
    "example_implementation": "Establish vendor verification programs, implement component authentication through serial number verification and cryptographic attestation, maintain approved supplier lists, and create reporting channels to CISA or internal security teams for counterfeit discoveries.",
    "non_technical_guidance": "To implement Component Authenticity controls:\n1. Develop a formal anti-counterfeit policy defining roles, responsibilities, and procedures.\n2. Create an approved supplier list and require vendor security assessments.\n3. Implement receiving inspection procedures that verify component authenticity.\n4. Train procurement and receiving personnel on counterfeit detection.\n5. Establish reporting procedures for suspected counterfeits (internal escalation and external reporting to CISA or industry consortiums).\n6. Maintain chain-of-custody documentation for critical components.\n7. Consider third-party authentication services for high-value components.\n8. Regularly audit supplier compliance with anti-counterfeit requirements.",
    "ai_guidance": "Implementing SR-11 requires a multi-layered approach combining policy, procedure, and technical verification. Start by establishing a formal anti-counterfeit policy that defines acceptable sources for components, verification requirements, and reporting obligations. For hardware components, implement authentication measures such as visual inspection of markings and packaging, verification of serial numbers against manufacturer databases, and cryptographic attestation where available (such as TPM-based platform authentication). For software, enforce code signing verification, maintain Software Bills of Materials (SBOMs), and verify package hashes against trusted repositories. Establish relationships with industry anti-counterfeit organizations and reporting channels to CISA for federal systems. Train personnel who handle procurement, receiving, and installation on counterfeit indicators including inconsistent packaging, unusual pricing, unfamiliar suppliers, and physical anomalies. Integrate counterfeit detection into your supply chain risk management program and maintain metrics on detected incidents. For critical systems, consider implementing hardware-based root of trust mechanisms that can cryptographically verify component authenticity during boot and runtime.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "SR-11.1",
        "title": "Anti-counterfeit Training",
        "official_text": "Train [Assignment: organization-defined personnel or roles] to detect counterfeit system components (including hardware, software, and firmware)."
      },
      {
        "id": "SR-11.2",
        "title": "Configuration Control for Component Service and Repair",
        "official_text": "Maintain configuration control over the following system components awaiting service or repair and serviced or repaired components awaiting return to service: [Assignment: organization-defined system components]."
      },
      {
        "id": "SR-11.3",
        "title": "Anti-counterfeit Scanning",
        "official_text": "Scan for counterfeit system components [Assignment: organization-defined frequency]."
      }
    ],
    "related_controls": [
      "AT-3",
      "CM-3",
      "MA-2",
      "MA-4",
      "PE-3",
      "RA-5",
      "SA-4",
      "SA-10",
      "SI-7",
      "SR-9",
      "SR-10"
    ],
    "supplemental_guidance": "Sources of counterfeit components include manufacturers, developers, vendors, and contractors. Anti-counterfeiting policies and procedures support tamper resistance and provide a level of protection against the introduction of malicious code. External reporting organizations include the Cybersecurity and Infrastructure Security Agency (CISA).",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# SR-11: Component Authenticity Verification Script\n# Purpose: Verify authenticity of software and firmware components\n\nLOG_FILE=\"/var/log/sr11_authenticity_$(date +%Y%m%d_%H%M%S).log\"\nCOUNTERFEIT_REPORT=\"/var/log/security/counterfeit_alerts.log\"\nRESULT=\"PASS\"\n\nmkdir -p /var/log/security\n\nlog_message() {\n    echo \"$(date '+%Y-%m-%d %H:%M:%S') - $1\" | tee -a \"$LOG_FILE\"\n}\n\nreport_counterfeit() {\n    local COMPONENT=\"$1\"\n    local REASON=\"$2\"\n    echo \"$(date '+%Y-%m-%d %H:%M:%S') - COUNTERFEIT ALERT: $COMPONENT - $REASON\" | tee -a \"$COUNTERFEIT_REPORT\"\n}\n\nlog_message \"=== SR-11 Component Authenticity Verification Started ===\"\n\n# 1. Verify Package Signatures (RPM-based systems)\nlog_message \"[STEP 1] Verifying package signatures...\"\nif command -v rpm &> /dev/null; then\n    UNSIGNED_PKGS=$(rpm -qa --qf '%{NAME}-%{VERSION}-%{RELEASE} %{SIGPGP:pgpsig}\\n' | grep -i 'not signed' || true)\n    if [ -n \"$UNSIGNED_PKGS\" ]; then\n        log_message \"[WARNING] Found unsigned packages:\"\n        echo \"$UNSIGNED_PKGS\" | tee -a \"$LOG_FILE\"\n        report_counterfeit \"RPM Packages\" \"Unsigned packages detected\"\n        RESULT=\"FAIL\"\n    else\n        log_message \"[OK] All RPM packages are signed\"\n    fi\nfi\n\n# 2. Verify Package Signatures (Debian-based systems)\nif command -v dpkg &> /dev/null; then\n    log_message \"[STEP 1b] Checking APT repository signatures...\"\n    if [ -f /etc/apt/sources.list ]; then\n        apt-key list 2>/dev/null | tee -a \"$LOG_FILE\"\n        log_message \"[INFO] APT keys listed above\"\n    fi\nfi\n\n# 2. Verify Kernel Module Signatures\nlog_message \"[STEP 2] Checking kernel module signatures...\"\nif [ -d /lib/modules/$(uname -r) ]; then\n    UNSIGNED_MODULES=$(find /lib/modules/$(uname -r) -name '*.ko*' -exec modinfo {} \\; 2>/dev/null | grep -B5 'sig_id:' | grep -A5 'filename:' | grep -v 'sig_' | head -20 || true)\n    log_message \"[INFO] Kernel module signature check completed\"\nfi\n\n# 3. Software Bill of Materials (SBOM) Check\nlog_message \"[STEP 3] Checking for SBOM documentation...\"\nSBOM_LOCATIONS=(\"/etc/sbom\" \"/var/lib/sbom\" \"/opt/sbom\")\nfor loc in \"${SBOM_LOCATIONS[@]}\"; do\n    if [ -d \"$loc\" ]; then\n        log_message \"[INFO] SBOM directory found: $loc\"\n        ls -la \"$loc\" | tee -a \"$LOG_FILE\"\n    fi\ndone\n\n# 4. Binary Integrity Check\nlog_message \"[STEP 4] Verifying critical binary integrity...\"\nCRITICAL_BINS=(\"/bin/bash\" \"/bin/sh\" \"/usr/bin/sudo\" \"/usr/bin/ssh\" \"/usr/sbin/sshd\")\nfor bin in \"${CRITICAL_BINS[@]}\"; do\n    if [ -f \"$bin\" ]; then\n        HASH=$(sha256sum \"$bin\" 2>/dev/null | cut -d' ' -f1)\n        log_message \"[INFO] $bin: $HASH\"\n    fi\ndone\n\n# 5. Check for known counterfeit indicators\nlog_message \"[STEP 5] Scanning for counterfeit indicators...\"\n\n# Check for suspicious kernel modules\nSUSPICIOUS=$(lsmod | grep -iE 'rootkit|backdoor|keylog' || true)\nif [ -n \"$SUSPICIOUS\" ]; then\n    log_message \"[CRITICAL] Suspicious modules detected:\"\n    echo \"$SUSPICIOUS\" | tee -a \"$LOG_FILE\"\n    report_counterfeit \"Kernel Modules\" \"Suspicious module names detected\"\n    RESULT=\"FAIL\"\nfi\n\n# 6. Hardware Serial Number Verification\nlog_message \"[STEP 6] Collecting hardware identifiers for verification...\"\nif command -v dmidecode &> /dev/null; then\n    dmidecode -s system-serial-number 2>/dev/null | tee -a \"$LOG_FILE\"\n    dmidecode -s baseboard-serial-number 2>/dev/null | tee -a \"$LOG_FILE\"\n    dmidecode -s bios-version 2>/dev/null | tee -a \"$LOG_FILE\"\nfi\n\nlog_message \"=== SR-11 Authenticity Verification Complete ===\"\nlog_message \"Overall Result: $RESULT\"\nlog_message \"Review counterfeit alerts at: $COUNTERFEIT_REPORT\"\n\nexit $([ \"$RESULT\" = \"PASS\" ] && echo 0 || echo 1)",
        "ansible": "---\n# SR-11: Component Authenticity Verification Playbook\n# Purpose: Verify authenticity of system components and report counterfeits\n\n- name: SR-11 Component Authenticity Verification\n  hosts: all\n  become: yes\n  vars:\n    log_dir: /var/log/security/authenticity\n    counterfeit_report: /var/log/security/counterfeit_alerts.log\n  \n  tasks:\n    - name: Create security log directory\n      file:\n        path: \"{{ log_dir }}\"\n        state: directory\n        mode: '0750'\n        owner: root\n        group: root\n\n    - name: Verify RPM package signatures (RHEL/CentOS)\n      shell: rpm -qa --qf '%{NAME}-%{VERSION}-%{RELEASE} %{SIGPGP:pgpsig}\\n' | grep -i 'not signed' || echo 'All packages signed'\n      register: rpm_unsigned\n      when: ansible_os_family == \"RedHat\"\n      changed_when: false\n\n    - name: Report unsigned RPM packages\n      lineinfile:\n        path: \"{{ counterfeit_report }}\"\n        line: \"{{ ansible_date_time.iso8601 }} - ALERT: Unsigned RPM packages detected on {{ inventory_hostname }}\"\n        create: yes\n      when: \n        - ansible_os_family == \"RedHat\"\n        - \"'not signed' in rpm_unsigned.stdout\"\n\n    - name: Verify Debian package integrity\n      shell: dpkg --verify 2>/dev/null | head -50 || echo 'Verification complete'\n      register: dpkg_verify\n      when: ansible_os_family == \"Debian\"\n      changed_when: false\n\n    - name: Collect hardware serial numbers\n      shell: |\n        echo \"System Serial: $(dmidecode -s system-serial-number 2>/dev/null)\"\n        echo \"Baseboard Serial: $(dmidecode -s baseboard-serial-number 2>/dev/null)\"\n        echo \"BIOS Version: $(dmidecode -s bios-version 2>/dev/null)\"\n      register: hardware_serials\n      changed_when: false\n\n    - name: Check for suspicious kernel modules\n      shell: lsmod | grep -iE 'rootkit|backdoor|keylog' || echo 'No suspicious modules'\n      register: suspicious_modules\n      changed_when: false\n\n    - name: Alert on suspicious modules\n      lineinfile:\n        path: \"{{ counterfeit_report }}\"\n        line: \"{{ ansible_date_time.iso8601 }} - CRITICAL: Suspicious kernel modules on {{ inventory_hostname }}: {{ suspicious_modules.stdout }}\"\n        create: yes\n      when: \"'No suspicious modules' not in suspicious_modules.stdout\"\n\n    - name: Calculate critical binary hashes\n      shell: sha256sum {{ item }} 2>/dev/null || echo 'Not found'\n      loop:\n        - /bin/bash\n        - /usr/bin/sudo\n        - /usr/bin/ssh\n        - /usr/sbin/sshd\n      register: binary_hashes\n      changed_when: false\n\n    - name: Generate authenticity report\n      template:\n        src: authenticity_report.j2\n        dest: \"{{ log_dir }}/authenticity_{{ ansible_date_time.date }}.log\"\n        mode: '0640'"
      },
      "windows": {
        "powershell": "# SR-11: Component Authenticity Verification Script for Windows\n# Purpose: Verify authenticity of software and firmware components\n\n$ErrorActionPreference = \"Continue\"\n$LogPath = \"C:\\SecurityLogs\\SR11_Authenticity\"\n$CounterfeitReport = \"C:\\SecurityLogs\\counterfeit_alerts.log\"\n$Timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$LogFile = \"$LogPath\\SR11_Authenticity_$Timestamp.log\"\n$Result = \"PASS\"\n\nNew-Item -ItemType Directory -Force -Path $LogPath | Out-Null\n\nfunction Write-Log {\n    param([string]$Message)\n    $Entry = \"$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') - $Message\"\n    Add-Content -Path $LogFile -Value $Entry\n    Write-Host $Entry\n}\n\nfunction Report-Counterfeit {\n    param([string]$Component, [string]$Reason)\n    $Alert = \"$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') - COUNTERFEIT ALERT: $Component - $Reason\"\n    Add-Content -Path $CounterfeitReport -Value $Alert\n    Write-Log \"[ALERT] $Alert\"\n}\n\nWrite-Log \"=== SR-11 Component Authenticity Verification Started ===\"\n\n# 1. Verify Code Signing on Critical Executables\nWrite-Log \"[STEP 1] Verifying code signatures on critical executables...\"\n$CriticalPaths = @(\n    \"$env:SystemRoot\\System32\\*.exe\",\n    \"$env:SystemRoot\\System32\\drivers\\*.sys\"\n)\n\n$UnsignedCount = 0\nforeach ($Path in $CriticalPaths) {\n    try {\n        $Files = Get-ChildItem -Path $Path -ErrorAction SilentlyContinue | Select-Object -First 100\n        foreach ($File in $Files) {\n            $Sig = Get-AuthenticodeSignature -FilePath $File.FullName -ErrorAction SilentlyContinue\n            if ($Sig.Status -ne 'Valid') {\n                $UnsignedCount++\n                if ($UnsignedCount -le 10) {\n                    Write-Log \"[WARNING] Invalid signature: $($File.FullName) - Status: $($Sig.Status)\"\n                }\n            }\n        }\n    } catch {\n        Write-Log \"[ERROR] Signature check failed for $Path\"\n    }\n}\n\nif ($UnsignedCount -gt 0) {\n    Write-Log \"[WARNING] Found $UnsignedCount files with invalid signatures\"\n    Report-Counterfeit \"Windows Executables\" \"$UnsignedCount files with invalid or missing signatures\"\n    $script:Result = \"FAIL\"\n} else {\n    Write-Log \"[OK] All checked executables have valid signatures\"\n}\n\n# 2. Verify Driver Signatures\nWrite-Log \"[STEP 2] Verifying driver signatures...\"\ntry {\n    $Drivers = Get-WindowsDriver -Online -ErrorAction SilentlyContinue\n    $UnsignedDrivers = $Drivers | Where-Object { $_.DriverSignature -ne 'Signed' }\n    if ($UnsignedDrivers) {\n        Write-Log \"[WARNING] Found unsigned drivers:\"\n        $UnsignedDrivers | ForEach-Object {\n            Write-Log \"  - $($_.OriginalFileName)\"\n        }\n        Report-Counterfeit \"Windows Drivers\" \"Unsigned drivers detected\"\n        $script:Result = \"FAIL\"\n    } else {\n        Write-Log \"[OK] All drivers are signed\"\n    }\n} catch {\n    Write-Log \"[INFO] Driver signature check requires elevation\"\n}\n\n# 3. Windows Update Authenticity\nWrite-Log \"[STEP 3] Checking Windows Update configuration...\"\ntry {\n    $WUServer = Get-ItemProperty -Path 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate' -ErrorAction SilentlyContinue\n    if ($WUServer.WUServer) {\n        Write-Log \"[INFO] WSUS Server configured: $($WUServer.WUServer)\"\n    } else {\n        Write-Log \"[INFO] Using Microsoft Update directly\"\n    }\n} catch {\n    Write-Log \"[INFO] Windows Update using default settings\"\n}\n\n# 4. Catalog File Verification\nWrite-Log \"[STEP 4] Verifying system catalog files...\"\ntry {\n    $CatalogFiles = Get-ChildItem -Path \"$env:SystemRoot\\System32\\CatRoot\\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\" -Filter \"*.cat\" -ErrorAction SilentlyContinue | Select-Object -First 20\n    foreach ($Cat in $CatalogFiles) {\n        $Sig = Get-AuthenticodeSignature -FilePath $Cat.FullName -ErrorAction SilentlyContinue\n        if ($Sig.Status -ne 'Valid') {\n            Write-Log \"[WARNING] Invalid catalog signature: $($Cat.Name)\"\n            Report-Counterfeit \"Catalog File\" \"Invalid signature on $($Cat.Name)\"\n        }\n    }\n    Write-Log \"[OK] Catalog file verification completed\"\n} catch {\n    Write-Log \"[ERROR] Catalog verification failed: $_\"\n}\n\n# 5. Hardware Authenticity\nWrite-Log \"[STEP 5] Collecting hardware identifiers...\"\ntry {\n    $SystemInfo = Get-CimInstance Win32_ComputerSystem | Select-Object Manufacturer, Model\n    $BiosInfo = Get-CimInstance Win32_BIOS | Select-Object Manufacturer, SerialNumber, SMBIOSBIOSVersion\n    Write-Log \"[INFO] System: $($SystemInfo.Manufacturer) $($SystemInfo.Model)\"\n    Write-Log \"[INFO] BIOS: $($BiosInfo.Manufacturer) - Version: $($BiosInfo.SMBIOSBIOSVersion)\"\n    Write-Log \"[INFO] Serial: $($BiosInfo.SerialNumber)\"\n} catch {\n    Write-Log \"[ERROR] Hardware info collection failed\"\n}\n\n# 6. Check for unsigned PowerShell modules\nWrite-Log \"[STEP 6] Checking PowerShell module signatures...\"\ntry {\n    $Modules = Get-Module -ListAvailable | Select-Object -First 50\n    $UnsignedModules = @()\n    foreach ($Module in $Modules) {\n        if ($Module.Path -and (Test-Path $Module.Path)) {\n            $Sig = Get-AuthenticodeSignature -FilePath $Module.Path -ErrorAction SilentlyContinue\n            if ($Sig.Status -ne 'Valid' -and $Sig.Status -ne 'NotSigned') {\n                $UnsignedModules += $Module.Name\n            }\n        }\n    }\n    if ($UnsignedModules.Count -gt 0) {\n        Write-Log \"[WARNING] Modules with invalid signatures: $($UnsignedModules -join ', ')\"\n    } else {\n        Write-Log \"[OK] PowerShell module check completed\"\n    }\n} catch {\n    Write-Log \"[INFO] Module signature check completed with errors\"\n}\n\nWrite-Log \"=== SR-11 Authenticity Verification Complete ===\"\nWrite-Log \"Overall Result: $Result\"\nWrite-Log \"Counterfeit alerts saved to: $CounterfeitReport\"\n\nif ($Result -eq \"FAIL\") { exit 1 } else { exit 0 }",
        "ansible": "---\n# SR-11: Component Authenticity Verification for Windows\n\n- name: SR-11 Windows Component Authenticity\n  hosts: windows\n  gather_facts: yes\n  vars:\n    log_path: C:\\SecurityLogs\\SR11_Authenticity\n  \n  tasks:\n    - name: Create log directory\n      win_file:\n        path: \"{{ log_path }}\"\n        state: directory\n\n    - name: Check driver signatures\n      win_shell: |\n        $drivers = Get-WindowsDriver -Online | Where-Object { $_.DriverSignature -ne 'Signed' }\n        if ($drivers) { $drivers | Select OriginalFileName | ConvertTo-Json } else { 'All signed' }\n      register: driver_check\n      failed_when: false\n\n    - name: Collect hardware identifiers\n      win_shell: |\n        $sys = Get-CimInstance Win32_ComputerSystem\n        $bios = Get-CimInstance Win32_BIOS\n        @{System=$sys.Manufacturer + ' ' + $sys.Model; Serial=$bios.SerialNumber; BIOS=$bios.SMBIOSBIOSVersion} | ConvertTo-Json\n      register: hardware_info\n\n    - name: Verify critical executable signatures\n      win_shell: |\n        $files = Get-ChildItem \"$env:SystemRoot\\System32\\cmd.exe\",\"$env:SystemRoot\\System32\\powershell.exe\" -ErrorAction SilentlyContinue\n        $results = @()\n        foreach ($f in $files) {\n          $sig = Get-AuthenticodeSignature $f.FullName\n          $results += @{File=$f.Name; Status=$sig.Status.ToString()}\n        }\n        $results | ConvertTo-Json\n      register: exe_signatures\n\n    - name: Generate authenticity report\n      win_copy:\n        content: |\n          SR-11 Component Authenticity Report\n          =====================================\n          Date: {{ ansible_date_time.date }}\n          Host: {{ inventory_hostname }}\n          \n          Hardware Info:\n          {{ hardware_info.stdout }}\n          \n          Driver Signatures:\n          {{ driver_check.stdout }}\n          \n          Executable Signatures:\n          {{ exe_signatures.stdout }}\n        dest: \"{{ log_path }}\\\\authenticity_{{ ansible_date_time.date }}.txt\""
      }
    },
    "stig_mappings": [
      {
        "stig_id": "SRG-OS-000366-GPOS-00153",
        "title": "Software Authenticity",
        "description": "The operating system must prevent the installation of software without verification of digital signature."
      }
    ],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Implement code signing verification, driver signature enforcement, and hardware serial number validation to detect counterfeit components."
    }
  },
  {
    "control_id": "SR-11.1",
    "control_name": "Anti-counterfeit Training",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "parent_control": "SR-11",
    "official_text": "Train [Assignment: organization-defined personnel or roles] to detect counterfeit system components (including hardware, software, and firmware).",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "intent": "To ensure personnel responsible for procurement, receiving, and maintenance can identify counterfeit components.",
    "rationale": "Trained personnel serve as a critical defense layer against counterfeit infiltration. Without proper training, staff may unknowingly accept counterfeit components, introducing security vulnerabilities and operational risks into the organization.",
    "plain_english_explanation": "This enhancement requires organizations to provide anti-counterfeit training to personnel who handle, inspect, or make decisions about system components. Training should cover identification of counterfeit hardware (visual inspection, documentation verification), software (signature verification, source validation), and firmware (version verification, hash validation). Trained roles typically include procurement officers, receiving clerks, IT administrators, and security personnel.",
    "example_implementation": "Develop a training program covering counterfeit identification techniques, establish certification requirements for relevant personnel, and conduct periodic refresher training.",
    "non_technical_guidance": "Implement anti-counterfeit training by:\n1. Identifying personnel roles requiring training (procurement, receiving, IT, security).\n2. Developing training materials covering hardware counterfeit indicators (poor quality markings, inconsistent packaging, unusual weight), software verification (code signing, repository authenticity), and firmware validation.\n3. Including real-world case studies of counterfeit incidents.\n4. Establishing initial training requirements for new hires and annual refresher training.\n5. Documenting training completion and maintaining records for audit purposes.\n6. Integrating anti-counterfeit awareness into broader security awareness programs.",
    "ai_guidance": "Anti-counterfeit training should be tailored to specific personnel roles and their level of interaction with system components. Procurement personnel need training on vendor verification, contract requirements, and red flags in supplier behavior including unusual pricing, unfamiliar distributors, and incomplete documentation. Receiving personnel require hands-on training for physical inspection techniques including examining component markings, packaging quality, documentation authenticity, weight/appearance consistency, and comparing against known-good reference samples. IT administrators need training on software and firmware verification including code signing validation, hash verification against manufacturer databases, and recognizing tampered installation media or modified binaries. Security personnel should understand the broader threat landscape including how adversaries use counterfeits as attack vectors for supply chain compromise. Training should include practical exercises with sample counterfeit and genuine components to develop visual recognition skills. Establish metrics to track training effectiveness including test scores, detection rates during exercises, and time-to-detection benchmarks. Update curricula based on emerging counterfeit techniques reported by industry groups such as GIDEP, SAE International, and government agencies including CISA and DHS. Consider annual recertification requirements for personnel in critical procurement and receiving roles.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "AT-2",
      "AT-3",
      "SR-11"
    ],
    "supplemental_guidance": "Training personnel to detect counterfeit components is critical for organizations that receive system components from external sources. Training includes examining documentation, physical characteristics, and testing samples to determine if components are genuine.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires development and delivery of training programs. No technical automation applicable."
    }
  },
  {
    "control_id": "SR-11.2",
    "control_name": "Configuration Control for Component Service and Repair",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "parent_control": "SR-11",
    "official_text": "Maintain configuration control over the following system components awaiting service or repair and serviced or repaired components awaiting return to service: [Assignment: organization-defined system components].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "intent": "To prevent substitution of counterfeit components during the service and repair process.",
    "rationale": "Components sent for external service or repair leave organizational control, creating an opportunity for counterfeit substitution. Maintaining configuration control through the repair cycle ensures components returned are authentic and unaltered.",
    "plain_english_explanation": "This enhancement requires organizations to track and verify system components throughout the service and repair lifecycle. Before sending components for repair, document their configuration (serial numbers, firmware versions, hardware identifiers). Upon return, verify the configuration matches the original to detect any substitutions or unauthorized modifications. This prevents adversaries from swapping genuine components with counterfeits during the repair process.",
    "example_implementation": "Implement a component tracking system that records baseline configurations before service and validates them upon return. Use tamper-evident seals and maintain chain-of-custody documentation throughout the repair cycle.",
    "non_technical_guidance": "Implement configuration control for service and repair by:\n1. Defining which components require configuration control during service (high-value, security-critical, or mission-essential components).\n2. Establishing baseline documentation procedures capturing serial numbers, firmware versions, and configuration states before components leave for service.\n3. Implementing chain-of-custody tracking from departure through return.\n4. Using tamper-evident seals or markers that indicate if components have been opened.\n5. Requiring verification inspection upon return comparing returned components against baseline documentation.\n6. Establishing approved repair vendors with security requirements in contracts.\n7. Maintaining audit trails of all service and repair activities.",
    "ai_guidance": "Configuration control during service and repair is essential for maintaining component authenticity throughout the lifecycle. Establish a formal process that begins with pre-service baseline documentation including component serial numbers, firmware versions, hardware identifiers, and cryptographic measurements where available. Photograph components before shipping to document physical condition, markings, and any tamper-evident seals. Use tamper-evident packaging with unique serialized seals that clearly indicate if components have been accessed during transit or repair. Maintain a secure chain-of-custody log documenting every transfer including date, time, personnel involved, and condition at handoff. Upon return, conduct thorough verification comparing all recorded identifiers against the returned component before reintegration. For firmware and software, verify cryptographic hashes match pre-service baselines stored in your configuration management database. Consider requiring authorized repair facilities to provide detailed service reports documenting exactly what work was performed, parts replaced, and firmware updated. For highly sensitive or mission-critical components, consider on-site repair options with cleared personnel or establishing secure courier transport mechanisms with GPS tracking. Integrate this process with your asset management system using automated workflows to ensure no components are lost or substituted during the repair cycle. Establish escalation procedures for components that fail verification upon return.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "CM-3",
      "MA-2",
      "MA-4",
      "SA-10",
      "SR-11"
    ],
    "supplemental_guidance": "Configuration control maintains the integrity of components during service and repair operations to prevent counterfeit substitution. This includes tracking components through the service process and verifying component authenticity upon return.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires procedural implementation for component tracking during service cycles. Technical automation supports but does not replace the procedural requirements."
    }
  },
  {
    "control_id": "SR-11.3",
    "control_name": "Anti-counterfeit Scanning",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "parent_control": "SR-11",
    "official_text": "Scan for counterfeit system components [Assignment: organization-defined frequency].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "intent": "To proactively identify counterfeit components that may have entered the system through automated or manual scanning processes.",
    "rationale": "Despite preventive controls, counterfeit components may enter organizational systems. Regular scanning provides a detection mechanism to identify counterfeits that bypassed initial screening, enabling remediation before they cause operational or security impacts.",
    "plain_english_explanation": "This enhancement requires organizations to periodically scan installed system components to detect counterfeits. Scanning may include verification of hardware serial numbers against manufacturer databases, firmware hash validation, software signature verification, and physical inspection of components. The scanning frequency should be risk-based, with more frequent scanning for critical systems.",
    "example_implementation": "Deploy automated scanning tools that verify component serial numbers, firmware hashes, and software signatures. Establish manual inspection procedures for hardware components. Define scanning frequencies based on system criticality.",
    "non_technical_guidance": "Implement anti-counterfeit scanning by:\n1. Defining scanning frequency based on system criticality and risk assessment.\n2. Implementing automated tools to verify software and firmware signatures.\n3. Establishing serial number verification against manufacturer databases.\n4. Conducting periodic physical inspections of hardware components.\n5. Maintaining records of all scans and their results.\n6. Defining escalation procedures for detected anomalies.\n7. Integrating scanning results into vulnerability management processes.",
    "ai_guidance": "Anti-counterfeit scanning combines automated and manual techniques to identify counterfeit components that may have bypassed initial screening. For software, deploy tools that verify digital signatures and compare installed versions against authorized baselines maintained in your configuration management database. For firmware, implement hash verification against known-good values from manufacturers and track firmware versions across your asset inventory. For hardware, consider specialized tools that can detect counterfeit integrated circuits through electrical testing, X-ray analysis, or decapsulation for high-security environments requiring physical verification. Automated scanning should run at defined intervals based on risk assessment: weekly for mission-critical systems, bi-weekly for moderate-sensitivity systems, and monthly for standard infrastructure. Capture all scan results for trending analysis to identify patterns that might indicate supply chain compromise. Manual physical inspection should complement automated scans, focusing on visual examination of component markings, packaging, documentation, and comparison against known-good reference samples. Integrate scanning results with your configuration management database and SIEM to track component provenance and correlate with other security events. When anomalies are detected, trigger incident response procedures to investigate, quarantine suspect components, and remediate. Implement continuous monitoring for software components through SBOM validation and software composition analysis to detect compromised dependencies.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "RA-5",
      "SI-7",
      "SR-10",
      "SR-11"
    ],
    "supplemental_guidance": "Anti-counterfeit scanning complements preventive measures by providing ongoing detection capability. Scanning frequency is determined by organizational risk assessment and the criticality of systems being protected.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# SR-11.3: Anti-counterfeit Scanning Script\n# Purpose: Scan for counterfeit system components\n\nLOG_FILE=\"/var/log/sr11_3_scan_$(date +%Y%m%d_%H%M%S).log\"\nALERT_FILE=\"/var/log/security/counterfeit_scan_alerts.log\"\nRESULT=\"PASS\"\n\nmkdir -p /var/log/security\n\nlog_message() {\n    echo \"$(date '+%Y-%m-%d %H:%M:%S') - $1\" | tee -a \"$LOG_FILE\"\n}\n\nalert_counterfeit() {\n    echo \"$(date '+%Y-%m-%d %H:%M:%S') - SCAN ALERT: $1\" | tee -a \"$ALERT_FILE\"\n}\n\nlog_message \"=== SR-11.3 Anti-counterfeit Scan Started ===\"\n\n# 1. Software Package Integrity Scan\nlog_message \"[SCAN 1] Verifying software package integrity...\"\n\nif command -v rpm &> /dev/null; then\n    log_message \"[INFO] Scanning RPM package integrity...\"\n    VERIFY_FAILED=$(rpm -Va 2>/dev/null | grep -v '^\\.\\.\\.\\.\\.' | head -50)\n    if [ -n \"$VERIFY_FAILED\" ]; then\n        log_message \"[WARNING] Package verification failures detected:\"\n        echo \"$VERIFY_FAILED\" | tee -a \"$LOG_FILE\"\n        alert_counterfeit \"RPM package verification failures detected\"\n        RESULT=\"REVIEW\"\n    else\n        log_message \"[OK] RPM package verification passed\"\n    fi\nfi\n\nif command -v debsums &> /dev/null; then\n    log_message \"[INFO] Scanning Debian package integrity...\"\n    DEBSUMS_FAILED=$(debsums -c 2>/dev/null | head -50)\n    if [ -n \"$DEBSUMS_FAILED\" ]; then\n        log_message \"[WARNING] Debian package verification failures:\"\n        echo \"$DEBSUMS_FAILED\" | tee -a \"$LOG_FILE\"\n        alert_counterfeit \"Debian package integrity failures\"\n        RESULT=\"REVIEW\"\n    else\n        log_message \"[OK] Debian package verification passed\"\n    fi\nfi\n\n# 2. Firmware Version Verification\nlog_message \"[SCAN 2] Scanning firmware versions...\"\nif command -v fwupdmgr &> /dev/null; then\n    fwupdmgr get-devices --json 2>/dev/null | tee -a \"$LOG_FILE\"\n    # Check for devices with known vulnerable firmware\n    OUTDATED=$(fwupdmgr get-updates 2>/dev/null)\n    if [ -n \"$OUTDATED\" ]; then\n        log_message \"[INFO] Firmware updates available - review for authenticity\"\n    fi\nfi\n\n# 3. Hardware Component Scan\nlog_message \"[SCAN 3] Scanning hardware components...\"\n\n# Collect hardware identifiers for verification\nSYSTEM_SERIAL=$(dmidecode -s system-serial-number 2>/dev/null)\nBASEBOARD_SERIAL=$(dmidecode -s baseboard-serial-number 2>/dev/null)\nBIOS_VERSION=$(dmidecode -s bios-version 2>/dev/null)\n\nlog_message \"[INFO] System Serial: $SYSTEM_SERIAL\"\nlog_message \"[INFO] Baseboard Serial: $BASEBOARD_SERIAL\"\nlog_message \"[INFO] BIOS Version: $BIOS_VERSION\"\n\n# Check for generic or suspicious serials\nif [[ \"$SYSTEM_SERIAL\" =~ ^(To\\ Be\\ Filled|123456|000000|XXXXXX|Not\\ Specified)$ ]]; then\n    log_message \"[WARNING] Generic system serial detected - verify hardware authenticity\"\n    alert_counterfeit \"Generic system serial number detected: $SYSTEM_SERIAL\"\n    RESULT=\"REVIEW\"\nfi\n\n# 4. Network Device Scan\nlog_message \"[SCAN 4] Scanning network interfaces...\"\nip link show 2>/dev/null | tee -a \"$LOG_FILE\"\n\n# Check for MAC address anomalies (all zeros, broadcasts, etc.)\nMAC_ADDRESSES=$(ip link show | grep -oP 'link/ether \\K[0-9a-f:]+' || true)\nfor MAC in $MAC_ADDRESSES; do\n    if [[ \"$MAC\" =~ ^(00:00:00:00:00:00|ff:ff:ff:ff:ff:ff)$ ]]; then\n        log_message \"[WARNING] Invalid MAC address detected: $MAC\"\n        alert_counterfeit \"Invalid MAC address: $MAC\"\n        RESULT=\"REVIEW\"\n    fi\ndone\n\n# 5. Kernel and Module Scan\nlog_message \"[SCAN 5] Scanning kernel modules for anomalies...\"\nKERNEL_VERSION=$(uname -r)\nlog_message \"[INFO] Kernel version: $KERNEL_VERSION\"\n\n# Check module signatures\nif [ -f /proc/sys/kernel/modules_disabled ]; then\n    MODULES_DISABLED=$(cat /proc/sys/kernel/modules_disabled)\n    log_message \"[INFO] Module loading disabled: $MODULES_DISABLED\"\nfi\n\n# 6. Certificate Store Scan\nlog_message \"[SCAN 6] Scanning certificate stores...\"\nif [ -d /etc/ssl/certs ]; then\n    CERT_COUNT=$(ls -1 /etc/ssl/certs/*.pem 2>/dev/null | wc -l)\n    log_message \"[INFO] System certificates: $CERT_COUNT\"\n    \n    # Check for expired certificates\n    for cert in /etc/ssl/certs/*.pem; do\n        if [ -f \"$cert\" ]; then\n            EXPIRY=$(openssl x509 -in \"$cert\" -noout -enddate 2>/dev/null | cut -d= -f2)\n            if [ -n \"$EXPIRY\" ]; then\n                EXPIRY_EPOCH=$(date -d \"$EXPIRY\" +%s 2>/dev/null || echo 0)\n                NOW_EPOCH=$(date +%s)\n                if [ \"$EXPIRY_EPOCH\" -lt \"$NOW_EPOCH\" ] && [ \"$EXPIRY_EPOCH\" -ne 0 ]; then\n                    log_message \"[WARNING] Expired certificate: $(basename $cert)\"\n                fi\n            fi\n        fi\n    done 2>/dev/null | head -10\nfi\n\nlog_message \"=== SR-11.3 Anti-counterfeit Scan Complete ===\"\nlog_message \"Overall Result: $RESULT\"\nlog_message \"Alerts saved to: $ALERT_FILE\"\n\nexit 0",
        "ansible": "---\n# SR-11.3: Anti-counterfeit Scanning Playbook\n\n- name: SR-11.3 Anti-counterfeit Scanning\n  hosts: all\n  become: yes\n  vars:\n    scan_log_dir: /var/log/security/counterfeit_scans\n  \n  tasks:\n    - name: Create scan log directory\n      file:\n        path: \"{{ scan_log_dir }}\"\n        state: directory\n        mode: '0750'\n\n    - name: Scan RPM package integrity\n      shell: rpm -Va 2>/dev/null | grep -v '^\\.\\.\\.\\.\\.' | head -100 || echo 'All packages verified'\n      register: rpm_verify\n      when: ansible_os_family == \"RedHat\"\n      changed_when: false\n\n    - name: Scan Debian package integrity\n      shell: debsums -c 2>/dev/null | head -100 || echo 'All packages verified'\n      register: deb_verify\n      when: ansible_os_family == \"Debian\"\n      changed_when: false\n      failed_when: false\n\n    - name: Collect hardware serial numbers\n      shell: |\n        echo \"System: $(dmidecode -s system-serial-number 2>/dev/null)\"\n        echo \"Baseboard: $(dmidecode -s baseboard-serial-number 2>/dev/null)\"\n        echo \"BIOS: $(dmidecode -s bios-version 2>/dev/null)\"\n      register: hardware_serials\n      changed_when: false\n\n    - name: Check for generic serial numbers\n      shell: dmidecode -s system-serial-number 2>/dev/null\n      register: system_serial\n      changed_when: false\n\n    - name: Alert on generic serials\n      debug:\n        msg: \"WARNING: Generic serial number detected - verify hardware authenticity\"\n      when: system_serial.stdout | regex_search('(To Be Filled|123456|000000|Not Specified)')\n\n    - name: Scan network MAC addresses\n      shell: ip link show | grep -oP 'link/ether \\K[0-9a-f:]+' || echo 'No MACs found'\n      register: mac_addresses\n      changed_when: false\n\n    - name: Generate scan report\n      template:\n        src: counterfeit_scan_report.j2\n        dest: \"{{ scan_log_dir }}/scan_{{ ansible_date_time.date }}.log\"\n        mode: '0640'"
      },
      "windows": {
        "powershell": "# SR-11.3: Anti-counterfeit Scanning Script for Windows\n\n$ErrorActionPreference = \"Continue\"\n$LogPath = \"C:\\SecurityLogs\\SR11_Scans\"\n$AlertFile = \"C:\\SecurityLogs\\counterfeit_scan_alerts.log\"\n$Timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$LogFile = \"$LogPath\\SR11_Scan_$Timestamp.log\"\n$Result = \"PASS\"\n\nNew-Item -ItemType Directory -Force -Path $LogPath | Out-Null\n\nfunction Write-Log {\n    param([string]$Message)\n    $Entry = \"$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') - $Message\"\n    Add-Content -Path $LogFile -Value $Entry\n    Write-Host $Entry\n}\n\nfunction Write-Alert {\n    param([string]$Message)\n    $Entry = \"$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') - SCAN ALERT: $Message\"\n    Add-Content -Path $AlertFile -Value $Entry\n    Write-Log $Entry\n}\n\nWrite-Log \"=== SR-11.3 Anti-counterfeit Scan Started ===\"\n\n# 1. Windows System File Verification\nWrite-Log \"[SCAN 1] Running System File Checker...\"\ntry {\n    $SfcResult = sfc /verifyonly 2>&1\n    if ($SfcResult -match 'integrity violations') {\n        Write-Log \"[WARNING] System file integrity violations detected\"\n        Write-Alert \"SFC detected integrity violations\"\n        $script:Result = \"REVIEW\"\n    } else {\n        Write-Log \"[OK] System file verification passed\"\n    }\n} catch {\n    Write-Log \"[INFO] SFC requires elevation\"\n}\n\n# 2. Driver Signature Scan\nWrite-Log \"[SCAN 2] Scanning driver signatures...\"\ntry {\n    $Drivers = Get-WindowsDriver -Online -ErrorAction SilentlyContinue\n    $UnsignedDrivers = $Drivers | Where-Object { $_.DriverSignature -ne 'Signed' }\n    if ($UnsignedDrivers) {\n        Write-Log \"[WARNING] Unsigned drivers found:\"\n        foreach ($d in $UnsignedDrivers) {\n            Write-Log \"  - $($d.OriginalFileName)\"\n            Write-Alert \"Unsigned driver: $($d.OriginalFileName)\"\n        }\n        $script:Result = \"REVIEW\"\n    } else {\n        Write-Log \"[OK] All drivers are signed\"\n    }\n} catch {\n    Write-Log \"[INFO] Driver scan requires elevation\"\n}\n\n# 3. Hardware Serial Verification\nWrite-Log \"[SCAN 3] Verifying hardware identifiers...\"\n$BiosSerial = (Get-CimInstance Win32_BIOS).SerialNumber\n$SystemSerial = (Get-CimInstance Win32_ComputerSystemProduct).IdentifyingNumber\nWrite-Log \"[INFO] BIOS Serial: $BiosSerial\"\nWrite-Log \"[INFO] System Serial: $SystemSerial\"\n\n$GenericSerials = @('To Be Filled', '123456', '000000', 'Not Specified', 'Default', 'System Serial Number')\nif ($GenericSerials -contains $BiosSerial -or $GenericSerials -contains $SystemSerial) {\n    Write-Log \"[WARNING] Generic serial number detected - verify hardware authenticity\"\n    Write-Alert \"Generic hardware serial detected\"\n    $script:Result = \"REVIEW\"\n}\n\n# 4. Certificate Store Scan\nWrite-Log \"[SCAN 4] Scanning certificate stores...\"\ntry {\n    $RootCerts = Get-ChildItem Cert:\\LocalMachine\\Root\n    $ExpiredCerts = $RootCerts | Where-Object { $_.NotAfter -lt (Get-Date) }\n    if ($ExpiredCerts) {\n        Write-Log \"[WARNING] Expired root certificates found:\"\n        foreach ($cert in $ExpiredCerts | Select-Object -First 5) {\n            Write-Log \"  - $($cert.Subject) - Expired: $($cert.NotAfter)\"\n        }\n    }\n    \n    # Check for untrusted certificates\n    $UntrustedCerts = Get-ChildItem Cert:\\LocalMachine\\Disallowed\n    Write-Log \"[INFO] Untrusted certificates in store: $($UntrustedCerts.Count)\"\n} catch {\n    Write-Log \"[ERROR] Certificate scan failed: $_\"\n}\n\n# 5. Software Signature Scan\nWrite-Log \"[SCAN 5] Scanning installed software signatures...\"\ntry {\n    $Programs = Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | \n                Where-Object { $_.DisplayName } | Select-Object -First 50\n    \n    foreach ($prog in $Programs) {\n        if ($prog.InstallLocation -and (Test-Path $prog.InstallLocation)) {\n            $Exes = Get-ChildItem -Path $prog.InstallLocation -Filter \"*.exe\" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 3\n            foreach ($exe in $Exes) {\n                $sig = Get-AuthenticodeSignature $exe.FullName -ErrorAction SilentlyContinue\n                if ($sig.Status -eq 'NotSigned') {\n                    Write-Log \"[INFO] Unsigned executable: $($exe.Name) in $($prog.DisplayName)\"\n                }\n            }\n        }\n    }\n    Write-Log \"[OK] Software signature scan completed\"\n} catch {\n    Write-Log \"[INFO] Software scan completed with errors\"\n}\n\n# 6. Network Adapter MAC Scan\nWrite-Log \"[SCAN 6] Scanning network adapter MAC addresses...\"\n$Adapters = Get-NetAdapter | Where-Object { $_.Status -eq 'Up' }\nforeach ($adapter in $Adapters) {\n    Write-Log \"[INFO] $($adapter.Name): MAC=$($adapter.MacAddress)\"\n    if ($adapter.MacAddress -match '^(00-00-00-00-00-00|FF-FF-FF-FF-FF-FF)$') {\n        Write-Alert \"Invalid MAC address on $($adapter.Name)\"\n        $script:Result = \"REVIEW\"\n    }\n}\n\nWrite-Log \"=== SR-11.3 Anti-counterfeit Scan Complete ===\"\nWrite-Log \"Overall Result: $Result\"\nWrite-Log \"Alerts saved to: $AlertFile\"\n\nexit 0",
        "ansible": "---\n# SR-11.3: Anti-counterfeit Scanning for Windows\n\n- name: SR-11.3 Windows Anti-counterfeit Scan\n  hosts: windows\n  gather_facts: yes\n  vars:\n    scan_log_path: C:\\SecurityLogs\\SR11_Scans\n  \n  tasks:\n    - name: Create scan log directory\n      win_file:\n        path: \"{{ scan_log_path }}\"\n        state: directory\n\n    - name: Scan driver signatures\n      win_shell: |\n        $unsigned = Get-WindowsDriver -Online | Where-Object { $_.DriverSignature -ne 'Signed' }\n        if ($unsigned) { $unsigned | Select OriginalFileName | ConvertTo-Json } else { 'All signed' }\n      register: driver_scan\n      failed_when: false\n\n    - name: Collect hardware serials\n      win_shell: |\n        @{\n          BIOS = (Get-CimInstance Win32_BIOS).SerialNumber\n          System = (Get-CimInstance Win32_ComputerSystemProduct).IdentifyingNumber\n        } | ConvertTo-Json\n      register: hardware_scan\n\n    - name: Scan for expired certificates\n      win_shell: |\n        Get-ChildItem Cert:\\LocalMachine\\Root | Where-Object { $_.NotAfter -lt (Get-Date) } | \n        Select Subject,NotAfter | ConvertTo-Json\n      register: cert_scan\n      failed_when: false\n\n    - name: Generate scan report\n      win_copy:\n        content: |\n          SR-11.3 Anti-counterfeit Scan Report\n          ======================================\n          Date: {{ ansible_date_time.date }}\n          Host: {{ inventory_hostname }}\n          \n          Driver Signatures:\n          {{ driver_scan.stdout }}\n          \n          Hardware Serials:\n          {{ hardware_scan.stdout }}\n          \n          Expired Certificates:\n          {{ cert_scan.stdout | default('None found') }}\n        dest: \"{{ scan_log_path }}\\\\scan_{{ ansible_date_time.date }}.txt\""
      }
    },
    "stig_mappings": [],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Deploy automated scanning tools to verify software signatures, driver authenticity, and hardware serial numbers."
    }
  },
  {
    "control_id": "SR-12",
    "control_name": "Component Disposal",
    "family": "Supply Chain Risk Management",
    "family_id": "sr",
    "official_text": "Dispose of [Assignment: organization-defined data, documentation, tools, or system components] using the following techniques and methods: [Assignment: organization-defined techniques and methods].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "intent": "To securely dispose of system components, data, and documentation to prevent unauthorized disclosure and prevent components from entering gray markets.",
    "rationale": "Improper disposal of system components creates multiple risks: sensitive data may be recovered from storage media, proprietary information may be disclosed through documentation, and improperly disposed components may enter gray markets where they can be resold as genuine parts or analyzed for vulnerabilities. Secure disposal protects both information confidentiality and supply chain integrity.",
    "plain_english_explanation": "This control requires organizations to properly dispose of data, documentation, tools, and system components using approved methods. For storage media, this means following NIST SP 800-88 guidelines for sanitization (Clear, Purge, or Destroy methods appropriate to data sensitivity). For hardware, this may include physical destruction or sanitization before recycling. Documentation should be shredded or incinerated. The goal is to prevent data recovery and keep disposed components from re-entering supply chains as potentially compromised parts.",
    "example_implementation": "Implement NIST SP 800-88 compliant media sanitization procedures using approved tools (DBAN, nwipe, ATA Secure Erase). Establish contracts with certified electronics recyclers. Maintain certificates of destruction for all disposed media and components.",
    "non_technical_guidance": "Implement component disposal by:\n1. Categorizing assets by data sensitivity to determine appropriate disposal methods.\n2. Developing disposal procedures aligned with NIST SP 800-88 for media sanitization.\n3. Establishing contracts with certified electronics recyclers (e.g., R2 or e-Stewards certified).\n4. Implementing chain-of-custody tracking for assets pending disposal.\n5. Requiring and retaining certificates of destruction for all disposed media.\n6. Training personnel on proper disposal procedures for different asset types.\n7. Conducting periodic audits of disposal processes and vendor compliance.\n8. Documenting disposal activities for audit and regulatory compliance.",
    "ai_guidance": "Component disposal must be approached systematically based on data sensitivity and asset type. For storage media containing sensitive data, implement NIST SP 800-88 compliant sanitization using the appropriate method: Clear (overwriting) for lower sensitivity data being reused internally, Purge (cryptographic erase or enhanced overwriting) for moderate sensitivity, and Destroy (physical destruction) for highest sensitivity or when reuse is not planned. For HDDs, use tools like nwipe, DBAN, or ATA Secure Erase commands. For SSDs and flash storage, use manufacturer-specific cryptographic erase tools that leverage the drive's encryption capabilities. For documentation, implement cross-cut shredding meeting DIN 66399 Level P-4 or higher for sensitive materials. For hardware components, coordinate with certified electronics recyclers who can provide verified destruction. Establish a disposal staging area with physical security controls to protect assets awaiting disposal. Implement a tracking system that follows assets from decommissioning through final disposal. Require vendors to provide certificates of destruction that include serial numbers, sanitization methods used, and destruction dates. Retain disposal records for the period required by your records retention policy, typically 3-7 years. Consider on-site destruction capabilities for highest-sensitivity assets to maintain complete control throughout the disposal process.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "MP-6",
      "SR-11"
    ],
    "supplemental_guidance": "Data, documentation, tools, or system components can be disposed of at any time during the system development life cycle (not only in the disposal or retirement phase of the life cycle). For example, disposal can occur during research and development, design, prototyping, or operations/maintenance and include methods such as disk cleaning, removal of cryptographic keys, partial reuse of components. Opportunities for compromise during disposal affect physical and logical data, including system documentation in paper-based or digital files; shipping and delivery documentation; memory sticks with software code; or complete routers or servers that include permanent media, which contain sensitive or proprietary information. Additionally, proper disposal of system components helps to prevent such components from entering the gray market.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# SR-12: NIST SP 800-88 Compliant Media Sanitization Script\n# Purpose: Securely dispose of data on storage media\n# WARNING: This script DESTROYS DATA. Use with extreme caution.\n\nset -e\n\nLOG_FILE=\"/var/log/sr12_disposal_$(date +%Y%m%d_%H%M%S).log\"\nCERTIFICATE_DIR=\"/var/log/security/disposal_certificates\"\n\nmkdir -p \"$CERTIFICATE_DIR\"\n\nlog_message() {\n    echo \"$(date '+%Y-%m-%d %H:%M:%S') - $1\" | tee -a \"$LOG_FILE\"\n}\n\ngenerate_certificate() {\n    local DEVICE=\"$1\"\n    local METHOD=\"$2\"\n    local RESULT=\"$3\"\n    local CERT_FILE=\"$CERTIFICATE_DIR/disposal_cert_$(date +%Y%m%d_%H%M%S)_$(basename $DEVICE).txt\"\n    \n    cat > \"$CERT_FILE\" << EOF\n================================================================================\n                    CERTIFICATE OF MEDIA SANITIZATION\n================================================================================\n\nDate of Sanitization: $(date '+%Y-%m-%d %H:%M:%S %Z')\nOrganization: [ORGANIZATION NAME]\nPerformed By: $(whoami)@$(hostname)\n\nMEDIA INFORMATION\n-----------------\nDevice: $DEVICE\nSerial Number: $(hdparm -I $DEVICE 2>/dev/null | grep 'Serial Number' | awk '{print $NF}' || echo 'N/A')\nModel: $(hdparm -I $DEVICE 2>/dev/null | grep 'Model Number' | cut -d: -f2 | xargs || echo 'N/A')\nCapacity: $(lsblk -b -d -o SIZE $DEVICE 2>/dev/null | tail -1 || echo 'N/A') bytes\n\nSANITIZATION METHOD\n-------------------\nMethod: $METHOD\nCompliance: NIST SP 800-88 Rev 1\nResult: $RESULT\n\nVERIFICATION\n------------\nVerification Performed: Yes\nVerification Method: Read-back verification of sanitization pattern\n\nCERTIFICATION\n-------------\nI certify that the above-described media has been sanitized in accordance with\nNIST SP 800-88 guidelines and organizational security policies.\n\nSignature: _______________________________\nDate: $(date '+%Y-%m-%d')\n\n================================================================================\nEOF\n    \n    log_message \"[INFO] Certificate generated: $CERT_FILE\"\n    echo \"$CERT_FILE\"\n}\n\n# NIST 800-88 Clear Method (1-pass overwrite)\nnist_clear() {\n    local DEVICE=\"$1\"\n    log_message \"[SANITIZE] Starting NIST 800-88 CLEAR method on $DEVICE\"\n    log_message \"[WARNING] This will DESTROY all data on $DEVICE\"\n    \n    # Single pass with zeros\n    if command -v shred &> /dev/null; then\n        shred -v -n 1 -z \"$DEVICE\" 2>&1 | tee -a \"$LOG_FILE\"\n    else\n        dd if=/dev/zero of=\"$DEVICE\" bs=4M status=progress 2>&1 | tee -a \"$LOG_FILE\"\n    fi\n    \n    generate_certificate \"$DEVICE\" \"NIST 800-88 CLEAR (Single-pass zero overwrite)\" \"COMPLETED\"\n}\n\n# NIST 800-88 Purge Method (Enhanced overwrite)\nnist_purge() {\n    local DEVICE=\"$1\"\n    log_message \"[SANITIZE] Starting NIST 800-88 PURGE method on $DEVICE\"\n    log_message \"[WARNING] This will DESTROY all data on $DEVICE\"\n    \n    if command -v nwipe &> /dev/null; then\n        # Use nwipe with DoD 5220.22-M method (3-pass)\n        nwipe --autonuke --method=dodshort --verify=last \"$DEVICE\" 2>&1 | tee -a \"$LOG_FILE\"\n    elif command -v shred &> /dev/null; then\n        # Fallback to shred with 3 passes + zero\n        shred -v -n 3 -z \"$DEVICE\" 2>&1 | tee -a \"$LOG_FILE\"\n    else\n        log_message \"[ERROR] No suitable sanitization tool found (nwipe or shred required)\"\n        return 1\n    fi\n    \n    generate_certificate \"$DEVICE\" \"NIST 800-88 PURGE (3-pass overwrite with verification)\" \"COMPLETED\"\n}\n\n# ATA Secure Erase (for SSDs and HDDs supporting it)\nata_secure_erase() {\n    local DEVICE=\"$1\"\n    log_message \"[SANITIZE] Starting ATA Secure Erase on $DEVICE\"\n    log_message \"[WARNING] This will DESTROY all data on $DEVICE\"\n    \n    # Check if device supports secure erase\n    if ! hdparm -I \"$DEVICE\" 2>/dev/null | grep -q 'supported: enhanced erase'; then\n        log_message \"[ERROR] Device does not support ATA Secure Erase\"\n        return 1\n    fi\n    \n    # Set security password\n    hdparm --user-master u --security-set-pass DISPOSAL \"$DEVICE\" 2>&1 | tee -a \"$LOG_FILE\"\n    \n    # Check if enhanced secure erase is supported\n    if hdparm -I \"$DEVICE\" 2>/dev/null | grep -q 'SECURITY ERASE UNIT'; then\n        # Perform secure erase\n        hdparm --user-master u --security-erase DISPOSAL \"$DEVICE\" 2>&1 | tee -a \"$LOG_FILE\"\n        log_message \"[OK] ATA Secure Erase completed\"\n    else\n        log_message \"[ERROR] Security Erase Unit not supported\"\n        # Clear the password\n        hdparm --user-master u --security-disable DISPOSAL \"$DEVICE\" 2>/dev/null\n        return 1\n    fi\n    \n    generate_certificate \"$DEVICE\" \"ATA Secure Erase (Hardware-based sanitization)\" \"COMPLETED\"\n}\n\n# SSD TRIM and Cryptographic Erase (for self-encrypting drives)\nssd_crypto_erase() {\n    local DEVICE=\"$1\"\n    log_message \"[SANITIZE] Starting SSD Cryptographic Erase on $DEVICE\"\n    \n    # Issue TRIM/discard to entire device\n    if command -v blkdiscard &> /dev/null; then\n        blkdiscard \"$DEVICE\" 2>&1 | tee -a \"$LOG_FILE\"\n        log_message \"[OK] TRIM/Discard completed\"\n    fi\n    \n    # For self-encrypting drives, destroy encryption key\n    if command -v sedutil-cli &> /dev/null; then\n        log_message \"[INFO] Attempting OPAL crypto erase...\"\n        sedutil-cli --revertNoErase \"$DEVICE\" 2>&1 | tee -a \"$LOG_FILE\" || true\n    fi\n    \n    generate_certificate \"$DEVICE\" \"SSD Cryptographic Erase (TRIM + Key Destruction)\" \"COMPLETED\"\n}\n\n# Display usage\nshow_usage() {\n    echo \"SR-12 NIST SP 800-88 Media Sanitization Tool\"\n    echo \"=============================================\"\n    echo \"\"\n    echo \"Usage: $0 <method> <device>\"\n    echo \"\"\n    echo \"Methods:\"\n    echo \"  clear     - NIST 800-88 Clear (single-pass zero overwrite)\"\n    echo \"  purge     - NIST 800-88 Purge (multi-pass overwrite)\"\n    echo \"  secure    - ATA Secure Erase (hardware-based)\"\n    echo \"  crypto    - SSD Cryptographic Erase (for SEDs)\"\n    echo \"  verify    - Verify device is sanitized (read sample sectors)\"\n    echo \"\"\n    echo \"Example: $0 purge /dev/sdb\"\n    echo \"\"\n    echo \"WARNING: These operations PERMANENTLY DESTROY DATA!\"\n}\n\n# Verification function\nverify_sanitization() {\n    local DEVICE=\"$1\"\n    log_message \"[VERIFY] Verifying sanitization of $DEVICE\"\n    \n    # Read sample sectors and check for non-zero data\n    local SAMPLE=$(dd if=\"$DEVICE\" bs=512 count=1000 2>/dev/null | xxd | grep -v '0000 0000 0000 0000' | head -10)\n    \n    if [ -z \"$SAMPLE\" ]; then\n        log_message \"[OK] Verification passed - device appears sanitized\"\n        return 0\n    else\n        log_message \"[WARNING] Non-zero data detected - sanitization may be incomplete\"\n        return 1\n    fi\n}\n\n# Main execution\nif [ $# -lt 1 ]; then\n    show_usage\n    exit 1\nfi\n\nMETHOD=\"$1\"\nDEVICE=\"${2:-}\"\n\ncase \"$METHOD\" in\n    clear)\n        [ -z \"$DEVICE\" ] && { echo \"Device required\"; exit 1; }\n        nist_clear \"$DEVICE\"\n        ;;\n    purge)\n        [ -z \"$DEVICE\" ] && { echo \"Device required\"; exit 1; }\n        nist_purge \"$DEVICE\"\n        ;;\n    secure)\n        [ -z \"$DEVICE\" ] && { echo \"Device required\"; exit 1; }\n        ata_secure_erase \"$DEVICE\"\n        ;;\n    crypto)\n        [ -z \"$DEVICE\" ] && { echo \"Device required\"; exit 1; }\n        ssd_crypto_erase \"$DEVICE\"\n        ;;\n    verify)\n        [ -z \"$DEVICE\" ] && { echo \"Device required\"; exit 1; }\n        verify_sanitization \"$DEVICE\"\n        ;;\n    *)\n        show_usage\n        exit 1\n        ;;\nesac\n\nlog_message \"[COMPLETE] SR-12 disposal operation finished\"\nlog_message \"[INFO] Certificates stored in: $CERTIFICATE_DIR\"",
        "ansible": "---\n# SR-12: Component Disposal Playbook\n# NIST SP 800-88 Compliant Media Sanitization\n# WARNING: This playbook DESTROYS DATA. Use with extreme caution.\n\n- name: SR-12 Media Sanitization\n  hosts: disposal_targets\n  become: yes\n  vars:\n    sanitization_method: purge  # Options: clear, purge, secure\n    target_device: \"\"  # Must be specified at runtime\n    certificate_dir: /var/log/security/disposal_certificates\n    generate_certificate: true\n  \n  tasks:\n    - name: Fail if no target device specified\n      fail:\n        msg: \"target_device must be specified (e.g., /dev/sdb)\"\n      when: target_device == \"\"\n\n    - name: Verify target device exists\n      stat:\n        path: \"{{ target_device }}\"\n      register: device_check\n\n    - name: Fail if device does not exist\n      fail:\n        msg: \"Device {{ target_device }} does not exist\"\n      when: not device_check.stat.exists\n\n    - name: Create certificate directory\n      file:\n        path: \"{{ certificate_dir }}\"\n        state: directory\n        mode: '0750'\n\n    - name: Install sanitization tools\n      package:\n        name:\n          - nwipe\n          - hdparm\n        state: present\n      when: ansible_os_family in ['RedHat', 'Debian']\n\n    - name: Collect device information\n      shell: |\n        hdparm -I {{ target_device }} 2>/dev/null | grep -E '(Serial|Model)' || echo 'Info unavailable'\n      register: device_info\n      changed_when: false\n\n    - name: Get device serial number\n      shell: hdparm -I {{ target_device }} 2>/dev/null | grep 'Serial Number' | awk '{print $NF}' || echo 'N/A'\n      register: device_serial\n      changed_when: false\n\n    - name: NIST 800-88 CLEAR sanitization\n      shell: shred -v -n 1 -z {{ target_device }}\n      when: sanitization_method == 'clear'\n      async: 86400  # 24 hour timeout for large drives\n      poll: 60\n\n    - name: NIST 800-88 PURGE sanitization\n      shell: nwipe --autonuke --method=dodshort --verify=last {{ target_device }}\n      when: sanitization_method == 'purge'\n      async: 86400\n      poll: 60\n\n    - name: ATA Secure Erase sanitization\n      block:\n        - name: Set security password\n          shell: hdparm --user-master u --security-set-pass DISPOSAL {{ target_device }}\n        \n        - name: Execute secure erase\n          shell: hdparm --user-master u --security-erase DISPOSAL {{ target_device }}\n      when: sanitization_method == 'secure'\n\n    - name: Generate disposal certificate\n      template:\n        src: disposal_certificate.j2\n        dest: \"{{ certificate_dir }}/disposal_{{ device_serial.stdout | regex_replace('[^a-zA-Z0-9]', '_') }}_{{ ansible_date_time.epoch }}.txt\"\n        mode: '0640'\n      when: generate_certificate\n      vars:\n        cert_device: \"{{ target_device }}\"\n        cert_serial: \"{{ device_serial.stdout }}\"\n        cert_method: \"{{ sanitization_method | upper }}\"\n        cert_date: \"{{ ansible_date_time.iso8601 }}\"\n        cert_host: \"{{ inventory_hostname }}\""
      },
      "windows": {
        "powershell": "# SR-12: NIST SP 800-88 Compliant Media Sanitization Script for Windows\n# Purpose: Securely dispose of data on storage media\n# WARNING: This script DESTROYS DATA. Use with extreme caution.\n\nparam(\n    [Parameter(Mandatory=$false)]\n    [ValidateSet('Clear','Purge','Secure','Verify','List')]\n    [string]$Method = 'List',\n    \n    [Parameter(Mandatory=$false)]\n    [int]$DiskNumber,\n    \n    [Parameter(Mandatory=$false)]\n    [switch]$Force\n)\n\n$ErrorActionPreference = \"Stop\"\n$LogPath = \"C:\\SecurityLogs\\SR12_Disposal\"\n$CertificatePath = \"C:\\SecurityLogs\\Disposal_Certificates\"\n$Timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$LogFile = \"$LogPath\\SR12_Disposal_$Timestamp.log\"\n\nNew-Item -ItemType Directory -Force -Path $LogPath | Out-Null\nNew-Item -ItemType Directory -Force -Path $CertificatePath | Out-Null\n\nfunction Write-Log {\n    param([string]$Message)\n    $Entry = \"$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') - $Message\"\n    Add-Content -Path $LogFile -Value $Entry\n    Write-Host $Entry\n}\n\nfunction Generate-Certificate {\n    param(\n        [int]$DiskNum,\n        [string]$Method,\n        [string]$Result\n    )\n    \n    $Disk = Get-Disk -Number $DiskNum\n    $CertFile = \"$CertificatePath\\disposal_cert_$Timestamp`_disk$DiskNum.txt\"\n    \n    $Certificate = @\"\n================================================================================\n                    CERTIFICATE OF MEDIA SANITIZATION\n================================================================================\n\nDate of Sanitization: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss K')\nOrganization: [ORGANIZATION NAME]\nPerformed By: $env:USERNAME@$env:COMPUTERNAME\n\nMEDIA INFORMATION\n-----------------\nDisk Number: $DiskNum\nSerial Number: $($Disk.SerialNumber)\nModel: $($Disk.Model)\nCapacity: $([math]::Round($Disk.Size / 1GB, 2)) GB\nPartition Style: $($Disk.PartitionStyle)\nBus Type: $($Disk.BusType)\n\nSANITIZATION METHOD\n-------------------\nMethod: $Method\nCompliance: NIST SP 800-88 Rev 1\nResult: $Result\n\nVERIFICATION\n------------\nVerification Performed: Yes\nVerification Method: Windows Disk Clean All with confirmation\n\nCERTIFICATION\n-------------\nI certify that the above-described media has been sanitized in accordance with\nNIST SP 800-88 guidelines and organizational security policies.\n\nSignature: _______________________________\nDate: $(Get-Date -Format 'yyyy-MM-dd')\n\n================================================================================\n\"@\n    \n    $Certificate | Out-File -FilePath $CertFile -Encoding UTF8\n    Write-Log \"[INFO] Certificate generated: $CertFile\"\n    return $CertFile\n}\n\nfunction List-Disks {\n    Write-Log \"=== Available Disks ===\"\n    $Disks = Get-Disk | Select-Object Number, FriendlyName, SerialNumber, Size, PartitionStyle, OperationalStatus\n    $Disks | Format-Table -AutoSize | Out-String | ForEach-Object { Write-Log $_ }\n    return $Disks\n}\n\nfunction Clear-DiskData {\n    param([int]$DiskNum)\n    \n    Write-Log \"[SANITIZE] Starting NIST 800-88 CLEAR method on Disk $DiskNum\"\n    Write-Log \"[WARNING] This will DESTROY all data on Disk $DiskNum\"\n    \n    if (-not $Force) {\n        $Confirm = Read-Host \"Are you sure you want to wipe Disk $DiskNum? (YES to confirm)\"\n        if ($Confirm -ne 'YES') {\n            Write-Log \"[ABORT] User cancelled operation\"\n            return\n        }\n    }\n    \n    # Clear disk (single pass - equivalent to NIST Clear)\n    try {\n        Clear-Disk -Number $DiskNum -RemoveData -RemoveOEM -Confirm:$false\n        Write-Log \"[OK] Disk cleared successfully\"\n        Generate-Certificate -DiskNum $DiskNum -Method \"NIST 800-88 CLEAR (Partition removal)\" -Result \"COMPLETED\"\n    } catch {\n        Write-Log \"[ERROR] Clear failed: $_\"\n        throw\n    }\n}\n\nfunction Purge-DiskData {\n    param([int]$DiskNum)\n    \n    Write-Log \"[SANITIZE] Starting NIST 800-88 PURGE method on Disk $DiskNum\"\n    Write-Log \"[WARNING] This will DESTROY all data on Disk $DiskNum\"\n    \n    if (-not $Force) {\n        $Confirm = Read-Host \"Are you sure you want to PURGE Disk $DiskNum? (YES to confirm)\"\n        if ($Confirm -ne 'YES') {\n            Write-Log \"[ABORT] User cancelled operation\"\n            return\n        }\n    }\n    \n    try {\n        # Get disk object\n        $Disk = Get-Disk -Number $DiskNum\n        \n        # Set disk offline first\n        Set-Disk -Number $DiskNum -IsOffline $true -ErrorAction SilentlyContinue\n        \n        # Set disk online and clear\n        Set-Disk -Number $DiskNum -IsOffline $false\n        Set-Disk -Number $DiskNum -IsReadOnly $false\n        \n        # Initialize to clear MBR/GPT\n        Clear-Disk -Number $DiskNum -RemoveData -RemoveOEM -Confirm:$false -ErrorAction SilentlyContinue\n        \n        # Use diskpart for full clean all (writes zeros to entire disk)\n        $DiskpartScript = @\"\nselect disk $DiskNum\nclean all\n\"@\n        \n        $TempFile = \"$env:TEMP\\diskpart_clean_$DiskNum.txt\"\n        $DiskpartScript | Out-File -FilePath $TempFile -Encoding ASCII\n        \n        Write-Log \"[INFO] Running diskpart clean all (this may take several hours)...\"\n        $Result = & diskpart /s $TempFile 2>&1\n        Write-Log \"[INFO] Diskpart output: $Result\"\n        \n        Remove-Item $TempFile -Force -ErrorAction SilentlyContinue\n        \n        Write-Log \"[OK] Disk purge completed\"\n        Generate-Certificate -DiskNum $DiskNum -Method \"NIST 800-88 PURGE (DiskPart Clean All - Full zero overwrite)\" -Result \"COMPLETED\"\n        \n    } catch {\n        Write-Log \"[ERROR] Purge failed: $_\"\n        throw\n    }\n}\n\nfunction Secure-EraseDisk {\n    param([int]$DiskNum)\n    \n    Write-Log \"[SANITIZE] Starting Secure Erase on Disk $DiskNum\"\n    Write-Log \"[INFO] Checking for hardware secure erase support...\"\n    \n    $Disk = Get-Disk -Number $DiskNum\n    \n    # Check if SSD with TRIM support\n    if ($Disk.BusType -eq 'NVMe' -or $Disk.MediaType -eq 'SSD') {\n        Write-Log \"[INFO] SSD detected - using TRIM-based sanitization\"\n        \n        if (-not $Force) {\n            $Confirm = Read-Host \"Are you sure you want to secure erase Disk $DiskNum? (YES to confirm)\"\n            if ($Confirm -ne 'YES') {\n                Write-Log \"[ABORT] User cancelled operation\"\n                return\n            }\n        }\n        \n        try {\n            # For NVMe drives, use Windows native format with quick format disabled\n            Clear-Disk -Number $DiskNum -RemoveData -RemoveOEM -Confirm:$false\n            \n            # Optimize-Volume with retrim for SSD\n            Initialize-Disk -Number $DiskNum -PartitionStyle GPT\n            $Part = New-Partition -DiskNumber $DiskNum -UseMaximumSize -AssignDriveLetter\n            Format-Volume -DriveLetter $Part.DriveLetter -FileSystem NTFS -Confirm:$false\n            Optimize-Volume -DriveLetter $Part.DriveLetter -ReTrim -Verbose\n            \n            Write-Log \"[OK] SSD secure erase completed\"\n            Generate-Certificate -DiskNum $DiskNum -Method \"Secure Erase (SSD TRIM-based sanitization)\" -Result \"COMPLETED\"\n            \n        } catch {\n            Write-Log \"[ERROR] Secure erase failed: $_\"\n            throw\n        }\n    } else {\n        Write-Log \"[INFO] HDD detected - falling back to PURGE method\"\n        Purge-DiskData -DiskNum $DiskNum\n    }\n}\n\nfunction Verify-Sanitization {\n    param([int]$DiskNum)\n    \n    Write-Log \"[VERIFY] Verifying sanitization of Disk $DiskNum\"\n    \n    try {\n        $Disk = Get-Disk -Number $DiskNum\n        \n        # Check if disk is raw (no partitions)\n        $Partitions = Get-Partition -DiskNumber $DiskNum -ErrorAction SilentlyContinue\n        \n        if (-not $Partitions) {\n            Write-Log \"[OK] Disk has no partitions - appears sanitized\"\n        } else {\n            Write-Log \"[WARNING] Disk still has partitions:\"\n            $Partitions | ForEach-Object { Write-Log \"  Partition $($_.PartitionNumber): $($_.Size / 1GB) GB\" }\n        }\n        \n        Write-Log \"[INFO] Disk status: $($Disk.OperationalStatus)\"\n        Write-Log \"[INFO] Partition style: $($Disk.PartitionStyle)\"\n        \n    } catch {\n        Write-Log \"[ERROR] Verification failed: $_\"\n    }\n}\n\n# Main execution\nWrite-Log \"=== SR-12 Media Sanitization Tool Started ===\"\nWrite-Log \"[INFO] Method: $Method\"\n\nswitch ($Method) {\n    'List' {\n        List-Disks\n    }\n    'Clear' {\n        if ($null -eq $DiskNumber) {\n            Write-Log \"[ERROR] DiskNumber parameter required for Clear operation\"\n            List-Disks\n            exit 1\n        }\n        Clear-DiskData -DiskNum $DiskNumber\n    }\n    'Purge' {\n        if ($null -eq $DiskNumber) {\n            Write-Log \"[ERROR] DiskNumber parameter required for Purge operation\"\n            List-Disks\n            exit 1\n        }\n        Purge-DiskData -DiskNum $DiskNumber\n    }\n    'Secure' {\n        if ($null -eq $DiskNumber) {\n            Write-Log \"[ERROR] DiskNumber parameter required for Secure operation\"\n            List-Disks\n            exit 1\n        }\n        Secure-EraseDisk -DiskNum $DiskNumber\n    }\n    'Verify' {\n        if ($null -eq $DiskNumber) {\n            Write-Log \"[ERROR] DiskNumber parameter required for Verify operation\"\n            List-Disks\n            exit 1\n        }\n        Verify-Sanitization -DiskNum $DiskNumber\n    }\n}\n\nWrite-Log \"=== SR-12 Operation Complete ===\"\nWrite-Log \"[INFO] Certificates stored in: $CertificatePath\"\nWrite-Log \"[INFO] Logs stored in: $LogPath\"",
        "ansible": "---\n# SR-12: Component Disposal Playbook for Windows\n# NIST SP 800-88 Compliant Media Sanitization\n# WARNING: This playbook DESTROYS DATA. Use with extreme caution.\n\n- name: SR-12 Windows Media Sanitization\n  hosts: windows_disposal\n  gather_facts: yes\n  vars:\n    sanitization_method: Purge  # Options: Clear, Purge, Secure\n    target_disk_number: \"\"  # Must be specified at runtime\n    certificate_path: C:\\SecurityLogs\\Disposal_Certificates\n    log_path: C:\\SecurityLogs\\SR12_Disposal\n  \n  tasks:\n    - name: Fail if no target disk specified\n      fail:\n        msg: \"target_disk_number must be specified\"\n      when: target_disk_number == \"\"\n\n    - name: Create certificate directory\n      win_file:\n        path: \"{{ certificate_path }}\"\n        state: directory\n\n    - name: Create log directory\n      win_file:\n        path: \"{{ log_path }}\"\n        state: directory\n\n    - name: Collect disk information before sanitization\n      win_shell: |\n        $disk = Get-Disk -Number {{ target_disk_number }}\n        @{\n          Number = $disk.Number\n          Model = $disk.Model\n          SerialNumber = $disk.SerialNumber\n          Size = $disk.Size\n          BusType = $disk.BusType\n          MediaType = $disk.MediaType\n        } | ConvertTo-Json\n      register: disk_info_before\n\n    - name: Execute Clear sanitization\n      win_shell: |\n        Clear-Disk -Number {{ target_disk_number }} -RemoveData -RemoveOEM -Confirm:$false\n      when: sanitization_method == 'Clear'\n\n    - name: Execute Purge sanitization (diskpart clean all)\n      win_shell: |\n        $script = \"select disk {{ target_disk_number }}`nclean all\"\n        $script | Out-File -FilePath \"$env:TEMP\\diskpart_purge.txt\" -Encoding ASCII\n        $result = & diskpart /s \"$env:TEMP\\diskpart_purge.txt\"\n        Remove-Item \"$env:TEMP\\diskpart_purge.txt\" -Force\n        $result\n      when: sanitization_method == 'Purge'\n      async: 86400  # 24 hour timeout\n      poll: 300  # Check every 5 minutes\n\n    - name: Execute Secure Erase for SSDs\n      win_shell: |\n        $disk = Get-Disk -Number {{ target_disk_number }}\n        if ($disk.BusType -eq 'NVMe' -or $disk.MediaType -eq 'SSD') {\n          Clear-Disk -Number {{ target_disk_number }} -RemoveData -RemoveOEM -Confirm:$false\n          Initialize-Disk -Number {{ target_disk_number }} -PartitionStyle GPT\n          $part = New-Partition -DiskNumber {{ target_disk_number }} -UseMaximumSize -AssignDriveLetter\n          Format-Volume -DriveLetter $part.DriveLetter -FileSystem NTFS -Confirm:$false\n          Optimize-Volume -DriveLetter $part.DriveLetter -ReTrim\n          'SSD Secure Erase Completed'\n        } else {\n          'Not an SSD - use Purge method instead'\n        }\n      when: sanitization_method == 'Secure'\n      register: secure_erase_result\n\n    - name: Generate disposal certificate\n      win_copy:\n        content: |\n          ================================================================================\n                              CERTIFICATE OF MEDIA SANITIZATION\n          ================================================================================\n          \n          Date of Sanitization: {{ ansible_date_time.iso8601 }}\n          Performed By: Ansible Automation\n          Host: {{ inventory_hostname }}\n          \n          MEDIA INFORMATION\n          -----------------\n          {{ disk_info_before.stdout }}\n          \n          SANITIZATION METHOD\n          -------------------\n          Method: NIST SP 800-88 {{ sanitization_method | upper }}\n          Compliance: NIST SP 800-88 Rev 1\n          Result: COMPLETED\n          \n          ================================================================================\n        dest: \"{{ certificate_path }}\\\\disposal_cert_{{ ansible_date_time.epoch }}_disk{{ target_disk_number }}.txt\""
      }
    },
    "stig_mappings": [
      {
        "stig_id": "V-32102",
        "title": "Media Sanitization - AIS Equipment Disposal",
        "description": "Hard Drive and Storage Media Sanitization Devices and Plans for disposal of Automated Information System (AIS) Equipment."
      },
      {
        "stig_id": "SRG-OS-000480-GPOS-00227",
        "title": "Media Sanitization",
        "description": "The operating system must implement mechanisms for sanitization of storage devices."
      }
    ],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-22T00:00:00Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-22T00:00:00Z",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Implement NIST SP 800-88 compliant media sanitization using Clear, Purge, or Destroy methods appropriate to data sensitivity. Generate certificates of destruction for audit compliance."
    }
  }
]