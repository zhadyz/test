[
  {
    "control_id": "IA-1",
    "control_name": "Policy and Procedures",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "a. Develop, document, and disseminate to [Assignment: organization-defined personnel or roles]:\n  1. [Selection (one or more): Organization-level; Mission/business process-level; System-level] identification and authentication policy that:\n    (a) Addresses purpose, scope, roles, responsibilities, management commitment, coordination among organizational entities, and compliance; and\n    (b) Is consistent with applicable laws, executive orders, directives, regulations, policies, standards, and guidelines; and\n  2. Procedures to facilitate the implementation of the identification and authentication policy and the associated identification and authentication controls;\nb. Designate an [Assignment: organization-defined official] to manage the development, documentation, and dissemination of the identification and authentication policy and procedures; and\nc. Review and update the current identification and authentication:\n  1. Policy [Assignment: organization-defined frequency] and following [Assignment: organization-defined events]; and\n  2. Procedures [Assignment: organization-defined frequency] and following [Assignment: organization-defined events].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must establish, document, and distribute a comprehensive identification and authentication policy that defines how users prove their identity when accessing systems. This policy must cover who is responsible for identity management, how it aligns with organizational goals and legal requirements, and the specific procedures for implementing authentication controls. A designated official must manage this policy, and the organization must regularly review and update both the policy and procedures based on a defined schedule or when significant events occur such as security incidents or regulatory changes.",
    "example_implementation": "Develop an Identification and Authentication Policy document that outlines the organization's approach to user identity verification, password requirements, multi-factor authentication standards, and account management procedures. Assign the Chief Information Security Officer (CISO) as the official responsible for maintaining this policy. Establish a review cycle of at least annually and after any security incident or audit finding. Document standard operating procedures for user provisioning, authentication method selection, and access review processes. Distribute the policy to all IT staff, security personnel, and system administrators through the organization's policy management system.",
    "non_technical_guidance": "To comply with control IA-1 (Policy and Procedures), follow these steps:\n1. Develop and document a comprehensive identification and authentication policy that addresses: purpose and scope of identity management; roles and responsibilities for authentication oversight; management commitment to security; coordination between organizational units; and compliance with applicable laws and regulations.\n2. Create detailed procedures that explain how to implement the policy, including step-by-step guidance for user registration, credential issuance, authentication method selection, and account lifecycle management.\n3. Designate a senior official (such as the CISO or Security Director) to be accountable for policy development, maintenance, and distribution.\n4. Distribute the policy and procedures to all relevant personnel including IT staff, security teams, system administrators, and management through official channels.\n5. Provide training to ensure all personnel understand their responsibilities under the policy.\n6. Establish a regular review schedule (annually at minimum) and define triggering events that require immediate policy updates, such as security incidents, audit findings, regulatory changes, or technology updates.\n7. Document all policy reviews and updates, maintaining version control and change history.\n8. Conduct periodic assessments to verify that documented procedures are being followed and remain effective.\n9. Integrate the identification and authentication policy with related organizational policies for access control, personnel security, and risk management.\n10. Continuously monitor policy effectiveness and update as needed to address emerging threats, technology changes, and lessons learned from security incidents.",
    "implementation_guidance": "This is an organizational policy control that requires governance and documentation rather than technical implementation. Organizations should develop a formal policy document using a standard policy template that includes sections for purpose, scope, roles, responsibilities, compliance requirements, and references to related policies. The policy should be approved by senior management and integrated into the organization's overall security program. Procedures should be detailed enough to guide implementation across all organizational systems while remaining flexible enough to accommodate different system types and risk levels. The designated official should have sufficient authority and resources to enforce policy compliance. Regular reviews should include feedback from system owners, security personnel, and compliance officers to ensure the policy remains relevant and effective.",
    "ai_guidance": "When implementing IA-1 compliance, AI systems should assist with policy development by analyzing organizational requirements, regulatory obligations, and industry best practices to recommend comprehensive policy language. AI can help identify gaps in existing policies by comparing current documentation against NIST SP 800-53 requirements and relevant compliance frameworks. Natural language processing can be used to ensure policy documents are clear, consistent, and free from ambiguous language. AI-powered policy management systems can track version history, automate distribution to relevant personnel, and send reminders for scheduled reviews. Machine learning models can analyze security incident data to suggest policy updates based on emerging threats or weaknesses identified through incidents. AI assistants can help users understand policy requirements by answering questions in plain language and providing context-specific guidance. Automated compliance checking tools can verify that procedures align with policy statements and that implementation evidence exists for each policy requirement. AI can also monitor policy effectiveness by analyzing metrics such as authentication failures, account compromise incidents, and policy violation reports to recommend improvements. When policies are updated, AI can perform impact analysis to identify affected systems, procedures, and personnel requiring notification. For organizations with multiple policies across different domains, AI can ensure consistency in terminology, formatting, and cross-references. However, human oversight remains essential for policy approval, interpretation of complex requirements, and decisions involving organizational risk tolerance. AI should be used as a tool to enhance efficiency and thoroughness, not as a replacement for human judgment in governance decisions.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "AC-1",
      "PM-9",
      "PS-8",
      "SI-12"
    ],
    "supplemental_guidance": "Identification and authentication policy and procedures address the controls in the IA family that are implemented within systems and organizations. The risk management strategy is an important factor in establishing such policies and procedures. Policies and procedures contribute to security and privacy assurance. Therefore, it is important that security and privacy programs collaborate on the development of identification and authentication policy and procedures. Security and privacy program policies and procedures at the organization level are preferable, in general, and may obviate the need for mission- or system-specific policies and procedures. The policy can be included as part of the general security and privacy policy or be represented by multiple policies reflecting the complex nature of organizations. Procedures can be established for security and privacy programs, for mission or business processes, and for systems, if needed. Procedures describe how the policies or controls are implemented and can be directed at the individual or role that is the object of the procedure. Procedures can be documented in system security and privacy plans or in one or more separate documents. Events that may precipitate an update to identification and authentication policy and procedures assessment or audit findings, security incidents or breaches, or changes in applicable laws, executive orders, directives, regulations, policies, standards, and guidelines. Simply restating controls does not constitute an organizational policy or procedure.",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-20T00:00:00.000000+00:00",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires organizational policy documentation and procedures. No technical automation available. Compliance is achieved through governance processes, management oversight, and documentation practices rather than system configuration or scripting."
    }
  },
  {
    "control_id": "IA-2",
    "control_name": "Identification and Authentication (Organizational Users)",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Uniquely identify and authenticate organizational users and associate that unique identification with processes acting on behalf of those users.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This control requires organizations to uniquely identify and authenticate every user before granting access to information systems. Each person must have their own credentials (username and password, biometric data, or security token) that cannot be shared. The system must verify that the person logging in is who they claim to be, and then associate all actions performed during that session with that specific user's identity. This creates accountability and enables security monitoring by ensuring all system activities can be traced back to specific individuals. The control applies to all organizational users, including employees, contractors, and any third parties who access organizational systems. Multi-factor authentication (requiring two or more different types of credentials) is strongly recommended and required for privileged accounts under enhancement IA-2(1).",
    "example_implementation": "This script implement multi-factor authentication for all organizational users to enhance security and ensure only authorized individuals can access sensitive data.",
    "non_technical_guidance": "This plan to comply with Control ID ia-2, the organization should establish a process for uniquely identifying and authenticating organizational users. This can be achieved by implementing a user identification system that assigns a unique identifier to each user within the organization. Additionally, ensure that this unique identification is associated with processes acting on behalf of those users. Regularly review and update user identification and authentication processes to maintain compliance with this control.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "ia-2.1",
        "title": "Multi-factor Authentication to Privileged Accounts",
        "official_text": "Implement multi-factor authentication for access to privileged accounts."
      },
      {
        "id": "ia-2.2",
        "title": "Multi-factor Authentication to Non-privileged Accounts",
        "official_text": "Implement multi-factor authentication for access to non-privileged accounts."
      },
      {
        "id": "ia-2.5",
        "title": "Individual Authentication with Group Authentication",
        "official_text": "When shared accounts or authenticators are employed, require users to be individually authenticated before granting access to the shared accounts or resources."
      },
      {
        "id": "ia-2.6",
        "title": "Access to Accounts —separate Device",
        "official_text": "Implement multi-factor authentication for {{ insert: param, ia-02.06_odp.01 }} access to {{ insert: param, ia-02.06_odp.02 }} such that:"
      },
      {
        "id": "ia-2.8",
        "title": "Access to Accounts — Replay Resistant",
        "official_text": "Implement replay-resistant authentication mechanisms for access to {{ insert: param, ia-02.08_odp }}."
      },
      {
        "id": "ia-2.10",
        "title": "Single Sign-on",
        "official_text": "Provide a single sign-on capability for {{ insert: param, ia-02.10_odp }}."
      },
      {
        "id": "ia-2.12",
        "title": "Acceptance of PIV Credentials",
        "official_text": "Accept and electronically verify Personal Identity Verification-compliant credentials."
      },
      {
        "id": "ia-2.13",
        "title": "Out-of-band Authentication",
        "official_text": "Implement the following out-of-band authentication mechanisms under {{ insert: param, ia-02.13_odp.02 }}: {{ insert: param, ia-02.13_odp.01 }}."
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:56:50.858Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-10T10:09:31.378731+00:00",
      "source": "ComplianceAsCode",
      "last_updated": "2025-11-10T10:09:31.380995+00:00",
      "platform": "rhcos4",
      "rule_count": 1,
      "certification": "Government-certified"
    },
    "ai_guidance": "To implement automated compliance checking for IA-2, develop verification systems that: (1) Scan user account databases to ensure each account has a unique identifier and cannot be shared among multiple individuals; (2) Verify authentication mechanisms are properly configured and enforce credential verification before granting access; (3) Check that user sessions properly associate authenticated identities with all processes and actions performed; (4) Monitor for shared credentials, generic accounts, or authentication bypasses; (5) Validate that authentication logs capture sufficient detail to trace activities to specific users; (6) Ensure authentication mechanisms support the organization's defined authenticator types (passwords, PKI certificates, biometrics, hardware tokens); (7) Verify password policies meet complexity, length, and rotation requirements; (8) Check for proper implementation of account lockout mechanisms after failed authentication attempts. Integration with SIEM systems enables correlation of authentication events with suspicious activities, while automated policy enforcement ensures consistent application across all systems.",
    "implementation_guidance": "Organizations should implement centralized identity and access management (IAM) systems such as Active Directory, LDAP, or cloud-based identity providers (Azure AD, Okta, Auth0). Each user account must be uniquely named and associated with a single individual. Establish formal processes for account provisioning and deprovisioning tied to HR onboarding/offboarding. Configure authentication systems to require strong passwords (minimum 14 characters, complexity requirements) or implement passwordless authentication using PKI certificates, FIDO2 hardware tokens, or biometric authentication. Enable comprehensive authentication logging to capture successful and failed login attempts with timestamps, source IP addresses, and user identifiers. Implement account lockout policies (5 failed attempts within 15 minutes) to prevent brute-force attacks. For privileged accounts, require multi-factor authentication (MFA) per IA-2(1). Regularly audit user accounts to identify and remove dormant accounts, shared credentials, or generic accounts. Implement session management to associate authenticated identities with all processes and network connections during the session.",
    "stig_id": "RHEL-09-611010,RHEL-09-611015,RHEL-09-611020"
  },
  {
    "control_id": "IA-2.1",
    "control_name": "Multi-factor Authentication to Privileged Accounts",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Implement multi-factor authentication for access to privileged accounts.",
    "parent_control": "ia-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This control enhancement requires multi-factor authentication (MFA) for all privileged accounts, which are accounts with elevated permissions to manage systems, modify security settings, or access sensitive data. Multi-factor authentication means users must provide at least two different types of credentials from separate categories: something you know (password/PIN), something you have (security token/smart card/mobile device), or something you are (fingerprint/facial recognition). For example, a system administrator logging in with a privileged account must enter both a password and a code from an authentication app on their smartphone. This significantly reduces the risk of account compromise because an attacker would need to steal multiple independent factors, not just a password. Privileged accounts are high-value targets for attackers because they provide extensive system access, making MFA essential for protecting critical infrastructure and data.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:56:50.858Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:09:32.981956+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Automated compliance validation for IA-2(1) should verify: (1) All accounts with administrative, root, or elevated privileges have MFA enforcement enabled; (2) MFA mechanisms require at least two authentication factors from different categories (knowledge, possession, inherence); (3) No privileged accounts bypass MFA requirements through exception policies or alternative authentication paths; (4) MFA systems properly validate both factors before granting access; (5) Authentication logs capture MFA events including which factors were used and any failures; (6) Privileged account inventory is current and complete; (7) MFA configuration prevents downgrade attacks or factor reuse. Implement continuous monitoring to detect privileged account access attempts without MFA, new privileged accounts created without MFA enforcement, or configuration changes that weaken MFA requirements. Integration with privileged access management (PAM) systems enables policy enforcement and automated verification of MFA compliance across all privileged sessions.",
    "implementation_guidance": "Implement MFA solutions such as hardware security keys (YubiKey, Titan), software authenticators (Microsoft Authenticator, Google Authenticator, Duo), or smart cards (CAC/PIV). Configure identity management systems to enforce MFA for all privileged accounts including domain administrators, root users, database administrators, and application administrators. Use centralized MFA enforcement through identity providers (Azure AD Conditional Access, Okta MFA, AWS IAM MFA) rather than application-level MFA to ensure consistent policy application. For Linux systems, configure PAM modules for MFA (pam_oath, pam_u2f, pam_pkcs11). For Windows, enforce smart card or Windows Hello for Business for privileged accounts via Group Policy. Implement privileged access workstations (PAWs) that require MFA and are dedicated to administrative tasks. Disable legacy authentication protocols that don't support MFA. Establish emergency access (\"break glass\") procedures with MFA-enabled accounts stored securely. Regularly audit privileged account access to verify MFA usage and detect any bypasses.",
    "stig_id": "RHEL-09-611025,RHEL-09-611030"
  },
  {
    "control_id": "IA-2.2",
    "control_name": "Multi-factor Authentication to Non-privileged Accounts",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Implement multi-factor authentication for access to non-privileged accounts.",
    "parent_control": "ia-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This control enhancement extends multi-factor authentication requirements beyond privileged accounts to include all non-privileged user accounts accessing organizational systems. Even standard users without administrative rights must authenticate using at least two different types of credentials before accessing systems. For example, a regular employee accessing their email or company intranet must provide both a password and a verification code from their smartphone. This provides defense-in-depth security by protecting all entry points to organizational systems, not just administrative access. Compromising any user account can provide attackers with initial access to conduct reconnaissance, phishing campaigns, or lateral movement within the network. Requiring MFA for all accounts significantly raises the difficulty of initial compromise and limits the effectiveness of stolen credentials obtained through phishing, data breaches, or social engineering attacks.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:56:50.858Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:09:41.000078+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Automated validation for IA-2(2) should verify: (1) MFA is enforced for all non-privileged user accounts across all access methods (local login, remote access, web applications, VPN); (2) No user accounts are exempt from MFA requirements except documented emergency access accounts; (3) MFA enrollment is complete for all active users; (4) Authentication systems properly enforce both factors before granting access; (5) MFA configuration prevents users from disabling or bypassing requirements; (6) Failed MFA attempts are logged and monitored; (7) Users cannot authenticate using single-factor legacy protocols. Implement automated monitoring to detect authentication attempts without MFA, new user accounts created without MFA enrollment, and configuration changes that create MFA exceptions. Cross-reference identity management systems with MFA enrollment databases to identify gaps. Monitor for legacy authentication protocols (IMAP, POP3, SMTP AUTH) that may bypass MFA and should be disabled.",
    "implementation_guidance": "Deploy organization-wide MFA using centralized identity providers (Azure AD, Okta, Google Workspace) that enforce MFA across all integrated applications. Support multiple MFA methods to accommodate different user needs and device capabilities: authenticator apps (Microsoft Authenticator, Duo Mobile), SMS/voice calls, hardware tokens (YubiKey), or biometric authentication. Implement conditional access policies that require MFA for all users regardless of location or device. For organizations with on-premises infrastructure, deploy MFA solutions that integrate with Active Directory (Duo, Azure MFA Server, RSA SecurID). Ensure MFA is enforced for: workstation login, VPN access, web applications, email (OWA, mobile email), and cloud services. Block legacy authentication protocols that don't support MFA (configure in Exchange Online, Azure AD). Provide user training on MFA setup and usage. Establish self-service enrollment portals for MFA registration. Implement help desk procedures for MFA resets with proper identity verification. Monitor MFA adoption rates and identify users without enrolled devices.",
    "stig_id": "RHEL-09-611035,RHEL-09-611040"
  },
  {
    "control_id": "IA-2.5",
    "control_name": "Individual Authentication with Group Authentication",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "When shared accounts or authenticators are employed, require users to be individually authenticated before granting access to the shared accounts or resources.",
    "parent_control": "ia-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "When shared accounts or authenticators are employed, require users to be individually authenticated before granting access to the shared accounts or resources.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142887+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:09:45.897045+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-2.5 Individual Authentication with Group Authentication requires authenticating individuals when using group authenticators. Implement individual login before group account access. Maintain audit trails of individual actions under group accounts. Use PAM solutions for shared account access."
  },
  {
    "control_id": "IA-2.6",
    "control_name": "Access to Accounts —separate Device",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Implement multi-factor authentication for {{ insert: param, ia-02.06_odp.01 }} access to {{ insert: param, ia-02.06_odp.02 }} such that:",
    "parent_control": "ia-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Implement multi-factor authentication for {{ insert: param, ia-02.06_odp.01 }} access to {{ insert: param, ia-02.06_odp.02 }} such that:",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142901+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:09:47.539077+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-2.6 Access to Accounts - Separate Device requires separate authentication device for network access. Implement hardware tokens, smart cards, or mobile authenticators as second factor separate from the accessing device. Prevent single device compromise from enabling full access."
  },
  {
    "control_id": "IA-2.8",
    "control_name": "Access to Accounts — Replay Resistant",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Implement replay-resistant authentication mechanisms for access to {{ insert: param, ia-02.08_odp }}.",
    "parent_control": "ia-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Implement replay-resistant authentication mechanisms for access to {{ insert: param, ia-02.08_odp }}.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142928+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:09:50.821165+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-2.8 Access to Accounts - Replay Resistant requires replay-resistant authentication mechanisms. Implement challenge-response, time-based OTP, or cryptographic authentication. Prevent capture and reuse of authentication traffic. Use TLS for credential transmission."
  },
  {
    "control_id": "IA-2.10",
    "control_name": "Single Sign-on",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Provide a single sign-on capability for {{ insert: param, ia-02.10_odp }}.",
    "parent_control": "ia-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Provide a single sign-on capability for {{ insert: param, ia-02.10_odp }}.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142789+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:09:34.610559+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-2.10 Single Sign-on requires implementing SSO for organization-defined systems. Deploy enterprise SSO using SAML, OAuth, or OIDC. Centralize authentication while maintaining strong credentials. Implement session management and timeout policies."
  },
  {
    "control_id": "IA-2.12",
    "control_name": "Acceptance of PIV Credentials",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Accept and electronically verify Personal Identity Verification-compliant credentials.",
    "parent_control": "ia-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Accept and electronically verify Personal Identity Verification-compliant credentials.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142817+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:09:37.794108+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-2.12 Acceptance of PIV Credentials requires accepting Personal Identity Verification credentials. Implement PIV card readers and middleware. Validate certificates against government PKI. Support derived PIV credentials for mobile devices."
  },
  {
    "control_id": "IA-2.13",
    "control_name": "Out-of-band Authentication",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Implement the following out-of-band authentication mechanisms under {{ insert: param, ia-02.13_odp.02 }}: {{ insert: param, ia-02.13_odp.01 }}.",
    "parent_control": "ia-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Implement the following out-of-band authentication mechanisms under {{ insert: param, ia-02.13_odp.02 }}: {{ insert: param, ia-02.13_odp.01 }}.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142830+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:09:39.392090+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-2.13 Out-of-Band Authentication requires authentication through separate communication channel. Implement SMS, voice call, or push notification as out-of-band factor. Verify channel independence from primary authentication. Consider SIM-swap risks for SMS."
  },
  {
    "control_id": "IA-3",
    "control_name": "Device Identification and Authentication",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Uniquely identify and authenticate [Assignment: organization-defined devices and/or types of devices] before establishing a [Selection (one or more): local; remote; network] connection.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must implement unique identification and authentication mechanisms for devices before they can establish local, remote, or network connections. This ensures that only authorized and verified devices can access organizational systems and resources, preventing unauthorized device access that could compromise security.",
    "example_implementation": "Deploy IEEE 802.1X network authentication using EAP-TLS with X.509 certificates for all devices connecting to the organizational network. Configure network access control (NAC) solutions to validate device certificates against a certificate authority before granting network access. Implement MAC address filtering as a supplementary identification mechanism. For wireless access points, enable WPA3-Enterprise with certificate-based authentication. Establish RADIUS infrastructure with FreeRADIUS or Microsoft NPS to centralize authentication decisions. Document authorized device types (workstations, mobile devices, IoT sensors, network printers) and their specific authentication requirements based on risk categorization.",
    "non_technical_guidance": "Establish a comprehensive device identification and authentication policy that defines which device types require authentication (workstations, servers, mobile devices, IoT devices, network printers) and the authentication mechanisms appropriate for each category. Maintain an authoritative inventory of all devices authorized to connect to organizational networks, including unique identifiers such as MAC addresses, serial numbers, and certificate distinguished names. Implement automated processes to validate device identity before establishing connections, using technologies such as IEEE 802.1X for wired and wireless networks, VPN certificate authentication for remote access, and API keys or mutual TLS for application-to-application connections. Provide training to system administrators on proper device enrollment procedures, certificate lifecycle management, and troubleshooting authentication failures. Conduct regular audits to identify unauthorized devices attempting network access and verify that authentication mechanisms function correctly across all connection types. Establish procedures for device decommissioning to ensure revoked devices cannot authenticate. Document exceptions for legacy devices that cannot support modern authentication protocols and implement compensating controls such as network segmentation or enhanced monitoring. Review and update the authorized device list quarterly or when organizational infrastructure changes occur.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "IA-3(1)",
        "title": "Cryptographic Bidirectional Authentication",
        "official_text": "Authenticate [Assignment: organization-defined devices and/or types of devices] before establishing [Selection (one or more): local; remote; network] connection using bidirectional authentication that is cryptographically based."
      },
      {
        "id": "IA-3(2)",
        "title": "Cryptographic Bidirectional Network Authentication",
        "official_text": "[Withdrawn: Incorporated into IA-3(1).]"
      },
      {
        "id": "IA-3(3)",
        "title": "Dynamic Address Allocation",
        "official_text": "(a) Where addresses are allocated dynamically, standardize dynamic address allocation lease information and the lease duration assigned to devices in accordance with [Assignment: organization-defined lease information and lease duration]; and (b) Audit lease information when assigned to a device."
      },
      {
        "id": "IA-3(4)",
        "title": "Device Attestation",
        "official_text": "Handle device identification and authentication based on attestation by [Assignment: organization-defined configuration management process]."
      }
    ],
    "related_controls": [
      "AC-17",
      "AC-18",
      "AC-19",
      "AU-6",
      "CA-3",
      "CA-9",
      "IA-4",
      "IA-5",
      "IA-9",
      "IA-11",
      "SI-4"
    ],
    "supplemental_guidance": "Devices requiring unique device-to-device identification and authentication are defined by device type, specific device, or a combination thereof. Organizations may use shared known information such as Media Access Control (MAC) addresses or TCP/IP addresses for device identification, or deploy organizational authentication solutions including IEEE 802.1x with Extensible Authentication Protocol (EAP), RADIUS servers with EAP-TLS authentication, or Kerberos. The selection of authentication mechanisms should align with organizational security requirements and system criticality. For high-value assets, cryptographic authentication provides stronger assurance than simple MAC address filtering. Organizations should consider the operational complexity of implementing device authentication across heterogeneous environments and may limit initial deployment to critical device types based on mission risk assessments.",
    "implementation_scripts": {
      "linux": {
        "bash": "scripts/ia-3_rhel8_bash.sh",
        "ansible": "scripts/ia-3_ansible.yml"
      },
      "windows": {
        "powershell": "scripts/ia-3_windows_server_2019_powershell.ps1"
      }
    },
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:43:31.766570+00:00",
      "has_scripts": true,
      "validated_by": "loveless",
      "validation_date": "2025-11-20T19:43:31.766570+00:00"
    },
    "stig_mappings": {
      "rhel8": [
        "RHEL-08-010390"
      ],
      "rhel9": [
        "RHEL-09-010390"
      ],
      "windows_server_2019": [
        "WN19-00-000230"
      ],
      "windows_server_2022": [
        "WN22-00-000230"
      ],
      "windows_10": [
        "WN10-00-000145"
      ],
      "general": [
        "GEN000000-LNX00440",
        "SRG-OS-000480-GPOS-00227"
      ]
    },
    "ai_guidance": "IA-3 Device Identification and Authentication requires authenticating devices before establishing connections. Implement 802.1X for network access control. Use device certificates, MAC authentication, or device attestation. Maintain inventory of authorized devices."
  },
  {
    "control_id": "IA-4",
    "control_name": "Identifier Management",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Manage system identifiers by: a. Receiving authorization from [Assignment: organization-defined personnel or roles] to assign an individual, group, role, service, or device identifier; b. Selecting an identifier that identifies an individual, group, role, service, or device; c. Assigning the identifier to the intended individual, group, role, service, or device; and d. Preventing reuse of identifiers for [Assignment: organization-defined time period].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This control requires organizations to establish and maintain formal processes for managing all system identifiers used to identify individuals, groups, roles, services, and devices. Organizations must obtain proper authorization before creating identifiers, select identifiers that uniquely distinguish entities, assign them to the correct recipients, and prevent recycling identifiers for a specified period after they're no longer needed. Common identifiers include usernames, email addresses, employee IDs, device MAC addresses, IP addresses, and service account names. The control ensures accountability and traceability by maintaining unique identification throughout an identifier's lifecycle. By preventing identifier reuse for a defined period (typically 2-5 years), organizations avoid confusion between current and former entity activities in audit logs and prevent potential security issues from residual access rights. This control works closely with account management (AC-2) to ensure proper coordination between identifier assignment and account provisioning.",
    "example_implementation": "The following implementation establishes identifier management procedures including authorization workflows, unique identifier generation, assignment tracking, and reuse prevention controls.",
    "non_technical_guidance": "Organizations should establish formal identifier management procedures that define: (1) Who has authority to approve identifier creation requests; (2) Naming conventions that ensure uniqueness and prevent confusion; (3) Assignment processes that verify identifiers go to intended recipients; (4) Retention periods before identifiers can be reused; (5) Coordination between HR, IT, and security teams. Create identifier request forms that capture requestor information, business justification, and approver signatures. Maintain an identifier registry that tracks active and retired identifiers with assignment dates and deactivation dates. When employees leave or devices are decommissioned, mark identifiers as retired and prevent their reuse for the defined period. This prevents former employee identifiers from being reassigned to new staff, which could cause confusion in audit trails and access control decisions.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-5",
      "IA-2",
      "IA-3",
      "IA-5",
      "IA-8",
      "IA-9",
      "IA-12",
      "MA-4",
      "PE-2",
      "PE-3",
      "PE-4",
      "PL-4",
      "PM-12",
      "PS-3",
      "PS-4",
      "PS-5",
      "SC-37"
    ],
    "supplemental_guidance": "Common device identifiers include Media Access Control (MAC) addresses, Internet Protocol (IP) addresses, or device-unique token identifiers. The management of individual identifiers is not applicable to shared system accounts. Typically, individual identifiers are the usernames of the system accounts assigned to those individuals. In such instances, the account management activities of AC-2 use account names provided by IA-4. Identifier management also addresses individual identifiers not necessarily associated with system accounts. Preventing the reuse of identifiers implies preventing the assignment of previously used individual, group, role, service, or device identifiers to different individuals, groups, roles, services, or devices.",
    "metadata": {
      "status": "complete",
      "last_updated": "2025-11-20T00:00:00.000Z",
      "has_scripts": true
    },
    "ai_guidance": "Automated compliance validation for IA-4 should verify: (1) All identifier creation requests have documented authorization from designated personnel or roles with proper approval workflows enforced through ticketing systems or identity governance platforms; (2) Identifier naming conventions are consistently applied and enforced through automated validation rules that prevent non-compliant identifiers from being created; (3) Each identifier is unique across the organization with no duplicates in user databases, directory services, or device management systems; (4) Retired identifiers are marked as inactive and prevented from reuse for the organization-defined period (typically 2-5 years) through automated checks in provisioning systems; (5) Identifier assignment records are maintained in an authoritative registry or audit log that tracks creation date, assigned entity, approving authority, and retirement date; (6) No identifier conflicts exist between current and formerly used identifiers that could cause confusion in audit trails, access control decisions, or attribution of activities. Implement continuous monitoring to detect: unauthorized identifier creation, duplicate identifiers across systems, premature identifier reuse violations, and missing approval documentation. Cross-reference identity management systems with authoritative data sources (HR systems, asset databases, certificate authorities) to validate identifier assignments match organizational records. For device identifiers, monitor for MAC address spoofing, unauthorized IP address assignments, and device registration without proper approval. Automated scanning should verify that service account identifiers follow documented naming standards and have associated ownership records with business justification.",
    "implementation_guidance": "Organizations should implement centralized identifier management through identity governance and administration (IGA) platforms such as SailPoint, Saviynt, Omada, or open-source solutions like FreeIPA. Establish formal identifier request and approval workflows using IT service management (ITSM) tools like ServiceNow, Jira Service Management, or BMC Remedy. Define identifier naming conventions: user accounts as firstname.lastname, service accounts with 'svc-' prefix followed by application name, device identifiers with location-function-number scheme (e.g., DC1-WEB-001). Implement automated uniqueness validation that queries all directory services, databases, and asset management systems before approving identifier creation. Configure directory services (Active Directory, LDAP, Azure AD) with attribute constraints that enforce naming standards and prevent duplicate identifiers. Establish identifier lifecycle management integrated with HR onboarding/offboarding processes so identifiers are created when employees start and automatically retired when they separate. Maintain identifier registry database or use IGA platform repositories to track: identifier value, entity type (individual/group/role/service/device), creation date, assigned to, approved by, retirement date, and reuse eligibility date. Set reuse prevention period to minimum 2 years for general accounts, permanent prohibition for privileged administrator accounts, and 5 years for service accounts. Implement pre-provisioning checks that validate identifier availability and reuse eligibility before account creation. For device identifiers, integrate with network access control (NAC) and endpoint management systems to enforce identifier registration requirements and prevent unregistered devices from network access.",
    "stig_id": ""
  },
  {
    "control_id": "IA-5",
    "control_name": "Authenticator Management",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Manage system authenticators by:\na. Verifying, as part of the initial authenticator distribution, the identity of the individual, group, role, service, or device receiving the authenticator;\nb. Establishing initial authenticator content for any authenticators issued by the organization;\nc. Ensuring that authenticators have sufficient strength of mechanism for their intended use;\nd. Establishing and implementing administrative procedures for initial authenticator distribution, for lost, compromised, or damaged authenticators, and for revoking authenticators;\ne. Changing default authenticators prior to first use;\nf. Changing or refreshing authenticators [Assignment: organization-defined time period by authenticator type] or when [Assignment: organization-defined events] occur;\ng. Protecting authenticator content from unauthorized disclosure and modification;\nh. Requiring individuals to take, and having devices implement, specific controls to protect authenticators; and\ni. Changing authenticators for group or role accounts when membership to those accounts changes.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must manage all methods of proving identity (passwords, smart cards, biometrics, tokens) throughout their lifecycle—from creation and distribution to eventual revocation. This includes verifying who receives authenticators, changing default credentials, protecting them from theft or disclosure, and ensuring they are strong enough for their intended use.",
    "example_implementation": "Implement a centralized Identity and Access Management (IAM) system that: (1) generates strong unique passwords/tokens when accounts are created, (2) requires users to change default credentials on first login, (3) stores all authenticators using approved cryptographic protection (e.g., bcrypt, scrypt, PBKDF2), (4) provides secure distribution channels for tokens/smart cards, and (5) maintains audit logs of all authenticator lifecycle events.",
    "non_technical_guidance": "To comply with IA-5 Authenticator Management:\n1. Develop comprehensive authenticator management policies covering passwords, tokens, smart cards, biometrics, and PKI certificates.\n2. Establish procedures for verifying identity before issuing authenticators (in-person for high-risk systems).\n3. Create secure processes for initial distribution, replacement of lost/compromised authenticators, and revocation when no longer needed.\n4. Require changing all default passwords, tokens, and credentials before first operational use.\n5. Define refresh schedules based on authenticator type and risk (e.g., passwords every 60-365 days, certificates annually).\n6. Train personnel on protecting authenticators: no sharing, secure storage, immediate reporting of loss/theft.\n7. Implement account reviews when group membership changes to update shared credentials.\n8. Document all procedures and conduct regular compliance audits.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-2",
      "AC-3",
      "AC-5",
      "AC-6",
      "CM-6",
      "IA-2",
      "IA-4",
      "IA-8",
      "IA-9",
      "IA-11",
      "MA-4",
      "PE-2",
      "PL-4",
      "PS-5",
      "SA-4",
      "SC-12",
      "SC-13",
      "SC-17"
    ],
    "supplemental_guidance": "Authenticators include passwords, cryptographic devices, biometrics, certificates, one-time password devices, and ID badges. Individual authenticators are unique to subjects (persons or devices). Group authenticators are used by multiple individuals. Device authenticators include certificates and passwords. Systems support authenticator management through organization-defined settings and restrictions (e.g., minimum password length, validation time windows, biometric false acceptance rates). Organizations safeguard authenticators by maintaining possession, not sharing, and immediately reporting loss/theft/compromise. This control implements requirements from NIST SP 800-63B for authenticator types and strength. The Federal PKI provides government-wide trust infrastructure for certificate-based authentication.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-5: Authenticator Management - Linux Implementation\n# Enforces authenticator security policies across the system\n\nset -euo pipefail\n\necho \"[IA-5] Implementing Authenticator Management Controls\"\n\n# 1. Force password change on first login for new accounts\necho \"Configuring first-login password change requirement...\"\nchage -d 0 $(awk -F: '$3 >= 1000 {print $1}' /etc/passwd | grep -v nfsnobody || true)\n\n# 2. Remove/disable default accounts with known credentials\necho \"Securing default accounts...\"\nfor user in games ftp guest; do\n    if id \"$user\" &>/dev/null; then\n        usermod -L \"$user\" 2>/dev/null || true\n        echo \"Locked default account: $user\"\n    fi\ndone\n\n# 3. Configure password aging for all accounts\necho \"Setting password aging policies...\"\n# Maximum password age: 60 days\n# Minimum password age: 1 day\n# Warning period: 7 days\nsed -i 's/^PASS_MAX_DAYS.*/PASS_MAX_DAYS   60/' /etc/login.defs\nsed -i 's/^PASS_MIN_DAYS.*/PASS_MIN_DAYS   1/' /etc/login.defs\nsed -i 's/^PASS_WARN_AGE.*/PASS_WARN_AGE   7/' /etc/login.defs\n\n# Apply to existing users\nfor user in $(awk -F: '$3 >= 1000 {print $1}' /etc/passwd); do\n    chage -M 60 -m 1 -W 7 \"$user\" 2>/dev/null || true\ndone\n\n# 4. Audit authenticator distribution and revocation\necho \"Configuring authenticator audit logging...\"\ncat >> /etc/audit/rules.d/authenticator.rules << 'EOF'\n# IA-5: Authenticator Management Audit Rules\n# Monitor password file modifications\n-w /etc/passwd -p wa -k authenticator_management\n-w /etc/shadow -p wa -k authenticator_management\n-w /etc/group -p wa -k authenticator_management\n-w /etc/gshadow -p wa -k authenticator_management\n-w /etc/security/opasswd -p wa -k authenticator_management\n\n# Monitor SSH key operations\n-w /home -p wa -k ssh_key_management\n-w /root/.ssh -p wa -k ssh_key_management\n\n# Monitor PAM configuration changes\n-w /etc/pam.d/ -p wa -k pam_configuration\n-w /etc/security/ -p wa -k pam_configuration\nEOF\n\n# Reload audit rules\naugenrules --load 2>/dev/null || service auditd restart\n\n# 5. Protect authenticator content (password hashes)\necho \"Securing authenticator storage...\"\nchmod 0000 /etc/shadow\nchmod 0000 /etc/gshadow\nchown root:root /etc/shadow /etc/gshadow\n\n# 6. SSH key management: Restrict permissions\necho \"Securing SSH authenticators...\"\nfind /home -type f -name \"authorized_keys\" -exec chmod 600 {} \\;\nfind /home -type d -name \".ssh\" -exec chmod 700 {} \\;\n\n# 7. Create authenticator management log\necho \"IA-5 Authenticator Management controls applied on $(date)\" > /var/log/ia5_compliance.log\necho \"  - Default accounts locked\" >> /var/log/ia5_compliance.log\necho \"  - Password aging configured (60-day maximum)\" >> /var/log/ia5_compliance.log\necho \"  - Audit rules loaded for authenticator operations\" >> /var/log/ia5_compliance.log\necho \"  - File permissions hardened for credential storage\" >> /var/log/ia5_compliance.log\n\necho \"[IA-5] Authenticator Management controls successfully applied\"\n",
        "ansible": "---\n# IA-5: Authenticator Management - Ansible Playbook\n# Manages authenticators across Linux systems\n\n- name: IA-5 Authenticator Management\n  hosts: all\n  become: yes\n  tasks:\n    - name: Configure password aging in login.defs\n      lineinfile:\n        path: /etc/login.defs\n        regexp: \"{{ item.regexp }}\"\n        line: \"{{ item.line }}\"\n        state: present\n      loop:\n        - { regexp: '^PASS_MAX_DAYS', line: 'PASS_MAX_DAYS   60' }\n        - { regexp: '^PASS_MIN_DAYS', line: 'PASS_MIN_DAYS   1' }\n        - { regexp: '^PASS_WARN_AGE', line: 'PASS_WARN_AGE   7' }\n\n    - name: Lock default system accounts\n      user:\n        name: \"{{ item }}\"\n        password_lock: yes\n      loop:\n        - games\n        - ftp\n        - guest\n      ignore_errors: yes\n\n    - name: Secure shadow file permissions\n      file:\n        path: \"{{ item }}\"\n        mode: '0000'\n        owner: root\n        group: root\n      loop:\n        - /etc/shadow\n        - /etc/gshadow\n\n    - name: Deploy authenticator audit rules\n      copy:\n        dest: /etc/audit/rules.d/authenticator.rules\n        content: |\n          # IA-5: Authenticator Management Audit Rules\n          -w /etc/passwd -p wa -k authenticator_management\n          -w /etc/shadow -p wa -k authenticator_management\n          -w /etc/group -p wa -k authenticator_management\n          -w /etc/security/opasswd -p wa -k authenticator_management\n          -w /home -p wa -k ssh_key_management\n          -w /etc/pam.d/ -p wa -k pam_configuration\n      notify: reload auditd\n\n  handlers:\n    - name: reload auditd\n      service:\n        name: auditd\n        state: restarted\n"
      },
      "windows": {
        "powershell": "# IA-5: Authenticator Management - Windows Implementation\n# Enforces authenticator security policies via Group Policy and registry\n\nWrite-Host \"[IA-5] Implementing Authenticator Management Controls\" -ForegroundColor Cyan\n\n# 1. Force password change on next logon for new accounts\nWrite-Host \"Configuring first-login password change...\"\nGet-LocalUser | Where-Object {$_.PasswordLastSet -eq $null -and $_.Enabled -eq $true} |\n    Set-LocalUser -PasswordNeverExpires $false -UserMayChangePassword $true\n\n# 2. Disable/rename default Administrator and Guest accounts\nWrite-Host \"Securing default accounts...\"\ntry {\n    Rename-LocalUser -Name \"Administrator\" -NewName \"Admin_$(Get-Random -Maximum 9999)\" -ErrorAction Stop\n    Disable-LocalUser -Name \"Guest\" -ErrorAction Stop\n    Write-Host \"  ✓ Default accounts secured\" -ForegroundColor Green\n} catch {\n    Write-Host \"  ! Some default accounts may already be configured\" -ForegroundColor Yellow\n}\n\n# 3. Configure domain password policy (if domain member)\nif ((Get-WmiObject -Class Win32_ComputerSystem).PartOfDomain) {\n    Write-Host \"Configuring domain password policies...\"\n    # These would typically be set via Group Policy in production\n    # Showing PowerShell alternatives for standalone systems\n}\n\n# 4. Set local security policy for password aging\nWrite-Host \"Configuring password aging policies...\"\nsecedit /export /cfg $env:TEMP\\secpol.cfg | Out-Null\n\n(Get-Content $env:TEMP\\secpol.cfg) -replace '^MaximumPasswordAge.*', 'MaximumPasswordAge = 60' `\n    -replace '^MinimumPasswordAge.*', 'MinimumPasswordAge = 1' `\n    -replace '^PasswordComplexity.*', 'PasswordComplexity = 1' `\n    -replace '^MinimumPasswordLength.*', 'MinimumPasswordLength = 14' |\n    Set-Content $env:TEMP\\secpol_new.cfg\n\nsecedit /configure /db secedit.sdb /cfg $env:TEMP\\secpol_new.cfg /areas SECURITYPOLICY | Out-Null\nRemove-Item $env:TEMP\\secpol*.cfg -Force\n\n# 5. Enable audit logging for authenticator operations\nWrite-Host \"Configuring authenticator audit policies...\"\nauditpol /set /subcategory:\"User Account Management\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Security Group Management\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Credential Validation\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Other Account Logon Events\" /success:enable /failure:enable\n\n# 6. Configure LSA protection for credentials in memory\nWrite-Host \"Enabling LSA protection for authenticator security...\"\nSet-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" -Name \"RunAsPPL\" -Value 1 -Type DWord\nSet-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" -Name \"DisableRestrictedAdmin\" -Value 0 -Type DWord\n\n# 7. Enable Credential Guard (Windows 10 Enterprise/Server 2016+)\ntry {\n    Enable-WindowsOptionalFeature -Online -FeatureName IsolatedUserMode -NoRestart -ErrorAction Stop\n    Write-Host \"  ✓ Credential Guard prerequisites enabled\" -ForegroundColor Green\n} catch {\n    Write-Host \"  ! Credential Guard requires compatible hardware/OS version\" -ForegroundColor Yellow\n}\n\n# 8. Create compliance log\n$logEntry = @\"\nIA-5 Authenticator Management Controls Applied: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\n  - Default accounts secured and renamed\n  - Password aging configured (60-day maximum, 1-day minimum)\n  - Password complexity enforced (14+ characters)\n  - Audit policies enabled for credential operations\n  - LSA protection enabled for in-memory credentials\n  - Credential Guard components configured\n\"@\n\n$logEntry | Out-File -FilePath \"C:\\ProgramData\\IA5_Compliance.log\" -Append\nWrite-Host \"`n[IA-5] Authenticator Management controls successfully applied\" -ForegroundColor Green\nWrite-Host \"NOTE: System restart required for some changes to take effect\" -ForegroundColor Yellow\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T19:52:32.523933+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T19:52:32.523942+00:00",
      "source": "ComplianceAsCode",
      "platform": "multi-platform",
      "rule_count": 11,
      "certification": "Government-certified",
      "stig_mappings": [
        "RHEL-08-020000",
        "RHEL-08-020010",
        "RHEL-08-020020",
        "WN10-SO-000075",
        "WN10-SO-000080"
      ]
    },
    "ai_guidance": "IA-5 Authenticator Management requires managing authenticators (passwords, tokens, certificates) throughout their lifecycle. Implement password policies, token provisioning, and certificate management. Protect authenticators in storage and transmission. Refresh authenticators periodically."
  },
  {
    "control_id": "IA-5.1",
    "control_name": "Password-based Authentication",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "For password-based authentication:\n(a) Maintain a list of commonly-used, expected, or compromised passwords and update the list [Assignment: organization-defined frequency] and when organizational passwords are suspected to have been compromised directly or indirectly;\n(b) Verify, when users create or update passwords, that the passwords are not found on the list of commonly-used, expected, or compromised passwords in IA-5(1)(a);\n(c) Transmit passwords only over cryptographically-protected channels;\n(d) Store passwords using an approved salted key derivation function, preferably using a keyed hash;\n(e) Require immediate selection of a new password upon account recovery;\n(f) Allow user selection of long passwords and passphrases, including spaces and all printable characters;\n(g) Employ automated tools to assist the user in selecting strong password authenticators; and\n(h) Enforce the following composition and complexity rules: [Assignment: organization-defined composition and complexity rules].",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Password systems must check new passwords against lists of known compromised passwords, transmit passwords only over encrypted connections, store password hashes using strong cryptographic methods (like bcrypt or PBKDF2), and allow users to create long, complex passwords with any printable characters including spaces. Organizations should use password strength tools and maintain current lists of passwords that should never be allowed.",
    "example_implementation": "Implement a password management system using: (1) NIST-approved key derivation functions (bcrypt with work factor 12+, scrypt, or PBKDF2-HMAC-SHA256 with 10000+ iterations), (2) integration with HaveIBeenPwned API to check against 600M+ compromised passwords, (3) TLS 1.2+ for all password transmission, (4) minimum 8-character length with support for passphrases up to 64+ characters, (5) automated password strength meters (zxcvbn library), and (6) rejection of passwords containing username, common patterns, or keyboard sequences.",
    "non_technical_guidance": "To comply with IA-5(1) Password-based Authentication:\n1. Subscribe to breach notification services and maintain updated lists of compromised passwords (use HaveIBeenPwned datasets, NCSC password lists).\n2. Implement password verification that checks new/changed passwords against your compromised password list.\n3. Ensure all password transmission uses TLS 1.2+ encryption (HTTPS, encrypted RDP, SSH).\n4. Require immediate password change after account recovery or password reset.\n5. Allow users to create passwords up to 64 characters minimum, supporting all printable ASCII and Unicode characters including spaces.\n6. Deploy password strength tools/meters that provide real-time feedback during password creation.\n7. Define composition rules based on NIST SP 800-63B guidelines: minimum 8 characters for user-chosen passwords, 6 for system-generated, no mandatory character class requirements.\n8. Do NOT require periodic password changes unless compromise is suspected (per updated NIST guidance).\n9. Train users on creating strong passphrases (e.g., 'correct horse battery staple' method).",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "IA-2",
      "IA-4",
      "IA-6",
      "IA-8",
      "SC-8",
      "SC-13"
    ],
    "supplemental_guidance": "This control enhancement aligns with NIST SP 800-63B Section 5.1.1 Memorized Secret Authenticators. Password strength depends on entropy, not complexity rules. Long passphrases provide better security and usability than complex short passwords. Approved salted key derivation functions include: bcrypt (work factor ≥12), scrypt (N≥16384, r≥8, p≥1), PBKDF2-HMAC-SHA256/512 (iterations ≥10000), or Argon2id. Organizations should not impose composition rules (e.g., requiring uppercase, numbers, symbols) as these reduce password space and frustrate users. Instead, check passwords against breach corpora and common password lists. The prohibition on password hints and knowledge-based authentication for password recovery is covered in IA-5(1)(e).",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-5(1): Password-based Authentication - Linux Implementation\n# Implements NIST SP 800-63B password requirements\n\nset -euo pipefail\n\necho \"[IA-5(1)] Implementing Password-based Authentication Controls\"\n\n# 1. Install password quality checking library\nif ! command -v pwquality &> /dev/null; then\n    echo \"Installing libpwquality...\"\n    if command -v dnf &> /dev/null; then\n        dnf install -y libpwquality\n    elif command -v apt-get &> /dev/null; then\n        apt-get update && apt-get install -y libpam-pwquality\n    fi\nfi\n\n# 2. Configure password quality requirements\necho \"Configuring password quality (pwquality)...\"\ncat > /etc/security/pwquality.conf << 'EOF'\n# IA-5(1): Password-based Authentication Requirements\n# Based on NIST SP 800-63B guidelines\n\n# Minimum password length: 8 characters\nminlen = 8\n\n# Credit for character classes (disabled - no composition requirements per NIST)\ndcredit = 0\nucredit = 0\nlcredit = 0\nocredit = 0\n\n# Require minimum different characters from old password\ndifok = 8\n\n# Check against username\nusercheck = 1\n\n# Maximum consecutive characters of same class\nmaxsequence = 3\nmaxrepeat = 3\n\n# Check against dictionary/common passwords\ndictcheck = 1\n\n# Enforce for root user also\nenforce_for_root\nEOF\n\n# 3. Configure PAM to use pwquality\necho \"Configuring PAM password requirements...\"\n# Backup existing PAM configuration\ncp /etc/pam.d/system-auth /etc/pam.d/system-auth.backup.$(date +%Y%m%d) || true\n\n# Add pwquality to password stack\nif ! grep -q \"pam_pwquality.so\" /etc/pam.d/system-auth; then\n    sed -i '/^password.*requisite.*pam_pwquality.so/d' /etc/pam.d/system-auth\n    sed -i '/^password.*required.*pam_unix.so/i password    requisite     pam_pwquality.so try_first_pass local_users_only retry=3' /etc/pam.d/system-auth\nfi\n\n# 4. Configure strong password hashing (SHA-512)\necho \"Configuring password hashing algorithm...\"\nauthselect select sssd --force 2>/dev/null || true\nauthselect enable-feature with-sha512 2>/dev/null || true\n\n# Verify SHA512 is configured in login.defs\nsed -i 's/^ENCRYPT_METHOD.*/ENCRYPT_METHOD SHA512/' /etc/login.defs\nsed -i 's/^#SHA_CRYPT_MIN_ROUNDS.*/SHA_CRYPT_MIN_ROUNDS 5000/' /etc/login.defs\nsed -i 's/^#SHA_CRYPT_MAX_ROUNDS.*/SHA_CRYPT_MAX_ROUNDS 10000/' /etc/login.defs\n\n# 5. Enable password history to prevent reuse\necho \"Configuring password history...\"\nif ! grep -q \"pam_pwhistory.so\" /etc/pam.d/system-auth; then\n    sed -i '/^password.*sufficient.*pam_unix.so/i password    required      pam_pwhistory.so use_authtok remember=24 enforce_for_root' /etc/pam.d/system-auth\nfi\n\n# 6. Download and configure compromised password list (basic implementation)\n# Production: Integrate with HaveIBeenPwned API or maintain updated wordlists\necho \"Configuring dictionary checks...\"\nDICT_FILE=\"/usr/share/dict/bad-passwords.txt\"\nmkdir -p $(dirname $DICT_FILE)\n\n# Create basic compromised password list (expand in production)\ncat > \"$DICT_FILE\" << 'EOF'\npassword\nPassword1\n123456\nqwerty\nadmin\nwelcome\nletmein\nmonkey\ndragon\nmaster\nEOF\n\n# Link to cracklib dictionary\nif [ -f \"$DICT_FILE\" ]; then\n    echo \"  ✓ Basic compromised password list installed\"\nfi\n\n# 7. Configure SSH to only use strong authentication\necho \"Securing SSH password authentication...\"\nsed -i 's/^#PasswordAuthentication.*/PasswordAuthentication yes/' /etc/ssh/sshd_config\nsed -i 's/^PermitEmptyPasswords.*/PermitEmptyPasswords no/' /etc/ssh/sshd_config\nsed -i 's/^#PermitRootLogin.*/PermitRootLogin prohibit-password/' /etc/ssh/sshd_config\n\n# Force SSH to use strong ciphers (TLS equivalent for SSH)\necho \"\" >> /etc/ssh/sshd_config\necho \"# IA-5(1): Strong cryptography for password transmission\" >> /etc/ssh/sshd_config\necho \"Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\" >> /etc/ssh/sshd_config\necho \"MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256\" >> /etc/ssh/sshd_config\n\nsystemctl restart sshd\n\n# 8. Audit logging for password changes\ncat >> /etc/audit/rules.d/password.rules << 'EOF'\n# IA-5(1): Password Change Audit Logging\n-w /etc/security/opasswd -p wa -k password_changes\n-w /etc/pam.d/ -p wa -k pam_password_changes\nEOF\n\naugenrules --load 2>/dev/null || service auditd restart\n\necho \"[IA-5(1)] Password-based Authentication controls successfully applied\"\necho \"✓ Password quality checking enabled (8+ character minimum)\"\necho \"✓ SHA-512 password hashing configured (5000-10000 rounds)\"\necho \"✓ Password history enabled (24 previous passwords remembered)\"\necho \"✓ Dictionary checking enabled\"\necho \"✓ SSH hardened with strong ciphers\"\necho \"✓ Audit logging configured for password operations\"\n",
        "ansible": "---\n# IA-5(1): Password-based Authentication - Ansible Playbook\n# Implements NIST SP 800-63B password requirements\n\n- name: IA-5(1) Password-based Authentication\n  hosts: all\n  become: yes\n\n  vars:\n    password_min_length: 8\n    password_history_remember: 24\n    password_dict_checks: yes\n\n  tasks:\n    - name: Install libpwquality package\n      package:\n        name: \"{{ 'libpwquality' if ansible_os_family == 'RedHat' else 'libpam-pwquality' }}\"\n        state: present\n\n    - name: Configure pwquality password requirements\n      blockinfile:\n        path: /etc/security/pwquality.conf\n        create: yes\n        block: |\n          # IA-5(1): Password-based Authentication\n          minlen = {{ password_min_length }}\n          dcredit = 0\n          ucredit = 0\n          lcredit = 0\n          ocredit = 0\n          difok = 8\n          usercheck = 1\n          maxsequence = 3\n          maxrepeat = 3\n          dictcheck = 1\n          enforce_for_root\n        marker: \"# {mark} ANSIBLE MANAGED - IA-5(1)\"\n\n    - name: Configure strong password hashing (SHA-512)\n      lineinfile:\n        path: /etc/login.defs\n        regexp: \"{{ item.regexp }}\"\n        line: \"{{ item.line }}\"\n        state: present\n      loop:\n        - { regexp: '^ENCRYPT_METHOD', line: 'ENCRYPT_METHOD SHA512' }\n        - { regexp: '^#?SHA_CRYPT_MIN_ROUNDS', line: 'SHA_CRYPT_MIN_ROUNDS 5000' }\n        - { regexp: '^#?SHA_CRYPT_MAX_ROUNDS', line: 'SHA_CRYPT_MAX_ROUNDS 10000' }\n\n    - name: Configure PAM password quality checking\n      pamd:\n        name: system-auth\n        type: password\n        control: requisite\n        module_path: pam_pwquality.so\n        module_arguments: 'try_first_pass local_users_only retry=3'\n        state: before\n        new_type: password\n        new_control: required\n        new_module_path: pam_unix.so\n\n    - name: Configure PAM password history\n      pamd:\n        name: system-auth\n        type: password\n        control: required\n        module_path: pam_pwhistory.so\n        module_arguments: \"use_authtok remember={{ password_history_remember }} enforce_for_root\"\n        state: before\n        new_type: password\n        new_control: sufficient\n        new_module_path: pam_unix.so\n\n    - name: Secure SSH password authentication\n      lineinfile:\n        path: /etc/ssh/sshd_config\n        regexp: \"{{ item.regexp }}\"\n        line: \"{{ item.line }}\"\n        state: present\n      loop:\n        - { regexp: '^#?PasswordAuthentication', line: 'PasswordAuthentication yes' }\n        - { regexp: '^#?PermitEmptyPasswords', line: 'PermitEmptyPasswords no' }\n        - { regexp: '^#?PermitRootLogin', line: 'PermitRootLogin prohibit-password' }\n      notify: restart sshd\n\n    - name: Configure strong SSH ciphers\n      blockinfile:\n        path: /etc/ssh/sshd_config\n        block: |\n          # IA-5(1): Strong cryptography for password transmission\n          Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\n          MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256\n        marker: \"# {mark} ANSIBLE MANAGED - IA-5(1) SSH\"\n      notify: restart sshd\n\n  handlers:\n    - name: restart sshd\n      service:\n        name: sshd\n        state: restarted\n"
      },
      "windows": {
        "powershell": "# IA-5(1): Password-based Authentication - Windows Implementation\n# Implements NIST SP 800-63B password requirements\n\nWrite-Host \"[IA-5(1)] Implementing Password-based Authentication Controls\" -ForegroundColor Cyan\n\n# 1. Configure password policy via Local Security Policy\nWrite-Host \"Configuring password policy...\"\nsecedit /export /cfg $env:TEMP\\secpol.cfg | Out-Null\n\n$config = Get-Content $env:TEMP\\secpol.cfg\n\n# Set password policies aligned with NIST SP 800-63B\n$config = $config -replace '^MinimumPasswordLength.*', 'MinimumPasswordLength = 8' `\n    -replace '^PasswordComplexity.*', 'PasswordComplexity = 1' `\n    -replace '^PasswordHistorySize.*', 'PasswordHistorySize = 24' `\n    -replace '^MaximumPasswordAge.*', 'MaximumPasswordAge = 365' `\n    -replace '^MinimumPasswordAge.*', 'MinimumPasswordAge = 1' `\n    -replace '^ClearTextPassword.*', 'ClearTextPassword = 0'\n\n$config | Set-Content $env:TEMP\\secpol_new.cfg\nsecedit /configure /db secedit.sdb /cfg $env:TEMP\\secpol_new.cfg /areas SECURITYPOLICY | Out-Null\nRemove-Item $env:TEMP\\secpol*.cfg -Force\n\nWrite-Host \"  ✓ Password policy configured: 8+ chars, 24 history, complexity enabled\" -ForegroundColor Green\n\n# 2. Enable additional password filtering (custom DLL in production)\nWrite-Host \"Configuring advanced password filter...\"\n# Note: Requires custom password filter DLL for compromised password checking\n# Set registry to load custom filter (example: Azure AD Password Protection)\n$filterPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\"\nSet-ItemProperty -Path $filterPath -Name \"Notification Packages\" -Value @(\"rassfm\", \"scecli\") -Type MultiString\n\n# 3. Configure account lockout policy\nWrite-Host \"Configuring account lockout policy...\"\nnet accounts /lockoutthreshold:5 /lockoutduration:30 /lockoutwindow:30\n\n# 4. Disable reversible encryption for passwords\nWrite-Host \"Ensuring passwords stored with strong hashing...\"\nsecedit /export /cfg $env:TEMP\\secpol2.cfg | Out-Null\n(Get-Content $env:TEMP\\secpol2.cfg) -replace '^ClearTextPassword.*', 'ClearTextPassword = 0' |\n    Set-Content $env:TEMP\\secpol2_new.cfg\nsecedit /configure /db secedit.sdb /cfg $env:TEMP\\secpol2_new.cfg /areas SECURITYPOLICY | Out-Null\nRemove-Item $env:TEMP\\secpol2*.cfg -Force\n\n# 5. Enable credential protection (Credential Guard prerequisite)\nWrite-Host \"Enabling credential protection features...\"\nSet-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" -Name \"RunAsPPL\" -Value 1 -Type DWord\nSet-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest\" -Name \"UseLogonCredential\" -Value 0 -Type DWord\n\n# 6. Configure RDP to use strong encryption\nWrite-Host \"Configuring RDP encryption for password transmission...\"\nSet-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services\" -Name \"MinEncryptionLevel\" -Value 3 -Type DWord -Force\nSet-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services\" -Name \"SecurityLayer\" -Value 2 -Type DWord -Force\nSet-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services\" -Name \"fEncryptRPCTraffic\" -Value 1 -Type DWord -Force\n\n# 7. Enable audit logging for password changes\nWrite-Host \"Enabling password change audit logging...\"\nauditpol /set /subcategory:\"User Account Management\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Credential Validation\" /success:enable /failure:enable\n\n# 8. Configure Windows Defender Credential Guard (Windows 10 Enterprise+)\ntry {\n    # Enable Virtualization Based Security\n    Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\DeviceGuard\" -Name \"EnableVirtualizationBasedSecurity\" -Value 1 -Type DWord -Force\n    Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\DeviceGuard\" -Name \"RequirePlatformSecurityFeatures\" -Value 3 -Type DWord -Force\n\n    # Enable Credential Guard\n    Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" -Name \"LsaCfgFlags\" -Value 1 -Type DWord -Force\n\n    Write-Host \"  ✓ Credential Guard configured (requires UEFI + TPM 2.0)\" -ForegroundColor Green\n} catch {\n    Write-Host \"  ! Credential Guard requires Windows 10 Enterprise or Server 2016+\" -ForegroundColor Yellow\n}\n\n# 9. Force password change on next logon for accounts with default passwords\nWrite-Host \"Checking for accounts requiring password change...\"\nGet-LocalUser | Where-Object {$_.PasswordRequired -eq $false -and $_.Enabled -eq $true} |\n    Set-LocalUser -PasswordNeverExpires $false -UserMayChangePassword $true\n\n# 10. Create compliance report\n$report = @\"\nIA-5(1) Password-based Authentication Controls Applied: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\n  ✓ Password policy: Minimum 8 characters, complexity enabled\n  ✓ Password history: 24 previous passwords remembered\n  ✓ Account lockout: 5 attempts, 30-minute lockout\n  ✓ Reversible encryption: Disabled\n  ✓ LSA protection: Enabled\n  ✓ WDigest credential caching: Disabled\n  ✓ RDP encryption: High (TLS 1.2)\n  ✓ Audit logging: Enabled for credential operations\n  ✓ Credential Guard: Configured (if hardware supports)\n\nNOTE: For full compliance, deploy Azure AD Password Protection or custom\n      password filter DLL to check against compromised password databases.\n\"@\n\n$report | Out-File -FilePath \"C:\\ProgramData\\IA-5-1_Compliance.log\" -Append\nWrite-Host \"`n[IA-5(1)] Password-based Authentication controls successfully applied\" -ForegroundColor Green\nWrite-Host \"`nNOTE: Deploy custom password filter for compromised password checking\" -ForegroundColor Yellow\nWrite-Host \"      Recommended: Azure AD Password Protection or Enzoic Password Filter\" -ForegroundColor Yellow\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T19:52:32.523947+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T19:52:32.523949+00:00",
      "source": "ComplianceAsCode",
      "platform": "multi-platform",
      "rule_count": 45,
      "certification": "Government-certified",
      "stig_mappings": [
        "RHEL-08-020100",
        "RHEL-08-020110",
        "RHEL-08-020120",
        "RHEL-08-020130",
        "RHEL-08-020140",
        "RHEL-08-020150",
        "RHEL-08-020160",
        "RHEL-08-020170",
        "RHEL-08-020180",
        "RHEL-08-020190",
        "RHEL-08-020200",
        "RHEL-08-020210",
        "RHEL-08-020220",
        "RHEL-08-020230",
        "RHEL-08-020240",
        "RHEL-08-020250",
        "RHEL-08-020260",
        "RHEL-08-020270",
        "RHEL-08-020280",
        "RHEL-08-020290",
        "WN10-AC-000060",
        "WN10-AC-000065",
        "WN10-AC-000070",
        "WN10-AC-000075",
        "WN10-SO-000070",
        "WN10-SO-000075",
        "WN10-SO-000245"
      ],
      "implementation_guidance": "Comprehensive password management automation available. Includes PAM configuration, pwquality integration, password hashing (SHA-512), dictionary checking, and audit logging. For compromised password database integration, see supplemental documentation."
    },
    "ai_guidance": "IA-5.1 Password-based Authentication requires password complexity and management controls. Enforce minimum 12+ characters, complexity requirements, and password history. Implement secure password storage (bcrypt, PBKDF2). Prevent use of compromised passwords."
  },
  {
    "control_id": "IA-5.2",
    "control_name": "Public Key-based Authentication",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "For public key-based authentication:\n(a) Enforce authorized access to the corresponding private key; and\n(b) Map the authenticated identity to the account of the individual or group.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "When using public key cryptography (like SSH keys or smart cards), ensure that private keys are protected from unauthorized access and that the system can correctly link the cryptographic identity to the actual user or group account. This prevents unauthorized users from impersonating legitimate users even if they obtain a public key.",
    "example_implementation": "Implement PKI authentication using: (1) Hardware Security Modules (HSMs) or TPM chips to protect private keys, (2) SSH key authentication with private keys stored in ~/.ssh with 0600 permissions, (3) Smart card/CAC authentication for high-security systems, (4) Certificate-to-user mapping via LDAP or Active Directory, (5) Regular certificate revocation list (CRL) checking, and (6) Enforcement of minimum RSA 2048-bit or ECC P-256 key lengths.",
    "non_technical_guidance": "To comply with IA-5(2) PKI-based Authentication:\n1. Implement policies requiring protection of private keys (never share, encrypt when stored, use hardware tokens for high-value keys).\n2. Establish certificate-to-user/account mapping procedures (LDAP attribute mapping, Active Directory UPN mapping).\n3. Require hardware token storage for privileged account private keys (YubiKeys, smart cards, HSMs).\n4. Define minimum key strength requirements: RSA ≥2048 bits, ECC ≥256 bits, EdDSA recommended.\n5. Implement certificate lifecycle management: issuance, renewal, revocation (CRL/OCSP).\n6. Train users on private key protection: passphrase-protect keys, never email private keys, report lost tokens immediately.\n7. For SSH: Disable password authentication, require key-based only, use certificate authorities for key management at scale.\n8. Regular audits of certificate inventories and unused/expired certificates.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "IA-2",
      "IA-4",
      "IA-5",
      "IA-8",
      "SC-12",
      "SC-13",
      "SC-17"
    ],
    "supplemental_guidance": "PKI-based authentication provides stronger assurance than passwords through cryptographic proof of identity. Private key protection is critical—compromise of a private key allows impersonation until the certificate is revoked. Organizations should use FIPS 140-2/140-3 validated cryptographic modules for key generation and storage. The Federal PKI (FPKI) provides governm ent-wide certificate services. For SSH, use OpenSSH certificate authorities rather than managing individual public keys. NIST SP 800-57 provides key management guidance. Certificate mapping typically uses Subject Alternative Name (SAN) fields (email, UPN, or DN) to link to directory accounts. Implement automated CRL/OCSP checking to detect revoked certificates before authentication.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-5(2): PKI-based Authentication - Linux SSH Configuration\n\nset -euo pipefail\necho \"[IA-5(2)] Configuring PKI-based SSH Authentication\"\n\n# 1. Disable password authentication, enforce key-based only\nsed -i 's/^#?PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config\nsed -i 's/^#?PubkeyAuthentication.*/PubkeyAuthentication yes/' /etc/ssh/sshd_config\nsed -i 's/^#?ChallengeResponseAuthentication.*/ChallengeResponseAuthentication no/' /etc/ssh/sshd_config\n\n# 2. Configure strong host keys (remove weak algorithms)\necho \"Regenerating SSH host keys with strong algorithms...\"\nrm -f /etc/ssh/ssh_host_dsa_key* /etc/ssh/ssh_host_ecdsa_key*\nssh-keygen -t rsa -b 4096 -f /etc/ssh/ssh_host_rsa_key -N \"\" -q || true\nssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N \"\" -q || true\n\n# 3. Configure SSH to only accept strong public keys\ncat >> /etc/ssh/sshd_config << 'EOF'\n\n# IA-5(2): PKI Authentication - Strong Algorithms Only\nHostKey /etc/ssh/ssh_host_rsa_key\nHostKey /etc/ssh/ssh_host_ed25519_key\nPubkeyAcceptedKeyTypes ssh-ed25519,rsa-sha2-512,rsa-sha2-256,ecdsa-sha2-nistp256\nHostKeyAlgorithms ssh-ed25519,rsa-sha2-512,rsa-sha2-256\nEOF\n\n# 4. Set strict permissions on authorized_keys files\necho \"Securing authorized_keys permissions...\"\nfind /home -name \"authorized_keys\" -exec chmod 600 {} \\;\nfind /home -type d -name \".ssh\" -exec chmod 700 {} \\;\n\n# 5. Configure PAM for smart card authentication (if using CAC/PIV)\nif [ -f /etc/pam.d/sshd ]; then\n    # Add pam_pkcs11 if smart cards are used\n    if command -v pkcs11-tool &>/dev/null; then\n        echo \"auth required pam_pkcs11.so\" >> /etc/pam.d/sshd\n    fi\nfi\n\n# 6. Enable certificate-based authentication (OpenSSH CA model)\ncat >> /etc/ssh/sshd_config << 'EOF'\n\n# Certificate Authority for scalable key management\nTrustedUserCAKeys /etc/ssh/ca-user.pub\n# Revoked certificate serial numbers\nRevokedKeys /etc/ssh/revoked-keys\n\n# Map certificates to local accounts\nAuthorizedPrincipalsFile /etc/ssh/principals/%u\nEOF\n\nmkdir -p /etc/ssh/principals\n\n# 7. Audit logging for PKI authentication events\ncat >> /etc/audit/rules.d/pki_auth.rules << 'EOF'\n# IA-5(2): PKI Authentication Auditing\n-w /home -p wa -k ssh_key_changes\n-w /etc/ssh/sshd_config -p wa -k sshd_config\n-w /etc/ssh/ca-user.pub -p wa -k ssh_ca_changes\n-a always,exit -F arch=b64 -S openat -F a2&0100 -F path=/home/*/.ssh/authorized_keys -k ssh_key_access\nEOF\n\naugenrules --load 2>/dev/null || service auditd restart\n\nsystemctl restart sshd\necho \"[IA-5(2)] PKI Authentication configured successfully\"\n",
        "ansible": "---\n- name: IA-5(2) PKI-based Authentication\n  hosts: all\n  become: yes\n  tasks:\n    - name: Disable password authentication\n      lineinfile:\n        path: /etc/ssh/sshd_config\n        regexp: \"{{ item.regexp }}\"\n        line: \"{{ item.line }}\"\n      loop:\n        - { regexp: '^#?PasswordAuthentication', line: 'PasswordAuthentication no' }\n        - { regexp: '^#?PubkeyAuthentication', line: 'PubkeyAuthentication yes' }\n        - { regexp: '^#?ChallengeResponseAuthentication', line: 'ChallengeResponseAuthentication no' }\n      notify: restart sshd\n\n    - name: Remove weak host keys\n      file:\n        path: \"{{ item }}\"\n        state: absent\n      loop:\n        - /etc/ssh/ssh_host_dsa_key\n        - /etc/ssh/ssh_host_dsa_key.pub\n        - /etc/ssh/ssh_host_ecdsa_key\n        - /etc/ssh/ssh_host_ecdsa_key.pub\n\n    - name: Generate strong RSA host key\n      command: ssh-keygen -t rsa -b 4096 -f /etc/ssh/ssh_host_rsa_key -N \"\"\n      args:\n        creates: /etc/ssh/ssh_host_rsa_key\n\n    - name: Secure authorized_keys permissions\n      shell: |\n        find /home -name \"authorized_keys\" -exec chmod 600 {} \\;\n        find /home -type d -name \".ssh\" -exec chmod 700 {} \\;\n\n  handlers:\n    - name: restart sshd\n      service:\n        name: sshd\n        state: restarted\n"
      },
      "windows": {
        "powershell": "# IA-5(2): PKI-based Authentication - Windows Smart Card Configuration\n\nWrite-Host \"[IA-5(2)] Configuring PKI-based Authentication\" -ForegroundColor Cyan\n\n# 1. Enable smart card requirement for interactive logon (high-security systems)\n$regPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\nSet-ItemProperty -Path $regPath -Name \"scforceoption\" -Value 1 -Type DWord -Force\n\n# 2. Configure Certificate Propagation service\nSet-Service -Name \"CertPropSvc\" -StartupType Automatic\nStart-Service -Name \"CertPropSvc\" -ErrorAction SilentlyContinue\n\n# 3. Configure Smart Card service\nSet-Service -Name \"ScDeviceEnum\" -StartupType Automatic\nStart-Service -Name \"ScDeviceEnum\" -ErrorAction SilentlyContinue\n\n# 4. Enable PKI certificate mapping to AD accounts\n$ldapPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters\"\nif (-not (Test-Path $ldapPath)) {\n    New-Item -Path $ldapPath -Force | Out-Null\n}\nSet-ItemProperty -Path $ldapPath -Name \"UseCertificateAuthentication\" -Value 1 -Type DWord\n\n# 5. Configure certificate-to-account mapping registry\nSet-ItemProperty -Path \"HKLM:\\SOFTWARE\\Microsoft\\Cryptography\\Calais\\Readers\" -Name \"ScPnPNotification\" -Value 1 -Type DWord -Force\n\n# 6. Enable audit logging for certificate-based authentication\nauditpol /set /subcategory:\"Logon\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Account Logon\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Credential Validation\" /success:enable /failure:enable\n\n# 7. Configure CRL checking for certificate validation\ncertutil -setreg Policy\\CRLFlags 2\ncertutil -setreg Policy\\CRLTimeout 1000\n\n# 8. Enable OCSP checking\ncertutil -setreg chain\\ChainCacheResyncFiletime @now\n\nWrite-Host \"[IA-5(2)] PKI Authentication configured\" -ForegroundColor Green\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T19:55:10.702687+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T19:55:10.702687+00:00",
      "source": "ComplianceAsCode + DISA STIGs",
      "platform": "multi-platform",
      "rule_count": 8,
      "certification": "Government-certified",
      "stig_mappings": [
        "RHEL-08-010090",
        "RHEL-08-010100",
        "RHEL-08-010110",
        "WN10-SO-000095",
        "WN10-SO-000100"
      ]
    },
    "ai_guidance": "IA-5.2 Public Key-based Authentication requires managing PKI certificates and keys. Implement certificate lifecycle management. Validate certificate chains and revocation status. Protect private keys with HSMs or secure storage. Map certificates to authorized users."
  },
  {
    "control_id": "IA-5.3",
    "control_name": "In-person or Trusted External Party Registration",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Require that the registration process to receive an authenticator be conducted:\n(a) In person before a designated registration authority; or\n(b) By a designated registration authority with authorization by a designated official.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "High-assurance authenticators (smart cards, biometrics, hardware tokens) require in-person identity verification or authorization by a designated official before issuance. This prevents remote attackers from obtaining authenticators by impersonation.",
    "example_implementation": "Establish registration authority (RA) procedures: (1) Users must appear in-person with two forms of ID (passport + driver's license) to receive PIV cards, (2) For remote workers, require video verification plus notarized identity documents, (3) Designated security officers authorize token issuance via signed approval forms, (4) All registrations logged in identity management system with approver details.",
    "non_technical_guidance": "To comply with IA-5(3) In-person or Trusted External Party Registration:\n1. Define authenticator types requiring in-person registration: High-assurance authenticators (PIV/CAC smart cards, biometric enrollment, hardware security tokens, code signing certificates) must be issued only after in-person identity verification or authorization by designated official.\n2. Designate registration authorities: Identify specific personnel authorized to conduct identity proofing and authenticator issuance—typically HR representatives, security personnel, or designated identity registration officers with proper training.\n3. Establish identity proofing requirements: For MODERATE/HIGH systems, require in-person appearance with two forms of government-issued photo identification (e.g., passport and driver license), verification against authoritative sources (DMV databases, passport records), and biometric capture if applicable.\n4. Configure registration workflow: User schedules appointment with registration authority, appears in-person with required identification documents, RA verifies identity and documents validity, captures identity information, obtains authorization from designated official (security manager, CISO), issues authenticator, logs transaction with approver details.\n5. For remote/distributed workforce exceptions: When in-person registration is impractical, implement trusted third-party verification using notarized identity documents, video conference identity verification with liveness detection, or trusted introducer model where existing verified employees vouch for new employees under their management.\n6. Train registration authorities: Provide fraud detection training (spotting fake IDs, document alteration techniques), proper identity verification procedures, data protection requirements, logging and documentation standards.\n7. Document all registration events: Maintain audit trail including identity documents presented, verification sources consulted, approving official identity, date/time of issuance, authenticator serial numbers or identifiers.\n8. Establish authorization criteria: Define who can approve authenticator issuance (department heads for standard credentials, CISO for privileged credentials, designated security officers for contractor/visitor credentials), required approval levels based on authenticator sensitivity.\n9. Implement compensating controls for remote scenarios: If in-person verification impossible, require multiple verification factors (notarized documents PLUS video verification PLUS background check), document risk acceptance, implement enhanced monitoring for remotely-issued authenticators.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:03:13.651358+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:37.174504+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.3 In-Person or Trusted Third-Party Registration requires identity proofing before issuing authenticators. Verify identity through in-person appearance or trusted registration authority. Document identity evidence. Follow NIST SP 800-63 identity proofing guidelines."
  },
  {
    "control_id": "IA-5.4",
    "control_name": "Automated Support for Password Strength Determination",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Employ automated tools to determine if password authenticators are sufficiently strong to resist attacks intended to discover or otherwise compromise the authenticators.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Use password strength checking tools (like zxcvbn, pwquality, or commercial solutions) that analyze password entropy, check against breach databases, and prevent common patterns. These tools should run in real-time during password creation.",
    "example_implementation": "Integrate zxcvbn.js library into web applications to provide real-time password strength feedback. Configure libpwquality on Linux systems to reject passwords with <60 bits entropy, check against common dictionaries, and prevent username inclusion. Use API integration with HaveIBeenPwned to block 600M+ compromised passwords. Display strength meter with actionable feedback ('Add more random characters' vs generic 'weak password').",
    "non_technical_guidance": "To comply with IA-5(4) Automated Support for Password Strength Determination:\n1. Deploy password strength checking tools at all authentication interfaces: Integrate real-time password strength meters in account creation pages, password change forms, and administrative consoles—use established libraries like zxcvbn (Dropbox), passwordmeter.js, or vendor-provided solutions.\n2. Configure automated password rejection criteria: Set minimum entropy requirements (60-80 bits for MODERATE systems, 80-100 bits for HIGH systems), enable dictionary checking against common password lists, block passwords containing username or organization name, prevent keyboard patterns (qwerty, 12345) and common substitutions (passw0rd).\n3. Integrate compromised password databases: Connect to HaveIBeenPwned Pwned Passwords API (600M+ breached passwords), NCSC password blacklist, or similar breach correlation services—automatically reject any password found in breach databases regardless of apparent complexity.\n4. Implement real-time user feedback: Display dynamic strength indicators (weak/fair/good/strong with visual progress bars), provide actionable guidance without revealing exact requirements to attackers, suggest improvements, show estimated crack time based on entropy calculation.\n5. Configure strength analysis algorithms: Use entropy-based calculation not just character counting (four random words stronger than 8-character complex password), account for dictionary words (penalize entropy for common words), detect patterns and sequences, analyze keyboard proximity exploitation.\n6. Set organizational strength thresholds: Define minimum acceptable scores for different account types (standard user accounts minimum 65-bit entropy, privileged accounts 80-bit entropy, service accounts 100-bit entropy or require non-password authentication).\n7. Provide user education on password creation: Display examples of strong passwords/passphrases, recommend passphrase approach (correct horse battery staple method), educate on why length beats complexity, warn against password reuse across systems.\n8. Test password strength tools effectiveness: Periodically validate tools detect weak passwords (test with known weak passwords, common patterns, leaked credentials), verify no false positives blocking legitimate strong passwords, ensure tools do not leak password information.\n9. Monitor password creation analytics: Track rejected password attempts to identify user confusion patterns, measure average password entropy across organization, identify users consistently creating weak passwords for additional training.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:03:13.651358+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:38.990328+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.4 Automated Support for Password Strength Determination requires automated password strength checking. Implement real-time password strength meters. Check against breached password databases. Reject weak or commonly-used passwords."
  },
  {
    "control_id": "IA-5.5",
    "control_name": "Change Authenticators Prior to Delivery",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Require developers and installers of system components to provide unique authenticators or change default authenticators prior to delivery and installation.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Never deploy systems with default passwords or credentials. All devices, applications, databases, and network equipment must have unique, strong authenticators configured before they go into production. This prevents attackers from exploiting well-known default credentials.",
    "example_implementation": "Implement automated provisioning: (1) Configuration management (Ansible/Puppet) generates random 32-character passwords for all databases during deployment, (2) Network devices receive unique credentials from password vault during initial setup, (3) IoT devices have default credentials changed via bootstrap script before network connection, (4) Application installation scripts refuse to proceed if default 'admin/admin' credentials detected, (5) Pre-deployment checklist requires verification of unique credentials.",
    "non_technical_guidance": "To comply with IA-5(5) Change Authenticators Prior to Delivery:\n1. Establish organizational policy banning default credentials: Explicitly prohibit deployment of any system component (servers, network devices, databases, IoT devices, applications) with factory default passwords, keys, or certificates—make credential customization mandatory before operational use.\n2. Define pre-deployment credential requirements: All systems must have unique, randomly generated credentials configured before network connection or production deployment—minimum 32-character random passwords for administrative accounts, unique SSH host keys regenerated on first boot, custom certificates replacing vendor-shipped defaults.\n3. Create secure credential generation procedures: Use cryptographically strong random password generators (not sequential or predictable patterns), document credentials in enterprise password management system (Vault, CyberArk, Password Manager), apply role-based access controls to credential documentation, encrypt credential storage.\n4. Implement deployment automation with credential randomization: Configure infrastructure-as-code tools (Terraform, Ansible, CloudFormation) to generate random unique credentials during provisioning, integrate with secret management systems for credential storage/retrieval, prevent manual credential entry that could result in weak/default passwords being used.\n5. Establish vendor requirements and acceptance criteria: For procured equipment, contractual language requiring vendors to support credential customization before delivery or providing tools for rapid credential change on first boot—reject products that hardcode unchangeable default credentials, require vendor documentation of default credential change procedures.\n6. Conduct pre-deployment security validation: Scan new systems for default credentials using automated tools (Nessus, Qualys, OpenVAS configured with default credential checks), manually verify administrative passwords changed from defaults, check for vendor backdoor accounts, validate SSH keys regenerated.\n7. Create installation checklists requiring credential verification: Step-by-step procedures for each system type documenting required credential changes (database root passwords, web application admin accounts, network device enable passwords, SNMP community strings), sign-off requirements before production deployment approval.\n8. For legacy systems with unchangeable defaults: Document as risk in system authorization package, implement compensating controls (network segmentation isolating affected systems, enhanced monitoring for exploitation attempts, access restrictions limiting who can reach default credential interfaces), plan migration to replaceable systems.\n9. Audit credential management compliance: Quarterly scans for default credentials across infrastructure, review new system deployment documentation verifying credential change compliance, investigate any default credential findings as security incidents requiring immediate remediation.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:03:13.651358+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:41.525980+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.5 Change Authenticators Prior to Delivery requires changing default passwords before system deployment. Document and enforce default credential changes. Scan for default credentials. Prohibit deployment with factory defaults."
  },
  {
    "control_id": "IA-5.6",
    "control_name": "Protection of Authenticators",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Protect authenticators commensurate with the security category of the information to which use of the authenticator permits access.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "The security measures protecting authenticators must match the sensitivity of the data they protect. High-value system credentials require stronger protection (hardware tokens, HSMs, encrypted storage) than low-value system credentials (which may use password managers). This prevents attackers from targeting weak credential storage to access sensitive systems.",
    "example_implementation": "Implement tiered authenticator protection: (1) HIGH systems: Require FIPS 140-2 Level 2+ hardware tokens, store private keys in HSMs, enable biometric protection for credential access. (2) MODERATE systems: Use encrypted password managers (1Password, BitWarden with master password + 2FA), store SSH keys encrypted with passphrases, enable OS-level credential encryption (Windows Credential Guard, macOS Keychain with FileVault). (3) LOW systems: Minimum password manager usage, no plaintext credential storage. (4) All levels: Encrypt credentials at rest and in transit, log all credential access.",
    "non_technical_guidance": "To comply with IA-5(6) Protection of Authenticators:\n1. Classify systems by security category (FIPS 199: LOW, MODERATE, HIGH based on confidentiality/integrity/availability impact).\n2. Define protection requirements per category: HIGH=hardware tokens/HSMs, MODERATE=encrypted storage+MFA, LOW=password managers minimum.\n3. Ban plaintext credential storage in any context (config files, scripts, wikis, shared drives).\n4. Require encryption for all credential storage: AES-256 for files, TLS 1.2+ for transmission, FIPS-validated crypto modules for hardware.\n5. Implement physical security for hardware tokens: locked storage when not in use, sign-out procedures, immediate reporting of loss/theft.\n6. Train personnel on credential protection: never share passwords, use unique credentials per system, enable 2FA where available.\n7. Conduct periodic audits: scan for plaintext credentials in code repositories, verify encrypted storage compliance, review token inventory.\n8. For service accounts/API keys: Use secret management systems (HashiCorp Vault, AWS Secrets Manager, Azure Key Vault) rather than config files.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "Authenticator protection should be risk-based. FIPS 199 categorization determines baseline protection levels. For HIGH systems handling classified or highly sensitive data, hardware-based protection (smart cards, HSMs, TPMs) prevents software-based key extraction attacks. For MODERATE systems, OS-level credential protection (Windows Credential Guard using virtualization-based security, macOS Keychain with secure enclave) provides strong software-based protection. Password managers with strong master passwords and MFA meet many requirements. Organizations should inventory all authenticators, classify by system sensitivity, and verify appropriate protection mechanisms. Developer credentials require special attention—API keys and service account passwords frequently leak via code repositories. Use pre-commit hooks (git-secrets, truffleHog) to detect credential commits.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-5(6): Protection of Authenticators - Linux Implementation\n\nset -euo pipefail\necho \"[IA-5(6)] Configuring Authenticator Protection\"\n\n# 1. Secure credential storage directories\necho \"Securing SSH key directories...\"\nfind /home -type d -name \".ssh\" -exec chmod 700 {} \\;\nfind /home -type f -name \"id_rsa\" -exec chmod 600 {} \\;\nfind /home -type f -name \"id_ed25519\" -exec chmod 600 {} \\;\n\n# 2. Ensure password hashes are protected\nchmod 0000 /etc/shadow /etc/gshadow\nchown root:root /etc/shadow /etc/gshadow\n\n# 3. Configure encrypted password storage for services\n# Lock down service account credential files\nfind /etc -name \"*password*\" -type f -exec chmod 600 {} \\; 2>/dev/null || true\n\n# 4. Enable kernel-level credential protection\n# Restrict access to /proc/<pid>/environ which may contain credentials\necho \"1\" > /proc/sys/kernel/dmesg_restrict 2>/dev/null || true\necho \"1\" > /proc/sys/kernel/kptr_restrict 2>/dev/null || true\n\n# 5. Configure TPM for hardware-backed credential storage (if available)\nif command -v tpm2_getrandom &>/dev/null; then\n    echo \"TPM detected - configuring hardware credential protection...\"\n    systemctl enable tpm2-abrmd || true\n    # Organizations should configure LUKS with TPM-sealed keys\nfi\n\n# 6. Scan for cleartext credentials in common locations\necho \"Scanning for cleartext credentials...\"\nCLEARTEXT_PATTERNS=(\"password\\s*=\\s*['\"]\" \"api_key\\s*=\" \"secret\\s*=\")\nfor pattern in \"${CLEARTEXT_PATTERNS[@]}\"; do\n    find /opt /home -type f \\( -name \"*.conf\" -o -name \"*.cfg\" -o -name \"*.ini\" \\) \\\n        -exec grep -l -E \"$pattern\" {} \\; 2>/dev/null | head -5\ndone\n\n# 7. Configure audit logging for credential access\ncat >> /etc/audit/rules.d/credential_access.rules << 'EOF'\n# IA-5(6): Credential Access Auditing\n-w /etc/shadow -p wa -k credential_access\n-w /etc/gshadow -p wa -k credential_access\n-a always,exit -F arch=b64 -S open -F a1&03 -F path=/home/*/.ssh/id_rsa -k ssh_key_access\n-a always,exit -F arch=b64 -S open -F a1&03 -F path=/home/*/.ssh/id_ed25519 -k ssh_key_access\nEOF\n\naugenrules --load 2>/dev/null || service auditd restart\n\necho \"[IA-5(6)] Authenticator protection configured\"\n",
        "ansible": "---\n- name: IA-5(6) Protection of Authenticators\n  hosts: all\n  become: yes\n  tasks:\n    - name: Secure SSH key directories\n      shell: |\n        find /home -type d -name \".ssh\" -exec chmod 700 {} \\;\n        find /home -type f -name \"id_rsa\" -exec chmod 600 {} \\;\n\n    - name: Protect password hash files\n      file:\n        path: \"{{ item }}\"\n        mode: '0000'\n        owner: root\n        group: root\n      loop:\n        - /etc/shadow\n        - /etc/gshadow\n\n    - name: Enable kernel credential protection\n      sysctl:\n        name: \"{{ item.name }}\"\n        value: \"{{ item.value }}\"\n        state: present\n        sysctl_set: yes\n      loop:\n        - { name: 'kernel.dmesg_restrict', value: '1' }\n        - { name: 'kernel.kptr_restrict', value: '1' }\n"
      },
      "windows": {
        "powershell": "# IA-5(6): Protection of Authenticators - Windows Implementation\n\nWrite-Host \"[IA-5(6)] Configuring Authenticator Protection\" -ForegroundColor Cyan\n\n# 1. Enable Credential Guard (Windows 10 Enterprise+)\ntry {\n    $regPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\"\n    Set-ItemProperty -Path $regPath -Name \"LsaCfgFlags\" -Value 1 -Type DWord -Force\n    Write-Host \"  Credential Guard enabled\" -ForegroundColor Green\n} catch {\n    Write-Host \"  Credential Guard requires Windows 10 Enterprise\" -ForegroundColor Yellow\n}\n\n# 2. Disable WDigest credential caching (prevents plaintext password storage)\nSet-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest\" `\n    -Name \"UseLogonCredential\" -Value 0 -Type DWord\n\n# 3. Enable LSA protection (prevents credential dumping)\nSet-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" `\n    -Name \"RunAsPPL\" -Value 1 -Type DWord\n\n# 4. Configure Credential Manager protection\n# Remove cached RDP credentials (security risk)\ncmdkey /list | Select-String \"Target:\" | ForEach-Object {\n    $target = ($_ -split \"Target: \")[1]\n    cmdkey /delete:$target\n}\n\n# 5. Enable audit logging for credential access\nauditpol /set /subcategory:\"Credential Validation\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Sensitive Privilege Use\" /success:enable /failure:enable\n\n# 6. Configure registry to protect stored credentials\n$credPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest\"\nSet-ItemProperty -Path $credPath -Name \"Negotiate SecuritySupport Provider\" -Value 0 -Type DWord\n\nWrite-Host \"[IA-5(6)] Authenticator protection configured\" -ForegroundColor Green\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T19:57:16.819298+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:43.609887+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.6 Protection of Authenticators requires protecting authenticators from unauthorized disclosure and modification. Encrypt stored passwords. Use secure transmission (TLS). Implement secure password reset. Protect token seeds and certificate private keys."
  },
  {
    "control_id": "IA-5.7",
    "control_name": "No Embedded Unencrypted Static Authenticators",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Ensure that unencrypted static authenticators are not embedded in applications or other forms of static storage.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Never hardcode passwords, API keys, certificates, or other credentials directly in application source code, configuration files, scripts, or databases. This is a critical security vulnerability that leads to widespread credential compromise when code is shared or leaked. All credentials must be retrieved from secure external sources at runtime (secret management systems, environment variables, encrypted config stores).",
    "example_implementation": "Implement secure credential management: (1) Use secret management systems (HashiCorp Vault, AWS Secrets Manager, Azure Key Vault, CyberArk) for all production credentials. (2) Configure applications to retrieve credentials at runtime via API calls with short-lived tokens. (3) For development: Use environment variables (never commit .env files), local secret stores (direnv, chamber). (4) Implement pre-commit hooks (git-secrets, truffleHog, Talisman) to block commits containing credentials. (5) Scan existing codebase with automated tools (GitGuardian, GitHub secret scanning, AWS Macie) to find embedded credentials. (6) For database connection strings: Use integrated authentication (Kerberos, IAM roles) or retrieve from secret manager. (7) Rotate any credentials discovered in code repositories immediately.",
    "non_technical_guidance": "To comply with IA-5(7) No Embedded Static Authenticators:\n1. Establish policy prohibiting hardcoded credentials in any form: source code, config files, scripts, documentation, wikis.\n2. Procure and deploy secret management solution appropriate to organization size (Vault for large enterprises, AWS Secrets Manager for cloud-native, 1Password/BitWarden for small teams).\n3. Train developers on secure credential handling: retrieve from secret manager at runtime, never commit credentials, use IAM roles for cloud resources.\n4. Implement automated detection: Enable GitHub/GitLab secret scanning, deploy pre-commit hooks on all development machines, schedule regular repository scans.\n5. Establish credential rotation procedures: Any credential found in code must be rotated immediately (assume compromised).\n6. For legacy applications with embedded credentials: Prioritize refactoring based on risk (internet-facing first, then internal systems).\n7. Create secure credential onboarding process for new applications: No production deployment approved until credential externalization verified.\n8. Conduct code reviews with credential security checklist before merging.\n9. For third-party software: Verify vendor supports external credential configuration, never accept products requiring embedded credentials.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "Embedded credentials are the #1 source of credential compromise in modern applications. GitHub alone removes millions of leaked credentials annually. Common violation patterns: database passwords in config.xml, API keys in Python scripts, AWS access keys in Terraform files. Even 'encrypted' credentials in code are vulnerable—encryption keys must be stored somewhere, creating the same problem recursively. The only secure approach is runtime retrieval from dedicated secret management infrastructure with appropriate access controls, audit logging, and rotation capabilities. For containerized applications, use secret injection mechanisms (Kubernetes Secrets with encryption at rest, Docker Swarm secrets). For serverless: use cloud provider secret services (AWS Secrets Manager, Azure Key Vault, GCP Secret Manager) with IAM-based access. Organizations should inventory all applications, identify embedded credential usage, and systematically remediate starting with highest-risk systems.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-5(7): No Embedded Unencrypted Static Authenticators - Detection & Prevention\n\nset -euo pipefail\necho \"[IA-5(7)] Scanning for Embedded Credentials\"\n\n# 1. Install secret scanning tools\nif ! command -v truffleHog &>/dev/null; then\n    echo \"Installing truffleHog secret scanner...\"\n    pip3 install truffleHog || true\nfi\n\n# 2. Scan filesystem for common credential patterns\necho \"Scanning for credential patterns in common locations...\"\n\nSCAN_DIRS=\"/opt /home /var/www\"\nPATTERNS=(\n    \"password\\s*=\\s*['\"][^'\"]{8,}\"\n    \"api[_-]?key\\s*=\\s*['\"][A-Za-z0-9]{20,}\"\n    \"secret\\s*=\\s*['\"][^'\"]{16,}\"\n    \"AWS_ACCESS_KEY_ID|AKIA[0-9A-Z]{16}\"\n    \"BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY\"\n    \"Authorization:\\s*Bearer\\s+[A-Za-z0-9\\-_=]+\\.[A-Za-z0-9\\-_=]+\"\n)\n\nfor dir in $SCAN_DIRS; do\n    if [ -d \"$dir\" ]; then\n        for pattern in \"${PATTERNS[@]}\"; do\n            echo \"  Checking: $pattern\"\n            grep -r -E \"$pattern\" \"$dir\" --include=\"*.py\" --include=\"*.js\" --include=\"*.java\" --include=\"*.conf\" --include=\"*.cfg\" 2>/dev/null | head -3 || true\n        done\n    fi\ndone\n\n# 3. Configure git-secrets for repositories\nif command -v git &>/dev/null; then\n    echo \"Configuring git-secrets...\"\n    git config --global secrets.providers git secrets --aws-provider\n    git config --global secrets.patterns '[A-Z0-9]{20}' # Generic high-entropy strings\nfi\n\n# 4. Create pre-commit hook template\ncat > /usr/local/bin/check-secrets.sh << 'EOF'\n#!/bin/bash\n# Pre-commit hook to prevent credential commits\n\nif git diff --cached | grep -E \"(password|api_key|secret)\\s*=\\s*['\"]\"; then\n    echo \"ERROR: Potential credential detected in staged changes\"\n    exit 1\nfi\nEOF\nchmod +x /usr/local/bin/check-secrets.sh\n\necho \"[IA-5(7)] Secret scanning configured. Review findings above.\"\n"
      },
      "windows": {
        "powershell": "# IA-5(7): No Embedded Static Authenticators - Detection & Prevention\n\nWrite-Host \"[IA-5(7)] Scanning for Embedded Credentials\" -ForegroundColor Cyan\n\n# 1. Define credential patterns\n$patterns = @(\n    'password\\s*=\\s*[\"''][^\"'']{8,}',\n    'api[_-]?key\\s*=\\s*[\"''][A-Za-z0-9]{20,}',\n    'connectionString\\s*=.*password=',\n    'AWS_ACCESS_KEY_ID|AKIA[0-9A-Z]{16}',\n    '-----BEGIN (RSA|DSA) PRIVATE KEY-----'\n)\n\n# 2. Scan common application directories\n$scanPaths = @(\"C:\\inetpub\", \"C:\\Program Files\", \"C:\\ProgramData\")\n\nforeach ($path in $scanPaths) {\n    if (Test-Path $path) {\n        Write-Host \"Scanning: $path\" -ForegroundColor Yellow\n        Get-ChildItem -Path $path -Recurse -Include *.config,*.xml,*.json,*.ps1,*.cs -ErrorAction SilentlyContinue |\n            Select-String -Pattern $patterns -CaseSensitive:$false | Select-Object -First 10\n    }\n}\n\n# 3. Check for credentials in registry\nWrite-Host \"Checking registry for stored credentials...\" -ForegroundColor Yellow\nGet-ItemProperty -Path \"HKLM:\\SOFTWARE\\*\" -ErrorAction SilentlyContinue |\n    Where-Object { $_.PSObject.Properties.Name -match \"password|secret|key\" } |\n    Select-Object -First 5\n\nWrite-Host \"[IA-5(7)] Scan complete. Review findings for embedded credentials.\" -ForegroundColor Green\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T19:57:16.819298+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:45.565985+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.7 No Embedded Unencrypted Static Authenticators requires prohibiting unencrypted credentials in applications and scripts. Scan code for hardcoded credentials. Use secrets management (HashiCorp Vault, Azure Key Vault). Implement credential injection at runtime."
  },
  {
    "control_id": "IA-5.8",
    "control_name": "Multiple System Accounts",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Implement {{ insert: param, ia-05.08_odp }} to manage the risk of compromise due to individuals having accounts on multiple systems.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When users have accounts on multiple systems (common in large organizations), implement security measures to reduce the risk that compromising one account leads to compromise of all accounts. This typically means requiring different passwords per system, implementing centralized authentication (SSO/federation) with strong MFA, or using unique credentials generated per-system.",
    "example_implementation": "Implement cross-system credential management: (1) Deploy SSO solution (Okta, Azure AD, Ping Identity) with MFA to eliminate per-system passwords. (2) For systems that can't integrate with SSO, use enterprise password manager (1Password Enterprise, LastPass Enterprise) to generate and store unique passwords per system. (3) Implement privileged access management (PAM) for administrative accounts—users authenticate to PAM system, which provides time-limited credentials to target systems. (4) For federated environments, use SAML/OIDC with step-up authentication for sensitive systems. (5) Monitor for password reuse across systems using security analytics.",
    "non_technical_guidance": "To comply with IA-5(8) Multiple System Accounts:\n1. Inventory all systems and identify users with multi-system access.\n2. Implement identity federation/SSO where technically feasible—reduces to single strong password + MFA.\n3. For systems without SSO capability: Require password managers with unique passwords per system (no password reuse).\n4. Establish password uniqueness policy: Organizational passwords must not match personal passwords, must be unique per system.\n5. Deploy PAM solution for privileged users: Vault-based password rotation, session recording, just-in-time access.\n6. Conduct user training on password reuse risks: If one account is compromised, all accounts with same password are compromised.\n7. Monitor authentication logs for anomalous activity patterns suggesting compromised credentials (impossible travel, multiple simultaneous sessions).\n8. For high-risk users (executives, admins): Require hardware tokens, prohibit password-based authentication entirely.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T19:57:16.819298+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:47.194579+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.8 Multiple System Accounts requires unique authenticators for each system account. Prohibit password reuse across systems. Implement unique service account credentials. Use password managers for credential uniqueness."
  },
  {
    "control_id": "IA-5.9",
    "control_name": "Federated Credential Management",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Use the following external organizations to federate credentials: {{ insert: param, ia-05.09_odp }}.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Instead of maintaining separate user accounts in every system, establish trust relationships with external identity providers to allow single sign-on across organizational boundaries. Users authenticate once with their home organization and can access resources at partner organizations without separate accounts.",
    "example_implementation": "Implement SAML/OIDC federation: (1) Azure AD Federation for Microsoft 365 and SaaS apps, (2) Okta/Ping Federation for third-party services, (3) InCommon/eduGAIN for research collaborations, (4) LOGIN.GOV for citizen services. Configure trust relationships, attribute release policies, step-up authentication rules.",
    "non_technical_guidance": "To comply with IA-5(9) Federated Credential Management:\n1. Identify business need for federation (partner collaborations, SaaS applications, inter-agency access).\n2. Vet external organizations before establishing trust: Assess security controls, review federation agreements, verify compliance certifications.\n3. Define approved external organizations for federation: Document specific partners and identity providers authorized for trust relationships.\n4. Establish federation technical standards: SAML 2.0 or OpenID Connect protocols, minimum AAL2 authentication assurance, certificate validation requirements.\n5. Configure identity provider (IdP) settings: Define user populations eligible for federation, attribute release policies (what user data is shared), session timeout configurations.\n6. Configure service provider (SP) settings: Trust only approved IdPs, validate digital signatures on assertions, implement appropriate authorization based on federated attributes.\n7. Document federation relationships in system security plans: List partners, data flows, security dependencies.\n8. Monitor federation audit logs: Track authentication events, detect anomalous patterns, alert on trust violations.\n9. Establish procedures for revoking federation trust: Response protocols if partner security is compromised, emergency trust termination processes.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:01:19.731989+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:48.856139+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.9 Federated Credential Management requires managing credentials across federated identity systems. Implement federation protocols (SAML, OIDC). Establish trust relationships with identity providers. Maintain attribute mappings. Handle credential synchronization."
  },
  {
    "control_id": "IA-5.10",
    "control_name": "Dynamic Credential Binding",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Bind identities and authenticators dynamically using the following rules: {{ insert: param, ia-05.10_odp }}.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Dynamically adjust authentication requirements based on context rather than using static authentication methods. Require stronger authentication (biometrics, hardware tokens) for high-risk scenarios (unknown device, suspicious location, sensitive data access) while allowing simpler authentication for low-risk contexts (known device, trusted network, routine operations).",
    "example_implementation": "Deploy adaptive authentication: Azure AD Conditional Access evaluates risk (impossible travel, leaked credentials, anonymous IP) and dynamically requires step-up authentication. Configure policies: Known device + corporate network = password only; Unknown device = password + hardware token + biometric. Integrate UEBA for anomaly detection.",
    "non_technical_guidance": "To comply with IA-5(10) Dynamic Credential Binding:\n1. Define risk-based authentication rules: Specify contexts requiring enhanced authentication (accessing PII, financial transactions, privileged operations, connections from untrusted networks).\n2. Implement adaptive authentication platform: Deploy Azure AD Conditional Access, Okta Adaptive MFA, Ping Intelligent SSO, or ForgeRock Intelligent Access.\n3. Configure contextual policies: Baseline authentication (password), Elevated risk (password + OTP), High risk (password + hardware token + biometric), Critical systems (smart card required).\n4. Integrate contextual signals: Device trust status (corporate-managed vs BYOD), network location (on-premises, VPN, public internet), user risk score (normal vs anomalous behavior), data classification (public, internal, confidential, restricted).\n5. Communicate dynamic authentication to users: Educate that additional authentication factors may be required based on access context.\n6. Tune policies based on telemetry: Monitor false positive rates (legitimate users blocked), false negative rates (risky access permitted), adjust thresholds to balance security and usability.\n7. Establish override procedures: Define processes for legitimate high-risk scenarios (executive international travel, emergency access during incidents).\n8. Document binding rules in security policies: Clearly specify what contexts trigger what authentication requirements.\n9. Implement continuous authentication: For zero trust environments, periodically re-evaluate user context during sessions and force re-authentication when risk changes.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:01:19.731989+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:21.250570+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.10 Dynamic Credential Binding requires binding credentials to specific devices or sessions. Implement device binding using certificates or tokens. Prevent credential use from unauthorized devices. Detect and alert on binding violations."
  },
  {
    "control_id": "IA-5.11",
    "control_name": "Hardware Token-based Authentication",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Use physical hardware authentication devices that meet quality standards for cryptographic strength and tamper resistance. Hardware tokens provide stronger security than passwords or software tokens because private keys cannot be extracted through malware or phishing attacks.",
    "example_implementation": "Deploy FIPS 140-2 Level 2 validated hardware tokens: YubiKey 5 Series for PIV and FIDO2, Titan Security Keys for FIDO U2F, PIV/CAC smart cards for federal systems, RSA SecurID for legacy OTP. Configure privileged accounts to require hardware token authentication, implement secure token lifecycle management.",
    "non_technical_guidance": "To comply with IA-5(11) Hardware Token-based Authentication:\n1. Define token quality requirements: FIPS 140-2 Level 2 minimum for cryptographic validation, FIPS 201 for federal PIV credentials, FIDO Certified for WebAuthn tokens.\n2. Procure certified hardware tokens: YubiKeys, Titan Keys, Feitian tokens, PIV-compliant smart cards from approved vendors.\n3. Establish secure issuance procedures: In-person identity verification before token distribution, signed user acknowledgment of responsibility, inventory tracking in asset management system.\n4. Deploy supporting infrastructure: Smart card readers on workstations, FIDO2-compatible browsers and applications, certificate enrollment services for PKI tokens.\n5. Configure authentication policies: Mandatory hardware tokens for privileged administrative accounts, remote access (VPN, SSH), systems processing HIGH confidentiality data.\n6. Train users on hardware token usage: Physical insertion/removal procedures, PIN entry security, protection from physical theft, immediate reporting of lost/stolen tokens.\n7. Implement redundancy: Issue two tokens per user (primary and backup), define secure backup token storage, enable backup authentication methods for token unavailability.\n8. Define token lifecycle: Validity periods (certificates typically 1-3 years), renewal procedures before expiration, revocation processes for lost/stolen/compromised tokens.\n9. Monitor for token anomalies: Detect suspicious usage patterns (token used from geographically impossible locations simultaneously suggests cloning attack), investigate authentication failures.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:01:19.731989+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:22.777772+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.11 Hardware Token-based Authentication requires hardware tokens for high-security authentication. Deploy FIDO2/WebAuthn security keys, smart cards, or hardware OTP tokens. Implement token lifecycle management. Maintain hardware token inventory."
  },
  {
    "control_id": "IA-5.12",
    "control_name": "Biometric Authentication Performance",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "For biometric-based authentication, employ mechanisms that satisfy the following biometric quality requirements {{ insert: param, ia-05.12_odp }}.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Biometric authentication systems must meet minimum accuracy thresholds balancing security (low false acceptance—system rarely accepts impostors) and usability (low false rejection—system rarely rejects legitimate users). Organizations define acceptable error rates based on system security requirements.",
    "example_implementation": "Deploy biometrics with defined performance: Windows Hello FAR ≤1:100,000 (one false accept per 100,000 attempts). iOS Face ID FAR 1:1,000,000. High-security iris scanners FAR 1:1,000,000. Configure liveness detection. Combine biometric + PIN for sensitive operations. Store templates in secure hardware (TPM, Secure Enclave).",
    "non_technical_guidance": "To comply with IA-5(12) Biometric Authentication Performance:\n1. Define biometric quality requirements by system classification: LOW systems FAR 1:10,000, MODERATE FAR 1:100,000, HIGH FAR 1:1,000,000 or better.\n2. Procure biometric systems meeting requirements: Verify vendor FAR/FRR specifications, require FIPS 201 compliance for federal systems, confirm independent testing results.\n3. Configure matching thresholds: Balance security (stricter matching = lower FAR but higher FRR = more false rejections) vs usability based on operational requirements.\n4. Implement liveness detection: Require certified presentation attack detection preventing photos/videos/masks/spoofs from defeating authentication.\n5. Establish enrollment procedures: Ensure high-quality biometric capture (proper lighting for facial recognition, clean fingers for fingerprint), capture multiple samples, provide user guidance on correct positioning.\n6. Consider multimodal biometrics for critical systems: Combine two or more biometric modalities (fingerprint AND face) to dramatically reduce FAR while maintaining acceptable FRR.\n7. Implement template protection: Store biometric templates encrypted in hardware security modules, never in cleartext software databases, protect transmission with TLS.\n8. Address privacy and consent: Obtain user consent for biometric collection, implement data minimization (store templates not raw images), define retention periods, provide opt-out alternatives.\n9. Plan for biometric compromise response: Unlike passwords, biometrics cannot be changed—establish revocation procedures, maintain alternative authentication methods, consider multimodal fallback if one modality compromised.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:01:19.731989+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:24.348625+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.12 Biometric Authentication requires implementing biometric authentication mechanisms. Deploy fingerprint, facial recognition, or iris scanning. Implement liveness detection. Protect biometric templates. Provide fallback authentication."
  },
  {
    "control_id": "IA-5.13",
    "control_name": "Expiration of Cached Authenticators",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Prohibit the use of cached authenticators after [Assignment: organization-defined time period].",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Systems sometimes cache authentication credentials (like Kerberos tickets or cached password hashes) to allow offline login or reduce authentication server load. This control requires configuring maximum lifetime for cached credentials to limit the window of vulnerability if a device is lost, stolen, or compromised.",
    "example_implementation": "Configure cached authenticator expiration: (1) Windows Group Policy: Maximum cached logons = 4, (2) Linux SSSD: offline_credentials_expiration = 1 day, (3) Kerberos: maximum ticket lifetime 10 hours, (4) Mobile MDM: offline authentication limit 8 hours, (5) Web sessions: token expiration 2-12 hours, (6) VPN: re-authentication every 12 hours.",
    "non_technical_guidance": "To comply with IA-5(13) Expiration of Cached Authenticators:\n1. Define expiration periods based on risk: HIGH systems 4-8 hours, MODERATE 12-24 hours, LOW 2-7 days.\n2. Configure credential caching timeouts on all platforms (Windows cached logons, Linux offline credentials, Kerberos tickets, VPN sessions).\n3. Balance security vs usability—shorter expiration provides better security but requires more frequent re-authentication.\n4. Consider operational scenarios: Mobile workers may require longer offline periods (24 hours) vs office workers (8 hours).\n5. Configure grace period notifications to warn users before cache expiration.\n6. Implement different timeouts by privilege level: Privileged accounts 4 hours maximum, standard users 24 hours.\n7. Test offline functionality to ensure users can work during cache validity period.\n8. Monitor for cache exploitation patterns (offline credential usage on stolen devices).\n9. For zero trust architectures: Minimize or eliminate credential caching entirely through always-on connectivity requirements.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:01:19.731989+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:25.942632+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.13 Expiration of Cached Authenticators requires limiting cached credential lifetime. Configure Kerberos ticket lifetimes, session token expiration, and credential cache timeouts. Force re-authentication after inactivity or time limit."
  },
  {
    "control_id": "IA-5.14",
    "control_name": "Managing Content of PKI Trust Stores",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "For PKI-based authentication, employ an organization-wide methodology for managing the content of PKI trust stores installed across all platforms, including networks, operating systems, browsers, and applications.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations using certificates for authentication must centrally manage which Certificate Authorities (CAs) are trusted across all systems. Uncontrolled trust store management leads to security risks—users might trust fraudulent certificates, expired CAs, or compromise CAs. Centralized trust store management ensures only approved CAs are trusted organization-wide, reducing certificate-based attacks.",
    "example_implementation": "Implement centralized PKI trust store management: (1) Deploy enterprise root CA certificates via Group Policy (Windows) or configuration management (Linux/Ansible). (2) Remove unauthorized public CAs from trust stores (browsers ship with 100+ CAs—prune to organizational requirements). (3) Configure automatic CRL/OCSP checking to detect revoked certificates. (4) Deploy certificate transparency monitoring to detect mis-issued certificates for organizational domains. (5) Use managed browser configurations (Chrome Enterprise, Firefox ESR with policy.json) to enforce trust store baselines. (6) Implement certificate pinning for critical applications (mobile apps, internal web services). (7) Monitor for trust store modifications via endpoint detection (EDR/SIEM alerts on certificate store changes).",
    "non_technical_guidance": "To comply with IA-5(14) Managing Content of PKI Trust Stores:\n1. Establish authoritative list of approved Certificate Authorities: Federal PKI root, organizational root CA, approved public CAs (DigiCert, IdenTrust for Let's Encrypt, Entrust).\n2. Deploy approved CA certificates to all platforms: Windows trust store via GPO, Linux ca-certificates package, macOS Keychain, mobile device trust stores via MDM.\n3. Remove unauthorized CAs from default trust stores: Operating systems ship with 100+ public CAs—many unnecessary for organizational use—prune to reduce attack surface.\n4. Implement centralized management tools: Microsoft Certificate Services, certmonger, or MDM certificate deployment.\n5. Configure automatic certificate validation: Enable CRL checking, deploy OCSP responders, configure certificate revocation checking in applications.\n6. Monitor for rogue certificates: Deploy certificate transparency monitoring (Google CT logs) to detect unauthorized certificates issued for organizational domains.\n7. Establish trust store change control: No unauthorized addition of CA certificates (malware often installs rogue root CAs for man-in-the-middle attacks).\n8. Document trust store baseline in system security plans.\n9. Audit trust stores quarterly: Scan endpoints for unauthorized CA certificates, verify approved CAs are present, check for expired certificates in trust stores.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:01:19.731989+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:27.531261+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.14 Managing Content of PKI Trust Stores requires controlling trusted certificate authorities. Maintain approved CA list. Remove untrusted CAs. Audit trust store changes. Implement certificate pinning where appropriate."
  },
  {
    "control_id": "IA-5.15",
    "control_name": "GSA-approved Products and Services",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Use only General Services Administration-approved products and services for identity, credential, and access management.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Federal agencies must use identity and access management products that have been evaluated and approved by GSA. This control applies primarily to federal government organizations and ensures procurement of vetted, secure identity solutions from the GSA Schedule 70 or other approved acquisition vehicles. Private sector organizations can interpret this as requiring formally evaluated/certified products (Common Criteria, FIPS 140, FIDO Certified).",
    "example_implementation": "For federal agencies: Procure identity solutions from GSA-approved sources: (1) GSA Schedule 70 for commercial identity products (Okta, Ping Identity, Microsoft licensing). (2) USAccess for PIV card enrollment and lifecycle services. (3) LOGIN.GOV for public-facing authentication services. (4) MAX.GOV Federal PKI Bridge CA for certificate services. (5) FedRAMP-authorized cloud identity services (Azure AD Government, AWS GovCloud IAM). For private sector: Use certified products (6) FIPS 140-2/140-3 validated cryptographic modules for credential storage, (7) FIDO Certified authenticators for phishing-resistant authentication, (8) Common Criteria evaluated IAM platforms.",
    "non_technical_guidance": "To comply with IA-5(15) GSA-approved Products and Services:\n1. For federal agencies: Consult GSA Schedule 70 (IT Schedule) for approved identity and access management vendors and products.\n2. Verify products are on GSA contract vehicles before procurement: Check GSA eBuy, GSA Advantage for product listings.\n3. For PIV/CAC credentials: Use USAccess shared service or approved PIV Service Providers (SPPs).\n4. For citizen authentication: Leverage LOGIN.GOV rather than building custom authentication infrastructure.\n5. For cloud services: Ensure FedRAMP authorization at appropriate impact level (Low/Moderate/High).\n6. Private sector interpretation: Procure products with formal security certifications (FIPS 140 cryptographic validation, Common Criteria EAL4+, FIDO Certification, PCI compliance for payment systems).\n7. Document procurement decisions in security authorization packages.\n8. Avoid custom-developed authentication systems—leverage commercial or government shared services where possible.\n9. For exceptions: Document risk acceptance if operational requirements necessitate non-approved products, implement compensating controls.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:01:19.731989+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:29.131280+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.15 GSA-approved Products and Services requires using GSA-approved identity products. Reference GSA FIPS 201 Evaluation Program approved products list. Ensure PIV compliance for federal systems. Use approved identity services."
  },
  {
    "control_id": "IA-5.16",
    "control_name": "In-person or Trusted External Party Authenticator Issuance",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Require that the issuance of [Assignment: organization-defined types of and/or specific authenticators] be conducted [Assignment: organization-defined registration authority] with authorization by [Assignment: organization-defined personnel or roles].",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "High-assurance authenticators (PIV cards, code signing certificates, privileged account credentials) require formal issuance procedures with in-person identity verification, designated registration authority approval, and authorization by appropriate officials. This prevents unauthorized individuals from obtaining powerful authenticators through social engineering or falsified documentation.",
    "example_implementation": "Establish formal authenticator issuance procedures: (1) PIV/CAC cards: In-person identity proofing with two forms of government-issued ID (passport + driver license), biometric capture, background check verification, security officer authorization. (2) Code signing certificates: Documented business justification, manager approval, registration authority verification, certificate pinned to specific developer identity. (3) Privileged account credentials: Formal access request ticket, role-based authorization workflow, least privilege review, time-limited issuance with automatic expiration. (4) Hardware tokens for executives: In-person issuance by IT security, signed acknowledgment of responsibility, inventory tracking. (5) All issuance events logged in centralized identity management system with approver details.",
    "non_technical_guidance": "To comply with IA-5(16) In-person or Trusted External Party Authenticator Issuance:\n1. Define authenticator types requiring formal issuance: PIV/CAC cards, code signing certificates, privileged account credentials, hardware security tokens, biometric enrollment.\n2. Designate registration authorities (RAs): Typically HR for employee credentials, IT security for privileged access, designated security personnel for contractors.\n3. Establish identity proofing requirements based on authenticator risk: High-value authenticators require in-person verification with two government-issued IDs, biometric enrollment, background check validation.\n4. Define authorization roles: Privileged credentials require CISO or designee approval, standard credentials require manager approval, temporary credentials require sponsor authorization.\n5. Implement issuance procedures: Scheduled appointments for in-person proofing, video verification acceptable for remote workers with notarized documentation, all issuance logged with approver identity.\n6. Create registration authority training program: RAs must understand identity proofing techniques, fraud detection, proper documentation.\n7. For remote/distributed workforce: Use trusted third-party identity proofing services (NIST AAL3-compliant services, notary services, approved partners).\n8. Implement compensating controls when in-person issuance impractical: Video verification with document authentication, biometric liveness checks, trusted introducer model.\n9. Audit issuance processes quarterly: Review authorization decisions, verify identity proofing documentation retained, check for policy violations.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:01:19.731989+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:30.728556+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.16 In-Person or Trusted Third-Party Issuance requires secure authenticator issuance processes. Issue high-assurance credentials in person or through verified trusted parties. Document issuance chain of custody. Verify recipient identity before issuance."
  },
  {
    "control_id": "IA-5.17",
    "control_name": "Presentation Attack Detection for Biometric Authenticators",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Employ presentation attack detection mechanisms for biometric-based authentication.",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Biometric systems must include liveness detection to prevent spoofing attacks using photos, videos, masks, fake fingers, or other presentation attacks. Without liveness detection, an attacker could bypass facial recognition with a printed photo or fingerprint scanner with a gelatin fake finger. Presentation attack detection (PAD) verifies that the biometric sample comes from a live person present at authentication time.",
    "example_implementation": "Implement presentation attack detection for biometric systems: (1) Facial recognition: Deploy systems with certified liveness detection (Apple Face ID with infrared dot projector, Windows Hello with 3D cameras detecting depth). Require eye blink or random facial movement challenges. (2) Fingerprint: Use capacitive sensors detecting electrical properties of live skin (not optical sensors vulnerable to fake fingers). Require pulse detection or temperature sensing. (3) Iris recognition: Deploy systems with near-infrared illumination detecting live pupil response. (4) Voice biometrics: Implement challenge-response with random passphrases to prevent playback attacks. (5) Procure only PAD-certified biometric systems: FIPS 201 certified for federal PIV, iBeta Level 1/2 PAD certification for commercial systems.",
    "non_technical_guidance": "To comply with IA-5(17) Presentation Attack Detection for Biometric Authenticators:\n1. Procure biometric systems with certified presentation attack detection capabilities: FIPS 201 Appendix A certification for federal systems, iBeta PAD Level 1 or 2 certification for commercial systems.\n2. Configure liveness detection settings: Enable active challenges (eye blink, facial movement) not just passive liveness, require multiple biometric samples from different angles.\n3. Define PAD test requirements for vendor evaluation: Test against realistic attack vectors (printed photos, video playback, 3D masks, fake fingers), require demonstrated resistance to NIST-published attack techniques.\n4. Implement multimodal biometrics for high-security scenarios: Combine face + fingerprint to increase attack difficulty.\n5. Train users on proper biometric presentation: Correct positioning, adequate lighting, removal of accessories (glasses for some facial systems).\n6. Monitor for PAD failures: Excessive failed liveness checks may indicate attack attempts, trigger security alerts.\n7. Establish PAD testing cadence: Re-evaluate systems annually as new attack techniques emerge, update systems with latest PAD firmware.\n8. Plan for PAD false rejects: Legitimate users occasionally fail liveness checks—implement fallback authentication (PIN, backup biometric modality) without compromising security.\n9. Document PAD capabilities in security authorization packages: Specify PAD technique (active vs passive), certification level, tested attack resistance.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:01:19.731989+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:32.319382+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.17 Presentation Attack Detection for Biometrics requires preventing biometric spoofing. Implement liveness detection for facial and fingerprint recognition. Test against presentation attacks. Use multi-modal biometrics for higher assurance."
  },
  {
    "control_id": "IA-5.18",
    "control_name": "Password Managers",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "For password-based authentication:\n(a) Employ [Assignment: organization-defined automated password managers]; and\n(b) Protect the passwords in the password managers using [Assignment: organization-defined safeguards].",
    "parent_control": "IA-5",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must provide approved password manager tools to help users create, store, and manage strong unique passwords for each system. Password managers eliminate the need to remember dozens of complex passwords, reducing password reuse and weak password selection. The master password or encryption keys protecting the password manager must be strongly safeguarded to prevent compromise of all stored credentials.",
    "example_implementation": "Deploy enterprise password manager with strong safeguards: (1) Procure enterprise-grade solution: 1Password Business/Enterprise, Bitwarden Enterprise, Keeper Enterprise, LastPass Enterprise. (2) Configure master password requirements: Minimum 16 characters, passphrase recommended, complexity enforced, no reuse of previous master passwords. (3) Enable MFA for password vault access: Hardware token (YubiKey) or biometric required in addition to master password. (4) Implement zero-knowledge architecture: Ensure vendor cannot access password vault contents (end-to-end encryption with client-side key derivation). (5) Configure password generation policies: Minimum 16 characters, random generation, avoid patterns. (6) Enable emergency access procedures: Designated recovery contacts, time-delayed access, approval workflows. (7) Deploy browser extensions and mobile apps with secure auto-fill configured. (8) Monitor vault access: Log all password retrievals, alert on anomalous access patterns.",
    "non_technical_guidance": "To comply with IA-5(18) Password Managers:\n1. Procure approved enterprise password manager: Evaluate 1Password, Bitwarden, Keeper, LastPass for enterprise features (centralized administration, audit logging, MFA enforcement, emergency access, SCIM provisioning).\n2. Define master password/passphrase requirements: Minimum 16-20 characters, recommend passphrase method (correct horse battery staple), enforce unique master password not used elsewhere.\n3. Mandate MFA for password vault access: Require hardware token (YubiKey) or biometric authentication in addition to master password, prohibit SMS-based MFA.\n4. Implement vault encryption safeguards: Verify zero-knowledge architecture (vendor cannot decrypt vaults), client-side key derivation (PBKDF2 100,000+ iterations or Argon2), AES-256 encryption.\n5. Train users on password manager usage: Generate random passwords for all accounts, enable auto-fill for convenience, never bypass password manager for important accounts, use secure password sharing feature for team credentials.\n6. Configure password complexity policies in manager: Auto-generated passwords minimum 16 characters, configurable per-site (some sites have maximum length limits).\n7. Implement emergency access procedures: Designate trusted contacts with time-delayed vault access (24-48 hours), require approval workflow, log all emergency access events.\n8. Monitor password manager adoption and usage: Track license utilization, identify users not using password manager, conduct training for low adoption teams.\n9. Plan for master password compromise: Implement rapid password rotation procedures, require immediate change of all passwords in vault if master password suspected compromised.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T20:01:19.731989+00:00",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:10:33.975300+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "IA-5.18 Password Managers requires providing approved password manager capabilities. Deploy enterprise password managers. Enable secure password generation. Implement secure sharing for team credentials. Sync across authorized devices."
  },
  {
    "control_id": "IA-6",
    "control_name": "Authentication Feedback",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Obscure feedback of authentication information during the authentication process to protect the information from possible exploitation and use by unauthorized individuals.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "During login, the system must hide authentication information such as passwords to prevent unauthorized individuals from seeing or capturing credentials through shoulder surfing or other observation methods. This typically involves displaying asterisks or dots instead of actual password characters, or providing only generic error messages that do not reveal whether a username or password was incorrect.",
    "example_implementation": "Configure authentication systems to display asterisks (*) when users type passwords. Implement generic error messages such as 'Authentication failed' or 'Invalid username or password' that do not reveal which credential component was incorrect. For command-line interfaces, disable password echoing to the terminal. For web applications, use password input fields with type='password' attribute to mask entered characters. Train administrators to use secure credential prompting methods that automatically obscure feedback rather than accepting plain-text passwords as command-line arguments.",
    "non_technical_guidance": "Organizations implementing IA-6 Authentication Feedback should establish comprehensive policies and procedures to protect authentication information from observation and exploitation:\n\n1. **Policy Development**: Establish organizational policy requiring all authentication interfaces to obscure feedback during credential entry, prohibiting display of clear-text passwords or authenticators in any form accessible to observers.\n\n2. **Application Security Standards**: Require development teams to implement password masking in all authentication forms using native controls (password input fields, asterisk display) and prohibit logging or displaying authentication credentials in error messages, debug output, or system logs.\n\n3. **Generic Error Messaging**: Standardize authentication failure messages across all systems to provide only generic feedback ('Authentication failed' or 'Invalid credentials') without revealing whether username, password, or other authentication factors were incorrect, preventing enumeration attacks.\n\n4. **Command-Line Security**: Prohibit passing passwords as command-line arguments or environment variables where they may be visible in process lists or command history. Require interactive password prompting with automatic obscuring for all administrative tools and scripts.\n\n5. **Physical Security Integration**: Implement privacy screens on workstations in high-traffic areas to prevent shoulder surfing. Position authentication terminals away from public view where feasible. Train users to be aware of their surroundings during authentication.\n\n6. **User Training**: Conduct regular security awareness training emphasizing the importance of protecting authentication information, being aware of shoulder surfing risks, and reporting any systems that display passwords in clear text.\n\n7. **Secure Session Management**: Ensure authentication sessions time out appropriately and locked screens do not display authentication information. Configure systems to clear authentication prompts when switching users or locking workstations.\n\n8. **Regular Audits**: Conduct periodic reviews of authentication interfaces across all systems (web applications, desktop software, mobile apps, command-line tools) to verify compliance with feedback obscuring requirements. Test both success and failure scenarios to ensure no sensitive information leakage.\n\n9. **Documentation Requirements**: Maintain security documentation for each system describing how authentication feedback is obscured, what information is logged, and what error messages are presented to users during authentication failures.\n\n10. **Vendor Requirements**: Include authentication feedback obscuring requirements in procurement specifications for commercial off-the-shelf software. Verify third-party applications comply with organizational standards before deployment.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "IA-2",
      "IA-5",
      "AC-7",
      "IA-4"
    ],
    "supplemental_guidance": "Authentication feedback from systems does not provide information that would allow unauthorized individuals to compromise authentication mechanisms. For some types of systems, such as desktops or notebooks with relatively large monitors, the threat (often referred to as shoulder surfing) may be significant. For other types of systems, such as mobile devices with small displays, the threat may be less significant and is balanced against the increased likelihood of typographic input errors due to small keyboards. Therefore, the means for obscuring authentication feedback should be selected accordingly. Obscuring authentication feedback includes displaying asterisks when users type passwords into input devices or displaying feedback for a very limited time before obscuring it.\n\nKey implementation considerations:\n\n**Shoulder Surfing Prevention**: The primary threat addressed by IA-6 is shoulder surfing, where attackers observe authentication credentials being entered. Display size, viewing angles, and physical environment should inform the level of obscuring implemented.\n\n**User Experience Balance**: While security requires obscuring feedback, usability must be maintained. Consider implementing brief character visibility (brief display before obscuring) on mobile devices with small keyboards to reduce typing errors while maintaining security.\n\n**Error Message Security**: Authentication error messages must not reveal system information that aids attackers. Messages should not indicate whether usernames exist, whether passwords are incorrect, or provide details about password requirements beyond initial policy statement.\n\n**Multi-Factor Authentication Integration**: When implementing multi-factor authentication (IA-2.1, IA-2.2), ensure all authentication factors are appropriately obscured. One-time passwords, security questions, and biometric confirmations should follow similar obscuring principles.\n\n**Logging and Monitoring**: While authentication feedback must be obscured from users, ensure audit logs capture sufficient information for security monitoring (IA-2, AU-2) without logging actual authenticator values. Log authentication attempts, results, and timing without capturing passwords.\n\n**Technical Debt Considerations**: Legacy systems or commercial off-the-shelf products that cannot be easily modified to obscure feedback should be identified as security risks, prioritized for remediation or replacement, and potentially subjected to compensating controls such as enhanced physical security or restricted network access.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-6: Authentication Feedback - Linux Implementation\n# Purpose: Configure systems to obscure authentication feedback\n# Tested on: RHEL 8/9, Ubuntu 20.04/22.04, CentOS Stream 8/9\n\nset -e\n\necho \"[IA-6] Implementing Authentication Feedback Obscuring Controls\"\n\n# 1. Verify PAM configuration for password obscuring\necho \"[1/6] Verifying PAM password obscuring configuration...\"\n\nPAM_UNIX_AUTH=\"/etc/pam.d/system-auth\"\nPAM_PASSWORD=\"/etc/pam.d/password-auth\"\n\nif [ -f \"$PAM_UNIX_AUTH\" ]; then\n    # Ensure pam_unix.so is configured (standard behavior obscures passwords)\n    if ! grep -q \"pam_unix.so\" \"$PAM_UNIX_AUTH\"; then\n        echo \"WARNING: pam_unix.so not found in $PAM_UNIX_AUTH\"\n        echo \"auth required pam_unix.so\" >> \"$PAM_UNIX_AUTH\"\n    else\n        echo \"✓ PAM authentication obscuring configured\"\n    fi\nfi\n\n# 2. Configure login.defs for secure password handling\necho \"[2/6] Configuring login.defs for secure authentication...\"\n\nLOGIN_DEFS=\"/etc/login.defs\"\n\nif [ -f \"$LOGIN_DEFS\" ]; then\n    # Disable LASTLOG_ENAB if it shows last failed login details\n    if ! grep -q \"^LASTLOG_ENAB\" \"$LOGIN_DEFS\"; then\n        echo \"LASTLOG_ENAB no\" >> \"$LOGIN_DEFS\"\n        echo \"✓ LASTLOG_ENAB disabled to prevent authentication detail leakage\"\n    fi\nfi\n\n# 3. Configure SSH to obscure authentication feedback\necho \"[3/6] Configuring SSH authentication feedback obscuring...\"\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\nif [ -f \"$SSHD_CONFIG\" ]; then\n    # Ensure generic authentication error messages\n    # LogLevel VERBOSE provides detailed logs but does not expose to users\n    \n    # Backup original config\n    cp \"$SSHD_CONFIG\" \"${SSHD_CONFIG}.ia6.backup.$(date +%Y%m%d_%H%M%S)\"\n    \n    # Configure obscured authentication feedback\n    if ! grep -q \"^PasswordAuthentication\" \"$SSHD_CONFIG\"; then\n        echo \"PasswordAuthentication yes\" >> \"$SSHD_CONFIG\"\n    fi\n    \n    # Ensure ChallengeResponseAuthentication obscures feedback\n    if ! grep -q \"^KbdInteractiveAuthentication\" \"$SSHD_CONFIG\"; then\n        echo \"KbdInteractiveAuthentication no\" >> \"$SSHD_CONFIG\"\n    fi\n    \n    # Test SSH config syntax\n    if sshd -t 2>/dev/null; then\n        echo \"✓ SSH configuration valid\"\n        systemctl reload sshd 2>/dev/null || service ssh reload 2>/dev/null || true\n    else\n        echo \"ERROR: SSH configuration invalid, reverting\"\n        mv \"${SSHD_CONFIG}.ia6.backup.$(date +%Y%m%d)\"* \"$SSHD_CONFIG\"\n    fi\nfi\n\n# 4. Configure sudo to obscure password feedback\necho \"[4/6] Configuring sudo authentication feedback...\"\n\nSUDOERS_FILE=\"/etc/sudoers\"\n\n# Ensure sudo uses secure password prompting (obscures by default)\nif [ -f \"$SUDOERS_FILE\" ]; then\n    # Check for pwfeedback option (if present, it shows asterisks - we want to ensure it's off for maximum obscuring)\n    if grep -q \"pwfeedback\" \"$SUDOERS_FILE\"; then\n        echo \"WARNING: pwfeedback option found in sudoers (displays asterisks)\"\n        echo \"Consider removing for maximum obscuring or keep for usability\"\n    else\n        echo \"✓ Sudo password obscuring configured (no feedback)\"\n    fi\nfi\n\n# 5. Verify TTY password obscuring\necho \"[5/6] Verifying TTY password echo is disabled...\"\n\n# Create test script to verify password reading obscures input\ncat > /tmp/ia6_test_obscure.sh << 'EOF'\n#!/bin/bash\nread -s -p \"Test password entry (will be obscured): \" testpw\necho \"\"\nif [ -n \"$testpw\" ]; then\n    echo \"✓ Password input obscured successfully\"\nelse\n    echo \"✓ Password input test completed\"\nfi\nEOF\n\nchmod +x /tmp/ia6_test_obscure.sh\necho \"✓ TTY password obscuring verification script created at /tmp/ia6_test_obscure.sh\"\n\n# 6. Configure GRUB to obscure password (if GRUB password is used)\necho \"[6/6] Checking GRUB authentication configuration...\"\n\nGRUB_CFG=\"/boot/grub2/grub.cfg\"\nGRUB_CUSTOM=\"/etc/grub.d/40_custom\"\n\nif [ -f \"$GRUB_CUSTOM\" ]; then\n    if grep -q \"password_pbkdf2\" \"$GRUB_CUSTOM\" 2>/dev/null; then\n        echo \"✓ GRUB password is hashed (pbkdf2) - feedback obscured\"\n    elif grep -q \"password\" \"$GRUB_CUSTOM\" 2>/dev/null; then\n        echo \"WARNING: GRUB password may not be properly obscured\"\n        echo \"Use grub2-mkpasswd-pbkdf2 to create hashed password\"\n    else\n        echo \"✓ No GRUB password configured\"\n    fi\nfi\n\necho \"\"\necho \"========================================\"\necho \"IA-6 Authentication Feedback Implementation Complete\"\necho \"========================================\"\necho \"\"\necho \"Summary:\"\necho \"- PAM authentication obscuring: Configured\"\necho \"- SSH authentication feedback: Obscured\"\necho \"- Sudo password feedback: Obscured\"\necho \"- TTY password echo: Disabled\"\necho \"\"\necho \"Verification:\"\necho \"1. Test SSH login: ssh user@localhost\"\necho \"2. Test sudo: sudo -v\"\necho \"3. Run: /tmp/ia6_test_obscure.sh\"\necho \"\"\necho \"All authentication interfaces should obscure password entry.\"\necho \"Error messages should be generic and not reveal credential details.\"\necho \"\"",
        "ansible": "---\n# IA-6: Authentication Feedback - Ansible Playbook\n# Purpose: Configure systems to obscure authentication feedback\n# Tested on: RHEL 8/9, Ubuntu 20.04/22.04, CentOS Stream 8/9\n\n- name: IA-6 Authentication Feedback Implementation\n  hosts: all\n  become: yes\n  vars:\n    ia6_backup_suffix: \"ia6.backup.{{ ansible_date_time.epoch }}\"\n    ia6_sshd_config: \"/etc/ssh/sshd_config\"\n    ia6_login_defs: \"/etc/login.defs\"\n    ia6_pam_system_auth: \"/etc/pam.d/system-auth\"\n  \n  tasks:\n    - name: Display IA-6 implementation banner\n      debug:\n        msg: \"Implementing NIST 800-53 IA-6 Authentication Feedback Obscuring\"\n    \n    # Task 1: Verify PAM Configuration\n    - name: Verify PAM authentication obscuring configuration\n      block:\n        - name: Check if system-auth PAM configuration exists\n          stat:\n            path: \"{{ ia6_pam_system_auth }}\"\n          register: pam_system_auth_stat\n        \n        - name: Verify pam_unix.so is configured for authentication\n          lineinfile:\n            path: \"{{ ia6_pam_system_auth }}\"\n            regexp: '^auth.*pam_unix.so'\n            line: 'auth required pam_unix.so'\n            state: present\n          when: pam_system_auth_stat.stat.exists\n          register: pam_unix_config\n        \n        - name: Display PAM configuration status\n          debug:\n            msg: \"PAM authentication obscuring configured (pam_unix.so obscures passwords by default)\"\n          when: pam_unix_config is changed or pam_system_auth_stat.stat.exists\n    \n    # Task 2: Configure login.defs\n    - name: Configure login.defs for secure authentication\n      block:\n        - name: Backup login.defs\n          copy:\n            src: \"{{ ia6_login_defs }}\"\n            dest: \"{{ ia6_login_defs }}.{{ ia6_backup_suffix }}\"\n            remote_src: yes\n          when: ansible_os_family in ['RedHat', 'Debian']\n          ignore_errors: yes\n        \n        - name: Disable LASTLOG_ENAB to prevent authentication detail leakage\n          lineinfile:\n            path: \"{{ ia6_login_defs }}\"\n            regexp: '^LASTLOG_ENAB'\n            line: 'LASTLOG_ENAB no'\n            state: present\n            create: no\n          when: ansible_os_family in ['RedHat', 'Debian']\n          ignore_errors: yes\n    \n    # Task 3: Configure SSH for obscured authentication feedback\n    - name: Configure SSH authentication feedback obscuring\n      block:\n        - name: Backup SSH configuration\n          copy:\n            src: \"{{ ia6_sshd_config }}\"\n            dest: \"{{ ia6_sshd_config }}.{{ ia6_backup_suffix }}\"\n            remote_src: yes\n        \n        - name: Ensure password authentication is properly configured\n          lineinfile:\n            path: \"{{ ia6_sshd_config }}\"\n            regexp: '^#?PasswordAuthentication'\n            line: 'PasswordAuthentication yes'\n            state: present\n          notify: Reload SSH service\n        \n        - name: Disable keyboard-interactive authentication feedback\n          lineinfile:\n            path: \"{{ ia6_sshd_config }}\"\n            regexp: '^#?KbdInteractiveAuthentication'\n            line: 'KbdInteractiveAuthentication no'\n            state: present\n          notify: Reload SSH service\n        \n        - name: Test SSH configuration syntax\n          command: sshd -t\n          register: sshd_test\n          failed_when: false\n          changed_when: false\n        \n        - name: Display SSH configuration validation result\n          debug:\n            msg: \"SSH configuration valid - authentication feedback obscured\"\n          when: sshd_test.rc == 0\n        \n        - name: Restore SSH configuration on validation failure\n          copy:\n            src: \"{{ ia6_sshd_config }}.{{ ia6_backup_suffix }}\"\n            dest: \"{{ ia6_sshd_config }}\"\n            remote_src: yes\n          when: sshd_test.rc != 0\n    \n    # Task 4: Configure sudo password obscuring\n    - name: Configure sudo authentication feedback\n      block:\n        - name: Check for pwfeedback option in sudoers\n          command: grep -q 'pwfeedback' /etc/sudoers\n          register: sudo_pwfeedback_check\n          failed_when: false\n          changed_when: false\n        \n        - name: Display sudo feedback configuration status\n          debug:\n            msg: |\n              Sudo password obscuring configured.\n              Note: 'pwfeedback' option {{ 'FOUND' if sudo_pwfeedback_check.rc == 0 else 'NOT FOUND' }}.\n              {% if sudo_pwfeedback_check.rc == 0 %}\n              pwfeedback displays asterisks - consider removing for maximum obscuring.\n              {% else %}\n              Sudo provides no visible feedback (maximum obscuring).\n              {% endif %}\n    \n    # Task 5: Verify TTY password obscuring capability\n    - name: Create TTY password obscuring verification script\n      copy:\n        dest: /tmp/ia6_test_obscure.sh\n        mode: '0755'\n        content: |\n          #!/bin/bash\n          read -s -p \"Test password entry (will be obscured): \" testpw\n          echo \"\"\n          if [ -n \"$testpw\" ]; then\n              echo \"✓ Password input obscured successfully\"\n          else\n              echo \"✓ Password input test completed\"\n          fi\n    \n    # Task 6: Check GRUB password configuration\n    - name: Check GRUB authentication configuration\n      block:\n        - name: Check if GRUB custom configuration exists\n          stat:\n            path: /etc/grub.d/40_custom\n          register: grub_custom_stat\n        \n        - name: Check for GRUB password configuration\n          shell: grep 'password' /etc/grub.d/40_custom\n          register: grub_password_check\n          failed_when: false\n          changed_when: false\n          when: grub_custom_stat.stat.exists\n        \n        - name: Verify GRUB password is hashed\n          debug:\n            msg: |\n              {% if grub_password_check.stdout is defined and 'password_pbkdf2' in grub_password_check.stdout %}\n              ✓ GRUB password is hashed (pbkdf2) - feedback obscured\n              {% elif grub_password_check.stdout is defined and 'password' in grub_password_check.stdout %}\n              WARNING: GRUB password may not be properly obscured.\n              Use grub2-mkpasswd-pbkdf2 to create hashed password.\n              {% else %}\n              No GRUB password configured.\n              {% endif %}\n          when: grub_custom_stat.stat.exists\n    \n    # Final verification report\n    - name: Display IA-6 implementation summary\n      debug:\n        msg: |\n          ========================================\n          IA-6 Authentication Feedback Implementation Complete\n          ========================================\n          \n          Summary:\n          - PAM authentication obscuring: Configured\n          - SSH authentication feedback: Obscured\n          - Sudo password feedback: Obscured\n          - TTY password echo: Disabled (via read -s)\n          \n          Verification Steps:\n          1. Test SSH login: ssh user@{{ ansible_hostname }}\n          2. Test sudo: sudo -v\n          3. Run: /tmp/ia6_test_obscure.sh\n          \n          All authentication interfaces should obscure password entry.\n          Error messages should be generic and not reveal credential details.\n  \n  handlers:\n    - name: Reload SSH service\n      service:\n        name: \"{{ 'sshd' if ansible_os_family == 'RedHat' else 'ssh' }}\"\n        state: reloaded"
      },
      "windows": {
        "powershell": "# IA-6: Authentication Feedback - Windows PowerShell Implementation\n# Purpose: Configure Windows systems to obscure authentication feedback\n# Tested on: Windows Server 2019/2022, Windows 10/11\n# Requires: Administrator privileges\n\n#Requires -RunAsAdministrator\n\n$ErrorActionPreference = 'Stop'\n$ScriptName = 'IA-6-Authentication-Feedback'\n$LogFile = \"C:\\Windows\\Temp\\$ScriptName-$(Get-Date -Format 'yyyyMMdd-HHmmss').log\"\n\nfunction Write-Log {\n    param([string]$Message, [string]$Level = 'INFO')\n    $LogMessage = \"$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') [$Level] $Message\"\n    Write-Output $LogMessage\n    Add-Content -Path $LogFile -Value $LogMessage\n}\n\nWrite-Log \"Starting IA-6 Authentication Feedback Implementation\" \"INFO\"\nWrite-Log \"========================================\" \"INFO\"\n\n# 1. Configure Credential Guard (prevents credential theft)\nWrite-Log \"[1/6] Checking Credential Guard status...\" \"INFO\"\n\ntry {\n    $DeviceGuard = Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\\Microsoft\\Windows\\DeviceGuard -ErrorAction SilentlyContinue\n    \n    if ($DeviceGuard) {\n        $CredGuardRunning = $DeviceGuard.SecurityServicesRunning -contains 1\n        $CredGuardConfigured = $DeviceGuard.SecurityServicesConfigured -contains 1\n        \n        if ($CredGuardRunning) {\n            Write-Log \"✓ Credential Guard is running (protects authentication credentials)\" \"INFO\"\n        } elseif ($CredGuardConfigured) {\n            Write-Log \"⚠ Credential Guard is configured but not running - system restart required\" \"WARN\"\n        } else {\n            Write-Log \"⚠ Credential Guard is not configured\" \"WARN\"\n            Write-Log \"Attempting to enable Credential Guard via registry...\" \"INFO\"\n            \n            # Enable Credential Guard via registry\n            $RegPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\"\n            Set-ItemProperty -Path $RegPath -Name \"LsaCfgFlags\" -Value 1 -Type DWord -Force\n            Write-Log \"✓ Credential Guard enabled - restart required to activate\" \"INFO\"\n        }\n    } else {\n        Write-Log \"⚠ Device Guard information not available (may not be supported on this system)\" \"WARN\"\n    }\n} catch {\n    Write-Log \"ERROR checking Credential Guard: $($_.Exception.Message)\" \"ERROR\"\n}\n\n# 2. Configure password masking via Group Policy (local)\nWrite-Log \"[2/6] Configuring password display policies...\" \"INFO\"\n\ntry {\n    # Ensure passwords are not displayed in clear text\n    $SecPolPath = \"C:\\Windows\\Temp\\secpol_ia6.cfg\"\n    \n    # Export current security policy\n    secedit /export /cfg $SecPolPath /quiet\n    \n    # Check if ClearTextPassword is disabled (should be 0)\n    $SecPol = Get-Content $SecPolPath\n    if ($SecPol -match \"ClearTextPassword\\s*=\\s*1\") {\n        Write-Log \"⚠ Clear text password storage is enabled - disabling...\" \"WARN\"\n        $SecPol = $SecPol -replace \"ClearTextPassword\\s*=\\s*1\", \"ClearTextPassword = 0\"\n        Set-Content -Path $SecPolPath -Value $SecPol\n        secedit /configure /db secedit.sdb /cfg $SecPolPath /quiet\n        Write-Log \"✓ Clear text password storage disabled\" \"INFO\"\n    } else {\n        Write-Log \"✓ Clear text password storage is already disabled\" \"INFO\"\n    }\n    \n    Remove-Item $SecPolPath -Force -ErrorAction SilentlyContinue\n} catch {\n    Write-Log \"ERROR configuring password display policies: $($_.Exception.Message)\" \"ERROR\"\n}\n\n# 3. Configure Interactive Logon Message (prevents information disclosure)\nWrite-Log \"[3/6] Configuring interactive logon policies...\" \"INFO\"\n\ntry {\n    $RegPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n    \n    # Ensure last username is not displayed at logon\n    $DontDisplayLastUserName = Get-ItemProperty -Path $RegPath -Name \"DontDisplayLastUserName\" -ErrorAction SilentlyContinue\n    \n    if ($DontDisplayLastUserName.DontDisplayLastUserName -ne 1) {\n        Set-ItemProperty -Path $RegPath -Name \"DontDisplayLastUserName\" -Value 1 -Type DWord -Force\n        Write-Log \"✓ Configured system to not display last username at logon\" \"INFO\"\n    } else {\n        Write-Log \"✓ System already configured to not display last username\" \"INFO\"\n    }\n    \n    # Ensure Ctrl+Alt+Del is required (prevents credential harvesting)\n    $DisableCAD = Get-ItemProperty -Path $RegPath -Name \"DisableCAD\" -ErrorAction SilentlyContinue\n    \n    if ($DisableCAD.DisableCAD -ne 0) {\n        Set-ItemProperty -Path $RegPath -Name \"DisableCAD\" -Value 0 -Type DWord -Force\n        Write-Log \"✓ Configured system to require Ctrl+Alt+Del for logon\" \"INFO\"\n    } else {\n        Write-Log \"✓ System already requires Ctrl+Alt+Del for logon\" \"INFO\"\n    }\n} catch {\n    Write-Log \"ERROR configuring interactive logon policies: $($_.Exception.Message)\" \"ERROR\"\n}\n\n# 4. Configure RDP authentication feedback obscuring\nWrite-Log \"[4/6] Configuring RDP authentication policies...\" \"INFO\"\n\ntry {\n    $RegPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\"\n    \n    # Ensure RDP uses Network Level Authentication (obscures credential entry)\n    $UserAuthentication = Get-ItemProperty -Path $RegPath -Name \"UserAuthentication\" -ErrorAction SilentlyContinue\n    \n    if ($UserAuthentication.UserAuthentication -ne 1) {\n        Set-ItemProperty -Path $RegPath -Name \"UserAuthentication\" -Value 1 -Type DWord -Force\n        Write-Log \"✓ Configured RDP to use Network Level Authentication\" \"INFO\"\n    } else {\n        Write-Log \"✓ RDP already uses Network Level Authentication\" \"INFO\"\n    }\n    \n    # Ensure RDP encryption is set to high level\n    $MinEncryptionLevel = Get-ItemProperty -Path $RegPath -Name \"MinEncryptionLevel\" -ErrorAction SilentlyContinue\n    \n    if ($MinEncryptionLevel.MinEncryptionLevel -lt 3) {\n        Set-ItemProperty -Path $RegPath -Name \"MinEncryptionLevel\" -Value 3 -Type DWord -Force\n        Write-Log \"✓ Configured RDP to use high encryption level\" \"INFO\"\n    } else {\n        Write-Log \"✓ RDP already uses high encryption level\" \"INFO\"\n    }\n} catch {\n    Write-Log \"ERROR configuring RDP authentication policies: $($_.Exception.Message)\" \"ERROR\"\n}\n\n# 5. Configure password policy for account lockout (prevents brute force with feedback)\nWrite-Log \"[5/6] Verifying account lockout policies...\" \"INFO\"\n\ntry {\n    # Check account lockout threshold\n    $LockoutThreshold = net accounts | Select-String \"Lockout threshold\"\n    Write-Log \"Current account lockout threshold: $LockoutThreshold\" \"INFO\"\n    \n    # Check lockout duration\n    $LockoutDuration = net accounts | Select-String \"Lockout duration\"\n    Write-Log \"Current lockout duration: $LockoutDuration\" \"INFO\"\n    \n    Write-Log \"✓ Account lockout policies reviewed (configure via Group Policy if needed)\" \"INFO\"\n} catch {\n    Write-Log \"ERROR checking account lockout policies: $($_.Exception.Message)\" \"ERROR\"\n}\n\n# 6. Create verification report\nWrite-Log \"[6/6] Generating compliance verification report...\" \"INFO\"\n\n$ComplianceReport = @\"\n\n========================================\nIA-6 Authentication Feedback Compliance Report\n========================================\nGenerated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\nSystem: $env:COMPUTERNAME\nOS: $(Get-CimInstance Win32_OperatingSystem | Select-Object -ExpandProperty Caption)\n\nConfiguration Summary:\n----------------------\n\n\"@\n\n# Credential Guard Status\ntry {\n    $DeviceGuard = Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\\Microsoft\\Windows\\DeviceGuard -ErrorAction SilentlyContinue\n    $CredGuardStatus = if ($DeviceGuard.SecurityServicesRunning -contains 1) { \"RUNNING\" } elseif ($DeviceGuard.SecurityServicesConfigured -contains 1) { \"CONFIGURED (restart required)\" } else { \"NOT CONFIGURED\" }\n} catch {\n    $CredGuardStatus = \"UNAVAILABLE\"\n}\n$ComplianceReport += \"`n1. Credential Guard: $CredGuardStatus\"\n\n# Last Username Display\n$DontDisplayLastUserName = Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" -Name \"DontDisplayLastUserName\" -ErrorAction SilentlyContinue\n$LastUsernameStatus = if ($DontDisplayLastUserName.DontDisplayLastUserName -eq 1) { \"HIDDEN\" } else { \"DISPLAYED\" }\n$ComplianceReport += \"`n2. Last Username Display: $LastUsernameStatus\"\n\n# Ctrl+Alt+Del Requirement\n$DisableCAD = Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" -Name \"DisableCAD\" -ErrorAction SilentlyContinue\n$CADStatus = if ($DisableCAD.DisableCAD -eq 0) { \"REQUIRED\" } else { \"NOT REQUIRED\" }\n$ComplianceReport += \"`n3. Ctrl+Alt+Del Logon: $CADStatus\"\n\n# RDP Network Level Authentication\n$UserAuthentication = Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" -Name \"UserAuthentication\" -ErrorAction SilentlyContinue\n$NLAStatus = if ($UserAuthentication.UserAuthentication -eq 1) { \"ENABLED\" } else { \"DISABLED\" }\n$ComplianceReport += \"`n4. RDP Network Level Authentication: $NLAStatus\"\n\n# RDP Encryption Level\n$MinEncryptionLevel = Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" -Name \"MinEncryptionLevel\" -ErrorAction SilentlyContinue\n$EncryptionStatus = switch ($MinEncryptionLevel.MinEncryptionLevel) {\n    1 { \"LOW\" }\n    2 { \"CLIENT COMPATIBLE\" }\n    3 { \"HIGH\" }\n    4 { \"FIPS COMPLIANT\" }\n    default { \"UNKNOWN\" }\n}\n$ComplianceReport += \"`n5. RDP Encryption Level: $EncryptionStatus\"\n\n$ComplianceReport += @\"\n\n\nCompliance Status:\n------------------\n✓ Authentication feedback is obscured during credential entry\n✓ System does not display sensitive authentication information\n✓ Generic error messages configured (Windows default behavior)\n✓ Credential protection mechanisms enabled\n\nVerification Steps:\n-------------------\n1. Test Windows logon - password should be masked with dots\n2. Test RDP connection - credentials should not be visible\n3. Attempt invalid login - error message should be generic\n4. Check Event Viewer - authentication failures logged without exposing credentials\n\nRecommendations:\n----------------\n- Implement privacy screens on workstations in high-traffic areas\n- Configure account lockout policies via Group Policy\n- Enable Credential Guard on all domain-joined systems (if supported)\n- Conduct regular security awareness training on shoulder surfing prevention\n\nLog File: $LogFile\n========================================\n\"@\n\nWrite-Output $ComplianceReport\nAdd-Content -Path $LogFile -Value $ComplianceReport\n\nWrite-Log \"IA-6 Authentication Feedback implementation completed successfully\" \"INFO\"\nWrite-Log \"Review the compliance report above and verify all configurations\" \"INFO\"\n\n# Return compliance status\nreturn @{\n    Success = $true\n    LogFile = $LogFile\n    CredentialGuard = $CredGuardStatus\n    ComplianceReport = $ComplianceReport\n}"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T11:30:00.000000Z",
      "has_scripts": true,
      "validated_by": "LOVELESS",
      "validation_date": "2025-11-20"
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T11:30:00.000000Z",
      "source": "ComplianceAsCode + STIG",
      "cac_status": "implemented",
      "cac_planned": false,
      "implementation_guidance": "Technical implementation provided with comprehensive Bash, Ansible, and PowerShell scripts covering Linux (RHEL/Ubuntu/CentOS) and Windows (Server 2019/2022, Win10/11) authentication feedback obscuring requirements."
    },
    "stig_mappings": [
      {
        "stig_id": "V-204757",
        "severity": "medium",
        "title": "The application server must obscure feedback of authentication information during the authentication process to protect the information from possible exploitation/use by unauthorized individuals.",
        "check_text": "Review application server documentation and configuration to determine if authentication feedback is obscured during the authentication process. If authentication information is not obscured, this is a finding."
      },
      {
        "stig_id": "V-61843",
        "severity": "medium",
        "title": "Applications must obscure feedback of authentication information during the authentication process",
        "check_text": "Review the application to determine if feedback of authentication information is obscured during the authentication process. Displaying asterisks when a user types in a password is an example of obscuring feedback. If feedback is not obscured, this is a finding."
      }
    ],
    "technical_details": {
      "platforms": [
        "Linux (RHEL 8/9, Ubuntu 20.04/22.04, CentOS Stream 8/9)",
        "Windows (Server 2019/2022, Windows 10/11)"
      ],
      "implementation_methods": [
        "PAM configuration for password obscuring (Linux)",
        "SSH authentication feedback obscuring (Linux)",
        "Sudo password masking (Linux)",
        "TTY password echo disabling (Linux)",
        "GRUB password hashing verification (Linux)",
        "Credential Guard enablement (Windows)",
        "Interactive logon policies (Windows)",
        "RDP Network Level Authentication (Windows)",
        "Clear text password prevention (Windows)"
      ],
      "verification_methods": [
        "Manual testing of authentication interfaces",
        "Automated configuration validation scripts",
        "Security policy export and analysis",
        "Event log monitoring for authentication feedback",
        "Visual verification of password masking"
      ],
      "compliance_validation": {
        "automated": true,
        "manual_steps_required": true,
        "verification_scripts_included": true
      }
    },
    "ai_guidance": "IA-6 Authenticator Feedback requires obscuring authentication feedback to protect credentials. Mask password entry, limit login attempt feedback, implement account lockout delays. Prevent enumeration of valid accounts through error messages."
  },
  {
    "control_id": "IA-7",
    "control_name": "Cryptographic Module Authentication",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Implement mechanisms for authentication to a cryptographic module that meet the requirements of applicable laws, executive orders, directives, policies, regulations, standards, and guidelines for such authentication.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must ensure that cryptographic modules used for encryption, decryption, and key management require proper authentication before operators can use them. This authentication must meet Federal Information Processing Standards (FIPS) 140-2 or FIPS 140-3 validation requirements. The control verifies that only authorized personnel can assume specific roles within cryptographic modules and perform cryptographic operations appropriate to those roles.",
    "enhanced_guidance": "Cryptographic Module Authentication (IA-7) ensures that access to cryptographic modules is controlled through robust authentication mechanisms that comply with FIPS 140-2 (transitioning to FIPS 140-3). This control addresses the authentication requirements specified in FIPS 140-2 Section 4.3.3, which mandates that cryptographic modules authenticate operators and verify they are authorized to assume requested roles and perform services within those roles.\n\nFIPS 140-2/140-3 validation is critical for Federal systems and contractors. Organizations must:\n\n1. **Use FIPS-Validated Cryptographic Modules**: All cryptographic operations must use modules validated through the Cryptographic Module Validation Program (CMVP). Validated modules appear on the CMVP Active List and must be used for new and existing Federal systems. The CMVP has been accepting FIPS 140-3 validations since September 2020, with a 5-year validation period (2 years for interim validations).\n\n2. **Implement Role-Based Authentication**: FIPS 140-2 defines four security levels, with higher levels requiring stronger authentication. Operator authentication verifies the identity of individuals accessing cryptographic modules and enforces role-based access control (RBAC) for cryptographic operations. Roles may include Crypto Officer, User, and Maintenance roles, each with distinct authorization levels.\n\n3. **Platform-Specific Implementation**:\n   - **Windows**: Enable FIPS mode via Group Policy Object (GPO): Computer Configuration >> Windows Settings >> Security Settings >> Local Policies >> Security Options >> 'System cryptography: Use FIPS compliant algorithms for encryption, hashing, and signing' = Enabled. This activates bcryptprimitives.dll and CNG.sys FIPS-validated modules.\n   - **Linux (RHEL/Ubuntu)**: Configure SSH to use FIPS-approved ciphers (aes256-ctr, aes192-ctr, aes128-ctr), enable FIPS mode system-wide, and configure PAM to use SHA-512 hashing for authentication (pam_unix.so with sha512 option).\n\n4. **STIG Compliance**: This control maps to multiple Defense Information Systems Agency (DISA) Security Technical Implementation Guide (STIG) requirements:\n   - Windows Server 2019 STIG V-205842 (WN19-SO-000360)\n   - Windows Server 2022 STIG V-254480\n   - RHEL 7 STIG RHEL-07-040110 (SSH FIPS ciphers)\n   - RHEL 8 STIG RHEL-08-010160 (PAM SHA-512 hashing)\n\n5. **Threat Mitigation**: IA-7 addresses spoofing threats in the STRIDE threat model by preventing unauthorized individuals from impersonating authorized cryptographic module operators. Without proper authentication, adversaries could execute unauthorized cryptographic operations, compromise key material, or decrypt sensitive information.\n\n6. **Integration with Related Controls**: IA-7 works synergistically with AC-3 (Access Enforcement), IA-5 (Authenticator Management), SC-12 (Cryptographic Key Establishment and Management), and SC-13 (Cryptographic Protection). Organizations must ensure authentication mechanisms integrate with enterprise identity management systems while maintaining cryptographic module isolation.\n\n7. **Continuous Validation**: Organizations must track CMVP validation status, as modules transition between Active, Historical, and Revoked lists. Modules on the Historical list (older than 5 years) may continue use in existing systems but cannot be deployed in new systems. Monitor NIST CSRC for validation updates and algorithm transitions (e.g., Triple-DES deprecation in January 2024).\n\n8. **Automation and Assessment**: Use OpenSCAP, ComplianceAsCode, and platform-specific automation (PowerShell, Bash, Ansible) to continuously validate FIPS compliance. Automated assessments should verify: FIPS mode enablement, cryptographic algorithm configurations, module validation certificates, and authentication mechanism compliance.",
    "example_implementation": "Technical implementation scripts for Windows Server 2019/2022 (PowerShell), RHEL 8 (Bash), Ubuntu 22.04 (Bash), and multi-platform Ansible playbooks are provided. These scripts validate FIPS 140-2/140-3 compliance by checking: FIPS mode registry settings (Windows), system-wide FIPS enablement (/proc/sys/crypto/fips_enabled on Linux), SSH cryptographic algorithm configurations, PAM authentication module settings, and TLS/SSL cipher suite restrictions. All scripts generate standardized JSON compliance reports with exit codes: 0 = compliant, 1 = non-compliant, 2 = error. Scripts are read-only, idempotent, and safe for production environments.",
    "non_technical_guidance": "To implement cryptographic module authentication that meets Federal requirements, follow these steps:\n\n1. **Inventory Cryptographic Modules**: Identify all systems using encryption, including servers, workstations, network devices, and applications. Document which cryptographic modules (libraries, hardware security modules, smart cards) each system uses.\n\n2. **Verify FIPS Validation**: Check the NIST Cryptographic Module Validation Program (CMVP) website to confirm your cryptographic modules have current FIPS 140-2 or FIPS 140-3 validation certificates. Modules must appear on the Active Validation List.\n\n3. **Enable FIPS Mode**: Work with system administrators to enable FIPS-compliant operation mode on all Federal systems. For Windows, this requires a Group Policy change. For Linux, it requires enabling FIPS mode and updating configuration files for SSH, PAM, and SSL/TLS services.\n\n4. **Implement Authentication Requirements**: Ensure cryptographic modules require authentication before use. This may involve configuring password requirements, multi-factor authentication, or hardware token authentication for accessing cryptographic operations.\n\n5. **Define Operator Roles**: Establish role-based access control for cryptographic operations. Define who can act as Crypto Officers (managing keys and module configuration) versus standard Users (performing encryption/decryption operations).\n\n6. **Document Policies**: Create organizational policies specifying which cryptographic modules are approved, how operators authenticate, what roles exist, and audit requirements. Include procedures for monitoring CMVP validation status.\n\n7. **Train Personnel**: Educate system administrators, security staff, and authorized cryptographic operators on FIPS requirements, authentication procedures, and their specific role responsibilities.\n\n8. **Establish Continuous Monitoring**: Implement automated compliance checking (using provided scripts or commercial tools) to continuously verify FIPS mode remains enabled and cryptographic configurations comply with Federal standards.\n\n9. **Audit and Review**: Conduct quarterly reviews of cryptographic module inventories, validation certificates, and authentication logs. Update configurations when NIST publishes algorithm transitions or new validation requirements.\n\n10. **Incident Response**: Establish procedures for responding to cryptographic module authentication failures, such as unauthorized access attempts or validation certificate expirations.",
    "is_technical": true,
    "requires_automation": true,
    "enhancements": [],
    "related_controls": [
      "AC-3",
      "IA-5",
      "SA-4",
      "SC-12",
      "SC-13"
    ],
    "supplemental_guidance": "Authentication within cryptographic modules verifies that operators are authorized to assume requested roles and perform authorized services within those roles. This control applies to cryptographic modules used by Federal systems and contractors, requiring compliance with FIPS 140-2 Section 4.3.3 authentication requirements. Organizations must track CMVP validation status and ensure modules remain on the Active Validation List. Integration with enterprise identity management systems (e.g., Active Directory, LDAP, SAML) may be necessary while maintaining cryptographic module isolation. FIPS mode impacts system interoperability; legacy systems using non-FIPS algorithms cannot communicate with FIPS-enabled systems.",
    "stig_mappings": {
      "windows": [
        {
          "stig_id": "V-205842",
          "rule_id": "WN19-SO-000360",
          "version": "Windows Server 2019 STIG v2r5",
          "severity": "CAT II",
          "requirement": "Windows Server 2019 must be configured to use FIPS-compliant algorithms for encryption, hashing, and signing."
        },
        {
          "stig_id": "V-254480",
          "version": "Windows Server 2022 STIG v1r2",
          "severity": "CAT II",
          "requirement": "Windows Server 2022 must be configured to use FIPS-compliant algorithms for encryption, hashing, and signing."
        }
      ],
      "linux": [
        {
          "stig_id": "RHEL-07-040110",
          "version": "RHEL 7 STIG v3r15",
          "severity": "CAT II",
          "requirement": "The Red Hat Enterprise Linux operating system must implement cryptography to protect the integrity of Lightweight Directory Access Protocol (LDAP) authentication communications."
        },
        {
          "stig_id": "RHEL-08-010160",
          "version": "RHEL 8 STIG v1r6",
          "severity": "CAT II",
          "requirement": "RHEL 8 pam_unix.so module must be configured in the password-auth file to use a FIPS 140-2 approved cryptographic hashing algorithm for system authentication."
        }
      ]
    },
    "references": {
      "nist": [
        "FIPS 140-2: Security Requirements for Cryptographic Modules",
        "FIPS 140-3: Security Requirements for Cryptographic Modules",
        "SP 800-56A: Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete Logarithm Cryptography",
        "SP 800-56B: Recommendation for Pair-Wise Key Establishment Using Integer Factorization Cryptography",
        "SP 800-56C: Recommendation for Key-Derivation Methods in Key-Establishment Schemes"
      ],
      "csf": [
        "NIST CSF v1.1: PR.AC-1",
        "NIST CSF v2.0: PR.AA-01, PR.AA-03"
      ]
    },
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T12:00:00Z",
      "has_scripts": true,
      "enhanced_by": "loveless-IA-7",
      "validation_status": "qa_approved",
      "compliance_frameworks": [
        "NIST SP 800-53 Rev 5",
        "DISA STIG",
        "FIPS 140-2",
        "FIPS 140-3",
        "FedRAMP"
      ]
    },
    "ai_guidance": "IA-7 Cryptographic Module Authentication requires authenticating cryptographic modules. Implement FIPS 140 validated modules. Authenticate modules before cryptographic operations. Protect module authentication credentials."
  },
  {
    "control_id": "IA-8",
    "control_name": "Identification and Authentication (Non-organizational Users)",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Uniquely identify and authenticate non-organizational users or processes acting on behalf of non-organizational users.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must ensure that anyone who is not part of the organization, such as contractors, vendors, partners, or external service providers, has a unique identity and authentication mechanism before accessing organizational systems. This prevents unauthorized access and ensures accountability for non-organizational user actions.",
    "example_implementation": "Implement a federated identity management system that requires external contractors to authenticate using their company-issued credentials through SAML 2.0 or OAuth 2.0. For vendor access, configure VPN gateway to require multi-factor authentication (MFA) using a one-time password (OTP) in addition to username and password. Maintain an access control list (ACL) that maps external user identities to specific system resources and permission levels.",
    "non_technical_guidance": "To ensure compliance with IA-8, organizations should establish a comprehensive non-organizational user management program that includes: (1) A formal process for requesting, approving, and provisioning access for external users with documented business justification; (2) Unique account creation for each non-organizational user that prevents credential sharing; (3) Multi-factor authentication requirements for all external access, such as hardware tokens or mobile authenticator apps; (4) Regular quarterly review of non-organizational user accounts to verify continued need and appropriate access levels; (5) Immediate account deactivation upon termination of contractor relationships or completion of vendor engagements; (6) Audit logging of all non-organizational user authentication attempts and access activities; (7) Training for external users on acceptable use policies and security requirements; (8) Integration with organizational identity management systems where feasible to maintain centralized control and visibility.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "IA-8(1)",
        "title": "Acceptance of PIV Credentials from Other Agencies",
        "official_text": "Accept and electronically verify Personal Identity Verification-compliant credentials from other federal agencies."
      },
      {
        "id": "IA-8(2)",
        "title": "Acceptance of External Authenticators",
        "official_text": "Accept only external authenticators that are NIST-compliant; and Document and maintain a list of accepted external authenticators."
      },
      {
        "id": "IA-8(4)",
        "title": "Use of Defined Profiles",
        "official_text": "Conform to the following profiles for identity management [Assignment: organization-defined identity management profiles]."
      },
      {
        "id": "IA-8(5)",
        "title": "Acceptance of PIV-I Credentials",
        "official_text": "Accept and verify federated or PKI credentials that meet [Assignment: organization-defined policy]."
      },
      {
        "id": "IA-8(6)",
        "title": "Disassociability",
        "official_text": "Implement the following measures to disassociate user attributes or identifier assertion relationships among individuals, credential service providers, and relying parties: [Assignment: organization-defined measures]."
      }
    ],
    "related_controls": [
      "AC-2",
      "AC-14",
      "AC-17",
      "AC-18",
      "AC-19",
      "AC-20",
      "IA-2",
      "IA-4",
      "IA-5",
      "IA-9",
      "IA-10",
      "IA-11",
      "MA-4",
      "PE-2",
      "RA-3",
      "SA-4",
      "SC-8"
    ],
    "supplemental_guidance": "Non-organizational users include system users other than organizational users explicitly covered by IA-2. These individuals are uniquely identified and authenticated for accesses other than those explicitly identified and documented in AC-14. Identification and authentication of non-organizational users accessing federal systems may be required to protect federal, proprietary, or privacy-related information (with exceptions noted for national security systems). Organizations consider many factors, including security, privacy, scalability, and practicality, when balancing the need to ensure ease of use for access to federal information and systems with the need to protect and adequately mitigate risk.",
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:35:20.521979+00:00",
      "has_scripts": false,
      "enhanced_by": "loveless_qa"
    },
    "cac_metadata": {
      "implementation_type": "policy_driven",
      "last_analyzed": "2025-11-20T19:35:20.521989+00:00",
      "source": "NIST SP 800-53 Rev 5",
      "cac_status": "not_applicable",
      "cac_planned": false,
      "implementation_guidance": "IA-8 is primarily a policy and procedural control that requires organizational processes for managing non-organizational user identification and authentication. Automated technical implementation is not available in ComplianceAsCode as this control is enforced through identity management systems, federated authentication platforms, and access control policies rather than system-level configuration."
    },
    "ai_guidance": "IA-8 Identification and Authentication (Non-Organizational Users) requires identifying and authenticating non-organizational users. Implement guest access procedures. Verify external user identity. Apply appropriate authentication strength. Maintain non-org user audit trails."
  },
  {
    "control_id": "IA-9",
    "control_name": "Service Identification and Authentication",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Uniquely identify and authenticate [Assignment: organization-defined system services and applications] before establishing communications with devices, users, or other services or applications.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Before any system service or application can communicate with devices, users, or other services, it must prove its identity using authentication mechanisms. This control ensures that services running on your systems are legitimate and authorized, preventing malicious services from impersonating legitimate ones. Think of it like requiring a digital ID badge for every software service that wants to interact with your system - the service must present valid credentials before being allowed to establish connections.",
    "example_implementation": "Implement mutual TLS (mTLS) authentication for all microservices in your service-oriented architecture, requiring each service to present a valid X.509 certificate before establishing communication. Deploy a service mesh like Istio or Linkerd that automatically handles service-to-service authentication using certificate-based identity. Configure API gateways to validate OAuth 2.0 tokens or JWT (JSON Web Tokens) for web services, ensuring that only authenticated applications can access backend services. Use code signing certificates for deployed applications and validate signatures at runtime before allowing service initialization.",
    "non_technical_guidance": "To comply with Control IA-9 (Service Identification and Authentication), organizations should implement the following non-technical steps:\n\n1. **Inventory Services**: Create a comprehensive inventory of all system services and applications that require identification and authentication, including web services, APIs, database services, microservices, and third-party integrations.\n\n2. **Define Authentication Requirements**: Document the authentication mechanisms required for each service category, specifying acceptable methods such as digital certificates, API keys, OAuth tokens, or mutual authentication protocols.\n\n3. **Establish Service Identity Management**: Develop policies and procedures for issuing, managing, and revoking service credentials throughout their lifecycle, including initial provisioning, periodic renewal, and emergency revocation.\n\n4. **Implement Service Registry**: Maintain a central registry of authorized services with their authentication credentials and permitted communication paths, ensuring only approved services can establish connections.\n\n5. **Configure Access Control**: Define which services are authorized to communicate with specific resources, implementing least-privilege principles to limit service-to-service interactions to only what is necessary.\n\n6. **Monitor Service Authentication**: Establish logging and monitoring procedures to track service authentication attempts, identifying unusual patterns that might indicate unauthorized services or credential compromise.\n\n7. **Regular Credential Rotation**: Implement a schedule for rotating service credentials and certificates, reducing the risk of compromised credentials being used for extended periods.\n\n8. **Incident Response Planning**: Develop procedures for responding to suspected service impersonation or credential theft, including steps for rapid credential revocation and service isolation.\n\n9. **Third-Party Service Vetting**: Establish a process for evaluating and approving third-party services and applications before allowing them to communicate with organizational systems.\n\n10. **Staff Training**: Provide training to development and operations teams on secure service authentication practices, credential management, and the importance of validating service identity.\n\n11. **Periodic Review**: Conduct regular audits of service authentication configurations and credential usage to ensure compliance with policies and identify potential security gaps.\n\n12. **Documentation**: Maintain comprehensive documentation of all service authentication mechanisms, credential locations, and communication pathways for audit and troubleshooting purposes.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "IA-3",
      "IA-4",
      "IA-5",
      "IA-13",
      "SC-8"
    ],
    "supplemental_guidance": "Service identification and authentication is critical in modern distributed architectures where services dynamically interact across networks and organizational boundaries. Organizations must be able to verify the authenticity of services before establishing communications to prevent service spoofing, man-in-the-middle attacks, and unauthorized access through rogue services.\n\nThe control applies to various service types including web applications, APIs, microservices, database services, messaging services, and third-party cloud services. Authentication mechanisms should be appropriate to the service architecture and security requirements, ranging from simple API key validation to sophisticated mutual authentication protocols.\n\nIn service-oriented and microservices architectures, external services often appear dynamically, making it essential for systems to determine service authenticity in real-time. Organizations should implement automated authentication mechanisms that can scale with dynamic service deployments while maintaining security.\n\nAuthentication safeguards include information or code signing, digital certificates, cryptographic tokens, provenance graphs, and electronic signatures that indicate or verify the sources of services. For web services, common approaches include OAuth 2.0, OpenID Connect, SAML assertions, and mutual TLS authentication.\n\nIn distributed architectures, identification and authentication decisions may be made by centralized services (such as identity providers, authorization servers, or service meshes) that provide authentication decisions to services that need to act on them. This approach reduces the complexity of implementing authentication in each service while maintaining centralized control and consistent policy enforcement.\n\nOrganizations should consider the sensitivity of data and operations when determining which services require authentication and the strength of authentication mechanisms. High-value services or those handling sensitive data should employ stronger authentication methods such as mutual authentication with certificate validation.\n\nRelated controls include IA-3 (Device Identification and Authentication) for authenticating devices, IA-4 (Identifier Management) for managing service identifiers, IA-5 (Authenticator Management) for managing service credentials, IA-13 (Identity Providers and Authorization Servers) for centralized authentication services, and SC-8 (Transmission Confidentiality and Integrity) for protecting authentication data in transit.",
    "implementation_scripts": {
      "linux": {
        "bash": {
          "description": "Configure mutual TLS authentication for systemd services and validate service certificates",
          "script": "#!/bin/bash\n# IA-9: Service Identification and Authentication - Linux Implementation\n# This script configures service authentication mechanisms for Linux systems\n\nset -euo pipefail\n\n# Configuration variables\nCERT_DIR=\"/etc/pki/tls/service-certs\"\nCA_CERT=\"/etc/pki/ca-trust/source/anchors/org-ca.crt\"\nSERVICE_LOG=\"/var/log/service-auth.log\"\n\necho \"[$(date)] Starting IA-9 service authentication configuration\" | tee -a \"$SERVICE_LOG\"\n\n# 1. Create certificate directory structure\nmkdir -p \"$CERT_DIR\"/{private,certs,requests}\nchmod 755 \"$CERT_DIR\"\nchmod 700 \"$CERT_DIR/private\"\n\n# 2. Configure TLS for Apache web services (if installed)\nif command -v httpd &> /dev/null || command -v apache2 &> /dev/null; then\n    echo \"[$(date)] Configuring Apache service authentication\" | tee -a \"$SERVICE_LOG\"\n    \n    # Enable SSL module\n    if [ -f /etc/httpd/conf.modules.d/00-ssl.conf ]; then\n        sed -i 's/^#LoadModule ssl_module/LoadModule ssl_module/' /etc/httpd/conf.modules.d/00-ssl.conf\n    fi\n    \n    # Configure SSL verification for backend services\n    cat > /etc/httpd/conf.d/service-auth.conf <<'EOF'\n# IA-9: Service Authentication Configuration\n<IfModule mod_ssl.c>\n    # Require valid certificates for service connections\n    SSLVerifyClient require\n    SSLVerifyDepth 3\n    SSLCACertificateFile /etc/pki/ca-trust/source/anchors/org-ca.crt\n    \n    # Log authentication attempts\n    LogLevel ssl:info\n    CustomLog /var/log/httpd/service-auth.log \"%t %h %{SSL_PROTOCOL}x %{SSL_CIPHER}x \\\"%r\\\" %b %{SSL_CLIENT_S_DN}x\"\nEOF\n    echo \"[$(date)] Apache service authentication configured\" | tee -a \"$SERVICE_LOG\"\nfi\n\n# 3. Configure mutual TLS for nginx (if installed)\nif command -v nginx &> /dev/null; then\n    echo \"[$(date)] Configuring Nginx service authentication\" | tee -a \"$SERVICE_LOG\"\n    \n    cat > /etc/nginx/conf.d/service-auth.conf <<'EOF'\n# IA-9: Service Authentication for Nginx\nserver {\n    listen 443 ssl;\n    \n    # Server certificate\n    ssl_certificate /etc/pki/tls/service-certs/certs/server.crt;\n    ssl_certificate_key /etc/pki/tls/service-certs/private/server.key;\n    \n    # Client certificate verification\n    ssl_client_certificate /etc/pki/ca-trust/source/anchors/org-ca.crt;\n    ssl_verify_client on;\n    ssl_verify_depth 3;\n    \n    # TLS configuration\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    ssl_prefer_server_ciphers on;\n    \n    # Log client DN for authentication tracking\n    access_log /var/log/nginx/service-auth.log combined;\n    \n    location / {\n        # Validate client certificate subject\n        if ($ssl_client_s_dn = \"\") {\n            return 403;\n        }\n        proxy_pass http://backend;\n        proxy_set_header X-Client-DN $ssl_client_s_dn;\n    }\n}\nEOF\n    echo \"[$(date)] Nginx service authentication configured\" | tee -a \"$SERVICE_LOG\"\nfi\n\n# 4. Configure PostgreSQL service authentication (if installed)\nif command -v psql &> /dev/null; then\n    echo \"[$(date)] Configuring PostgreSQL service authentication\" | tee -a \"$SERVICE_LOG\"\n    \n    PG_HBA=\"/var/lib/pgsql/data/pg_hba.conf\"\n    if [ -f \"$PG_HBA\" ]; then\n        # Require certificate authentication for service connections\n        cat >> \"$PG_HBA\" <<'EOF'\n\n# IA-9: Service Authentication\n# Require SSL certificate authentication for service accounts\nhostssl all service_user 0.0.0.0/0 cert clientcert=verify-full\nhostssl all +service_role 0.0.0.0/0 cert clientcert=verify-full\nEOF\n        \n        # Configure postgresql.conf for SSL\n        PG_CONF=\"/var/lib/pgsql/data/postgresql.conf\"\n        if [ -f \"$PG_CONF\" ]; then\n            sed -i \"s/^#ssl = off/ssl = on/\" \"$PG_CONF\"\n            sed -i \"s|^#ssl_cert_file = .*|ssl_cert_file = '/etc/pki/tls/service-certs/certs/postgres.crt'|\" \"$PG_CONF\"\n            sed -i \"s|^#ssl_key_file = .*|ssl_key_file = '/etc/pki/tls/service-certs/private/postgres.key'|\" \"$PG_CONF\"\n            sed -i \"s|^#ssl_ca_file = .*|ssl_ca_file = '/etc/pki/ca-trust/source/anchors/org-ca.crt'|\" \"$PG_CONF\"\n        fi\n        echo \"[$(date)] PostgreSQL service authentication configured\" | tee -a \"$SERVICE_LOG\"\n    fi\nfi\n\n# 5. Configure systemd service authentication monitoring\ncat > /etc/systemd/system/service-auth-monitor.service <<'EOF'\n[Unit]\nDescription=IA-9 Service Authentication Monitor\nAfter=network.target\n\n[Service]\nType=simple\nExecStart=/usr/local/bin/service-auth-monitor.sh\nRestart=on-failure\nRestartSec=5s\nStandardOutput=journal\nStandardError=journal\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n# 6. Create service authentication monitoring script\ncat > /usr/local/bin/service-auth-monitor.sh <<'EOF'\n#!/bin/bash\n# Monitor service authentication events\nLOG_FILE=\"/var/log/service-auth.log\"\n\nwhile true; do\n    # Monitor for failed service authentication attempts\n    journalctl -u \"*.service\" --since \"1 minute ago\" | grep -i \"authentication failure\\|certificate.*fail\\|ssl.*error\" >> \"$LOG_FILE\"\n    \n    # Check for services running without proper authentication\n    netstat -tulpn | grep LISTEN | while read line; do\n        port=$(echo \"$line\" | awk '{print $4}' | cut -d: -f2)\n        service=$(echo \"$line\" | awk '{print $7}')\n        if [ ! -z \"$service\" ]; then\n            echo \"[$(date)] Service $service listening on port $port\" >> \"$LOG_FILE\"\n        fi\n    done\n    \n    sleep 60\ndone\nEOF\n\nchmod +x /usr/local/bin/service-auth-monitor.sh\n\n# 7. Enable and start monitoring service\nsystemctl daemon-reload\nsystemctl enable service-auth-monitor.service\nsystemctl start service-auth-monitor.service\n\n# 8. Configure auditd rules for service authentication\nif command -v auditctl &> /dev/null; then\n    cat >> /etc/audit/rules.d/service-auth.rules <<'EOF'\n# IA-9: Service Authentication Audit Rules\n-w /etc/pki/tls/service-certs/ -p wa -k service_certs\n-w /etc/ssl/certs/ -p wa -k service_certs\n-a always,exit -F arch=b64 -S connect -F success=0 -k service_connection_failed\n-a always,exit -F arch=b32 -S connect -F success=0 -k service_connection_failed\nEOF\n    \n    augenrules --load\n    echo \"[$(date)] Audit rules for service authentication configured\" | tee -a \"$SERVICE_LOG\"\nfi\n\n# 9. Create certificate validation script\ncat > /usr/local/bin/validate-service-certs.sh <<'EOF'\n#!/bin/bash\n# Validate service certificates\n\nCERT_DIR=\"/etc/pki/tls/service-certs/certs\"\nCA_CERT=\"/etc/pki/ca-trust/source/anchors/org-ca.crt\"\nEXPIRY_WARNING_DAYS=30\n\nfor cert in \"$CERT_DIR\"/*.crt; do\n    if [ -f \"$cert\" ]; then\n        # Check certificate validity\n        if openssl verify -CAfile \"$CA_CERT\" \"$cert\" > /dev/null 2>&1; then\n            # Check expiry\n            expiry_date=$(openssl x509 -in \"$cert\" -noout -enddate | cut -d= -f2)\n            expiry_epoch=$(date -d \"$expiry_date\" +%s)\n            current_epoch=$(date +%s)\n            days_until_expiry=$(( ($expiry_epoch - $current_epoch) / 86400 ))\n            \n            if [ $days_until_expiry -lt $EXPIRY_WARNING_DAYS ]; then\n                echo \"WARNING: Certificate $cert expires in $days_until_expiry days\"\n                logger -t service-auth -p warning \"Certificate $cert expires in $days_until_expiry days\"\n            fi\n        else\n            echo \"ERROR: Certificate $cert failed validation\"\n            logger -t service-auth -p error \"Certificate $cert failed validation\"\n        fi\n    fi\ndone\nEOF\n\nchmod +x /usr/local/bin/validate-service-certs.sh\n\n# 10. Schedule periodic certificate validation\ncat > /etc/cron.daily/validate-service-certs <<'EOF'\n#!/bin/bash\n/usr/local/bin/validate-service-certs.sh\nEOF\nchmod +x /etc/cron.daily/validate-service-certs\n\necho \"[$(date)] IA-9 service authentication configuration completed successfully\" | tee -a \"$SERVICE_LOG\"\necho \"Certificate directory: $CERT_DIR\"\necho \"Service authentication log: $SERVICE_LOG\"\necho \"Next steps:\"\necho \"  1. Generate or import service certificates to $CERT_DIR\"\necho \"  2. Configure service-specific authentication in application configs\"\necho \"  3. Review logs at $SERVICE_LOG for authentication events\"\necho \"  4. Run /usr/local/bin/validate-service-certs.sh to verify certificate validity\"\n"
        },
        "ansible": {
          "description": "Ansible playbook to enforce service authentication across Linux infrastructure",
          "script": "---\n# IA-9: Service Identification and Authentication - Ansible Playbook\n# Configures service authentication mechanisms across Linux systems\n\n- name: IA-9 Service Identification and Authentication Configuration\n  hosts: all\n  become: true\n  vars:\n    cert_base_dir: \"/etc/pki/tls/service-certs\"\n    ca_cert_path: \"/etc/pki/ca-trust/source/anchors/org-ca.crt\"\n    service_log_file: \"/var/log/service-auth.log\"\n    cert_expiry_warning_days: 30\n\n  tasks:\n    - name: Create certificate directory structure\n      file:\n        path: \"{{ item }}\"\n        state: directory\n        mode: '0755'\n      loop:\n        - \"{{ cert_base_dir }}\"\n        - \"{{ cert_base_dir }}/certs\"\n        - \"{{ cert_base_dir }}/requests\"\n\n    - name: Create private key directory with restricted permissions\n      file:\n        path: \"{{ cert_base_dir }}/private\"\n        state: directory\n        mode: '0700'\n\n    - name: Configure Apache SSL service authentication\n      block:\n        - name: Check if Apache is installed\n          command: which httpd\n          register: apache_installed\n          changed_when: false\n          failed_when: false\n\n        - name: Enable Apache SSL module\n          lineinfile:\n            path: /etc/httpd/conf.modules.d/00-ssl.conf\n            regexp: '^#LoadModule ssl_module'\n            line: 'LoadModule ssl_module modules/mod_ssl.so'\n            state: present\n          when: apache_installed.rc == 0\n          notify: restart apache\n\n        - name: Deploy Apache service authentication configuration\n          copy:\n            dest: /etc/httpd/conf.d/service-auth.conf\n            content: |\n              # IA-9: Service Authentication Configuration\n              <IfModule mod_ssl.c>\n                  SSLVerifyClient require\n                  SSLVerifyDepth 3\n                  SSLCACertificateFile {{ ca_cert_path }}\n                  LogLevel ssl:info\n                  CustomLog /var/log/httpd/service-auth.log \"%t %h %{SSL_PROTOCOL}x %{SSL_CIPHER}x \\\"%r\\\" %b %{SSL_CLIENT_S_DN}x\"\n              </IfModule>\n            mode: '0644'\n          when: apache_installed.rc == 0\n          notify: restart apache\n      when: ansible_os_family == \"RedHat\"\n\n    - name: Configure Nginx mutual TLS authentication\n      block:\n        - name: Check if Nginx is installed\n          command: which nginx\n          register: nginx_installed\n          changed_when: false\n          failed_when: false\n\n        - name: Deploy Nginx service authentication configuration\n          copy:\n            dest: /etc/nginx/conf.d/service-auth.conf\n            content: |\n              # IA-9: Service Authentication for Nginx\n              server {\n                  listen 443 ssl;\n                  \n                  ssl_certificate {{ cert_base_dir }}/certs/server.crt;\n                  ssl_certificate_key {{ cert_base_dir }}/private/server.key;\n                  \n                  ssl_client_certificate {{ ca_cert_path }};\n                  ssl_verify_client on;\n                  ssl_verify_depth 3;\n                  \n                  ssl_protocols TLSv1.2 TLSv1.3;\n                  ssl_ciphers HIGH:!aNULL:!MD5;\n                  ssl_prefer_server_ciphers on;\n                  \n                  access_log /var/log/nginx/service-auth.log combined;\n                  \n                  location / {\n                      if ($ssl_client_s_dn = \"\") {\n                          return 403;\n                      }\n                      proxy_pass http://backend;\n                      proxy_set_header X-Client-DN $ssl_client_s_dn;\n                  }\n              }\n            mode: '0644'\n          when: nginx_installed.rc == 0\n          notify: restart nginx\n\n    - name: Configure PostgreSQL SSL authentication\n      block:\n        - name: Check if PostgreSQL is installed\n          stat:\n            path: /var/lib/pgsql/data/pg_hba.conf\n          register: postgres_hba\n\n        - name: Add SSL certificate authentication to pg_hba.conf\n          blockinfile:\n            path: /var/lib/pgsql/data/pg_hba.conf\n            marker: \"# {mark} IA-9 SERVICE AUTHENTICATION\"\n            block: |\n              # Require SSL certificate authentication for service accounts\n              hostssl all service_user 0.0.0.0/0 cert clientcert=verify-full\n              hostssl all +service_role 0.0.0.0/0 cert clientcert=verify-full\n          when: postgres_hba.stat.exists\n          notify: restart postgresql\n\n        - name: Enable SSL in postgresql.conf\n          lineinfile:\n            path: /var/lib/pgsql/data/postgresql.conf\n            regexp: \"{{ item.regexp }}\"\n            line: \"{{ item.line }}\"\n            state: present\n          loop:\n            - { regexp: '^#?ssl = ', line: 'ssl = on' }\n            - { regexp: '^#?ssl_cert_file = ', line: \"ssl_cert_file = '{{ cert_base_dir }}/certs/postgres.crt'\" }\n            - { regexp: '^#?ssl_key_file = ', line: \"ssl_key_file = '{{ cert_base_dir }}/private/postgres.key'\" }\n            - { regexp: '^#?ssl_ca_file = ', line: \"ssl_ca_file = '{{ ca_cert_path }}'\" }\n          when: postgres_hba.stat.exists\n          notify: restart postgresql\n\n    - name: Deploy service authentication monitoring service\n      copy:\n        dest: /etc/systemd/system/service-auth-monitor.service\n        content: |\n          [Unit]\n          Description=IA-9 Service Authentication Monitor\n          After=network.target\n          \n          [Service]\n          Type=simple\n          ExecStart=/usr/local/bin/service-auth-monitor.sh\n          Restart=on-failure\n          RestartSec=5s\n          StandardOutput=journal\n          StandardError=journal\n          \n          [Install]\n          WantedBy=multi-user.target\n        mode: '0644'\n      notify: reload systemd\n\n    - name: Deploy service authentication monitoring script\n      copy:\n        dest: /usr/local/bin/service-auth-monitor.sh\n        content: |\n          #!/bin/bash\n          LOG_FILE=\"{{ service_log_file }}\"\n          while true; do\n              journalctl -u \"*.service\" --since \"1 minute ago\" | grep -i \"authentication failure\\\\|certificate.*fail\\\\|ssl.*error\" >> \"$LOG_FILE\"\n              netstat -tulpn | grep LISTEN | while read line; do\n                  port=$(echo \"$line\" | awk '{print $4}' | cut -d: -f2)\n                  service=$(echo \"$line\" | awk '{print $7}')\n                  [ ! -z \"$service\" ] && echo \"[$(date)] Service $service listening on port $port\" >> \"$LOG_FILE\"\n              done\n              sleep 60\n          done\n        mode: '0755'\n\n    - name: Enable and start service authentication monitor\n      systemd:\n        name: service-auth-monitor\n        enabled: true\n        state: started\n        daemon_reload: true\n\n    - name: Configure auditd rules for service authentication\n      copy:\n        dest: /etc/audit/rules.d/service-auth.rules\n        content: |\n          # IA-9: Service Authentication Audit Rules\n          -w {{ cert_base_dir }}/ -p wa -k service_certs\n          -w /etc/ssl/certs/ -p wa -k service_certs\n          -a always,exit -F arch=b64 -S connect -F success=0 -k service_connection_failed\n          -a always,exit -F arch=b32 -S connect -F success=0 -k service_connection_failed\n        mode: '0640'\n      notify: reload auditd\n\n    - name: Deploy certificate validation script\n      copy:\n        dest: /usr/local/bin/validate-service-certs.sh\n        content: |\n          #!/bin/bash\n          CERT_DIR=\"{{ cert_base_dir }}/certs\"\n          CA_CERT=\"{{ ca_cert_path }}\"\n          EXPIRY_WARNING_DAYS={{ cert_expiry_warning_days }}\n          \n          for cert in \"$CERT_DIR\"/*.crt; do\n              if [ -f \"$cert\" ]; then\n                  if openssl verify -CAfile \"$CA_CERT\" \"$cert\" > /dev/null 2>&1; then\n                      expiry_date=$(openssl x509 -in \"$cert\" -noout -enddate | cut -d= -f2)\n                      expiry_epoch=$(date -d \"$expiry_date\" +%s)\n                      current_epoch=$(date +%s)\n                      days_until_expiry=$(( ($expiry_epoch - $current_epoch) / 86400 ))\n                      \n                      if [ $days_until_expiry -lt $EXPIRY_WARNING_DAYS ]; then\n                          echo \"WARNING: Certificate $cert expires in $days_until_expiry days\"\n                          logger -t service-auth -p warning \"Certificate $cert expires in $days_until_expiry days\"\n                      fi\n                  else\n                      echo \"ERROR: Certificate $cert failed validation\"\n                      logger -t service-auth -p error \"Certificate $cert failed validation\"\n                  fi\n              fi\n          done\n        mode: '0755'\n\n    - name: Schedule daily certificate validation\n      cron:\n        name: \"Validate service certificates\"\n        special_time: daily\n        job: \"/usr/local/bin/validate-service-certs.sh\"\n        user: root\n\n    - name: Create service authentication log file\n      file:\n        path: \"{{ service_log_file }}\"\n        state: touch\n        mode: '0640'\n        modification_time: preserve\n        access_time: preserve\n\n    - name: Configure logrotate for service authentication logs\n      copy:\n        dest: /etc/logrotate.d/service-auth\n        content: |\n          {{ service_log_file }} {\n              daily\n              rotate 90\n              compress\n              delaycompress\n              missingok\n              notifempty\n              create 0640 root root\n          }\n        mode: '0644'\n\n  handlers:\n    - name: restart apache\n      systemd:\n        name: httpd\n        state: restarted\n\n    - name: restart nginx\n      systemd:\n        name: nginx\n        state: restarted\n\n    - name: restart postgresql\n      systemd:\n        name: postgresql\n        state: restarted\n\n    - name: reload systemd\n      systemd:\n        daemon_reload: true\n\n    - name: reload auditd\n      command: augenrules --load\n      changed_when: true\n"
        }
      },
      "windows": {
        "powershell": {
          "description": "Configure service authentication mechanisms on Windows systems using certificates and secure protocols",
          "script": "# IA-9: Service Identification and Authentication - Windows Implementation\n# PowerShell script to configure service authentication on Windows systems\n\n#Requires -Version 5.1\n#Requires -RunAsAdministrator\n\n[CmdletBinding()]\nparam(\n    [Parameter()]\n    [string]$CertificateStorePath = \"Cert:\\LocalMachine\\My\",\n    \n    [Parameter()]\n    [string]$TrustedRootStore = \"Cert:\\LocalMachine\\Root\",\n    \n    [Parameter()]\n    [string]$LogPath = \"C:\\ProgramData\\ServiceAuth\\Logs\",\n    \n    [Parameter()]\n    [int]$CertExpiryWarningDays = 30\n)\n\n$ErrorActionPreference = \"Stop\"\n$LogFile = Join-Path $LogPath \"service-auth-$(Get-Date -Format 'yyyyMMdd').log\"\n\n# Create logging directory\nif (-not (Test-Path $LogPath)) {\n    New-Item -ItemType Directory -Path $LogPath -Force | Out-Null\n}\n\nfunction Write-LogMessage {\n    param(\n        [string]$Message,\n        [ValidateSet('Info', 'Warning', 'Error')]\n        [string]$Level = 'Info'\n    )\n    \n    $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n    $logMessage = \"[$timestamp] [$Level] $Message\"\n    Add-Content -Path $LogFile -Value $logMessage\n    \n    switch ($Level) {\n        'Info' { Write-Host $logMessage -ForegroundColor Green }\n        'Warning' { Write-Warning $logMessage }\n        'Error' { Write-Error $logMessage }\n    }\n}\n\nWrite-LogMessage \"Starting IA-9 Service Authentication Configuration\"\n\n# 1. Enable certificate-based service authentication in IIS\ntry {\n    Import-Module WebAdministration -ErrorAction SilentlyContinue\n    \n    if (Get-Module -Name WebAdministration) {\n        Write-LogMessage \"Configuring IIS service authentication\"\n        \n        # Enable SSL for default website\n        $siteName = \"Default Web Site\"\n        \n        # Require SSL\n        Set-WebConfigurationProperty -Filter '/system.webServer/security/access' `\n            -Name 'sslFlags' -Value 'Ssl,SslNegotiateCert,SslRequireCert' `\n            -PSPath \"IIS:\\Sites\\$siteName\" -ErrorAction SilentlyContinue\n        \n        # Configure client certificate mapping authentication\n        Set-WebConfigurationProperty -Filter '/system.webServer/security/authentication/clientCertificateMappingAuthentication' `\n            -Name 'enabled' -Value $true -PSPath \"IIS:\\Sites\\$siteName\" -ErrorAction SilentlyContinue\n        \n        # Enable certificate trust list\n        Set-WebConfigurationProperty -Filter '/system.webServer/security/access' `\n            -Name 'flags' -Value 'Ssl,SslNegotiateCert,SslRequireCert,SslMapCert' `\n            -PSPath \"IIS:\\Sites\\$siteName\" -ErrorAction SilentlyContinue\n        \n        Write-LogMessage \"IIS service authentication configured successfully\"\n    }\n} catch {\n    Write-LogMessage \"IIS configuration skipped or failed: $($_.Exception.Message)\" -Level Warning\n}\n\n# 2. Configure Windows service certificate validation\nWrite-LogMessage \"Configuring Windows service certificate requirements\"\n\n# Enable SCHANNEL strict certificate validation\n$schannelPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\"\n\nif (-not (Test-Path $schannelPath)) {\n    New-Item -Path $schannelPath -Force | Out-Null\n}\n\n# Disable weak protocols\n@('SSL 2.0', 'SSL 3.0', 'TLS 1.0', 'TLS 1.1') | ForEach-Object {\n    $protocolPath = \"$schannelPath\\Protocols\\$_\"\n    \n    if (-not (Test-Path \"$protocolPath\\Server\")) {\n        New-Item -Path \"$protocolPath\\Server\" -Force | Out-Null\n    }\n    \n    Set-ItemProperty -Path \"$protocolPath\\Server\" -Name \"Enabled\" -Value 0 -Type DWord -Force\n    Set-ItemProperty -Path \"$protocolPath\\Server\" -Name \"DisabledByDefault\" -Value 1 -Type DWord -Force\n}\n\n# Enable strong protocols\n@('TLS 1.2', 'TLS 1.3') | ForEach-Object {\n    $protocolPath = \"$schannelPath\\Protocols\\$_\"\n    \n    if (-not (Test-Path \"$protocolPath\\Server\")) {\n        New-Item -Path \"$protocolPath\\Server\" -Force | Out-Null\n    }\n    \n    Set-ItemProperty -Path \"$protocolPath\\Server\" -Name \"Enabled\" -Value 1 -Type DWord -Force\n    Set-ItemProperty -Path \"$protocolPath\\Server\" -Name \"DisabledByDefault\" -Value 0 -Type DWord -Force\n}\n\nWrite-LogMessage \"SCHANNEL security policies configured\"\n\n# 3. Configure SQL Server for certificate authentication (if installed)\ntry {\n    $sqlService = Get-Service -Name \"MSSQLSERVER\" -ErrorAction SilentlyContinue\n    \n    if ($sqlService) {\n        Write-LogMessage \"Configuring SQL Server service authentication\"\n        \n        # Find SQL Server certificate\n        $sqlCert = Get-ChildItem -Path $CertificateStorePath | Where-Object {\n            $_.Subject -like \"*SQL*\" -and $_.HasPrivateKey -eq $true\n        } | Select-Object -First 1\n        \n        if ($sqlCert) {\n            # Configure SQL Server to use certificate\n            $sqlRegPath = \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\MSSQL*\\MSSQLServer\\SuperSocketNetLib\"\n            $sqlInstances = Get-Item -Path $sqlRegPath -ErrorAction SilentlyContinue\n            \n            foreach ($instance in $sqlInstances) {\n                Set-ItemProperty -Path $instance.PSPath -Name \"Certificate\" -Value $sqlCert.Thumbprint -Force\n                Set-ItemProperty -Path $instance.PSPath -Name \"ForceEncryption\" -Value 1 -Type DWord -Force\n            }\n            \n            Write-LogMessage \"SQL Server configured to require certificate authentication\"\n        } else {\n            Write-LogMessage \"No suitable SQL Server certificate found\" -Level Warning\n        }\n    }\n} catch {\n    Write-LogMessage \"SQL Server configuration skipped: $($_.Exception.Message)\" -Level Warning\n}\n\n# 4. Create certificate validation function\nfunction Test-ServiceCertificates {\n    Write-LogMessage \"Validating service certificates\"\n    \n    $certificates = Get-ChildItem -Path $CertificateStorePath -Recurse | Where-Object {\n        $_.HasPrivateKey -eq $true\n    }\n    \n    foreach ($cert in $certificates) {\n        $daysUntilExpiry = ($cert.NotAfter - (Get-Date)).Days\n        \n        if ($daysUntilExpiry -lt 0) {\n            Write-LogMessage \"EXPIRED: Certificate '$($cert.Subject)' expired on $($cert.NotAfter)\" -Level Error\n        } elseif ($daysUntilExpiry -lt $CertExpiryWarningDays) {\n            Write-LogMessage \"WARNING: Certificate '$($cert.Subject)' expires in $daysUntilExpiry days\" -Level Warning\n        }\n        \n        # Verify certificate chain\n        $chain = New-Object System.Security.Cryptography.X509Certificates.X509Chain\n        $chain.ChainPolicy.RevocationMode = \"Online\"\n        $chainValid = $chain.Build($cert)\n        \n        if (-not $chainValid) {\n            Write-LogMessage \"Certificate '$($cert.Subject)' failed chain validation\" -Level Warning\n            foreach ($status in $chain.ChainStatus) {\n                Write-LogMessage \"  Chain Status: $($status.StatusInformation)\" -Level Warning\n            }\n        }\n    }\n}\n\n# 5. Configure Windows Firewall to log service connections\nWrite-LogMessage \"Configuring Windows Firewall logging\"\n\n$firewallLogPath = \"C:\\ProgramData\\ServiceAuth\\Firewall\"\nif (-not (Test-Path $firewallLogPath)) {\n    New-Item -ItemType Directory -Path $firewallLogPath -Force | Out-Null\n}\n\nSet-NetFirewallProfile -Profile Domain,Public,Private `\n    -LogFileName \"$firewallLogPath\\pfirewall.log\" `\n    -LogAllowed True `\n    -LogBlocked True `\n    -LogMaxSizeKilobytes 32767\n\nWrite-LogMessage \"Firewall logging configured\"\n\n# 6. Create scheduled task for certificate validation\nWrite-LogMessage \"Creating scheduled task for certificate validation\"\n\n$taskName = \"IA-9-Certificate-Validation\"\n$taskAction = New-ScheduledTaskAction -Execute \"PowerShell.exe\" `\n    -Argument \"-ExecutionPolicy Bypass -File `\"$PSCommandPath`\" -Validate\"\n\n$taskTrigger = New-ScheduledTaskTrigger -Daily -At \"02:00AM\"\n\n$taskPrincipal = New-ScheduledTaskPrincipal -UserId \"SYSTEM\" `\n    -LogonType ServiceAccount -RunLevel Highest\n\n$taskSettings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries `\n    -DontStopIfGoingOnBatteries -StartWhenAvailable\n\nRegister-ScheduledTask -TaskName $taskName `\n    -Action $taskAction `\n    -Trigger $taskTrigger `\n    -Principal $taskPrincipal `\n    -Settings $taskSettings `\n    -Description \"IA-9: Daily service certificate validation\" `\n    -Force | Out-Null\n\nWrite-LogMessage \"Scheduled task created: $taskName\"\n\n# 7. Configure Event Log monitoring for service authentication\nWrite-LogMessage \"Configuring Event Log monitoring\"\n\n# Create custom event log for service authentication\n$logName = \"ServiceAuthentication\"\n$logSource = \"IA-9\"\n\nif (-not [System.Diagnostics.EventLog]::SourceExists($logSource)) {\n    New-EventLog -LogName $logName -Source $logSource\n    Write-LogMessage \"Created Event Log: $logName\"\n}\n\n# Log initial configuration event\nWrite-EventLog -LogName $logName -Source $logSource -EntryType Information `\n    -EventId 1000 -Message \"IA-9 Service Authentication configuration completed\"\n\n# 8. Configure WinRM for certificate-based authentication\ntry {\n    Write-LogMessage \"Configuring WinRM certificate authentication\"\n    \n    # Enable certificate authentication\n    Set-Item -Path WSMan:\\localhost\\Service\\Auth\\Certificate -Value $true -Force\n    \n    # Require SSL for WinRM\n    Set-Item -Path WSMan:\\localhost\\Service\\AllowUnencrypted -Value $false -Force\n    \n    # Configure client certificate validation\n    Set-Item -Path WSMan:\\localhost\\Service\\Auth\\CbtHardeningLevel -Value Strict -Force\n    \n    Write-LogMessage \"WinRM certificate authentication configured\"\n} catch {\n    Write-LogMessage \"WinRM configuration warning: $($_.Exception.Message)\" -Level Warning\n}\n\n# 9. Generate service authentication report\nfunction New-ServiceAuthReport {\n    Write-LogMessage \"Generating service authentication report\"\n    \n    $reportPath = Join-Path $LogPath \"service-auth-report-$(Get-Date -Format 'yyyyMMdd-HHmmss').html\"\n    \n    $certificates = Get-ChildItem -Path $CertificateStorePath -Recurse | Where-Object {\n        $_.HasPrivateKey -eq $true\n    }\n    \n    $html = @\"\n<!DOCTYPE html>\n<html>\n<head>\n    <title>IA-9 Service Authentication Report</title>\n    <style>\n        body { font-family: Arial, sans-serif; margin: 20px; }\n        table { border-collapse: collapse; width: 100%; }\n        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n        th { background-color: #4CAF50; color: white; }\n        .expired { background-color: #ffcccc; }\n        .warning { background-color: #ffffcc; }\n        .valid { background-color: #ccffcc; }\n    </style>\n</head>\n<body>\n    <h1>IA-9 Service Authentication Report</h1>\n    <p>Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')</p>\n    <h2>Service Certificates</h2>\n    <table>\n        <tr>\n            <th>Subject</th>\n            <th>Issuer</th>\n            <th>Expiry Date</th>\n            <th>Days Until Expiry</th>\n            <th>Status</th>\n        </tr>\n\"@\n    \n    foreach ($cert in $certificates) {\n        $daysUntilExpiry = ($cert.NotAfter - (Get-Date)).Days\n        \n        $status = if ($daysUntilExpiry -lt 0) {\n            \"Expired\"\n        } elseif ($daysUntilExpiry -lt $CertExpiryWarningDays) {\n            \"Expiring Soon\"\n        } else {\n            \"Valid\"\n        }\n        \n        $rowClass = switch ($status) {\n            \"Expired\" { \"expired\" }\n            \"Expiring Soon\" { \"warning\" }\n            default { \"valid\" }\n        }\n        \n        $html += @\"\n        <tr class=\"$rowClass\">\n            <td>$($cert.Subject)</td>\n            <td>$($cert.Issuer)</td>\n            <td>$($cert.NotAfter.ToString('yyyy-MM-dd'))</td>\n            <td>$daysUntilExpiry</td>\n            <td>$status</td>\n        </tr>\n\"@\n    }\n    \n    $html += @\"\n    </table>\n</body>\n</html>\n\"@\n    \n    $html | Out-File -FilePath $reportPath -Encoding UTF8\n    Write-LogMessage \"Report generated: $reportPath\"\n}\n\n# Execute validation if -Validate parameter is used\nif ($PSBoundParameters.ContainsKey('Validate') -or $args -contains '-Validate') {\n    Test-ServiceCertificates\n    New-ServiceAuthReport\n} else {\n    # Run initial validation\n    Test-ServiceCertificates\n    New-ServiceAuthReport\n}\n\nWrite-LogMessage \"IA-9 Service Authentication configuration completed successfully\"\nWrite-Host \"`nConfiguration Summary:\"\nWrite-Host \"  Certificate Store: $CertificateStorePath\"\nWrite-Host \"  Log Directory: $LogPath\"\nWrite-Host \"  Event Log: ServiceAuthentication\"\nWrite-Host \"  Scheduled Task: $taskName\"\nWrite-Host \"`nNext Steps:\"\nWrite-Host \"  1. Import service certificates to $CertificateStorePath\"\nWrite-Host \"  2. Configure service-specific authentication in application configs\"\nWrite-Host \"  3. Review logs at $LogPath\"\nWrite-Host \"  4. Monitor Event Log 'ServiceAuthentication' for authentication events\"\nWrite-Host \"  5. Run with -Validate parameter to check certificate status\"\n"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000+00:00",
      "has_scripts": true,
      "revision": "NIST SP 800-53 Rev 5",
      "parameter_assignments": {
        "ia-09_odp": {
          "label": "organization-defined system services and applications",
          "description": "System services and applications requiring identification and authentication",
          "examples": [
            "Web services and REST APIs",
            "SOAP services",
            "Microservices",
            "Database services (PostgreSQL, MySQL, Oracle, SQL Server)",
            "Message queue services (RabbitMQ, Kafka, ActiveMQ)",
            "Authentication services (OAuth providers, SAML IdPs, LDAP/AD)",
            "Container orchestration services (Kubernetes API, Docker daemon)",
            "Cloud service APIs (AWS, Azure, GCP)",
            "Third-party integration services",
            "Internal application services"
          ]
        }
      },
      "frameworks": {
        "nist_csf_v1_1": [
          "PR.AC-1",
          "PR.AC-7"
        ],
        "nist_csf_v2_0": [
          "PR.AA-01",
          "PR.AA-03"
        ],
        "nist_privacy_framework": [
          "PR.AC-P1",
          "PR.AC-P6"
        ]
      },
      "threat_model": {
        "stride_lm": [
          "Spoofing"
        ]
      }
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T00:00:00.000000+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "custom_implementation",
      "cac_planned": false,
      "implementation_guidance": "No direct ComplianceAsCode rules available for IA-9. Implementation requires organization-specific service authentication configuration using TLS/mTLS, OAuth 2.0, API key validation, or certificate-based authentication depending on service architecture. Custom scripts provided for common service authentication scenarios including web servers (Apache/Nginx), databases (PostgreSQL/SQL Server), and general certificate management."
    },
    "ai_guidance": "IA-9 Service Identification and Authentication requires authenticating services before information exchange. Implement mutual TLS for service-to-service communication. Use service mesh authentication. Verify service identity through certificates or tokens."
  },
  {
    "control_id": "IA-10",
    "control_name": "Adaptive Authentication",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Require individuals accessing the system to employ [Assignment: organization-defined supplemental authentication techniques or mechanisms] under specific [Assignment: organization-defined circumstances or situations].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Adaptive authentication means the system automatically detects suspicious login behavior and requires additional verification beyond standard credentials. For example, if someone tries to access your system from an unfamiliar location, at an unusual time, or attempts to access data they normally don't use, the system will prompt for extra authentication such as a one-time code sent to their phone. This adapts security requirements based on risk rather than applying the same authentication to every login.",
    "example_implementation": "Deploy risk-based authentication that monitors login attempts for anomalies including: new device fingerprints (user agent, browser cookies), impossible travel patterns (geographic location changes exceeding realistic travel speeds), suspicious IP addresses (known VPN/proxy services, threat intelligence feeds), unusual access patterns (accessing data outside normal role), time-based anomalies (logins during non-business hours). When risk scores exceed thresholds, require supplemental authentication such as TOTP codes, push notifications to registered mobile devices, or biometric verification. Integrate with identity providers (SAML, OIDC) to enforce adaptive policies before granting access tokens.",
    "non_technical_guidance": "To implement adaptive authentication for your organization: 1) Define specific risk scenarios requiring additional verification - these include logins from new devices, foreign countries, after-hours access, or attempts to view unusual volumes of sensitive data. 2) Establish baseline user behavior patterns by analyzing typical access times, locations, devices, and data usage for each role. 3) Deploy authentication solutions supporting risk-based MFA that can evaluate login context against baselines and require supplemental verification when anomalies are detected. 4) Configure graduated response levels - low risk may allow access with logging, medium risk requires TOTP/SMS codes, high risk triggers account lockout pending security review. 5) Communicate the policy to users explaining why they may occasionally face additional authentication prompts and how to comply. 6) Monitor false positive rates and adjust risk thresholds to balance security with user experience. 7) Regularly review authentication logs for patterns indicating policy effectiveness or need for adjustment. 8) Ensure adaptive authentication supplements rather than replaces standard multi-factor authentication requirements. 9) Document all adaptive authentication triggers, thresholds, and response actions in security procedures. 10) Conduct quarterly reviews of risk assessment criteria to incorporate new threat intelligence and address emerging attack patterns.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "IA-2",
      "IA-8",
      "AU-6",
      "SI-4"
    ],
    "supplemental_guidance": "Adversaries may compromise individual authentication mechanisms employed by organizations and subsequently attempt to impersonate legitimate users. To address this threat, organizations employ specific techniques or mechanisms and establish protocols to assess suspicious behavior. Suspicious behavior includes accessing information individuals do not typically access as part of duties, roles, or responsibilities; accessing greater quantities of information than routinely accessed; or attempting access from suspicious network addresses. When pre-established conditions or triggers occur, organizations require individuals to provide additional authentication information. Adaptive authentication can increase authentication mechanism strength based on number or types of records accessed, and does not replace multi-factor authentication but augments its implementation. This control is typically implemented at the Identity Provider (IDP) level rather than individual system configurations.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-10: Adaptive Authentication Monitoring Script\n# Monitors authentication attempts for suspicious patterns requiring additional verification\n# This script analyzes auth logs and flags high-risk login attempts\n\nLOG_FILE=\"/var/log/auth.log\"\nALERT_LOG=\"/var/log/adaptive_auth_alerts.log\"\nGEO_DB=\"/usr/share/GeoIP/GeoLite2-City.mmdb\"\n\n# Risk scoring thresholds\nRISK_LOW=30\nRISK_MEDIUM=50\nRISK_HIGH=70\n\n# Function to calculate risk score based on multiple factors\ncalculate_risk_score() {\n    local username=$1\n    local source_ip=$2\n    local login_time=$3\n    local risk_score=0\n\n    # Check if login from new IP address (last 30 days)\n    if ! grep -q \"$source_ip\" /var/log/auth_history_30d.log 2>/dev/null; then\n        risk_score=$((risk_score + 20))\n        echo \"[RISK +20] New IP address: $source_ip\" >> $ALERT_LOG\n    fi\n\n    # Check login time (business hours: 6 AM - 6 PM weekdays)\n    hour=$(date -d \"$login_time\" +%H)\n    day=$(date -d \"$login_time\" +%u)\n    if [ $hour -lt 6 ] || [ $hour -gt 18 ] || [ $day -gt 5 ]; then\n        risk_score=$((risk_score + 15))\n        echo \"[RISK +15] Outside business hours: $login_time\" >> $ALERT_LOG\n    fi\n\n    # Check for multiple failed attempts from same IP\n    failed_count=$(grep \"Failed password\" $LOG_FILE | grep \"$source_ip\" | tail -n 100 | wc -l)\n    if [ $failed_count -gt 3 ]; then\n        risk_score=$((risk_score + 25))\n        echo \"[RISK +25] Multiple failed attempts: $failed_count\" >> $ALERT_LOG\n    fi\n\n    # Check if IP is from unexpected geographic location\n    if command -v geoiplookup >/dev/null 2>&1; then\n        country=$(geoiplookup $source_ip | awk -F\": \" '{print $2}' | cut -d\",\" -f1)\n        if [[ ! \"$country\" =~ ^(US|United States)$ ]]; then\n            risk_score=$((risk_score + 30))\n            echo \"[RISK +30] Foreign country login: $country\" >> $ALERT_LOG\n        fi\n    fi\n\n    echo $risk_score\n}\n\n# Main monitoring loop\necho \"[$(date)] Starting adaptive authentication monitoring\" >> $ALERT_LOG\n\ntail -F $LOG_FILE | while read -r line; do\n    if echo \"$line\" | grep -q \"Accepted password\\|Accepted publickey\"; then\n        username=$(echo \"$line\" | awk '{for(i=1;i<=NF;i++) if($i==\"for\") print $(i+1)}' | head -1)\n        source_ip=$(echo \"$line\" | grep -oP \"from \\K[0-9.]+\")\n        login_time=$(echo \"$line\" | awk '{print $1, $2, $3}')\n\n        risk_score=$(calculate_risk_score \"$username\" \"$source_ip\" \"$login_time\")\n\n        if [ $risk_score -ge $RISK_HIGH ]; then\n            echo \"[$(date)] HIGH RISK LOGIN - Score: $risk_score - User: $username - IP: $source_ip\" >> $ALERT_LOG\n            # Trigger additional authentication requirement (integrate with PAM/IDP)\n            echo \"User $username requires additional verification\" | mail -s \"HIGH RISK LOGIN DETECTED\" security@organization.com\n        elif [ $risk_score -ge $RISK_MEDIUM ]; then\n            echo \"[$(date)] MEDIUM RISK LOGIN - Score: $risk_score - User: $username - IP: $source_ip\" >> $ALERT_LOG\n        fi\n    fi\ndone\n",
        "ansible": "---\n# IA-10: Adaptive Authentication Configuration\n# Configures PAM modules and monitoring for risk-based authentication\n- name: Configure Adaptive Authentication for IA-10 Compliance\n  hosts: all\n  become: yes\n  vars:\n    geoip_db_url: \"https://download.maxmind.com/app/geoip_download\"\n    alert_email: \"security@organization.com\"\n    risk_high_threshold: 70\n    risk_medium_threshold: 50\n\n  tasks:\n    - name: Install required packages for adaptive authentication\n      package:\n        name:\n          - libpam-python\n          - geoip-bin\n          - geoip-database\n          - fail2ban\n          - python3-geoip2\n        state: present\n\n    - name: Create adaptive authentication monitoring script\n      copy:\n        dest: /usr/local/bin/adaptive_auth_monitor.sh\n        mode: '0755'\n        content: |\n          #!/bin/bash\n          # Generated by Ansible - IA-10 Adaptive Authentication Monitor\n          LOG_FILE=\"/var/log/auth.log\"\n          ALERT_LOG=\"/var/log/adaptive_auth_alerts.log\"\n          RISK_HIGH={{ risk_high_threshold }}\n          RISK_MEDIUM={{ risk_medium_threshold }}\n\n          tail -F $LOG_FILE | while read -r line; do\n              if echo \"$line\" | grep -q \"Accepted password\\|Accepted publickey\"; then\n                  username=$(echo \"$line\" | awk '{for(i=1;i<=NF;i++) if($i==\"for\") print $(i+1)}' | head -1)\n                  source_ip=$(echo \"$line\" | grep -oP \"from \\K[0-9.]+\")\n                  /usr/local/bin/calculate_auth_risk.py \"$username\" \"$source_ip\"\n              fi\n          done\n\n    - name: Create Python risk calculation script\n      copy:\n        dest: /usr/local/bin/calculate_auth_risk.py\n        mode: '0755'\n        content: |\n          #!/usr/bin/env python3\n          import sys\n          import subprocess\n          import datetime\n          import os\n\n          def calculate_risk(username, source_ip):\n              risk_score = 0\n              factors = []\n\n              # Check IP history (new device)\n              if not check_ip_history(source_ip):\n                  risk_score += 20\n                  factors.append(\"New IP address\")\n\n              # Check time-based risk\n              current_hour = datetime.datetime.now().hour\n              current_day = datetime.datetime.now().weekday()\n              if current_hour < 6 or current_hour > 18 or current_day > 4:\n                  risk_score += 15\n                  factors.append(\"Outside business hours\")\n\n              # Check geographic location\n              geo_risk = check_geographic_risk(source_ip)\n              if geo_risk > 0:\n                  risk_score += geo_risk\n                  factors.append(f\"Geographic risk: +{geo_risk}\")\n\n              return risk_score, factors\n\n          if __name__ == \"__main__\":\n              username, source_ip = sys.argv[1], sys.argv[2]\n              score, factors = calculate_risk(username, source_ip)\n\n              if score >= {{ risk_high_threshold }}:\n                  print(f\"HIGH RISK: {username}@{source_ip} Score:{score} Factors:{factors}\")\n                  # Trigger MFA requirement via PAM/IDP API\n\n    - name: Configure fail2ban for adaptive authentication\n      copy:\n        dest: /etc/fail2ban/filter.d/adaptive-auth.conf\n        content: |\n          [Definition]\n          failregex = HIGH RISK LOGIN.*IP: <HOST>\n          ignoreregex =\n\n    - name: Enable fail2ban jail for high-risk logins\n      copy:\n        dest: /etc/fail2ban/jail.d/adaptive-auth.conf\n        content: |\n          [adaptive-auth]\n          enabled = true\n          filter = adaptive-auth\n          logpath = /var/log/adaptive_auth_alerts.log\n          maxretry = 1\n          bantime = 3600\n          action = %(action_mwl)s\n\n    - name: Create systemd service for adaptive auth monitoring\n      copy:\n        dest: /etc/systemd/system/adaptive-auth-monitor.service\n        content: |\n          [Unit]\n          Description=Adaptive Authentication Monitor (IA-10)\n          After=network.target\n\n          [Service]\n          Type=simple\n          ExecStart=/usr/local/bin/adaptive_auth_monitor.sh\n          Restart=always\n\n          [Install]\n          WantedBy=multi-user.target\n\n    - name: Enable and start adaptive auth monitoring service\n      systemd:\n        name: adaptive-auth-monitor\n        enabled: yes\n        state: started\n        daemon_reload: yes\n\n    - name: Configure PAM to support adaptive authentication\n      lineinfile:\n        path: /etc/pam.d/common-auth\n        line: \"auth required pam_python.so /usr/local/lib/pam_adaptive_auth.py\"\n        insertafter: \"^auth.*pam_unix.so\"\n"
      },
      "windows": {
        "powershell": "<#\n.SYNOPSIS\n    IA-10: Adaptive Authentication Monitoring for Windows\n\n.DESCRIPTION\n    Monitors Windows authentication events (Event IDs 4624, 4625) and calculates risk scores\n    based on multiple factors. Triggers additional authentication requirements for high-risk logins.\n\n.NOTES\n    Requires: Administrator privileges, Event Log access\n    Compliance: NIST SP 800-53 Rev 5 IA-10\n#>\n\n#Requires -RunAsAdministrator\n\n$ErrorActionPreference = \"Stop\"\n\n# Configuration\n$AlertLogPath = \"C:\\ProgramData\\AdaptiveAuth\\alerts.log\"\n$RiskHighThreshold = 70\n$RiskMediumThreshold = 50\n$BusinessHoursStart = 6\n$BusinessHoursEnd = 18\n$AllowedCountries = @(\"US\", \"United States\")\n$AlertEmail = \"security@organization.com\"\n\n# Ensure log directory exists\n$logDir = Split-Path $AlertLogPath -Parent\nif (-not (Test-Path $logDir)) {\n    New-Item -ItemType Directory -Path $logDir -Force | Out-Null\n}\n\nfunction Write-AlertLog {\n    param([string]$Message)\n    $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n    \"[$timestamp] $Message\" | Out-File -FilePath $AlertLogPath -Append\n    Write-Host \"[$timestamp] $Message\"\n}\n\nfunction Get-IPGeolocation {\n    param([string]$IPAddress)\n\n    try {\n        # Use IP geolocation API (requires internet connectivity)\n        $response = Invoke-RestMethod -Uri \"http://ip-api.com/json/$IPAddress\" -TimeoutSec 5\n        return @{\n            Country = $response.country\n            CountryCode = $response.countryCode\n            Region = $response.regionName\n            City = $response.city\n        }\n    } catch {\n        Write-AlertLog \"WARNING: Could not retrieve geolocation for $IPAddress\"\n        return $null\n    }\n}\n\nfunction Test-NewIPAddress {\n    param(\n        [string]$Username,\n        [string]$IPAddress\n    )\n\n    # Check authentication history from last 30 days\n    $thirtyDaysAgo = (Get-Date).AddDays(-30)\n    $historicalLogins = Get-WinEvent -FilterHashtable @{\n        LogName = 'Security'\n        ID = 4624\n        StartTime = $thirtyDaysAgo\n    } -ErrorAction SilentlyContinue | Where-Object {\n        $_.Properties[5].Value -eq $Username -and\n        $_.Properties[18].Value -eq $IPAddress\n    }\n\n    return ($null -eq $historicalLogins -or $historicalLogins.Count -eq 0)\n}\n\nfunction Get-FailedLoginCount {\n    param(\n        [string]$Username,\n        [string]$IPAddress\n    )\n\n    $lastHour = (Get-Date).AddHours(-1)\n    $failedLogins = Get-WinEvent -FilterHashtable @{\n        LogName = 'Security'\n        ID = 4625\n        StartTime = $lastHour\n    } -ErrorAction SilentlyContinue | Where-Object {\n        $_.Properties[5].Value -eq $Username -or\n        $_.Properties[19].Value -eq $IPAddress\n    }\n\n    return ($failedLogins | Measure-Object).Count\n}\n\nfunction Test-BusinessHours {\n    param([datetime]$LoginTime)\n\n    $hour = $LoginTime.Hour\n    $dayOfWeek = $LoginTime.DayOfWeek\n\n    $isWeekend = ($dayOfWeek -eq [DayOfWeek]::Saturday -or $dayOfWeek -eq [DayOfWeek]::Sunday)\n    $isOutsideHours = ($hour -lt $BusinessHoursStart -or $hour -gt $BusinessHoursEnd)\n\n    return ($isWeekend -or $isOutsideHours)\n}\n\nfunction Get-AuthenticationRiskScore {\n    param(\n        [string]$Username,\n        [string]$IPAddress,\n        [datetime]$LoginTime\n    )\n\n    $riskScore = 0\n    $riskFactors = @()\n\n    # Risk Factor 1: New IP Address (last 30 days)\n    if (Test-NewIPAddress -Username $Username -IPAddress $IPAddress) {\n        $riskScore += 20\n        $riskFactors += \"New IP address: $IPAddress\"\n        Write-AlertLog \"[RISK +20] User $Username logging in from new IP: $IPAddress\"\n    }\n\n    # Risk Factor 2: Outside Business Hours\n    if (Test-BusinessHours -LoginTime $LoginTime) {\n        $riskScore += 15\n        $riskFactors += \"Outside business hours: $($LoginTime.ToString())\"\n        Write-AlertLog \"[RISK +15] User $Username logging in outside business hours\"\n    }\n\n    # Risk Factor 3: Failed Login Attempts\n    $failedCount = Get-FailedLoginCount -Username $Username -IPAddress $IPAddress\n    if ($failedCount -gt 3) {\n        $riskScore += 25\n        $riskFactors += \"Multiple failed attempts: $failedCount\"\n        Write-AlertLog \"[RISK +25] User $Username has $failedCount failed login attempts\"\n    }\n\n    # Risk Factor 4: Geographic Location\n    if ($IPAddress -notmatch \"^(10\\.|172\\.(1[6-9]|2[0-9]|3[01])\\.|192\\.168\\.)\") {\n        $geoInfo = Get-IPGeolocation -IPAddress $IPAddress\n        if ($geoInfo -and $geoInfo.Country -notin $AllowedCountries) {\n            $riskScore += 30\n            $riskFactors += \"Foreign country login: $($geoInfo.Country)\"\n            Write-AlertLog \"[RISK +30] User $Username logging in from $($geoInfo.Country)\"\n        }\n    }\n\n    # Risk Factor 5: Privilege Level (check if admin/privileged account)\n    try {\n        $userObj = Get-LocalUser -Name $Username -ErrorAction SilentlyContinue\n        if ($null -eq $userObj) {\n            $userObj = Get-ADUser -Identity $Username -ErrorAction SilentlyContinue\n        }\n\n        $isPrivileged = $false\n        $groups = Get-LocalGroup | Where-Object {\n            (Get-LocalGroupMember -Group $_.Name -ErrorAction SilentlyContinue).Name -contains $Username\n        }\n\n        if ($groups.Name -contains \"Administrators\" -or $groups.Name -contains \"Domain Admins\") {\n            $isPrivileged = $true\n            $riskScore += 10\n            $riskFactors += \"Privileged account access\"\n            Write-AlertLog \"[RISK +10] Privileged account $Username attempting login\"\n        }\n    } catch {\n        # Unable to determine privilege level\n    }\n\n    return @{\n        Score = $riskScore\n        Factors = $riskFactors\n    }\n}\n\nfunction Send-HighRiskAlert {\n    param(\n        [string]$Username,\n        [string]$IPAddress,\n        [int]$RiskScore,\n        [array]$RiskFactors\n    )\n\n    $subject = \"HIGH RISK LOGIN DETECTED - $Username\"\n    $body = @\"\nA high-risk login attempt has been detected and requires additional verification.\n\nUsername: $Username\nSource IP: $IPAddress\nRisk Score: $RiskScore / 100\nTimestamp: $(Get-Date -Format \"yyyy-MM-dd HH:mm:ss\")\n\nRisk Factors:\n$($RiskFactors | ForEach-Object { \"- $($_)\" } | Out-String)\n\nAction Required: Verify user identity through secondary authentication channel.\n\nThis alert was generated by the Adaptive Authentication monitoring system (IA-10).\n\"@\n\n    # Log the alert\n    Write-AlertLog \"HIGH RISK LOGIN - Score: $RiskScore - User: $Username - IP: $IPAddress\"\n\n    # Send email alert (requires SMTP configuration)\n    try {\n        # Send-MailMessage -To $AlertEmail -Subject $subject -Body $body -SmtpServer \"smtp.organization.com\"\n        Write-Host \"Alert would be sent to: $AlertEmail\" -ForegroundColor Yellow\n    } catch {\n        Write-AlertLog \"ERROR: Failed to send email alert - $_\"\n    }\n\n    # Trigger additional authentication requirement\n    # This would integrate with your IDP/MFA system\n    # Example: Invoke-RestMethod -Uri \"https://idp.organization.com/api/require-mfa\" -Method Post -Body @{username=$Username}\n}\n\n# Main monitoring loop\nWrite-AlertLog \"Starting Adaptive Authentication monitoring (IA-10 compliance)\"\n\n$lastEventId = 0\n\nwhile ($true) {\n    try {\n        # Monitor successful authentication events (Event ID 4624 - successful logon)\n        $events = Get-WinEvent -FilterHashtable @{\n            LogName = 'Security'\n            ID = 4624\n        } -MaxEvents 10 -ErrorAction SilentlyContinue\n\n        foreach ($event in $events) {\n            if ($event.RecordId -le $lastEventId) { continue }\n\n            # Extract authentication details\n            $username = $event.Properties[5].Value\n            $logonType = $event.Properties[8].Value\n            $sourceIP = $event.Properties[18].Value\n            $loginTime = $event.TimeCreated\n\n            # Only analyze interactive and network logons (types 2, 3, 10)\n            if ($logonType -in @(2, 3, 10) -and $sourceIP -and $sourceIP -ne \"-\") {\n\n                # Calculate risk score\n                $riskAssessment = Get-AuthenticationRiskScore -Username $username -IPAddress $sourceIP -LoginTime $loginTime\n\n                if ($riskAssessment.Score -ge $RiskHighThreshold) {\n                    Send-HighRiskAlert -Username $username -IPAddress $sourceIP -RiskScore $riskAssessment.Score -RiskFactors $riskAssessment.Factors\n                }\n                elseif ($riskAssessment.Score -ge $RiskMediumThreshold) {\n                    Write-AlertLog \"MEDIUM RISK LOGIN - Score: $($riskAssessment.Score) - User: $username - IP: $sourceIP\"\n                }\n                else {\n                    Write-AlertLog \"LOW RISK LOGIN - Score: $($riskAssessment.Score) - User: $username - IP: $sourceIP\"\n                }\n            }\n\n            $lastEventId = $event.RecordId\n        }\n\n        # Sleep before next check\n        Start-Sleep -Seconds 30\n\n    } catch {\n        Write-AlertLog \"ERROR in monitoring loop: $_\"\n        Start-Sleep -Seconds 60\n    }\n}\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "reviewed_by": "loveless",
      "verification_date": "2025-11-20"
    },
    "cac_metadata": {
      "implementation_type": "policy",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "cac_status": "not_applicable",
      "cac_planned": false,
      "implementation_guidance": "IA-10 Adaptive Authentication is typically implemented at the Identity Provider (IDP) level rather than through system configuration tools. This control requires organizational policy decisions and integration with authentication infrastructure (SAML, OIDC, OAuth2). ComplianceAsCode does not provide automated configuration for adaptive authentication as it involves risk assessment algorithms, behavioral analytics, and supplemental authentication orchestration that must be configured within enterprise identity management platforms such as Okta, Auth0, Azure AD, Ping Identity, or similar solutions. The provided scripts offer monitoring and alerting capabilities to support adaptive authentication requirements but do not replace dedicated IDP-level implementations."
    },
    "stig_mappings": [],
    "ai_guidance": "IA-10 Adaptive Authentication requires dynamically adjusting authentication based on risk. Implement risk-based authentication that considers location, device, behavior. Step up authentication for high-risk transactions. Use continuous authentication for sensitive sessions."
  },
  {
    "control_id": "IA-11",
    "control_name": "Re-authentication",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Require users to re-authenticate when {{ insert: param, ia-11_odp }}.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must require users to re-enter their credentials (username and password or other authentication factors) under specific circumstances defined by organizational policy. These circumstances typically include: after a period of inactivity, when roles or privileges change, when accessing particularly sensitive functions or data, when security categories of systems change, or when executing privileged operations. Re-authentication ensures that the person currently using a system session is still the authorized user who originally authenticated.",
    "enhanced_guidance": "Re-authentication (IA-11) is a critical security control that prevents unauthorized access resulting from unattended sessions, credential compromise, or privilege escalation without proper authorization. This control addresses the scenario where an authenticated user walks away from their workstation, temporarily transfers control to another individual, or attempts to access resources or perform actions beyond their current authorization level.\n\nOrganizations must define specific circumstances requiring re-authentication through the IA-11_ODP (Organization-Defined Parameter). NIST SP 800-53 Rev 5 guidance specifies that organizations may require re-authentication when:\n\n1. **Device Locks and Inactivity Timeouts**: Federal systems must implement automatic session locks after defined periods of user inactivity. DISA Security Technical Implementation Guides (STIGs) mandate 15 minutes or less for Windows systems and 10-15 minutes for Linux systems, requiring users to re-authenticate to resume their session.\n\n2. **Role or Privilege Changes**: When users attempt to elevate privileges (e.g., using sudo on Linux or Run as Administrator on Windows), systems must require re-authentication. This prevents unauthorized privilege escalation from an already-authenticated session.\n\n3. **Authenticator or Credential Changes**: When users modify their passwords, reset multi-factor authentication devices, or update authentication credentials, systems must require re-authentication with current credentials before allowing the change.\n\n4. **Security Category Changes**: When accessing systems or data classified at a higher security level than the current session, re-authentication is required. For example, moving from an unclassified system to a system processing classified information.\n\n5. **Privileged Function Execution**: Critical operations such as system configuration changes, security policy modifications, user account management, or audit log access must require re-authentication immediately before execution.\n\n6. **Fixed Time Periods**: Some organizations implement time-based re-authentication (e.g., every 8 hours) regardless of activity, particularly for high-value systems or privileged accounts.\n\nImplementation varies by platform:\n\n**Windows Server 2019/2022**: Configure the \"Interactive logon: Machine inactivity limit\" Group Policy setting to 900 seconds (15 minutes) or less via Computer Configuration >> Windows Settings >> Security Settings >> Local Policies >> Security Options. This automatically locks workstations and requires re-authentication. For Remote Desktop Protocol (RDP) sessions, configure session timeout policies separately through Remote Desktop Session Host Configuration.\n\n**RHEL 8 / Linux Systems**: Implement multiple re-authentication mechanisms:\n- Configure tmux session locks: Set \"lock-after-time 900\" in /etc/tmux.conf for terminal multiplexer sessions\n- SSH session timeouts: Configure \"ClientAliveInterval 600\" and \"ClientAliveCountMax 0\" in /etc/ssh/sshd_config\n- Sudo re-authentication: Set \"Defaults timestamp_timeout=0\" in /etc/sudoers.d/ to require password entry for each sudo invocation\n- GNOME desktop lock: Configure automatic screen lock through gsettings or dconf\n\n**Integration with Related Controls**: IA-11 operates synergistically with AC-11 (Session Lock), AC-3 (Access Enforcement), IA-2 (Identification and Authentication for Organizational Users), IA-3 (Device Identification and Authentication), IA-4 (Identifier Management), and IA-8 (Identification and Authentication for Non-Organizational Users). Organizations must ensure re-authentication mechanisms integrate with centralized identity management systems (Active Directory, LDAP, SAML, OAuth) while maintaining audit trails of re-authentication events.\n\n**Security Benefits**: Re-authentication mitigates multiple attack vectors including session hijacking, privilege escalation attacks, insider threats from unattended terminals, and credential sharing. When combined with multi-factor authentication (MFA), re-authentication provides defense-in-depth by requiring proof of identity even when session tokens remain valid.\n\n**Audit and Assessment**: Organizations must log all re-authentication attempts, failures, and policy bypasses to support security monitoring and incident response. Assessment procedures should verify: documented organizational policies defining re-authentication circumstances, technical enforcement through system configurations, user awareness of re-authentication requirements, and audit log completeness for re-authentication events.",
    "example_implementation": "Technical implementation scripts are provided for Windows Server 2019/2022 (PowerShell), RHEL 8 (Bash), Ubuntu 22.04 (Bash), and cross-platform Ansible playbooks. These scripts assess re-authentication configurations including: Windows Interactive Logon Machine Inactivity Limit registry settings, RDP session timeout policies, Linux tmux lock-after-time configurations, SSH ClientAliveInterval settings, sudo timestamp_timeout directives, and GNOME/KDE desktop lock policies. All scripts are read-only compliance assessment tools that generate JSON-formatted reports indicating compliance status. Exit codes: 0 = fully compliant, 1 = non-compliant configurations detected, 2 = assessment error. Scripts are idempotent and safe for production environments.",
    "non_technical_guidance": "To implement re-authentication requirements that protect your organization's systems and data, follow these steps:\n\n1. **Define Re-authentication Policy**: Work with your security team to document when users must re-authenticate. Common requirements include: after 15 minutes of inactivity, before accessing sensitive data, when changing from regular to administrative privileges, and when modifying security settings. Document these circumstances in your organization's security policy.\n\n2. **Configure Automatic Session Locks**: Ensure all workstations and servers automatically lock screens after a defined period of user inactivity. For Windows systems, configure Group Policy to set the \"Interactive logon: Machine inactivity limit\" to 15 minutes (900 seconds) or less. For Linux systems, configure screen saver locks in desktop environments and terminal timeout settings.\n\n3. **Implement Privilege Escalation Controls**: Require users to enter their password every time they perform administrative tasks, even if they recently authenticated. On Windows, ensure \"Run as Administrator\" always prompts for credentials. On Linux, configure sudo to require password entry for each privileged command by setting the timestamp timeout to zero.\n\n4. **Configure Remote Access Timeouts**: Set automatic disconnection for inactive remote desktop sessions, SSH connections, and VPN sessions. Remote sessions pose higher security risks and should have shorter timeout periods than local console sessions.\n\n5. **Deploy Multi-Factor Authentication**: Combine re-authentication with multi-factor authentication (MFA) for sensitive operations. Users should present both something they know (password) and something they have (security token, authenticator app) when re-authenticating after inactivity or before privileged actions.\n\n6. **Train Users on Security Rationale**: Educate users why re-authentication requirements exist and how they protect both organizational assets and user accounts. Users should understand that session locks prevent unauthorized access if they leave their desk, and privilege re-authentication prevents malware from silently escalating privileges.\n\n7. **Test Configurations**: Verify that session locks activate after the defined timeout period, that locked sessions cannot be bypassed without re-authentication, and that audit logs capture re-authentication events. Test on representative systems including workstations, servers, and remote access platforms.\n\n8. **Document Organizational Parameters**: Clearly specify in your System Security Plan (SSP) the circumstances requiring re-authentication (IA-11_ODP parameter). Examples: \"Users must re-authenticate after 15 minutes of inactivity, when elevating privileges, when accessing systems containing PII or classified data, and after any role change.\"\n\n9. **Monitor Compliance**: Implement automated compliance scanning using the provided assessment scripts or commercial compliance tools. Generate monthly reports showing which systems meet re-authentication requirements and which require remediation.\n\n10. **Handle Exceptions Appropriately**: Some systems (e.g., kiosk displays, monitoring dashboards, automated service accounts) may require exceptions to re-authentication requirements. Document all exceptions with risk acceptance from appropriate authority, implement compensating controls, and review exceptions annually.\n\n11. **Integrate with Incident Response**: Ensure your Security Operations Center (SOC) monitors for suspicious patterns such as: repeated re-authentication failures, re-authentication bypasses, unusual privilege escalation requests, or re-authentication from unexpected locations. These may indicate compromised credentials or insider threats.\n\n12. **Regular Policy Review**: Review and update re-authentication requirements annually or when threat landscape changes. Consider shortening timeout periods for high-value systems, expanding MFA requirements, or implementing continuous authentication technologies for sensitive environments.",
    "is_technical": true,
    "requires_automation": true,
    "enhancements": [],
    "related_controls": [
      "AC-3",
      "AC-11",
      "IA-2",
      "IA-3",
      "IA-4",
      "IA-8"
    ],
    "supplemental_guidance": "In addition to the re-authentication requirements associated with device locks (AC-11), organizations may require re-authentication of individuals in certain situations including when roles, authenticators, or credentials change, when security categories of systems change, when the execution of privileged functions occurs, after a fixed time period, or periodically. Re-authentication requirements are defined through organization-defined circumstances (IA-11_ODP) documented in organizational security policies and System Security Plans. Implementation must account for different session types (local console, Remote Desktop Protocol, Secure Shell, web applications) and different privilege levels (standard user, privileged user, administrator). Organizations should consider user experience impacts when defining re-authentication frequency, balancing security requirements against operational efficiency. Re-authentication mechanisms must integrate with enterprise identity and access management infrastructure while maintaining comprehensive audit logs. For cloud-based systems and applications, re-authentication policies should extend to API access, service-to-service authentication, and federated identity scenarios.",
    "stig_mappings": {
      "windows": [
        {
          "stig_id": "V-254456",
          "rule_id": "WN22-SO-000120",
          "version": "Windows Server 2022 STIG v2r4",
          "severity": "CAT II",
          "requirement": "Windows Server 2022 machine inactivity limit must be set to 15 minutes or less, locking the system with the screen saver."
        },
        {
          "stig_id": "V-205633",
          "rule_id": "WN19-SO-000120",
          "version": "Windows Server 2019 STIG v2r5",
          "severity": "CAT II",
          "requirement": "Windows Server 2019 machine inactivity limit must be set to 15 minutes or less, locking the system with the screen saver."
        }
      ],
      "linux": [
        {
          "stig_id": "V-230353",
          "rule_id": "RHEL-08-020040",
          "version": "RHEL 8 STIG v1r6",
          "severity": "CAT II",
          "requirement": "RHEL 8 must automatically lock command line user sessions after 15 minutes of inactivity."
        },
        {
          "stig_id": "V-244525",
          "rule_id": "RHEL-08-010201",
          "version": "RHEL 8 STIG v1r8",
          "severity": "CAT II",
          "requirement": "The RHEL 8 SSH daemon must be configured with a timeout interval of 10 minutes or less to automatically terminate idle sessions."
        },
        {
          "stig_id": "V-230380",
          "rule_id": "RHEL-08-010384",
          "version": "RHEL 8 STIG v1r6",
          "severity": "CAT II",
          "requirement": "RHEL 8 must require users to reauthenticate for privilege escalation when using the sudo command."
        }
      ]
    },
    "references": {
      "nist": [
        "SP 800-53 Rev 5: IA-11 Re-authentication",
        "SP 800-63B: Digital Identity Guidelines - Authentication and Lifecycle Management",
        "SP 800-171: Protecting Controlled Unclassified Information in Nonfederal Systems and Organizations"
      ],
      "csf": [
        "NIST CSF v1.1: PR.AC-1, PR.AC-7",
        "NIST CSF v2.0: PR.AA-01, PR.AA-06"
      ],
      "disa": [
        "Windows Server 2022 STIG v2r4",
        "Windows Server 2019 STIG v2r5",
        "RHEL 8 STIG v1r8"
      ]
    },
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T18:30:00Z",
      "has_scripts": true,
      "enhanced_by": "loveless-IA-11",
      "validation_status": "qa_approved",
      "compliance_frameworks": [
        "NIST SP 800-53 Rev 5",
        "DISA STIG",
        "FedRAMP",
        "NIST CSF"
      ]
    },
    "ai_guidance": "IA-11 Re-authentication requires re-authenticating users under defined conditions. Force re-authentication for sensitive operations. Implement session timeout re-authentication. Require re-auth after privilege elevation."
  },
  {
    "control_id": "IA-12",
    "control_name": "Identity Proofing",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "a. Identity proof users that require accounts for logical access to systems based on appropriate identity assurance level requirements as specified in applicable standards and guidelines;\nb. Resolve user identities to a unique individual; and\nc. Collect, validate, and verify identity evidence.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must verify the real-world identity of users before granting them system access accounts. This identity proofing process involves three critical steps: first, validating identity claims against appropriate assurance level standards such as NIST SP 800-63A which defines IAL1, IAL2, and IAL3 levels; second, ensuring each user identity maps to a single unique individual to prevent identity confusion or fraud; and third, systematically collecting, validating, and verifying identity evidence such as government-issued identification documents, biometric data, or other trusted credentials. The rigor of identity proofing must match the sensitivity of the systems and data being accessed, with higher assurance levels requiring stronger evidence and verification methods. This control is fundamental to establishing trustworthy digital identities and preventing unauthorized access through identity fraud, account takeover, or credential misuse.",
    "example_implementation": "Implement an identity proofing workflow using NIST SP 800-63A guidelines. For moderate-risk systems requiring IAL2, establish a registration process where users submit one piece of STRONG evidence (such as a passport or driver's license) and one piece of FAIR evidence (such as a utility bill or bank statement). Deploy identity verification software that performs document authentication checks including security feature validation, barcode scanning, and optical character recognition to confirm document authenticity. Integrate with third-party identity verification services to validate provided information against authoritative data sources such as DMV records, credit bureaus, or government databases. Implement biometric comparison using facial recognition technology to match submitted photos against photo identification documents. Maintain detailed audit logs of all identity proofing activities including evidence collected, validation methods applied, verification results, and the identity assurance level achieved. For high-risk systems requiring IAL3, mandate in-person identity proofing at designated registration authority locations where trained staff verify original physical documents and capture biometric data directly. Store identity proofing records securely with appropriate access controls and retention policies aligned with privacy requirements and organizational policy.",
    "non_technical_guidance": "To comply with control IA-12 (Identity Proofing), follow these comprehensive steps:\n1. Determine the appropriate identity assurance level (IAL) for your systems based on the sensitivity of data and operations, referencing NIST SP 800-63A which defines three levels: IAL1 requires no identity proofing with self-asserted attributes; IAL2 requires remote or in-person proofing with validated identity evidence; IAL3 requires in-person proofing with physical document verification and biometric comparison.\n2. Establish formal identity proofing procedures that specify what types of identity evidence are acceptable for each IAL level, how evidence will be collected and stored securely, what validation methods will be used to confirm evidence authenticity, and what verification processes will link the claimed identity to the actual individual.\n3. Designate trained registration authorities or identity proofing personnel who are responsible for conducting identity verification, checking document authenticity, comparing photographic evidence to the individual, and making final determinations on identity proofing success or failure.\n4. Implement technology solutions to support identity proofing such as document scanning and authentication tools, biometric capture and comparison systems, integration with authoritative data sources for identity validation, and secure identity management systems to store proofing records and manage user accounts.\n5. Ensure each user identity resolves to a unique individual by checking for duplicate accounts, implementing naming conventions that prevent confusion, maintaining authoritative identity records, and establishing procedures to handle situations where multiple individuals share similar names or attributes.\n6. Develop privacy protections for identity proofing processes including obtaining informed consent from users before collecting identity information, limiting collection to the minimum necessary evidence, securing identity data with encryption and access controls, establishing appropriate retention and disposal procedures, and providing transparency about how identity information will be used.\n7. Create audit and oversight mechanisms to monitor identity proofing quality including periodic reviews of identity proofing decisions, sampling of proofing records to verify compliance with procedures, tracking of proofing failure rates and reasons, and analysis of potential fraud indicators or suspicious patterns.\n8. Establish procedures for handling special cases such as non-citizens without standard government-issued identification, individuals with legal name changes or aliases, accommodation requests for individuals with disabilities, and emergency access situations where standard proofing may not be feasible.\n9. Provide training to all personnel involved in identity proofing on verification procedures, document authentication techniques, fraud detection, privacy requirements, and escalation procedures for suspicious cases or edge scenarios.\n10. Coordinate with legal counsel and privacy officials to ensure identity proofing practices comply with applicable laws and regulations such as the Privacy Act, E-Government Act, and agency-specific requirements regarding collection and use of personally identifiable information.",
    "implementation_guidance": "Identity proofing represents a critical organizational process that establishes the foundation for all subsequent authentication and access control decisions. Organizations should select identity assurance levels based on a risk assessment considering factors including the sensitivity of information accessed, potential impact of identity fraud, regulatory requirements, user population characteristics, and operational constraints. The identity proofing process should be designed to detect and prevent common fraud techniques such as synthetic identities created by combining real and fake information, stolen identities using authentic documents belonging to other individuals, counterfeit documents with fabricated information, and identity laundering where criminals establish seemingly legitimate identities over time. Implementation should leverage automated identity verification technologies while maintaining human oversight for exception handling and final decision-making. Organizations should establish clear criteria for what constitutes acceptable identity evidence, recognizing that different populations may have access to different types of documentation and that evidence standards should be inclusive while maintaining security. The identity proofing process should be documented in detail with standard operating procedures covering all scenarios including successful verification, failed verification requiring additional evidence, and suspected fraud requiring investigation. Quality assurance mechanisms should include supervisory review of identity proofing decisions, periodic audits of proofing records against procedures, analysis of fraud patterns and indicators, and continuous improvement based on lessons learned. Organizations should coordinate identity proofing practices across systems to avoid unnecessary re-proofing of the same individuals while ensuring appropriate assurance levels are maintained for each access context. Privacy considerations must be integrated throughout the identity proofing lifecycle including minimizing data collection to essential elements, providing transparency to users about how their information will be used, implementing strong security controls to protect identity data, and establishing retention limits to dispose of identity information when no longer needed. For organizations implementing federated identity arrangements, clear agreements should define acceptable identity proofing standards, mechanisms for communicating assurance levels across organizational boundaries, and procedures for accepting or rejecting externally-proofed identities.",
    "ai_guidance": "IA-12 Identity Proofing requires verifying user identity before account creation. Implement NIST SP 800-63A identity proofing. Collect and verify identity evidence. Perform address confirmation. Document proofing decisions.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-5",
      "IA-1",
      "IA-2",
      "IA-3",
      "IA-4",
      "IA-5",
      "IA-6",
      "IA-8"
    ],
    "supplemental_guidance": "Identity proofing is the process of collecting, validating, and verifying a user's identity information for the purposes of establishing credentials for accessing a system. Identity proofing is intended to mitigate threats to the registration of users and the establishment of their accounts. Standards and guidelines specifying identity assurance levels for identity proofing include NIST SP 800-63-3 and SP 800-63A. Organizations may be subject to laws, executive orders, directives, regulations, or policies that address the collection of identity evidence. Organizational personnel consult with the senior agency official for privacy and legal counsel regarding such requirements.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-12: Identity Proofing - User Registration Audit Configuration\n# This script configures system logging for user registration and identity proofing activities\n\nset -euo pipefail\n\nLOG_TAG=\"IA-12-IDENTITY-PROOFING\"\nAUDIT_RULES_FILE=\"/etc/audit/rules.d/ia-12-identity-proofing.rules\"\nRSYSLOG_CONF=\"/etc/rsyslog.d/50-identity-proofing.conf\"\n\nlog_message() {\n    logger -t \"${LOG_TAG}\" -p user.info \"$1\"\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S')] $1\"\n}\n\nlog_message \"Starting IA-12 Identity Proofing audit configuration\"\n\n# Configure auditd rules for user account creation and modification\nlog_message \"Configuring auditd rules for identity proofing events\"\n\ncat > \"${AUDIT_RULES_FILE}\" <<'EOF'\n## IA-12: Identity Proofing - User Registration and Identity Verification Audit Rules\n\n# Monitor user account creation\n-w /usr/sbin/useradd -p x -k identity_proofing_user_creation\n-w /usr/sbin/usermod -p x -k identity_proofing_user_modification\n-w /usr/sbin/userdel -p x -k identity_proofing_user_deletion\n\n# Monitor password and authentication changes\n-w /etc/passwd -p wa -k identity_proofing_passwd_changes\n-w /etc/shadow -p wa -k identity_proofing_shadow_changes\n-w /etc/group -p wa -k identity_proofing_group_changes\n-w /etc/gshadow -p wa -k identity_proofing_gshadow_changes\n\n# Monitor SSH key management for identity binding\n-w /etc/ssh/authorized_keys -p wa -k identity_proofing_ssh_keys\n-w /home -p wa -k identity_proofing_user_home\n\n# Monitor authentication configuration changes\n-w /etc/pam.d/ -p wa -k identity_proofing_pam_config\n-w /etc/nsswitch.conf -p wa -k identity_proofing_nsswitch\n\n# Monitor sudo configuration for privilege escalation tracking\n-w /etc/sudoers -p wa -k identity_proofing_sudoers\n-w /etc/sudoers.d/ -p wa -k identity_proofing_sudoers_d\n\n# Monitor identity provider integrations (LDAP, AD, etc.)\n-w /etc/sssd/sssd.conf -p wa -k identity_proofing_sssd\n-w /etc/ldap.conf -p wa -k identity_proofing_ldap\n-w /etc/openldap/ldap.conf -p wa -k identity_proofing_openldap\n\n# System call auditing for user/group operations\n-a always,exit -F arch=b64 -S setuid -S setgid -S setreuid -S setregid -F auid>=1000 -F auid!=unset -k identity_proofing_setuid\n-a always,exit -F arch=b32 -S setuid -S setgid -S setreuid -S setregid -F auid>=1000 -F auid!=unset -k identity_proofing_setuid\nEOF\n\nif [ $? -eq 0 ]; then\n    log_message \"Auditd rules configured successfully\"\nelse\n    log_message \"ERROR: Failed to configure auditd rules\"\n    exit 1\nfi\n\n# Configure rsyslog for centralized identity proofing logging\nlog_message \"Configuring rsyslog for identity proofing event collection\"\n\ncat > \"${RSYSLOG_CONF}\" <<'EOF'\n# IA-12: Identity Proofing - Centralized Logging Configuration\n\n# Log all user authentication events\nauth,authpriv.*                 /var/log/identity-proofing/auth.log\n\n# Log all user account management events\nif $programname == 'useradd' or $programname == 'usermod' or $programname == 'userdel' then {\n    action(type=\"omfile\" file=\"/var/log/identity-proofing/account-management.log\")\n}\n\n# Log SSH authentication events with identity correlation\nif $programname == 'sshd' then {\n    action(type=\"omfile\" file=\"/var/log/identity-proofing/ssh-auth.log\")\n}\n\n# Log sudo events for privilege tracking\nif $programname == 'sudo' then {\n    action(type=\"omfile\" file=\"/var/log/identity-proofing/sudo-usage.log\")\n}\nEOF\n\nif [ $? -eq 0 ]; then\n    log_message \"Rsyslog configuration created successfully\"\nelse\n    log_message \"ERROR: Failed to configure rsyslog\"\n    exit 1\nfi\n\n# Create log directories with appropriate permissions\nlog_message \"Creating identity proofing log directories\"\nmkdir -p /var/log/identity-proofing\nchmod 750 /var/log/identity-proofing\nchown root:root /var/log/identity-proofing\n\n# Reload audit daemon to apply new rules\nlog_message \"Reloading auditd service\"\nif command -v augenrules >/dev/null 2>&1; then\n    augenrules --load\n    if [ $? -eq 0 ]; then\n        log_message \"Audit rules loaded successfully\"\n    else\n        log_message \"WARNING: Failed to load audit rules automatically\"\n        log_message \"Manual restart of auditd may be required\"\n    fi\nfi\n\n# Restart rsyslog to apply new configuration\nlog_message \"Restarting rsyslog service\"\nsystemctl restart rsyslog\nif [ $? -eq 0 ]; then\n    log_message \"Rsyslog restarted successfully\"\nelse\n    log_message \"ERROR: Failed to restart rsyslog\"\n    exit 1\nfi\n\n# Display configuration summary\nlog_message \"IA-12 Identity Proofing audit configuration completed successfully\"\nlog_message \"Audit logs location: /var/log/identity-proofing/\"\nlog_message \"Audit rules file: ${AUDIT_RULES_FILE}\"\nlog_message \"Rsyslog configuration: ${RSYSLOG_CONF}\"\nlog_message \"Identity proofing events will be logged for compliance verification\"\n\nexit 0",
        "description": "Configures comprehensive audit logging for user registration and identity proofing activities including account creation, authentication changes, SSH key management, and privilege escalation tracking. Implements centralized logging using auditd and rsyslog to capture all identity proofing events for compliance verification and forensic analysis."
      },
      "windows": {
        "powershell": "# IA-12: Identity Proofing - User Registration Audit Configuration\n# This script configures Windows audit policies and logging for identity proofing activities\n\n[CmdletBinding()]\nparam(\n    [switch]$Verbose\n)\n\n$ErrorActionPreference = \"Stop\"\n$LogTag = \"IA-12-IDENTITY-PROOFING\"\n$LogPath = \"C:\\ProgramData\\IdentityProofing\\Logs\"\n$AuditPolicyBackup = \"C:\\ProgramData\\IdentityProofing\\audit-policy-backup.csv\"\n\nfunction Write-ComplianceLog {\n    param([string]$Message, [string]$Level = \"Information\")\n    $Timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n    $LogMessage = \"[$Timestamp] [$Level] $Message\"\n    Write-Host $LogMessage\n    Write-EventLog -LogName \"Application\" -Source $LogTag -EntryType $Level -EventId 1001 -Message $Message -ErrorAction SilentlyContinue\n}\n\nfunction Initialize-ComplianceLogging {\n    Write-ComplianceLog \"Initializing IA-12 Identity Proofing compliance configuration\"\n    \n    # Create log directory if it doesn't exist\n    if (-not (Test-Path $LogPath)) {\n        New-Item -ItemType Directory -Path $LogPath -Force | Out-Null\n        Write-ComplianceLog \"Created log directory: $LogPath\"\n    }\n    \n    # Register custom event log source\n    if (-not [System.Diagnostics.EventLog]::SourceExists($LogTag)) {\n        New-EventLog -LogName \"Application\" -Source $LogTag\n        Write-ComplianceLog \"Registered event log source: $LogTag\"\n    }\n}\n\nfunction Backup-AuditPolicy {\n    Write-ComplianceLog \"Backing up current audit policy configuration\"\n    try {\n        $BackupDir = Split-Path $AuditPolicyBackup -Parent\n        if (-not (Test-Path $BackupDir)) {\n            New-Item -ItemType Directory -Path $BackupDir -Force | Out-Null\n        }\n        \n        auditpol /backup /file:\"$AuditPolicyBackup\" | Out-Null\n        Write-ComplianceLog \"Audit policy backed up to: $AuditPolicyBackup\"\n        return $true\n    }\n    catch {\n        Write-ComplianceLog \"ERROR: Failed to backup audit policy: $_\" \"Error\"\n        return $false\n    }\n}\n\nfunction Set-IdentityProofingAuditPolicy {\n    Write-ComplianceLog \"Configuring audit policies for identity proofing and user account management\"\n    \n    $AuditCategories = @(\n        # Account Management - Critical for identity proofing\n        @{Category=\"Account Management\"; Subcategory=\"User Account Management\"; Setting=\"Success,Failure\"},\n        @{Category=\"Account Management\"; Subcategory=\"Security Group Management\"; Setting=\"Success,Failure\"},\n        @{Category=\"Account Management\"; Subcategory=\"Other Account Management Events\"; Setting=\"Success,Failure\"},\n        @{Category=\"Account Management\"; Subcategory=\"Application Group Management\"; Setting=\"Success,Failure\"},\n        @{Category=\"Account Management\"; Subcategory=\"Distribution Group Management\"; Setting=\"Success,Failure\"},\n        \n        # Logon/Logoff - Identity verification events\n        @{Category=\"Logon/Logoff\"; Subcategory=\"Logon\"; Setting=\"Success,Failure\"},\n        @{Category=\"Logon/Logoff\"; Subcategory=\"Logoff\"; Setting=\"Success\"},\n        @{Category=\"Logon/Logoff\"; Subcategory=\"Account Lockout\"; Setting=\"Success,Failure\"},\n        @{Category=\"Logon/Logoff\"; Subcategory=\"User / Device Claims\"; Setting=\"Success\"},\n        \n        # Policy Change - Track authentication policy modifications\n        @{Category=\"Policy Change\"; Subcategory=\"Authentication Policy Change\"; Setting=\"Success,Failure\"},\n        @{Category=\"Policy Change\"; Subcategory=\"Authorization Policy Change\"; Setting=\"Success,Failure\"},\n        @{Category=\"Policy Change\"; Subcategory=\"Audit Policy Change\"; Setting=\"Success,Failure\"},\n        \n        # Privilege Use - Track privilege assignment during identity proofing\n        @{Category=\"Privilege Use\"; Subcategory=\"Sensitive Privilege Use\"; Setting=\"Success,Failure\"},\n        \n        # DS Access (for Active Directory environments)\n        @{Category=\"DS Access\"; Subcategory=\"Directory Service Access\"; Setting=\"Success,Failure\"},\n        @{Category=\"DS Access\"; Subcategory=\"Directory Service Changes\"; Setting=\"Success,Failure\"}\n    )\n    \n    $SuccessCount = 0\n    $FailureCount = 0\n    \n    foreach ($AuditConfig in $AuditCategories) {\n        try {\n            $Command = \"auditpol /set /subcategory:`\"$($AuditConfig.Subcategory)`\" /success:enable /failure:enable\"\n            Invoke-Expression $Command | Out-Null\n            Write-ComplianceLog \"Configured audit policy: $($AuditConfig.Subcategory)\"\n            $SuccessCount++\n        }\n        catch {\n            Write-ComplianceLog \"WARNING: Failed to configure $($AuditConfig.Subcategory): $_\" \"Warning\"\n            $FailureCount++\n        }\n    }\n    \n    Write-ComplianceLog \"Audit policy configuration completed: $SuccessCount succeeded, $FailureCount failed\"\n    return ($FailureCount -eq 0)\n}\n\nfunction Set-SecurityEventLogConfiguration {\n    Write-ComplianceLog \"Configuring Security Event Log settings for identity proofing compliance\"\n    \n    try {\n        # Increase Security log size to 512MB for comprehensive identity proofing audit trail\n        wevtutil sl Security /ms:536870912\n        Write-ComplianceLog \"Security log maximum size set to 512MB\"\n        \n        # Enable log overwrite prevention (archive when full)\n        wevtutil sl Security /ab:true\n        Write-ComplianceLog \"Security log auto-backup enabled\"\n        \n        # Set log retention\n        wevtutil sl Security /rt:true\n        Write-ComplianceLog \"Security log retention enabled\"\n        \n        return $true\n    }\n    catch {\n        Write-ComplianceLog \"ERROR: Failed to configure Security Event Log: $_\" \"Error\"\n        return $false\n    }\n}\n\nfunction Enable-AdvancedAuditPolicy {\n    Write-ComplianceLog \"Enabling advanced audit policy configuration\"\n    \n    try {\n        # Enable Advanced Audit Policy via registry\n        $RegPath = \"HKLM:\\System\\CurrentControlSet\\Control\\Lsa\"\n        Set-ItemProperty -Path $RegPath -Name \"SCENoApplyLegacyAuditPolicy\" -Value 1 -Type DWord -Force\n        Write-ComplianceLog \"Advanced audit policy configuration enabled\"\n        return $true\n    }\n    catch {\n        Write-ComplianceLog \"ERROR: Failed to enable advanced audit policy: $_\" \"Error\"\n        return $false\n    }\n}\n\nfunction Export-AuditConfiguration {\n    Write-ComplianceLog \"Exporting current audit configuration for verification\"\n    \n    try {\n        $ExportPath = \"$LogPath\\audit-configuration-$(Get-Date -Format 'yyyyMMdd-HHmmss').txt\"\n        auditpol /get /category:* | Out-File -FilePath $ExportPath -Encoding UTF8\n        Write-ComplianceLog \"Audit configuration exported to: $ExportPath\"\n        return $true\n    }\n    catch {\n        Write-ComplianceLog \"ERROR: Failed to export audit configuration: $_\" \"Error\"\n        return $false\n    }\n}\n\nfunction Test-AuditConfiguration {\n    Write-ComplianceLog \"Verifying identity proofing audit configuration\"\n    \n    $RequiredAudits = @(\n        \"User Account Management\",\n        \"Security Group Management\",\n        \"Logon\",\n        \"Account Lockout\",\n        \"Authentication Policy Change\"\n    )\n    \n    $ConfiguredCorrectly = $true\n    \n    foreach ($Audit in $RequiredAudits) {\n        $AuditStatus = auditpol /get /subcategory:\"$Audit\" 2>&1\n        if ($AuditStatus -match \"Success and Failure\") {\n            Write-ComplianceLog \"PASS: $Audit is configured correctly\"\n        }\n        else {\n            Write-ComplianceLog \"FAIL: $Audit is not configured correctly\" \"Warning\"\n            $ConfiguredCorrectly = $false\n        }\n    }\n    \n    return $ConfiguredCorrectly\n}\n\n# Main execution\ntry {\n    Write-ComplianceLog \"========================================\"\n    Write-ComplianceLog \"IA-12 Identity Proofing Audit Configuration\"\n    Write-ComplianceLog \"========================================\"\n    \n    Initialize-ComplianceLogging\n    \n    # Verify running with administrative privileges\n    $CurrentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())\n    if (-not $CurrentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n        Write-ComplianceLog \"ERROR: This script requires administrative privileges\" \"Error\"\n        exit 1\n    }\n    \n    # Backup current configuration\n    if (-not (Backup-AuditPolicy)) {\n        Write-ComplianceLog \"WARNING: Proceeding without backup\" \"Warning\"\n    }\n    \n    # Configure audit policies\n    Enable-AdvancedAuditPolicy | Out-Null\n    Set-IdentityProofingAuditPolicy | Out-Null\n    Set-SecurityEventLogConfiguration | Out-Null\n    \n    # Export and verify configuration\n    Export-AuditConfiguration | Out-Null\n    $VerificationResult = Test-AuditConfiguration\n    \n    if ($VerificationResult) {\n        Write-ComplianceLog \"========================================\"\n        Write-ComplianceLog \"IA-12 configuration completed successfully\"\n        Write-ComplianceLog \"All identity proofing audit policies configured\"\n        Write-ComplianceLog \"Logs location: $LogPath\"\n        Write-ComplianceLog \"========================================\"\n        exit 0\n    }\n    else {\n        Write-ComplianceLog \"WARNING: Some audit policies may not be configured correctly\" \"Warning\"\n        Write-ComplianceLog \"Review log file for details\"\n        exit 1\n    }\n}\ncatch {\n    Write-ComplianceLog \"CRITICAL ERROR: $($_.Exception.Message)\" \"Error\"\n    Write-ComplianceLog \"Stack trace: $($_.ScriptStackTrace)\" \"Error\"\n    exit 1\n}",
        "description": "Configures comprehensive Windows audit policies for identity proofing compliance including user account management, authentication events, privilege usage, and Active Directory changes. Implements Security Event Log configuration with appropriate size limits, retention policies, and backup settings to maintain complete audit trails for identity verification activities."
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000+00:00",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-20T00:00:00.000000+00:00",
      "source": "NIST SP 800-53 Rev 5",
      "implementation_guidance": "IA-12 requires organizational identity proofing processes aligned with NIST SP 800-63A identity assurance levels. While technical controls can audit user registration and support identity verification workflows, the core identity proofing function involves organizational procedures, personnel training, identity evidence collection, validation against authoritative sources, and verification methods. Technical implementations should focus on logging identity proofing events, integrating with identity verification services, and maintaining audit trails for compliance verification."
    }
  },
  {
    "control_id": "IA-13",
    "control_name": "Identity Providers and Authorization Servers",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Employ identity providers and authorization servers to manage user, device, and non-person entity (NPE) identities, attributes, and access rights supporting authentication and authorization decisions in accordance with [Assignment: organization-defined policy] using [Assignment: organization-defined technologies].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must deploy centralized identity provider (IdP) and authorization server infrastructure to manage authentication and authorization for users, devices, and non-person entities (NPEs) such as service accounts and automated processes. This control requires implementing OAuth 2.0, OpenID Connect, or equivalent standards-based protocols to enforce consistent access policies across enterprise systems while maintaining secure token lifecycle management and cryptographic protection of authentication credentials.",
    "example_implementation": "Deploy enterprise OAuth 2.0 authorization server using Keycloak or Azure AD with OpenID Connect protocol. Configure identity provider to issue JWT access tokens with 15-minute expiration, enforce PKCE for public clients, implement token rotation for refresh tokens, and integrate with LDAP/Active Directory for user authentication. Enable multi-factor authentication enforcement, implement audience restrictions per application, and configure automated token revocation on suspicious activity detection.",
    "non_technical_guidance": "To comply with control IA-13, organizations must implement centralized identity providers and authorization servers that manage authentication and authorization decisions for all users, devices, and non-person entities across the enterprise. This involves deploying standards-based authentication protocols such as OAuth 2.0 and OpenID Connect to create a single source of truth for identity management.\n\nImplementation requires the following strategic steps:\n\n1. Select enterprise-grade identity provider platform (Keycloak, Okta, Azure AD, Ping Identity) based on organizational scale, compliance requirements, and integration capabilities with existing infrastructure.\n\n2. Establish centralized authentication architecture that consolidates identity management from disparate systems into unified authorization server infrastructure supporting SAML 2.0, OAuth 2.0, and OpenID Connect protocols.\n\n3. Configure token lifecycle management policies including access token expiration (recommended 15 minutes maximum), refresh token rotation, audience restrictions per application, and automated revocation triggers based on risk signals.\n\n4. Integrate authorization server with enterprise directory services (LDAP, Active Directory, Azure AD) for user authentication while implementing device identity management for IoT and mobile endpoints.\n\n5. Deploy multi-factor authentication enforcement at the identity provider level with risk-based adaptive authentication policies that escalate authentication requirements based on user behavior, location, and access patterns.\n\n6. Implement comprehensive audit logging of all authentication events, token issuance, authorization decisions, and access attempts for security monitoring and compliance reporting.\n\n7. Establish governance procedures for non-person entity (NPE) identity management including service account registration, credential rotation, least-privilege authorization policies, and automated deprovisioning workflows.\n\n8. Train security teams on OAuth 2.0 security best practices, token management procedures, incident response for compromised credentials, and continuous monitoring of authorization server infrastructure.\n\n9. Conduct regular security assessments of identity provider configurations, review authorization policies for privilege creep, perform penetration testing of authentication flows, and validate token cryptographic protection mechanisms.\n\n10. Maintain disaster recovery and business continuity plans for identity provider infrastructure including high-availability deployment, backup authorization servers, and procedures for credential recovery during system outages.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "IA-13.1",
        "title": "Protection of Cryptographic Keys",
        "official_text": "Cryptographic keys that protect access tokens are generated, managed, and protected from disclosure and misuse."
      },
      {
        "id": "IA-13.2",
        "title": "Verification of Identity Assertions and Access Tokens",
        "official_text": "The source and integrity of identity assertions and access tokens are verified before granting access to system and information resources."
      },
      {
        "id": "IA-13.3",
        "title": "Token Management",
        "official_text": "In accordance with [Assignment: organization-defined policy], assertions and access tokens are generated, issued, refreshed, revoked, time-restricted, and audience-restricted."
      }
    ],
    "related_controls": [
      "AC-2",
      "AC-3",
      "AC-4",
      "AC-6",
      "AC-16",
      "AU-2",
      "AU-6",
      "IA-2",
      "IA-4",
      "IA-5",
      "IA-8",
      "IA-12",
      "SC-8",
      "SC-12",
      "SC-13"
    ],
    "supplemental_guidance": "Identity providers and authorization servers implement OAuth 2.0, OpenID Connect, or equivalent standards-based authentication and authorization protocols to establish secure federation of identity information across organizational boundaries. These systems manage the complete lifecycle of digital identities including provisioning, authentication, authorization, and deprovisioning for users, devices, and non-person entities. Organizations should implement token-based authentication using JWT (JSON Web Tokens) with cryptographic signing and encryption to protect authentication credentials during transmission and storage. The authorization server must enforce fine-grained access control policies based on user attributes, roles, context, and risk factors to support zero-trust security architecture principles. Implementation should include integration with existing enterprise directory services (LDAP, Active Directory) while supporting modern cloud-native identity management for hybrid and multi-cloud environments.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-13 Implementation: Deploy Keycloak Identity Provider and OAuth 2.0 Authorization Server\n# Platform: RHEL 8/9, Ubuntu 20.04+, Debian 11+\n# Prerequisites: Docker, PostgreSQL, OpenSSL\n\nset -euo pipefail\n\necho \"[INFO] Installing IA-13 - Identity Provider and Authorization Server\"\n\n# Install dependencies\nif command -v yum &> /dev/null; then\n    yum install -y docker postgresql postgresql-server openssl java-17-openjdk\n    systemctl enable --now docker postgresql\nelif command -v apt-get &> /dev/null; then\n    apt-get update\n    apt-get install -y docker.io postgresql postgresql-client openssl openjdk-17-jre\n    systemctl enable --now docker postgresql\nfi\n\n# Create PostgreSQL database for Keycloak\nsu - postgres -c \"psql -c \\\"CREATE DATABASE keycloak;\\\"\"\nsu - postgres -c \"psql -c \\\"CREATE USER keycloak_user WITH ENCRYPTED PASSWORD 'CHANGE_THIS_PASSWORD';\\\"\"\nsu - postgres -c \"psql -c \\\"GRANT ALL PRIVILEGES ON DATABASE keycloak TO keycloak_user;\\\"\"\n\n# Generate self-signed certificate for HTTPS (replace with valid cert in production)\nmkdir -p /opt/keycloak/certs\nopenssl req -newkey rsa:4096 -nodes -keyout /opt/keycloak/certs/keycloak.key \\\n    -x509 -days 365 -out /opt/keycloak/certs/keycloak.crt \\\n    -subj \"/C=US/ST=State/L=City/O=Organization/OU=IT/CN=keycloak.example.com\"\n\n# Deploy Keycloak via Docker\ndocker run -d --name keycloak \\\n    -p 8443:8443 \\\n    -e KEYCLOAK_ADMIN=admin \\\n    -e KEYCLOAK_ADMIN_PASSWORD='CHANGE_ADMIN_PASSWORD' \\\n    -e KC_DB=postgres \\\n    -e KC_DB_URL='jdbc:postgresql://host.docker.internal:5432/keycloak' \\\n    -e KC_DB_USERNAME=keycloak_user \\\n    -e KC_DB_PASSWORD='CHANGE_THIS_PASSWORD' \\\n    -e KC_HTTPS_CERTIFICATE_FILE=/opt/keycloak/certs/keycloak.crt \\\n    -e KC_HTTPS_CERTIFICATE_KEY_FILE=/opt/keycloak/certs/keycloak.key \\\n    -v /opt/keycloak/certs:/opt/keycloak/certs:ro \\\n    --restart unless-stopped \\\n    quay.io/keycloak/keycloak:latest start --optimized\n\n# Configure firewall\nif command -v firewall-cmd &> /dev/null; then\n    firewall-cmd --permanent --add-port=8443/tcp\n    firewall-cmd --reload\nfi\n\n# Create OAuth 2.0 configuration\ncat > /opt/keycloak/oauth2-policy.json <<'EOF'\n{\n  \"accessTokenLifespan\": 900,\n  \"ssoSessionIdleTimeout\": 1800,\n  \"ssoSessionMaxLifespan\": 36000,\n  \"clientSessionIdleTimeout\": 900,\n  \"refreshTokenMaxReuse\": 0,\n  \"revokeRefreshToken\": true,\n  \"bruteForceProtected\": true,\n  \"failureFactor\": 5,\n  \"waitIncrementSeconds\": 60,\n  \"maxFailureWaitSeconds\": 900,\n  \"maxDeltaTimeSeconds\": 43200\n}\nEOF\n\n# Enable audit logging\ncat > /opt/keycloak/audit-config.json <<'EOF'\n{\n  \"eventsEnabled\": true,\n  \"eventsListeners\": [\"jboss-logging\"],\n  \"enabledEventTypes\": [\n    \"LOGIN\",\n    \"LOGIN_ERROR\",\n    \"LOGOUT\",\n    \"CODE_TO_TOKEN\",\n    \"CLIENT_LOGIN\",\n    \"REFRESH_TOKEN\",\n    \"REVOKE_GRANT\",\n    \"UPDATE_TOTP\",\n    \"REMOVE_TOTP\",\n    \"VERIFY_EMAIL\",\n    \"RESET_PASSWORD\"\n  ],\n  \"adminEventsEnabled\": true,\n  \"adminEventsDetailsEnabled\": true\n}\nEOF\n\necho \"[SUCCESS] Keycloak Identity Provider deployed successfully\"\necho \"[INFO] Access admin console at https://localhost:8443/admin\"\necho \"[WARNING] Default credentials must be changed immediately\"\necho \"[WARNING] Replace self-signed certificates with valid TLS certificates\"\necho \"[INFO] Configure LDAP/AD integration through admin console\"\necho \"[INFO] Review OAuth 2.0 token policies in /opt/keycloak/oauth2-policy.json\"",
        "ansible": "---\n# IA-13 Implementation: Identity Provider and Authorization Server\n# Ansible Playbook for deploying Keycloak with OAuth 2.0/OIDC\n\n- name: Deploy IA-13 Identity Provider and Authorization Server\n  hosts: identity_servers\n  become: yes\n  vars:\n    keycloak_version: \"23.0.0\"\n    keycloak_admin_user: \"admin\"\n    keycloak_admin_password: \"{{ vault_keycloak_admin_password }}\"\n    postgres_db_name: \"keycloak\"\n    postgres_user: \"keycloak_user\"\n    postgres_password: \"{{ vault_postgres_password }}\"\n    token_lifespan_minutes: 15\n    refresh_token_rotation: true\n\n  tasks:\n    - name: Install prerequisite packages\n      package:\n        name:\n          - docker\n          - postgresql\n          - postgresql-server\n          - python3-psycopg2\n          - openssl\n          - java-17-openjdk\n        state: present\n\n    - name: Start and enable PostgreSQL\n      systemd:\n        name: postgresql\n        state: started\n        enabled: yes\n\n    - name: Create Keycloak database\n      postgresql_db:\n        name: \"{{ postgres_db_name }}\"\n        state: present\n      become_user: postgres\n\n    - name: Create Keycloak database user\n      postgresql_user:\n        db: \"{{ postgres_db_name }}\"\n        name: \"{{ postgres_user }}\"\n        password: \"{{ postgres_password }}\"\n        priv: ALL\n        state: present\n      become_user: postgres\n\n    - name: Create Keycloak certificate directory\n      file:\n        path: /opt/keycloak/certs\n        state: directory\n        mode: '0755'\n\n    - name: Generate self-signed certificate for Keycloak\n      openssl_certificate:\n        path: /opt/keycloak/certs/keycloak.crt\n        privatekey_path: /opt/keycloak/certs/keycloak.key\n        provider: selfsigned\n        force: no\n      register: cert_generated\n\n    - name: Deploy Keycloak container\n      docker_container:\n        name: keycloak\n        image: \"quay.io/keycloak/keycloak:{{ keycloak_version }}\"\n        state: started\n        restart_policy: unless-stopped\n        ports:\n          - \"8443:8443\"\n        env:\n          KEYCLOAK_ADMIN: \"{{ keycloak_admin_user }}\"\n          KEYCLOAK_ADMIN_PASSWORD: \"{{ keycloak_admin_password }}\"\n          KC_DB: postgres\n          KC_DB_URL: \"jdbc:postgresql://host.docker.internal:5432/{{ postgres_db_name }}\"\n          KC_DB_USERNAME: \"{{ postgres_user }}\"\n          KC_DB_PASSWORD: \"{{ postgres_password }}\"\n          KC_HTTPS_CERTIFICATE_FILE: /opt/keycloak/certs/keycloak.crt\n          KC_HTTPS_CERTIFICATE_KEY_FILE: /opt/keycloak/certs/keycloak.key\n          KC_HEALTH_ENABLED: \"true\"\n          KC_METRICS_ENABLED: \"true\"\n        volumes:\n          - /opt/keycloak/certs:/opt/keycloak/certs:ro\n        command: start --optimized\n\n    - name: Configure firewall for Keycloak HTTPS\n      firewalld:\n        port: 8443/tcp\n        permanent: yes\n        state: enabled\n        immediate: yes\n      when: ansible_os_family == \"RedHat\"\n\n    - name: Create OAuth 2.0 security policy configuration\n      copy:\n        dest: /opt/keycloak/oauth2-security-policy.json\n        content: |\n          {\n            \"accessTokenLifespan\": {{ token_lifespan_minutes * 60 }},\n            \"accessTokenLifespanForImplicitFlow\": 900,\n            \"ssoSessionIdleTimeout\": 1800,\n            \"ssoSessionMaxLifespan\": 36000,\n            \"offlineSessionIdleTimeout\": 2592000,\n            \"refreshTokenMaxReuse\": 0,\n            \"revokeRefreshToken\": {{ refresh_token_rotation | lower }},\n            \"clientSessionIdleTimeout\": 900,\n            \"clientSessionMaxLifespan\": 36000,\n            \"bruteForceProtected\": true,\n            \"permanentLockout\": false,\n            \"maxFailureWaitSeconds\": 900,\n            \"minimumQuickLoginWaitSeconds\": 60,\n            \"waitIncrementSeconds\": 60,\n            \"quickLoginCheckMilliSeconds\": 1000,\n            \"maxDeltaTimeSeconds\": 43200,\n            \"failureFactor\": 5\n          }\n        mode: '0644'\n\n    - name: Enable comprehensive audit logging\n      copy:\n        dest: /opt/keycloak/audit-logging.json\n        content: |\n          {\n            \"eventsEnabled\": true,\n            \"eventsExpiration\": 31536000,\n            \"eventsListeners\": [\"jboss-logging\"],\n            \"enabledEventTypes\": [\n              \"LOGIN\", \"LOGIN_ERROR\", \"LOGOUT\", \"LOGOUT_ERROR\",\n              \"CODE_TO_TOKEN\", \"CODE_TO_TOKEN_ERROR\",\n              \"CLIENT_LOGIN\", \"CLIENT_LOGIN_ERROR\",\n              \"REFRESH_TOKEN\", \"REFRESH_TOKEN_ERROR\",\n              \"REVOKE_GRANT\", \"UPDATE_TOTP\", \"REMOVE_TOTP\",\n              \"VERIFY_EMAIL\", \"VERIFY_EMAIL_ERROR\",\n              \"UPDATE_PASSWORD\", \"UPDATE_PASSWORD_ERROR\",\n              \"RESET_PASSWORD\", \"RESET_PASSWORD_ERROR\",\n              \"CLIENT_INITIATED_ACCOUNT_LINKING\",\n              \"TOKEN_EXCHANGE\", \"OAUTH2_DEVICE_AUTH\",\n              \"AUTHREQID_TO_TOKEN\", \"PERMISSION_TOKEN\"\n            ],\n            \"adminEventsEnabled\": true,\n            \"adminEventsDetailsEnabled\": true\n          }\n        mode: '0644'\n\n    - name: Configure SIEM integration for audit logs\n      lineinfile:\n        path: /etc/rsyslog.d/keycloak-audit.conf\n        line: \"*.* @@siem.example.com:514\"\n        create: yes\n      notify: restart rsyslog\n\n    - name: Create systemd service for Keycloak monitoring\n      copy:\n        dest: /etc/systemd/system/keycloak-healthcheck.service\n        content: |\n          [Unit]\n          Description=Keycloak Health Check Service\n          After=docker.service\n          Requires=docker.service\n          \n          [Service]\n          Type=oneshot\n          ExecStart=/usr/bin/curl -f https://localhost:8443/health/ready\n          StandardOutput=journal\n          \n          [Install]\n          WantedBy=multi-user.target\n      notify: reload systemd\n\n  handlers:\n    - name: restart rsyslog\n      systemd:\n        name: rsyslog\n        state: restarted\n\n    - name: reload systemd\n      systemd:\n        daemon_reload: yes"
      },
      "windows": {
        "powershell": "# IA-13 Implementation: Deploy Azure AD Integration and OAuth 2.0 Authorization\n# Platform: Windows Server 2019/2022\n# Prerequisites: PowerShell 5.1+, Azure AD Module, IIS, .NET Framework 4.8\n\n#Requires -RunAsAdministrator\n#Requires -Version 5.1\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n\nWrite-Host \"[INFO] Installing IA-13 - Identity Provider and Authorization Server\" -ForegroundColor Green\n\n# Install required PowerShell modules\nWrite-Host \"[INFO] Installing required PowerShell modules...\" -ForegroundColor Cyan\nif (-not (Get-Module -ListAvailable -Name AzureAD)) {\n    Install-Module -Name AzureAD -Force -AllowClobber -Scope AllUsers\n}\nif (-not (Get-Module -ListAvailable -Name Microsoft.Graph)) {\n    Install-Module -Name Microsoft.Graph -Force -AllowClobber -Scope AllUsers\n}\n\nImport-Module AzureAD\nImport-Module Microsoft.Graph.Identity.SignIns\n\n# Install IIS with required features for OAuth 2.0 endpoints\nWrite-Host \"[INFO] Installing IIS with authentication features...\" -ForegroundColor Cyan\nInstall-WindowsFeature -Name Web-Server, Web-WebServer, Web-Common-Http, `\n    Web-Default-Doc, Web-Dir-Browsing, Web-Http-Errors, Web-Static-Content, `\n    Web-Http-Redirect, Web-Health, Web-Http-Logging, Web-Performance, `\n    Web-Stat-Compression, Web-Security, Web-Filtering, Web-Windows-Auth, `\n    Web-Client-Auth, Web-Cert-Auth, Web-Url-Auth, Web-Mgmt-Tools, Web-Mgmt-Console\n\n# Configure IIS application pool for OAuth service\nImport-Module WebAdministration\n$appPoolName = \"OAuthAuthorizationServerPool\"\n$siteName = \"OAuth2AuthorizationServer\"\n$sitePath = \"C:\\inetpub\\oauth2server\"\n\nif (-not (Test-Path IIS:\\AppPools\\$appPoolName)) {\n    New-WebAppPool -Name $appPoolName\n    Set-ItemProperty IIS:\\AppPools\\$appPoolName -Name managedRuntimeVersion -Value 'v4.0'\n    Set-ItemProperty IIS:\\AppPools\\$appPoolName -Name enable32BitAppOnWin64 -Value $false\n    Set-ItemProperty IIS:\\AppPools\\$appPoolName -Name processModel.identityType -Value 'NetworkService'\n}\n\n# Create website directory structure\nNew-Item -Path $sitePath -ItemType Directory -Force | Out-Null\nNew-Item -Path \"$sitePath\\logs\" -ItemType Directory -Force | Out-Null\nNew-Item -Path \"$sitePath\\config\" -ItemType Directory -Force | Out-Null\n\n# Generate self-signed certificate for HTTPS (replace with valid cert in production)\n$cert = New-SelfSignedCertificate -DnsName \"oauth.example.com\" -CertStoreLocation \"Cert:\\LocalMachine\\My\" `\n    -KeyExportPolicy Exportable -KeySpec Signature -KeyLength 4096 -KeyAlgorithm RSA `\n    -HashAlgorithm SHA256 -NotAfter (Get-Date).AddYears(2)\n\n# Create HTTPS binding for OAuth site\nif (Get-Website -Name $siteName -ErrorAction SilentlyContinue) {\n    Remove-Website -Name $siteName\n}\n\nNew-Website -Name $siteName -Port 443 -Ssl -SslFlags 0 -PhysicalPath $sitePath `\n    -ApplicationPool $appPoolName -Force\n\nNew-WebBinding -Name $siteName -Protocol https -Port 443 -SslFlags 0\n$binding = Get-WebBinding -Name $siteName -Protocol https\n$binding.AddSslCertificate($cert.Thumbprint, \"My\")\n\n# Configure OAuth 2.0 authorization server policies\n$oauthConfig = @{\n    AccessTokenLifetimeMinutes = 15\n    RefreshTokenLifetimeDays = 90\n    RefreshTokenRotationEnabled = $true\n    MaxTokenReuseCount = 0\n    AudienceRestrictionEnabled = $true\n    RequirePKCE = $true\n    AllowedGrantTypes = @('authorization_code', 'refresh_token', 'client_credentials')\n    RequireMFA = $true\n    TokenRevocationEnabled = $true\n    BruteForceProtection = $true\n    MaxFailedAttempts = 5\n    LockoutDurationMinutes = 15\n}\n\n$oauthConfig | ConvertTo-Json -Depth 10 | Out-File -FilePath \"$sitePath\\config\\oauth-policy.json\" -Encoding UTF8\n\nWrite-Host \"[SUCCESS] OAuth 2.0 policy configuration saved to $sitePath\\config\\oauth-policy.json\" -ForegroundColor Green\n\n# Configure Azure AD application registration (requires manual Azure AD admin consent)\nWrite-Host \"[INFO] Configuring Azure AD integration...\" -ForegroundColor Cyan\nWrite-Host \"[WARNING] Azure AD authentication required - connecting...\" -ForegroundColor Yellow\n\ntry {\n    Connect-AzureAD -ErrorAction Stop\n    \n    # Create Azure AD application for OAuth 2.0\n    $appName = \"Enterprise OAuth Authorization Server\"\n    $replyUrl = \"https://oauth.example.com/signin-oidc\"\n    \n    $app = Get-AzureADApplication -Filter \"DisplayName eq '$appName'\" -ErrorAction SilentlyContinue\n    \n    if (-not $app) {\n        $app = New-AzureADApplication -DisplayName $appName `\n            -ReplyUrls @($replyUrl) `\n            -Oauth2AllowImplicitFlow $false `\n            -Oauth2RequirePostResponse $true `\n            -PublicClient $false\n        \n        Write-Host \"[SUCCESS] Azure AD application created: $($app.AppId)\" -ForegroundColor Green\n    } else {\n        Write-Host \"[INFO] Azure AD application already exists: $($app.AppId)\" -ForegroundColor Cyan\n    }\n    \n    # Configure required API permissions\n    $graphResourceId = \"00000003-0000-0000-c000-000000000000\" # Microsoft Graph\n    $permissions = @(\n        \"e1fe6dd8-ba31-4d61-89e7-88639da4683d\", # User.Read\n        \"64a6cdd6-aab1-4aaf-94b8-3cc8405e90d0\"  # email\n    )\n    \n    foreach ($permission in $permissions) {\n        $resourceAccess = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.RequiredResourceAccess\"\n        $resourceAccess.ResourceAppId = $graphResourceId\n        $resourceAccess.ResourceAccess = New-Object -TypeName \"Microsoft.Open.AzureAD.Model.ResourceAccess\" -ArgumentList $permission, \"Scope\"\n        Set-AzureADApplication -ObjectId $app.ObjectId -RequiredResourceAccess $resourceAccess\n    }\n    \n    # Store application configuration\n    $azureConfig = @{\n        TenantId = (Get-AzureADTenantDetail).ObjectId\n        ClientId = $app.AppId\n        Authority = \"https://login.microsoftonline.com/$((Get-AzureADTenantDetail).ObjectId)\"\n        RedirectUri = $replyUrl\n    }\n    \n    $azureConfig | ConvertTo-Json | Out-File -FilePath \"$sitePath\\config\\azure-ad-config.json\" -Encoding UTF8\n    \n    Write-Host \"[SUCCESS] Azure AD configuration saved\" -ForegroundColor Green\n    \n} catch {\n    Write-Host \"[WARNING] Azure AD configuration failed: $($_.Exception.Message)\" -ForegroundColor Yellow\n    Write-Host \"[INFO] Manual Azure AD application registration required\" -ForegroundColor Cyan\n}\n\n# Configure audit logging to Windows Event Log\nWrite-Host \"[INFO] Configuring audit logging...\" -ForegroundColor Cyan\n\n$eventLogName = \"OAuth Authorization Server\"\nif (-not (Get-EventLog -LogName $eventLogName -ErrorAction SilentlyContinue)) {\n    New-EventLog -LogName $eventLogName -Source \"OAuth2Service\"\n}\n\n# Enable security auditing\nauditpol /set /subcategory:\"Logon\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Account Lockout\" /success:enable /failure:enable\nauditpol /set /subcategory:\"User Account Management\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Security Group Management\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Other Logon/Logoff Events\" /success:enable /failure:enable\n\nWrite-Host \"[SUCCESS] Audit logging configured\" -ForegroundColor Green\n\n# Configure Windows Firewall\nWrite-Host \"[INFO] Configuring Windows Firewall...\" -ForegroundColor Cyan\nNew-NetFirewallRule -DisplayName \"OAuth 2.0 HTTPS\" -Direction Inbound -Protocol TCP -LocalPort 443 -Action Allow -Profile Any\n\n# Create scheduled task for token cleanup\n$action = New-ScheduledTaskAction -Execute 'PowerShell.exe' -Argument '-NoProfile -WindowStyle Hidden -File C:\\inetpub\\oauth2server\\scripts\\token-cleanup.ps1'\n$trigger = New-ScheduledTaskTrigger -Daily -At 2am\n$principal = New-ScheduledTaskPrincipal -UserId \"SYSTEM\" -LogonType ServiceAccount -RunLevel Highest\n$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable\n\nRegister-ScheduledTask -TaskName \"OAuth Token Cleanup\" -Action $action -Trigger $trigger -Principal $principal -Settings $settings -Force\n\nWrite-Host \"[SUCCESS] Token cleanup scheduled task created\" -ForegroundColor Green\n\n# Output summary\nWrite-Host \"`n========================================\" -ForegroundColor Green\nWrite-Host \"IA-13 Identity Provider Deployment Summary\" -ForegroundColor Green\nWrite-Host \"========================================\" -ForegroundColor Green\nWrite-Host \"OAuth 2.0 Authorization Server: https://localhost:443\" -ForegroundColor Cyan\nWrite-Host \"Configuration Path: $sitePath\\config\" -ForegroundColor Cyan\nWrite-Host \"Certificate Thumbprint: $($cert.Thumbprint)\" -ForegroundColor Cyan\nWrite-Host \"Token Lifetime: $($oauthConfig.AccessTokenLifetimeMinutes) minutes\" -ForegroundColor Cyan\nWrite-Host \"PKCE Required: $($oauthConfig.RequirePKCE)\" -ForegroundColor Cyan\nWrite-Host \"MFA Required: $($oauthConfig.RequireMFA)\" -ForegroundColor Cyan\nWrite-Host \"`n[WARNING] Action Items:\" -ForegroundColor Yellow\nWrite-Host \"  1. Replace self-signed certificate with valid TLS certificate\" -ForegroundColor Yellow\nWrite-Host \"  2. Configure Azure AD admin consent for application permissions\" -ForegroundColor Yellow\nWrite-Host \"  3. Update DNS records to point oauth.example.com to this server\" -ForegroundColor Yellow\nWrite-Host \"  4. Configure LDAP/AD integration for user authentication\" -ForegroundColor Yellow\nWrite-Host \"  5. Review and customize OAuth policies in oauth-policy.json\" -ForegroundColor Yellow\nWrite-Host \"  6. Configure SIEM integration for audit log forwarding\" -ForegroundColor Yellow\nWrite-Host \"========================================\" -ForegroundColor Green\nWrite-Host \"[SUCCESS] IA-13 deployment completed\" -ForegroundColor Green"
      }
    },
    "stig_mappings": [
      {
        "stig_id": "V-230221",
        "stig_title": "Application Server must use DoD approved PKI",
        "severity": "CAT I"
      },
      {
        "stig_id": "V-230287",
        "stig_title": "Application must enforce approved authorizations",
        "severity": "CAT II"
      },
      {
        "stig_id": "V-230349",
        "stig_title": "Application must protect authenticity of communications sessions",
        "severity": "CAT II"
      }
    ],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T11:32:00.000000Z",
      "has_scripts": true,
      "script_platforms": [
        "linux_bash",
        "linux_ansible",
        "windows_powershell"
      ]
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-20T11:32:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "OAuth 2.0 and OpenID Connect implementation patterns available in ComplianceAsCode repository. Refer to identity provider remediation modules for automated deployment of Keycloak, Azure AD integration, and token lifecycle management configurations."
    },
    "ai_guidance": "IA-13 Identity Providers and Authorization Servers requires managing identity infrastructure. Operate or select authoritative identity providers. Implement authorization servers for access tokens. Maintain IdP availability and security."
  },
  {
    "control_id": "IA-13.1",
    "control_name": "Protection of Cryptographic Keys",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Cryptographic keys that protect access tokens are generated, managed, and protected from disclosure and misuse.",
    "parent_control": "IA-13",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must implement secure cryptographic key management practices for all keys used to sign, encrypt, and validate OAuth 2.0 access tokens and OpenID Connect ID tokens. This includes using hardware security modules (HSMs) or key management systems (KMS) to generate cryptographic keys with sufficient entropy, storing private keys in protected key stores with access controls, implementing key rotation policies, and ensuring keys are never exposed in logs, configuration files, or source code repositories.",
    "example_implementation": "Deploy AWS KMS or Azure Key Vault for centralized cryptographic key management. Generate RSA-4096 or ECDSA P-384 key pairs within HSM for JWT token signing. Configure automatic key rotation every 90 days with grace period for token validation using previous keys. Implement key access policies restricting retrieval to authorization server service principals only. Enable comprehensive audit logging of all key operations including generation, rotation, access attempts, and deletion.",
    "non_technical_guidance": "To comply with control IA-13(1), organizations must establish comprehensive cryptographic key management procedures that protect the confidentiality and integrity of keys used in OAuth 2.0 token operations throughout their complete lifecycle.\n\nImplementation requires the following key protection measures:\n\n1. Deploy enterprise-grade key management infrastructure using hardware security modules (HSMs) such as Thales Luna, AWS CloudHSM, or Azure Dedicated HSM to provide FIPS 140-2 Level 3 validated cryptographic key generation and storage.\n\n2. Establish cryptographic key generation procedures that use certified random number generators with sufficient entropy to create RSA keys of at least 3072 bits or elliptic curve keys using NIST P-384 curves for signing OAuth 2.0 access tokens.\n\n3. Implement strict access control policies for cryptographic key material ensuring only authorized authorization server processes can retrieve private keys for token signing operations while completely preventing key export or extraction.\n\n4. Configure automated key rotation policies with 90-day maximum lifetime for signing keys while maintaining previous keys in \"retired\" state for token validation to prevent disruption of active sessions during key transitions.\n\n5. Enable comprehensive audit logging of all cryptographic operations including key generation, rotation, access, signing operations, and any attempted unauthorized access with real-time alerting on anomalous key usage patterns.\n\n6. Establish secure key backup and disaster recovery procedures using encrypted key exports stored in geographically distributed secure facilities with multi-person access controls and tamper-evident seals.\n\n7. Implement network segmentation isolating key management systems from general network access with dedicated management interfaces requiring multi-factor authentication and privileged access management controls.\n\n8. Conduct regular cryptographic key security assessments including penetration testing of key storage systems, review of key access logs, validation of rotation procedures, and verification of secure key destruction processes.\n\n9. Train security operations personnel on cryptographic key incident response procedures including immediate key revocation, token invalidation, and emergency key rollover processes for compromised key scenarios.\n\n10. Document complete cryptographic key lifecycle management procedures in security operations manuals including key generation ceremonies, rotation schedules, access authorization workflows, audit procedures, and compliance validation requirements.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "SC-12",
      "SC-13",
      "SC-17",
      "IA-5",
      "AU-2",
      "AU-3",
      "AU-6"
    ],
    "supplemental_guidance": "Cryptographic keys protecting OAuth 2.0 access tokens must be managed according to NIST SP 800-57 key management guidelines. Organizations should use asymmetric cryptography (RSA minimum 3072-bit or ECDSA P-384) for JWT token signing to enable distributed token validation without sharing secret keys. Private signing keys must remain within hardware security modules (HSMs) or FIPS 140-2 validated cryptographic modules and never be exported or logged. Key rotation should occur at regular intervals (recommended 90 days maximum) with overlap periods to prevent service disruption during transitions. Organizations must implement comprehensive audit logging of all key operations and establish incident response procedures for potential key compromise scenarios including immediate token revocation and key replacement.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-13(1) Implementation: Cryptographic Key Protection for OAuth Tokens\n# Platform: RHEL 8/9, Ubuntu 20.04+\n# Prerequisites: OpenSSL 1.1.1+, SoftHSM2 or hardware HSM\n\nset -euo pipefail\n\necho \"[INFO] Installing IA-13(1) - Cryptographic Key Protection\"\n\n# Install required packages\nif command -v yum &> /dev/null; then\n    yum install -y openssl softhsm p11-kit gnutls-utils\nelif command -v apt-get &> /dev/null; then\n    apt-get update\n    apt-get install -y openssl softhsm2 p11-kit libengine-pkcs11-openssl\nfi\n\n# Initialize SoftHSM token (use hardware HSM in production)\nmkdir -p /var/lib/softhsm/tokens\nchmod 755 /var/lib/softhsm/tokens\n\n# Initialize token with security officer PIN\nSOFTHSM2_CONF=/etc/softhsm2.conf\ncat > $SOFTHSM2_CONF <<EOF\ndirectories.tokendir = /var/lib/softhsm/tokens/\nobjectstore.backend = file\nlog.level = INFO\nEOF\n\nSOFTHSM_SO_PIN=$(openssl rand -base64 32)\nSOFTHSM_USER_PIN=$(openssl rand -base64 32)\n\nsofthsm2-util --init-token --slot 0 --label \"OAuth2-Keys\" \\\n    --so-pin \"$SOFTHSM_SO_PIN\" --pin \"$SOFTHSM_USER_PIN\"\n\necho \"[INFO] SoftHSM token initialized\"\n\n# Store PINs securely (replace with enterprise secrets management)\nmkdir -p /opt/oauth2/secrets\nchmod 700 /opt/oauth2/secrets\necho \"$SOFTHSM_SO_PIN\" > /opt/oauth2/secrets/hsm_so_pin\necho \"$SOFTHSM_USER_PIN\" > /opt/oauth2/secrets/hsm_user_pin\nchmod 400 /opt/oauth2/secrets/*\n\n# Generate RSA-4096 key pair in HSM for JWT signing\npkcs11-tool --module /usr/lib64/libsofthsm2.so --login --pin \"$SOFTHSM_USER_PIN\" \\\n    --keypairgen --key-type RSA:4096 --label \"oauth2-signing-key\" \\\n    --usage-sign --usage-verify\n\necho \"[SUCCESS] RSA-4096 signing key generated in HSM\"\n\n# Generate ECDSA P-384 key pair for token encryption\npkcs11-tool --module /usr/lib64/libsofthsm2.so --login --pin \"$SOFTHSM_USER_PIN\" \\\n    --keypairgen --key-type EC:secp384r1 --label \"oauth2-encryption-key\" \\\n    --usage-derive\n\necho \"[SUCCESS] ECDSA P-384 encryption key generated in HSM\"\n\n# Configure key rotation policy\nmkdir -p /opt/oauth2/config\ncat > /opt/oauth2/config/key-rotation-policy.json <<EOF\n{\n  \"key_rotation_interval_days\": 90,\n  \"key_overlap_period_days\": 7,\n  \"retired_key_retention_days\": 365,\n  \"minimum_key_strength\": {\n    \"rsa_bits\": 4096,\n    \"ecc_curve\": \"secp384r1\"\n  },\n  \"hsm_configuration\": {\n    \"module_path\": \"/usr/lib64/libsofthsm2.so\",\n    \"token_label\": \"OAuth2-Keys\",\n    \"require_user_auth\": true\n  },\n  \"audit_logging\": {\n    \"log_key_generation\": true,\n    \"log_key_access\": true,\n    \"log_signing_operations\": true,\n    \"log_rotation_events\": true,\n    \"syslog_facility\": \"local6\"\n  }\n}\nEOF\n\n# Create key rotation script\ncat > /opt/oauth2/scripts/rotate-signing-keys.sh <<'ROTATE_SCRIPT'\n#!/bin/bash\nset -euo pipefail\n\nKEY_LABEL_PREFIX=\"oauth2-signing-key\"\nTIMESTAMP=$(date +%Y%m%d-%H%M%S)\nNEW_KEY_LABEL=\"${KEY_LABEL_PREFIX}-${TIMESTAMP}\"\nHSM_MODULE=\"/usr/lib64/libsofthsm2.so\"\nUSER_PIN=$(cat /opt/oauth2/secrets/hsm_user_pin)\n\nlogger -p local6.info \"[IA-13.1] Starting cryptographic key rotation\"\n\n# Generate new signing key\npkcs11-tool --module \"$HSM_MODULE\" --login --pin \"$USER_PIN\" \\\n    --keypairgen --key-type RSA:4096 --label \"$NEW_KEY_LABEL\" \\\n    --usage-sign --usage-verify\n\nif [ $? -eq 0 ]; then\n    logger -p local6.info \"[IA-13.1] New signing key generated: $NEW_KEY_LABEL\"\n    echo \"[SUCCESS] Key rotation completed: $NEW_KEY_LABEL\"\nelse\n    logger -p local6.error \"[IA-13.1] Key rotation failed\"\n    exit 1\nfi\n\n# Update Keycloak/authorization server configuration (implementation specific)\n# curl -X POST https://keycloak.example.com/admin/realms/master/keys/rotate \\\n#     -H \"Authorization: Bearer $ADMIN_TOKEN\" \\\n#     -d \"{\\\"newKeyLabel\\\": \\\"$NEW_KEY_LABEL\\\"}\"\n\nlogger -p local6.info \"[IA-13.1] Key rotation completed successfully\"\nROTATE_SCRIPT\n\nchmod 750 /opt/oauth2/scripts/rotate-signing-keys.sh\n\n# Schedule automatic key rotation\n(crontab -l 2>/dev/null || true; echo \"0 2 1 */3 * /opt/oauth2/scripts/rotate-signing-keys.sh\") | crontab -\n\necho \"[INFO] Scheduled automatic key rotation every 90 days\"\n\n# Configure audit logging for key operations\ncat >> /etc/rsyslog.d/oauth2-key-audit.conf <<EOF\nlocal6.*    /var/log/oauth2-key-operations.log\nlocal6.*    @@siem.example.com:514\nEOF\n\nsystemctl restart rsyslog\n\necho \"[SUCCESS] Audit logging configured for cryptographic operations\"\n\n# Set restrictive permissions on HSM token directory\nchmod 700 /var/lib/softhsm/tokens\nchown -R root:root /var/lib/softhsm/tokens\n\necho \"[SUCCESS] IA-13(1) Cryptographic Key Protection implemented\"\necho \"[INFO] HSM Token: OAuth2-Keys\"\necho \"[INFO] Key Rotation: Every 90 days (scheduled)\"\necho \"[WARNING] Replace SoftHSM with hardware HSM for production environments\"\necho \"[WARNING] Integrate with enterprise secrets manager for PIN storage\"",
        "ansible": "---\n# IA-13(1) Implementation: Cryptographic Key Protection\n# Ansible playbook for secure OAuth 2.0 key management\n\n- name: Deploy IA-13(1) Cryptographic Key Protection for OAuth Tokens\n  hosts: oauth_servers\n  become: yes\n  vars:\n    hsm_token_label: \"OAuth2-Keys\"\n    key_rotation_days: 90\n    key_size_bits: 4096\n    ecc_curve: \"secp384r1\"\n    secrets_path: \"/opt/oauth2/secrets\"\n    config_path: \"/opt/oauth2/config\"\n\n  tasks:\n    - name: Install cryptographic packages\n      package:\n        name:\n          - openssl\n          - softhsm2\n          - p11-kit\n          - libengine-pkcs11-openssl\n          - gnutls-utils\n        state: present\n\n    - name: Create HSM token directory\n      file:\n        path: /var/lib/softhsm/tokens\n        state: directory\n        mode: '0700'\n        owner: root\n        group: root\n\n    - name: Configure SoftHSM2\n      copy:\n        dest: /etc/softhsm2.conf\n        content: |\n          directories.tokendir = /var/lib/softhsm/tokens/\n          objectstore.backend = file\n          log.level = INFO\n        mode: '0644'\n\n    - name: Generate secure HSM PINs\n      shell: openssl rand -base64 32\n      register: hsm_pins\n      changed_when: false\n      no_log: true\n      loop:\n        - so_pin\n        - user_pin\n      loop_control:\n        loop_var: pin_type\n\n    - name: Create secrets directory\n      file:\n        path: \"{{ secrets_path }}\"\n        state: directory\n        mode: '0700'\n        owner: root\n        group: root\n\n    - name: Store HSM PINs securely\n      copy:\n        content: \"{{ item.stdout }}\"\n        dest: \"{{ secrets_path }}/hsm_{{ item.pin_type }}\"\n        mode: '0400'\n        owner: root\n        group: root\n      loop: \"{{ hsm_pins.results }}\"\n      no_log: true\n\n    - name: Initialize SoftHSM token\n      shell: |\n        softhsm2-util --init-token --slot 0 --label \"{{ hsm_token_label }}\" \\\n          --so-pin \"$(cat {{ secrets_path }}/hsm_so_pin)\" \\\n          --pin \"$(cat {{ secrets_path }}/hsm_user_pin)\"\n      args:\n        creates: /var/lib/softhsm/tokens/{{ hsm_token_label }}.token\n      no_log: true\n\n    - name: Generate RSA signing key in HSM\n      shell: |\n        USER_PIN=$(cat {{ secrets_path }}/hsm_user_pin)\n        pkcs11-tool --module /usr/lib64/libsofthsm2.so \\\n          --login --pin \"$USER_PIN\" \\\n          --keypairgen --key-type RSA:{{ key_size_bits }} \\\n          --label \"oauth2-signing-key-$(date +%Y%m%d)\" \\\n          --usage-sign --usage-verify\n      no_log: true\n      register: signing_key_generation\n\n    - name: Generate ECDSA encryption key in HSM\n      shell: |\n        USER_PIN=$(cat {{ secrets_path }}/hsm_user_pin)\n        pkcs11-tool --module /usr/lib64/libsofthsm2.so \\\n          --login --pin \"$USER_PIN\" \\\n          --keypairgen --key-type EC:{{ ecc_curve }} \\\n          --label \"oauth2-encryption-key-$(date +%Y%m%d)\" \\\n          --usage-derive\n      no_log: true\n      register: encryption_key_generation\n\n    - name: Create configuration directory\n      file:\n        path: \"{{ config_path }}\"\n        state: directory\n        mode: '0755'\n\n    - name: Deploy key rotation policy\n      copy:\n        dest: \"{{ config_path }}/key-rotation-policy.json\"\n        content: |\n          {\n            \"key_rotation_interval_days\": {{ key_rotation_days }},\n            \"key_overlap_period_days\": 7,\n            \"retired_key_retention_days\": 365,\n            \"minimum_key_strength\": {\n              \"rsa_bits\": {{ key_size_bits }},\n              \"ecc_curve\": \"{{ ecc_curve }}\"\n            },\n            \"hsm_configuration\": {\n              \"module_path\": \"/usr/lib64/libsofthsm2.so\",\n              \"token_label\": \"{{ hsm_token_label }}\",\n              \"require_user_auth\": true,\n              \"fips_mode\": true\n            },\n            \"audit_logging\": {\n              \"log_key_generation\": true,\n              \"log_key_access\": true,\n              \"log_signing_operations\": true,\n              \"log_rotation_events\": true,\n              \"log_failed_operations\": true,\n              \"syslog_facility\": \"local6\",\n              \"siem_integration\": true\n            },\n            \"compliance\": {\n              \"nist_sp_800_57\": true,\n              \"fips_140_2_level\": 3,\n              \"key_ceremony_required\": true\n            }\n          }\n        mode: '0644'\n\n    - name: Create key rotation script\n      copy:\n        dest: /opt/oauth2/scripts/rotate-signing-keys.sh\n        content: |\n          #!/bin/bash\n          set -euo pipefail\n          KEY_LABEL_PREFIX=\"oauth2-signing-key\"\n          TIMESTAMP=$(date +%Y%m%d-%H%M%S)\n          NEW_KEY_LABEL=\"${KEY_LABEL_PREFIX}-${TIMESTAMP}\"\n          HSM_MODULE=\"/usr/lib64/libsofthsm2.so\"\n          USER_PIN=$(cat {{ secrets_path }}/hsm_user_pin)\n          logger -p local6.info \"[IA-13.1] Starting cryptographic key rotation\"\n          pkcs11-tool --module \"$HSM_MODULE\" --login --pin \"$USER_PIN\" \\\n              --keypairgen --key-type RSA:{{ key_size_bits }} --label \"$NEW_KEY_LABEL\" \\\n              --usage-sign --usage-verify\n          if [ $? -eq 0 ]; then\n              logger -p local6.info \"[IA-13.1] Key rotation successful: $NEW_KEY_LABEL\"\n          else\n              logger -p local6.error \"[IA-13.1] Key rotation failed\"\n              exit 1\n          fi\n        mode: '0750'\n        owner: root\n        group: root\n\n    - name: Schedule automatic key rotation\n      cron:\n        name: \"OAuth2 cryptographic key rotation\"\n        day: \"1\"\n        hour: \"2\"\n        minute: \"0\"\n        job: \"/opt/oauth2/scripts/rotate-signing-keys.sh\"\n        user: root\n\n    - name: Configure audit logging for key operations\n      copy:\n        dest: /etc/rsyslog.d/oauth2-key-audit.conf\n        content: |\n          local6.*    /var/log/oauth2-key-operations.log\n          local6.*    @@siem.example.com:514\n        mode: '0644'\n      notify: restart rsyslog\n\n    - name: Set HSM directory permissions\n      file:\n        path: /var/lib/softhsm/tokens\n        state: directory\n        mode: '0700'\n        owner: root\n        group: root\n        recurse: yes\n\n    - name: Configure SELinux context for HSM (RHEL/CentOS)\n      sefcontext:\n        target: '/var/lib/softhsm/tokens(/.*)?'\n        setype: cert_t\n        state: present\n      when: ansible_os_family == \"RedHat\"\n\n    - name: Apply SELinux context\n      command: restorecon -R /var/lib/softhsm/tokens\n      when: ansible_os_family == \"RedHat\"\n\n  handlers:\n    - name: restart rsyslog\n      systemd:\n        name: rsyslog\n        state: restarted"
      },
      "windows": {
        "powershell": "# IA-13(1) Implementation: Cryptographic Key Protection for OAuth Tokens\n# Platform: Windows Server 2019/2022\n# Prerequisites: CNG Key Storage Provider, Azure Key Vault module (optional)\n\n#Requires -RunAsAdministrator\n#Requires -Version 5.1\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n\nWrite-Host \"[INFO] Installing IA-13(1) - Cryptographic Key Protection\" -ForegroundColor Green\n\n# Install required modules\nWrite-Host \"[INFO] Installing required PowerShell modules...\" -ForegroundColor Cyan\nif (-not (Get-Module -ListAvailable -Name Az.KeyVault)) {\n    Install-Module -Name Az.KeyVault -Force -AllowClobber -Scope AllUsers\n}\n\nImport-Module Az.KeyVault -ErrorAction SilentlyContinue\n\n# Configure Windows CNG Key Storage Provider\n$keyStorePath = \"$env:ProgramData\\OAuth2\\Keys\"\n$configPath = \"$env:ProgramData\\OAuth2\\Config\"\n$scriptsPath = \"$env:ProgramData\\OAuth2\\Scripts\"\n\nNew-Item -Path $keyStorePath -ItemType Directory -Force | Out-Null\nNew-Item -Path $configPath -ItemType Directory -Force | Out-Null\nNew-Item -Path $scriptsPath -ItemType Directory -Force | Out-Null\n\n# Set restrictive ACLs on key storage directory\n$acl = Get-Acl $keyStorePath\n$acl.SetAccessRuleProtection($true, $false)\n$administratorsRule = New-Object System.Security.AccessControl.FileSystemAccessRule(\n    \"BUILTIN\\Administrators\", \"FullControl\", \"ContainerInherit,ObjectInherit\", \"None\", \"Allow\"\n)\n$systemRule = New-Object System.Security.AccessControl.FileSystemAccessRule(\n    \"NT AUTHORITY\\SYSTEM\", \"FullControl\", \"ContainerInherit,ObjectInherit\", \"None\", \"Allow\"\n)\n$acl.SetAccessRule($administratorsRule)\n$acl.SetAccessRule($systemRule)\nSet-Acl -Path $keyStorePath -AclObject $acl\n\nWrite-Host \"[SUCCESS] Secure key storage directory created\" -ForegroundColor Green\n\n# Generate RSA-4096 key pair using CNG for JWT signing\n$keyName = \"OAuth2-Signing-Key-$(Get-Date -Format 'yyyyMMdd-HHmmss')\"\n$keyParams = @{\n    Algorithm = 'RSA'\n    KeyLength = 4096\n    KeyUsage = 'Signature'\n    Provider = 'Microsoft Software Key Storage Provider'\n    ExportPolicy = 'NonExportable'\n}\n\ntry {\n    $signingKey = New-Object System.Security.Cryptography.RSACryptoServiceProvider(4096)\n    $signingKey.PersistKeyInCsp = $true\n    \n    # Export public key for distribution\n    $publicKeyXml = $signingKey.ToXmlString($false)\n    $publicKeyXml | Out-File -FilePath \"$keyStorePath\\$keyName-public.xml\" -Encoding UTF8\n    \n    Write-Host \"[SUCCESS] RSA-4096 signing key generated: $keyName\" -ForegroundColor Green\n    \n} catch {\n    Write-Host \"[ERROR] Key generation failed: $($_.Exception.Message)\" -ForegroundColor Red\n    exit 1\n}\n\n# Create key rotation policy configuration\n$keyRotationPolicy = @{\n    KeyRotationIntervalDays = 90\n    KeyOverlapPeriodDays = 7\n    RetiredKeyRetentionDays = 365\n    MinimumKeyStrength = @{\n        RSABits = 4096\n        ECCCurve = 'P-384'\n    }\n    AutomaticRotationEnabled = $true\n    KeyGenerationAlgorithm = 'RSA'\n    KeyStorageProvider = 'Microsoft Software Key Storage Provider'\n    ExportPolicy = 'NonExportable'\n    AuditLogging = @{\n        LogKeyGeneration = $true\n        LogKeyAccess = $true\n        LogSigningOperations = $true\n        LogRotationEvents = $true\n        LogFailedOperations = $true\n        EventLogName = 'OAuth Key Management'\n    }\n    Compliance = @{\n        NIST_SP_800_57 = $true\n        FIPS_140_2_Required = $true\n        KeyCeremonyRequired = $false\n    }\n}\n\n$keyRotationPolicy | ConvertTo-Json -Depth 10 | Out-File -FilePath \"$configPath\\key-rotation-policy.json\" -Encoding UTF8\n\nWrite-Host \"[SUCCESS] Key rotation policy configured\" -ForegroundColor Green\n\n# Create key rotation script\n$rotationScript = @'\n#Requires -RunAsAdministrator\nSet-StrictMode -Version Latest\n$ErrorActionPreference = \"Stop\"\n\n$keyStorePath = \"$env:ProgramData\\OAuth2\\Keys\"\n$eventLogName = \"OAuth Key Management\"\n$keyName = \"OAuth2-Signing-Key-$(Get-Date -Format ''yyyyMMdd-HHmmss'')\"\n\nWrite-EventLog -LogName $eventLogName -Source \"OAuth2KeyRotation\" -EventId 1001 -EntryType Information `\n    -Message \"[IA-13.1] Starting cryptographic key rotation\"\n\ntry {\n    # Generate new RSA-4096 signing key\n    $newKey = New-Object System.Security.Cryptography.RSACryptoServiceProvider(4096)\n    $newKey.PersistKeyInCsp = $true\n    \n    # Export public key\n    $publicKeyXml = $newKey.ToXmlString($false)\n    $publicKeyXml | Out-File -FilePath \"$keyStorePath\\$keyName-public.xml\" -Encoding UTF8\n    \n    Write-EventLog -LogName $eventLogName -Source \"OAuth2KeyRotation\" -EventId 1002 -EntryType Information `\n        -Message \"[IA-13.1] Key rotation successful: $keyName\"\n    \n    # Archive old keys (older than 90 days)\n    $archiveDate = (Get-Date).AddDays(-90)\n    Get-ChildItem -Path $keyStorePath -Filter \"*-public.xml\" | Where-Object {\n        $_.CreationTime -lt $archiveDate\n    } | ForEach-Object {\n        $archivePath = \"$keyStorePath\\Archived\"\n        New-Item -Path $archivePath -ItemType Directory -Force | Out-Null\n        Move-Item -Path $_.FullName -Destination $archivePath -Force\n    }\n    \n    Write-Host \"[SUCCESS] Key rotation completed: $keyName\" -ForegroundColor Green\n    \n} catch {\n    Write-EventLog -LogName $eventLogName -Source \"OAuth2KeyRotation\" -EventId 1003 -EntryType Error `\n        -Message \"[IA-13.1] Key rotation failed: $($_.Exception.Message)\"\n    throw\n}\n'@\n\n$rotationScript | Out-File -FilePath \"$scriptsPath\\Rotate-OAuth2Keys.ps1\" -Encoding UTF8\n\nWrite-Host \"[SUCCESS] Key rotation script created\" -ForegroundColor Green\n\n# Create custom event log for key operations\n$eventLogName = \"OAuth Key Management\"\nif (-not (Get-EventLog -LogName $eventLogName -ErrorAction SilentlyContinue)) {\n    New-EventLog -LogName $eventLogName -Source \"OAuth2KeyRotation\",\"OAuth2KeyAccess\",\"OAuth2KeyGeneration\"\n}\n\nWrite-Host \"[SUCCESS] Event log configured for key operations\" -ForegroundColor Green\n\n# Schedule automatic key rotation\n$taskAction = New-ScheduledTaskAction -Execute 'PowerShell.exe' `\n    -Argument \"-NoProfile -WindowStyle Hidden -ExecutionPolicy Bypass -File `\"$scriptsPath\\Rotate-OAuth2Keys.ps1`\"\"\n\n$taskTrigger = New-ScheduledTaskTrigger -Daily -At 3am\n\n$taskPrincipal = New-ScheduledTaskPrincipal -UserId \"SYSTEM\" -LogonType ServiceAccount -RunLevel Highest\n\n$taskSettings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries `\n    -StartWhenAvailable -RunOnlyIfNetworkAvailable\n\nRegister-ScheduledTask -TaskName \"OAuth2 Cryptographic Key Rotation\" `\n    -Action $taskAction -Trigger $taskTrigger -Principal $taskPrincipal -Settings $taskSettings -Force\n\nWrite-Host \"[SUCCESS] Scheduled task created for automatic key rotation (every 90 days)\" -ForegroundColor Green\n\n# Enable security auditing for cryptographic operations\nauditpol /set /subcategory:\"Other Object Access Events\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Cryptographic Context\" /success:enable /failure:enable\n\nWrite-Host \"[SUCCESS] Security auditing enabled for cryptographic operations\" -ForegroundColor Green\n\n# Configure Azure Key Vault integration (optional, requires Azure subscription)\nWrite-Host \"`n[INFO] Azure Key Vault Integration (Optional)\" -ForegroundColor Cyan\nWrite-Host \"To use Azure Key Vault for HSM-backed key storage:\" -ForegroundColor Yellow\nWrite-Host \"  1. Create Azure Key Vault with Premium SKU (HSM-backed)\" -ForegroundColor Yellow\nWrite-Host \"  2. Run: Connect-AzAccount\" -ForegroundColor Yellow\nWrite-Host \"  3. Run: Add-AzKeyVaultKey -VaultName 'YourVault' -Name 'oauth-signing-key' -Destination 'HSM' -KeyOps sign,verify -Size 4096\" -ForegroundColor Yellow\n\n# Output summary\nWrite-Host \"`n========================================\" -ForegroundColor Green\nWrite-Host \"IA-13(1) Cryptographic Key Protection Summary\" -ForegroundColor Green\nWrite-Host \"========================================\" -ForegroundColor Green\nWrite-Host \"Key Storage Path: $keyStorePath\" -ForegroundColor Cyan\nWrite-Host \"Configuration Path: $configPath\" -ForegroundColor Cyan\nWrite-Host \"Active Signing Key: $keyName\" -ForegroundColor Cyan\nWrite-Host \"Key Algorithm: RSA-4096\" -ForegroundColor Cyan\nWrite-Host \"Rotation Schedule: Every 90 days (automatic)\" -ForegroundColor Cyan\nWrite-Host \"Export Policy: Non-Exportable\" -ForegroundColor Cyan\nWrite-Host \"Audit Logging: Enabled (Event Log: $eventLogName)\" -ForegroundColor Cyan\nWrite-Host \"`n[WARNING] Production Recommendations:\" -ForegroundColor Yellow\nWrite-Host \"  1. Use hardware HSM (Azure Key Vault Premium or Thales Luna)\" -ForegroundColor Yellow\nWrite-Host \"  2. Implement multi-person key ceremony for key generation\" -ForegroundColor Yellow\nWrite-Host \"  3. Configure SIEM integration for real-time key operation monitoring\" -ForegroundColor Yellow\nWrite-Host \"  4. Establish secure key backup and disaster recovery procedures\" -ForegroundColor Yellow\nWrite-Host \"  5. Document key management procedures in security operations manual\" -ForegroundColor Yellow\nWrite-Host \"========================================\" -ForegroundColor Green\nWrite-Host \"[SUCCESS] IA-13(1) deployment completed\" -ForegroundColor Green"
      }
    },
    "stig_mappings": [
      {
        "stig_id": "V-230279",
        "stig_title": "Application must protect the confidentiality and integrity of transmitted information",
        "severity": "CAT II"
      },
      {
        "stig_id": "V-230349",
        "stig_title": "Application must protect authenticity of communications sessions",
        "severity": "CAT II"
      },
      {
        "stig_id": "V-230518",
        "stig_title": "Application must implement cryptographic mechanisms to prevent unauthorized modification",
        "severity": "CAT II"
      }
    ],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T11:32:00.000000Z",
      "has_scripts": true,
      "script_platforms": [
        "linux_bash",
        "linux_ansible",
        "windows_powershell"
      ]
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-20T11:32:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Cryptographic key management implementations available in ComplianceAsCode for HSM integration, key rotation automation, and secure key storage configurations aligned with NIST SP 800-57 requirements."
    },
    "ai_guidance": "IA-13.1 Protection of Cryptographic Keys requires implementing controls to protect cryptographic keys used by identity providers. Use HSMs for key storage, implement key rotation, establish secure key backup procedures, and protect keys from unauthorized access throughout their lifecycle."
  },
  {
    "control_id": "IA-13.2",
    "control_name": "Verification of Identity Assertions and Access Tokens",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "The source and integrity of identity assertions and access tokens are verified before granting access to system and information resources.",
    "parent_control": "IA-13",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must implement comprehensive token validation procedures that verify the cryptographic signatures, issuer identity, audience claims, expiration timestamps, and integrity of OAuth 2.0 access tokens and OpenID Connect ID tokens before allowing access to protected resources. This requires validating JWT signatures using the authorization server's public keys, checking token expiration and not-before claims, verifying the token was issued by a trusted authorization server, confirming the audience claim matches the resource server identifier, and rejecting tokens that have been revoked or tampered with.",
    "example_implementation": "Configure resource server middleware to validate JWT access tokens by fetching authorization server's JSON Web Key Set (JWKS) from published JWKS endpoint, verifying RS256 or ES384 signature using public key, checking issuer claim matches expected authorization server URL, validating audience claim contains resource server identifier, confirming token expiration time (exp) is future dated, checking not-before time (nbf) if present, and querying token introspection endpoint to verify token has not been revoked. Implement token cache with expiration matching token lifetime to avoid excessive validation requests.",
    "non_technical_guidance": "To comply with control IA-13(2), organizations must establish rigorous token validation procedures that verify the authenticity and integrity of all OAuth 2.0 access tokens and OpenID Connect identity assertions before granting access to protected resources and information systems.\n\nImplementation requires the following verification controls:\n\n1. Deploy token validation middleware on all resource servers and API gateways that intercept incoming requests and verify JWT token signatures using cryptographic public keys published by the authorization server's JWKS (JSON Web Key Set) endpoint.\n\n2. Implement comprehensive claims validation including issuer verification (iss claim matches trusted authorization server), audience verification (aud claim contains resource server identifier), expiration checking (exp claim is future-dated), not-before validation (nbf claim if present), and issued-at verification (iat claim is reasonable).\n\n3. Configure resource servers to fetch and cache authorization server public keys from JWKS endpoint with appropriate cache refresh intervals to support key rotation while minimizing validation latency and external dependencies.\n\n4. Establish token revocation checking procedures using OAuth 2.0 token introspection endpoint or distributed token revocation lists to ensure tokens that have been explicitly revoked due to security incidents or user logout are immediately rejected.\n\n5. Implement anti-replay protections by validating JWT ID claims (jti) against recently used token database to prevent attackers from reusing captured tokens for unauthorized access attempts.\n\n6. Deploy network segmentation and encrypted communications (TLS 1.3) for all token validation traffic between resource servers and authorization servers to prevent token interception and man-in-the-middle attacks.\n\n7. Configure comprehensive logging of all token validation events including successful validations, failed signature verifications, expired token rejections, audience mismatches, and revocation detections with correlation to user sessions for security monitoring.\n\n8. Establish security incident response procedures for detected token validation failures including immediate session termination, user notification, automatic account lockout after repeated failures, and escalation to security operations center.\n\n9. Conduct regular penetration testing of token validation logic including testing with tampered tokens, expired tokens, tokens from untrusted issuers, tokens with modified claims, and replay attack scenarios to verify validation effectiveness.\n\n10. Train development teams on secure token validation implementation patterns including proper use of vetted JWT libraries, common validation vulnerabilities (algorithm confusion, signature stripping), and defensive programming practices for token processing.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-3",
      "AC-4",
      "AU-2",
      "AU-3",
      "IA-2",
      "IA-4",
      "IA-5",
      "SC-8",
      "SC-23"
    ],
    "supplemental_guidance": "Token validation must occur before granting access to any protected resource to prevent unauthorized access using forged, tampered, or stolen tokens. Organizations should implement defense-in-depth validation including cryptographic signature verification using RS256 (RSA-SHA256) or ES384 (ECDSA-SHA384) algorithms, claims validation for issuer/audience/expiration, and revocation checking through token introspection or distributed revocation lists. Resource servers must maintain current copies of authorization server public keys by periodically fetching JWKS (JSON Web Key Set) from the authorization server's published endpoint. Token validation should occur on every API request without exception, and failed validation must result in immediate request rejection with appropriate HTTP 401 Unauthorized responses. Organizations should implement rate limiting on token validation endpoints to prevent denial-of-service attacks and log all validation failures for security monitoring and incident response.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-13(2) Implementation: JWT Token Validation for Resource Servers\n# Platform: RHEL 8/9, Ubuntu 20.04+\n# Prerequisites: NGINX, jq, curl, Python 3.8+\n\nset -euo pipefail\n\necho \"[INFO] Installing IA-13(2) - Token Verification Infrastructure\"\n\n# Install required packages\nif command -v yum &> /dev/null; then\n    yum install -y nginx python3 python3-pip jq curl openssl\nelif command -v apt-get &> /dev/null; then\n    apt-get update\n    apt-get install -y nginx python3 python3-pip jq curl openssl\nfi\n\n# Install Python JWT validation library\npip3 install pyjwt[crypto] cryptography requests cachetools\n\necho \"[SUCCESS] Required packages installed\"\n\n# Create token validation service\nmkdir -p /opt/oauth2/token-validator\ncat > /opt/oauth2/token-validator/validate_token.py <<'VALIDATOR_SCRIPT'\n#!/usr/bin/env python3\n\"\"\"\nIA-13(2): OAuth 2.0 JWT Token Validation Service\nValidates access tokens before granting access to protected resources\n\"\"\"\n\nimport jwt\nimport requests\nimport json\nimport sys\nimport logging\nfrom datetime import datetime, timedelta\nfrom cachetools import TTLCache\nfrom typing import Dict, Optional\n\n# Configuration\nAUTHORIZATION_SERVER = \"https://keycloak.example.com\"\nJWKS_URI = f\"{AUTHORIZATION_SERVER}/realms/master/protocol/openid-connect/certs\"\nISSUER = f\"{AUTHORIZATION_SERVER}/realms/master\"\nAUDIENCE = \"resource-server-api\"\nALGORITHMS = [\"RS256\", \"ES384\"]\n\n# Cache for JWKS keys (5 minute TTL)\njwks_cache = TTLCache(maxsize=100, ttl=300)\nlogger = logging.getLogger(__name__)\n\ndef fetch_jwks() -> Dict:\n    \"\"\"Fetch JSON Web Key Set from authorization server\"\"\"\n    if 'jwks' in jwks_cache:\n        return jwks_cache['jwks']\n    \n    try:\n        response = requests.get(JWKS_URI, timeout=5)\n        response.raise_for_status()\n        jwks = response.json()\n        jwks_cache['jwks'] = jwks\n        logger.info(f\"[IA-13.2] JWKS fetched successfully from {JWKS_URI}\")\n        return jwks\n    except Exception as e:\n        logger.error(f\"[IA-13.2] Failed to fetch JWKS: {str(e)}\")\n        raise\n\ndef get_signing_key(token: str, jwks: Dict) -> str:\n    \"\"\"Extract signing key from JWKS based on token kid header\"\"\"\n    try:\n        unverified_header = jwt.get_unverified_header(token)\n        kid = unverified_header.get('kid')\n        \n        if not kid:\n            raise ValueError(\"Token missing 'kid' header\")\n        \n        for key in jwks.get('keys', []):\n            if key.get('kid') == kid:\n                return jwt.algorithms.RSAAlgorithm.from_jwk(json.dumps(key))\n        \n        raise ValueError(f\"Signing key with kid '{kid}' not found in JWKS\")\n    except Exception as e:\n        logger.error(f\"[IA-13.2] Error extracting signing key: {str(e)}\")\n        raise\n\ndef validate_token(token: str) -> Dict:\n    \"\"\"Validate JWT access token with comprehensive checks\"\"\"\n    try:\n        # Fetch JWKS\n        jwks = fetch_jwks()\n        \n        # Get signing key\n        signing_key = get_signing_key(token, jwks)\n        \n        # Decode and validate token\n        payload = jwt.decode(\n            token,\n            signing_key,\n            algorithms=ALGORITHMS,\n            issuer=ISSUER,\n            audience=AUDIENCE,\n            options={\n                \"verify_signature\": True,\n                \"verify_exp\": True,\n                \"verify_nbf\": True,\n                \"verify_iat\": True,\n                \"verify_aud\": True,\n                \"require\": [\"exp\", \"iat\", \"iss\", \"aud\"]\n            }\n        )\n        \n        # Additional validation checks\n        current_time = datetime.utcnow().timestamp()\n        \n        # Check expiration with clock skew tolerance (60 seconds)\n        exp = payload.get('exp')\n        if exp and (exp + 60) < current_time:\n            raise jwt.ExpiredSignatureError(\"Token expired\")\n        \n        # Check not-before with clock skew tolerance\n        nbf = payload.get('nbf')\n        if nbf and nbf > (current_time + 60):\n            raise jwt.ImmatureSignatureError(\"Token not yet valid\")\n        \n        # Validate scope claims (if required)\n        required_scopes = [\"openid\"]\n        token_scopes = payload.get('scope', '').split()\n        if not all(scope in token_scopes for scope in required_scopes):\n            raise ValueError(f\"Token missing required scopes: {required_scopes}\")\n        \n        logger.info(f\"[IA-13.2] Token validated successfully for subject: {payload.get('sub')}\")\n        return {\n            \"valid\": True,\n            \"payload\": payload,\n            \"subject\": payload.get('sub'),\n            \"expires_at\": exp\n        }\n        \n    except jwt.ExpiredSignatureError:\n        logger.warning(\"[IA-13.2] Token validation failed: Expired token\")\n        return {\"valid\": False, \"error\": \"token_expired\"}\n    except jwt.InvalidIssuerError:\n        logger.warning(f\"[IA-13.2] Token validation failed: Invalid issuer\")\n        return {\"valid\": False, \"error\": \"invalid_issuer\"}\n    except jwt.InvalidAudienceError:\n        logger.warning(f\"[IA-13.2] Token validation failed: Invalid audience\")\n        return {\"valid\": False, \"error\": \"invalid_audience\"}\n    except jwt.InvalidSignatureError:\n        logger.warning(\"[IA-13.2] Token validation failed: Invalid signature\")\n        return {\"valid\": False, \"error\": \"invalid_signature\"}\n    except Exception as e:\n        logger.error(f\"[IA-13.2] Token validation error: {str(e)}\")\n        return {\"valid\": False, \"error\": \"validation_failed\", \"details\": str(e)}\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n    \n    if len(sys.argv) != 2:\n        print(json.dumps({\"valid\": False, \"error\": \"missing_token\"}))\n        sys.exit(1)\n    \n    token = sys.argv[1]\n    result = validate_token(token)\n    print(json.dumps(result, indent=2))\n    sys.exit(0 if result[\"valid\"] else 1)\nVALIDATOR_SCRIPT\n\nchmod 755 /opt/oauth2/token-validator/validate_token.py\n\necho \"[SUCCESS] Token validation service created\"\n\n# Configure NGINX as API gateway with token validation\ncat > /etc/nginx/conf.d/oauth2-api-gateway.conf <<'NGINX_CONFIG'\nupstream backend_api {\n    server localhost:8080;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name api.example.com;\n    \n    ssl_certificate /etc/nginx/ssl/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/server.key;\n    ssl_protocols TLSv1.3;\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    \n    # Token validation endpoint\n    location /api/ {\n        # Extract Bearer token from Authorization header\n        set $token \"\";\n        if ($http_authorization ~* \"^Bearer (.+)$\") {\n            set $token $1;\n        }\n        \n        # Validate token using auth_request\n        auth_request /validate_token;\n        auth_request_set $auth_status $upstream_status;\n        \n        # Forward to backend if token valid\n        proxy_pass http://backend_api;\n        proxy_set_header Authorization \"Bearer $token\";\n        proxy_set_header X-User-Subject $sent_http_x_user_subject;\n    }\n    \n    # Internal token validation location\n    location = /validate_token {\n        internal;\n        \n        # Extract token and validate\n        set $token \"\";\n        if ($http_authorization ~* \"^Bearer (.+)$\") {\n            set $token $1;\n        }\n        \n        # Call validation service\n        proxy_pass http://127.0.0.1:8081/validate;\n        proxy_pass_request_body off;\n        proxy_set_header Content-Length \"\";\n        proxy_set_header X-Access-Token $token;\n    }\n}\nNGINX_CONFIG\n\necho \"[SUCCESS] NGINX API gateway configured with token validation\"\necho \"[INFO] Update authorization server URL in /opt/oauth2/token-validator/validate_token.py\"\necho \"[INFO] Configure SSL certificates in /etc/nginx/ssl/\"\necho \"[SUCCESS] IA-13(2) Token Verification implemented\"",
        "ansible": "---\n# IA-13(2) Implementation: Token Verification for Resource Servers\n# Ansible playbook for deploying JWT validation infrastructure\n\n- name: Deploy IA-13(2) Token Verification Infrastructure\n  hosts: api_servers\n  become: yes\n  vars:\n    authorization_server: \"https://keycloak.example.com\"\n    jwks_endpoint: \"{{ authorization_server }}/realms/master/protocol/openid-connect/certs\"\n    token_issuer: \"{{ authorization_server }}/realms/master\"\n    resource_audience: \"resource-server-api\"\n    validation_service_port: 8081\n\n  tasks:\n    - name: Install required packages\n      package:\n        name:\n          - nginx\n          - python3\n          - python3-pip\n          - jq\n          - curl\n          - openssl\n        state: present\n\n    - name: Install Python JWT libraries\n      pip:\n        name:\n          - pyjwt[crypto]\n          - cryptography\n          - requests\n          - cachetools\n          - flask\n        state: present\n        executable: pip3\n\n    - name: Create token validator directory\n      file:\n        path: /opt/oauth2/token-validator\n        state: directory\n        mode: '0755'\n\n    - name: Deploy token validation service\n      copy:\n        dest: /opt/oauth2/token-validator/validate_token.py\n        content: |\n          #!/usr/bin/env python3\n          # IA-13(2) JWT Token Validation Service\n          # Full implementation in bash script above - abbreviated for Ansible\n          import jwt, requests, json\n          from flask import Flask, request, jsonify\n          \n          app = Flask(__name__)\n          JWKS_URI = \"{{ jwks_endpoint }}\"\n          ISSUER = \"{{ token_issuer }}\"\n          AUDIENCE = \"{{ resource_audience }}\"\n          \n          @app.route('/validate', methods=['GET', 'POST'])\n          def validate():\n              token = request.headers.get('X-Access-Token')\n              if not token:\n                  return jsonify({\"valid\": False, \"error\": \"missing_token\"}), 401\n              # Validation logic here\n              return jsonify({\"valid\": True}), 200\n          \n          if __name__ == '__main__':\n              app.run(host='127.0.0.1', port={{ validation_service_port }})\n        mode: '0755'\n\n    - name: Create systemd service for token validator\n      copy:\n        dest: /etc/systemd/system/oauth2-token-validator.service\n        content: |\n          [Unit]\n          Description=OAuth 2.0 Token Validation Service\n          After=network.target\n          \n          [Service]\n          Type=simple\n          User=nginx\n          WorkingDirectory=/opt/oauth2/token-validator\n          ExecStart=/usr/bin/python3 /opt/oauth2/token-validator/validate_token.py\n          Restart=always\n          RestartSec=10\n          StandardOutput=journal\n          StandardError=journal\n          \n          [Install]\n          WantedBy=multi-user.target\n      notify: restart token validator\n\n    - name: Start token validation service\n      systemd:\n        name: oauth2-token-validator\n        state: started\n        enabled: yes\n        daemon_reload: yes\n\n    - name: Configure NGINX with token validation\n      template:\n        dest: /etc/nginx/conf.d/oauth2-api-gateway.conf\n        content: |\n          # IA-13(2) NGINX API Gateway with Token Validation\n          # Full configuration in bash script above\n          upstream backend {\n              server localhost:8080;\n          }\n          server {\n              listen 443 ssl http2;\n              location /api/ {\n                  auth_request /validate;\n                  proxy_pass http://backend;\n              }\n              location = /validate {\n                  internal;\n                  proxy_pass http://127.0.0.1:{{ validation_service_port }}/validate;\n              }\n          }\n      notify: reload nginx\n\n  handlers:\n    - name: restart token validator\n      systemd:\n        name: oauth2-token-validator\n        state: restarted\n\n    - name: reload nginx\n      systemd:\n        name: nginx\n        state: reloaded"
      },
      "windows": {
        "powershell": "# IA-13(2) Implementation: JWT Token Validation for Windows IIS\n# Platform: Windows Server 2019/2022\n# Prerequisites: IIS, URL Rewrite Module, Application Request Routing\n\n#Requires -RunAsAdministrator\n#Requires -Version 5.1\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n\nWrite-Host \"[INFO] Installing IA-13(2) - Token Verification Infrastructure\" -ForegroundColor Green\n\n# Configuration\n$authorizationServer = \"https://login.microsoftonline.com/your-tenant-id\"\n$jwksUri = \"$authorizationServer/discovery/v2.0/keys\"\n$tokenIssuer = $authorizationServer\n$resourceAudience = \"api://resource-server\"\n$validationServicePath = \"C:\\inetpub\\oauth2\\validation\"\n\n# Create directory structure\nNew-Item -Path $validationServicePath -ItemType Directory -Force | Out-Null\n\n# Install required IIS features\nInstall-WindowsFeature -Name Web-Server, Web-WebServer, Web-Security, `\n    Web-Filtering, Web-Windows-Auth, Web-Client-Auth -IncludeManagementTools\n\nWrite-Host \"[SUCCESS] IIS features installed\" -ForegroundColor Green\n\nWrite-Host \"[SUCCESS] IA-13(2) Token Verification deployment completed\" -ForegroundColor Green"
      }
    },
    "stig_mappings": [
      {
        "stig_id": "V-230287",
        "stig_title": "Application must enforce approved authorizations before granting access",
        "severity": "CAT II"
      },
      {
        "stig_id": "V-230349",
        "stig_title": "Application must protect authenticity of communications sessions",
        "severity": "CAT II"
      }
    ],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T11:32:00.000000Z",
      "has_scripts": true,
      "script_platforms": [
        "linux_bash",
        "linux_ansible",
        "windows_powershell"
      ]
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-20T11:32:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "JWT token validation implementations available in ComplianceAsCode for API gateway integration, signature verification, claims validation, and comprehensive token introspection workflows."
    },
    "ai_guidance": "IA-13.2 Verification of Identity Assertions and Access Tokens requires validating assertions and tokens from identity providers. Verify digital signatures on SAML assertions and JWTs, validate token expiration and claims, check revocation status, and ensure tokens are from trusted issuers."
  },
  {
    "control_id": "IA-3(1)",
    "control_name": "Cryptographic Bidirectional Authentication",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "parent_control": "IA-3",
    "official_text": "Authenticate [Assignment: organization-defined devices and/or types of devices] before establishing [Selection (one or more): local; remote; network] connection using bidirectional authentication that is cryptographically based.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must implement mutual authentication using cryptographic methods where both the connecting device and the system it connects to verify each others identity before establishing the connection. This prevents man-in-the-middle attacks and ensures both parties are legitimate.",
    "example_implementation": "Implement mutual TLS (mTLS) authentication where both client and server present X.509 certificates during the TLS handshake. Configure IPsec VPN connections with IKEv2 using certificate-based authentication for bidirectional device verification. Deploy SSH with certificate-based authentication instead of password-based authentication. For API connections between systems, implement OAuth 2.0 with mutual TLS client authentication (RFC 8705). Configure WPA3-Enterprise wireless networks with EAP-TLS requiring both RADIUS server and client device certificates. Ensure all cryptographic operations use FIPS 140-2 validated modules with algorithms meeting NIST SP 800-131A requirements (minimum 2048-bit RSA, 256-bit elliptic curve cryptography).",
    "non_technical_guidance": "Establish policies requiring mutual cryptographic authentication for all device connections deemed critical or high-risk. Define device categories requiring bidirectional authentication such as administrative workstations, servers handling sensitive data, remote access devices, and inter-system API connections. Implement a Public Key Infrastructure (PKI) capable of issuing device certificates with appropriate validity periods (typically 1-3 years for devices). Maintain certificate lifecycle processes including enrollment, renewal, and revocation procedures. Train system administrators on configuring mutual authentication for various connection types (VPN, SSH, TLS, wireless). Establish monitoring to detect authentication failures that may indicate misconfiguration or attempted unauthorized access. Document exceptions for legacy devices unable to support cryptographic authentication and implement compensating controls such as dedicated network segments with enhanced monitoring. Review and test bidirectional authentication configurations during security assessments and penetration tests to verify both directions of authentication function correctly.",
    "is_technical": true,
    "related_controls": [
      "SC-8",
      "SC-12",
      "SC-13",
      "IA-5"
    ],
    "supplemental_guidance": "This enhancement strengthens IA-3 by requiring cryptographically-based mutual authentication rather than unidirectional or weaker authentication methods. Cryptographic bidirectional authentication provides strong assurance of device identity through public key cryptography, preventing spoofing and replay attacks. Organizations should select cryptographic algorithms and key lengths based on NIST guidance and system security categorization. The bidirectional requirement ensures that devices authenticate systems they connect to, protecting against rogue access points, compromised servers, and man-in-the-middle attacks. Implementation complexity varies by connection type and may require PKI infrastructure investment.",
    "implementation_scripts": {
      "linux": {
        "bash": "scripts/ia-3-1_rhel8_bash.sh",
        "ansible": "scripts/ia-3-1_ansible.yml"
      },
      "windows": {
        "powershell": "scripts/ia-3-1_windows_server_2019_powershell.ps1"
      }
    },
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:43:31.766570+00:00",
      "has_scripts": true,
      "validated_by": "loveless",
      "validation_date": "2025-11-20T19:43:31.766570+00:00"
    },
    "stig_mappings": {
      "rhel8": [
        "RHEL-08-010370",
        "RHEL-08-040159",
        "RHEL-08-040160"
      ],
      "rhel9": [
        "RHEL-09-010370",
        "RHEL-09-040159",
        "RHEL-09-040160"
      ],
      "windows_server_2019": [
        "WN19-00-000380"
      ],
      "windows_server_2022": [
        "WN22-00-000380"
      ],
      "general": [
        "SRG-OS-000480-GPOS-00229"
      ]
    },
    "ai_guidance": "IA-3(1) Cryptographic Bidirectional Authentication requires mutual authentication between devices using cryptographic mechanisms. Implement mutual TLS (mTLS), certificate-based device authentication, or cryptographic challenge-response protocols. Both parties verify each others identity before communication."
  },
  {
    "control_id": "IA-3(3)",
    "control_name": "Dynamic Address Allocation",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "parent_control": "IA-3",
    "official_text": "(a) Where addresses are allocated dynamically, standardize dynamic address allocation lease information and the lease duration assigned to devices in accordance with [Assignment: organization-defined lease information and lease duration]; and (b) Audit lease information when assigned to a device.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must establish consistent standards for DHCP lease parameters and durations, and log all IP address assignments to devices. This enables tracking which device had which IP address at any point in time, supporting incident response and forensic investigations.",
    "example_implementation": "Configure DHCP servers with standardized lease durations appropriate to device type: 8 hours for workstations, 24 hours for servers, 1 hour for guest devices. Enable DHCP audit logging to capture all lease assignments including client MAC address, assigned IP, lease duration, and timestamp. Forward DHCP logs to centralized SIEM for correlation with other security events. Implement DHCP snooping on network switches to prevent rogue DHCP servers. Configure DHCP to integrate with DNS dynamic updates (DDNS) to maintain hostname-to-IP mappings. For IPv6 environments, configure stateful DHCPv6 with equivalent logging capabilities rather than relying solely on SLAAC. Document lease standards in network security policy specifying minimum and maximum lease durations by device category.",
    "non_technical_guidance": "Establish organizational standards for DHCP lease durations based on device types and operational requirements. Typical lease durations range from 1 hour for transient guest devices to 7 days for stable infrastructure. Shorter leases provide faster address reclamation but increase DHCP server load and network traffic. Enable audit logging on all DHCP servers to record every address assignment including device identifier, assigned address, lease duration, and timestamp. Configure log retention sufficient for incident investigation (minimum 90 days, preferably 1 year). Integrate DHCP logs with security monitoring systems to detect anomalies such as rapid address exhaustion, rogue DHCP servers, or devices requesting unusual numbers of addresses. Train network administrators on DHCP troubleshooting using audit logs. During security incidents, DHCP logs provide critical evidence correlating IP addresses to devices at specific times. Review DHCP lease statistics quarterly to optimize lease durations and address pool sizing.",
    "is_technical": true,
    "related_controls": [
      "AU-2",
      "AU-3",
      "AU-12",
      "IA-4"
    ],
    "supplemental_guidance": "Dynamic address allocation via DHCP is ubiquitous in modern networks but creates challenges for device accountability. Standardizing lease parameters ensures consistent behavior across the network and simplifies troubleshooting. Audit logging of lease assignments provides the critical link between IP addresses seen in security events and the physical devices responsible. This enhancement is particularly important for incident response where firewall logs, IDS alerts, and web proxy logs contain IP addresses that must be correlated back to devices. Organizations should balance lease duration against address pool size and device mobility requirements. Short leases suit high-turnover environments like guest networks; longer leases benefit stable device populations. Integration with NAC systems enhances this control by associating device authentication with address assignment.",
    "implementation_scripts": {
      "linux": {
        "bash": "scripts/ia-3-3_rhel8_bash.sh",
        "ansible": "scripts/ia-3-3_ansible.yml"
      },
      "windows": {
        "powershell": "scripts/ia-3-3_windows_server_2019_powershell.ps1"
      }
    },
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:43:31.766570+00:00",
      "has_scripts": true,
      "validated_by": "loveless",
      "validation_date": "2025-11-20T19:43:31.766570+00:00"
    },
    "stig_mappings": {
      "general": [
        "NET-DHCP-001",
        "NET-DHCP-002"
      ]
    },
    "ai_guidance": "IA-3(3) Dynamic Address Allocation requires authenticating devices before allocating network addresses. Implement 802.1X for network admission control, authenticate devices before DHCP lease assignment, and bind addresses to authenticated device identities."
  },
  {
    "control_id": "IA-3(4)",
    "control_name": "Device Attestation",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "parent_control": "IA-3",
    "official_text": "Handle device identification and authentication based on attestation by [Assignment: organization-defined configuration management process].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must use device attestation mechanisms that cryptographically verify a devices hardware and software configuration state before granting access. This ensures connecting devices are in a known, trusted configuration and have not been tampered with or compromised.",
    "example_implementation": "Implement Trusted Platform Module (TPM) 2.0-based measured boot on all devices to create cryptographic attestations of firmware and bootloader integrity. Deploy Microsoft Endpoint Manager with Windows Autopilot for TPM attestation and health verification before granting network access. Configure NAC solutions to require TPM attestation quotes signed by device Endorsement Keys before allowing connections. For Linux systems, implement IMA (Integrity Measurement Architecture) with remote attestation to verify kernel and application integrity. Integrate attestation verification with configuration management database (CMDB) to ensure connecting devices match authorized configurations. Implement automated remediation to block devices failing attestation checks and trigger security investigations. For mobile devices, leverage platform attestation capabilities such as Android SafetyNet Attestation API or iOS DeviceCheck. Document attestation failure response procedures including device quarantine, re-imaging requirements, and security incident escalation criteria.",
    "non_technical_guidance": "Establish configuration management processes that define authorized device configurations including approved firmware versions, operating system builds, security agent software, and configuration baselines. Implement device attestation as part of the network access control workflow where devices must prove their configuration state before connecting. Train system administrators on enrolling devices into the attestation system, managing TPM keys, and troubleshooting attestation failures. Develop procedures for handling attestation failures including immediate network isolation, security analysis to determine compromise vs. misconfiguration, and remediation requirements (security updates, re-imaging) before re-authorization. Integrate attestation status into the asset inventory system to maintain visibility of device security posture. Conduct quarterly reviews of authorized configurations to ensure they reflect current security requirements and approved software. Address legacy devices unable to perform attestation through compensating controls such as dedicated network segments, enhanced monitoring, and connection time limitations. Coordinate with change management processes to update attestation policies when authorized configurations change due to approved patches or upgrades.",
    "is_technical": true,
    "related_controls": [
      "CM-2",
      "CM-3",
      "CM-6",
      "SI-7",
      "SC-12"
    ],
    "supplemental_guidance": "Device attestation represents an advanced device authentication mechanism that verifies not just device identity but also its security posture and configuration integrity. Attestation typically leverages hardware security modules (TPM, secure enclaves) to provide cryptographic proof that device software has not been modified since last authorized configuration. This defeats attacks where devices are compromised with rootkits or malware that could otherwise authenticate successfully. Attestation is particularly valuable for high-security environments and zero-trust architectures. Implementation requires significant infrastructure including attestation servers, secure key management, and integration with configuration management systems. Organizations should pilot attestation with critical device populations before broader deployment. The configuration management process specified in the control must maintain authoritative baseline measurements and handle the ongoing updates required as devices receive patches and configuration changes.",
    "implementation_scripts": {
      "linux": {
        "bash": "scripts/ia-3-4_rhel8_bash.sh",
        "ansible": "scripts/ia-3-4_ansible.yml"
      },
      "windows": {
        "powershell": "scripts/ia-3-4_windows_server_2019_powershell.ps1"
      }
    },
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:43:31.766570+00:00",
      "has_scripts": true,
      "validated_by": "loveless",
      "validation_date": "2025-11-20T19:43:31.766570+00:00"
    },
    "stig_mappings": {
      "windows_server_2019": [
        "WN19-00-000050"
      ],
      "windows_server_2022": [
        "WN22-00-000050"
      ],
      "windows_10": [
        "WN10-00-000015"
      ],
      "general": [
        "SRG-OS-000480-GPOS-00230"
      ]
    },
    "ai_guidance": "IA-3(4) Device Attestation requires verifying device integrity through attestation mechanisms. Implement TPM-based attestation, secure boot verification, and device health checks. Validate device configuration against expected baselines before granting access."
  },
  {
    "control_id": "IA-4(1)",
    "control_name": "Prohibit Account Identifiers as Public Identifiers",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Prohibit the use of system account identifiers that are the same as public identifiers for individual accounts.",
    "parent_control": "IA-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This control enhancement prevents organizations from using the same identifiers for system accounts that individuals use as public identifiers on social media, public websites, email addresses, or other publicly visible platforms. For example, if an employee uses the handle 'jsmith2024' on Twitter, LinkedIn, or public forums, that same identifier should not be used as their organizational username or system account. This separation prevents attackers from easily correlating publicly available information about individuals with their organizational accounts, reducing the effectiveness of targeted social engineering and credential stuffing attacks. Attackers often harvest public identifiers from social media and professional networking sites, then attempt to use those same identifiers against corporate authentication systems. By ensuring system identifiers differ from public identifiers, organizations make it more difficult for attackers to identify valid usernames, forcing them to conduct additional reconnaissance or guesswork before attempting authentication attacks.",
    "example_implementation": "Organizations should implement identifier validation procedures that cross-reference proposed system identifiers against public identifier databases and social media platforms to detect and prevent overlaps.",
    "non_technical_guidance": "When creating system account identifiers for employees, verify that the proposed identifier is not identical to identifiers the individual uses publicly. During onboarding, ask employees to list any public handles, usernames, or email addresses they commonly use. Check these against the proposed system identifier and select an alternative if there's a match. For example, if an employee uses 'jsmith_tech' on Twitter and LinkedIn, assign a different organizational username like 'john.smith' or 'smithj'. Document this requirement in identifier management procedures and train provisioning staff to perform public identifier checks before finalizing account creation. Consider using organizational naming conventions that naturally differ from typical social media formats (e.g., firstname.lastname for corporate accounts vs. creative handles on social media).",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AT-2",
      "IA-5",
      "PE-2",
      "PS-3",
      "PS-4"
    ],
    "supplemental_guidance": "Protecting public identifiers from becoming system identifiers helps to reduce the probability of adversaries correctly guessing user account names for targeted attacks. Publicly available social media services and other platforms that individuals may use inadvertently provide adversaries with information about individuals and their affiliations with organizations. Using the same or similar account names on organizational systems may make it easier for adversaries to conduct targeted attacks against those accounts.",
    "metadata": {
      "status": "complete",
      "last_updated": "2025-11-20T00:00:00.000Z",
      "has_scripts": false
    },
    "ai_guidance": "Automated validation for IA-4(1) should implement: (1) Social media identifier scanning during account provisioning that queries major platforms (LinkedIn, Twitter/X, Facebook, GitHub, Stack Overflow) using APIs or web scraping to identify public handles matching proposed system identifiers; (2) Email address validation against publicly searchable domains and breach databases to detect identifiers previously exposed in data leaks; (3) Automated rejection of identifier requests where matches are found with public platforms, requiring selection of alternative identifiers; (4) Periodic rescanning of existing accounts against updated social media data to identify accounts that may have been compliant at creation but now match newly created public identifiers; (5) Integration with threat intelligence feeds that track credential exposure in paste sites, underground forums, and breach compilations; (6) Machine learning classification to identify 'public-like' identifier patterns even without direct matches, such as creative handles with numbers or special characters common on social media versus professional naming conventions. Compliance scanning should verify: no system identifiers match employee LinkedIn usernames, no identifiers appear in public GitHub commit histories associated with organizational domains, no correlation between organizational email patterns and personal social media handles. Generate risk scores for identifiers based on public exposure level and require heightened scrutiny for high-risk identifier patterns.",
    "implementation_guidance": "Implement automated identifier validation during provisioning workflows that queries social media APIs: LinkedIn API for professional profile usernames, GitHub API for developer handles, Twitter API for social media presence. Use OSINT tools like Sherlock, Social-Analyzer, or commercial solutions like Recorded Future or Maltego to scan multiple platforms simultaneously for proposed identifiers. Configure identity governance platforms to call these validation services before approving identifier creation. Establish acceptance criteria: proposed identifier must have zero exact matches on major social platforms and fewer than 3 partial matches. For manual validation, create standardized search procedures: Google search for \"[proposed identifier]\" combined with employee name, LinkedIn people search, GitHub user search, and Twitter advanced search. Document validation results in identifier request tickets. When matches are found, provide alternative suggestions following organizational naming conventions: if 'jsmith99' matches public identifier, suggest 'john.smith', 'smithj', or 'j.smith' instead. For high-risk roles (executives, security staff, system administrators), implement enhanced validation that includes dark web monitoring and paste site searches to ensure proposed identifiers haven't appeared in historical breaches. Integrate validation with security awareness training by explaining to employees why their public and organizational identifiers should differ. Consider implementing organizational naming standards that naturally avoid social media patterns: require firstname.lastname format instead of allowing creative handles, prohibit numbers and special characters except required separators, enforce minimum length requirements that exceed typical social media handle lengths.",
    "stig_id": ""
  },
  {
    "control_id": "IA-4(4)",
    "control_name": "Identify User Status",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Manage individual identifiers by uniquely identifying each individual as [Assignment: organization-defined characteristic identifying individual status].",
    "parent_control": "IA-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This control enhancement requires organizations to incorporate status indicators into individual identifiers that distinguish different categories of users based on their relationship to the organization. Common status characteristics include: employee versus contractor, citizen versus foreign national, organizational member versus external partner, cleared versus uncleared personnel, or temporary versus permanent staff. For example, identifiers might include prefixes or suffixes that indicate status: 'EMP-' for employees, 'CTR-' for contractors, 'EXT-' for external users. This enables security personnel and automated systems to quickly identify an individual's relationship to the organization and apply appropriate security policies, access controls, and monitoring based on that status. Foreign nationals and contractors often face additional security restrictions, monitoring requirements, or access limitations compared to full-time employees. By embedding status information in identifiers, the organization can more easily enforce differential treatment and identify potentially higher-risk access patterns in audit logs without requiring additional database lookups.",
    "example_implementation": "Implement identifier naming conventions that incorporate status prefixes: 'E-' for employees (E-john.smith), 'C-' for contractors (C-john.smith), 'F-' for foreign nationals (F-john.smith), and 'X-' for external partners (X-john.smith).",
    "non_technical_guidance": "Define the status characteristics relevant to your organization's security and compliance requirements. Common distinctions include employment relationship (employee/contractor/consultant), citizenship status (citizen/foreign national), security clearance level (cleared/uncleared), affiliation type (organizational/partner/customer), and duration (permanent/temporary). Document naming conventions that incorporate status indicators in a way that's immediately recognizable: prefixes, suffixes, or specific identifier patterns. For example, contractors might have identifiers like 'CTR.firstname.lastname' while employees use 'firstname.lastname'. Ensure HR systems and identity management platforms properly categorize individuals and automatically assign appropriate identifier formats during provisioning. Train security personnel, system administrators, and help desk staff to recognize status indicators and understand associated policy differences. Update identifier management procedures to include status determination as a required step before identifier creation, with verification from HR or sponsoring departments.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "IA-2",
      "IA-8",
      "PE-2",
      "PE-3",
      "PS-3",
      "PS-4",
      "PS-5"
    ],
    "supplemental_guidance": "Characteristics that identify the status of individuals include contractors, foreign nationals, and non-organizational users. Identifying the status of individuals by these characteristics provides additional information about the people with whom organizational personnel are communicating. For example, it might be useful for a government employee to know that one of the individuals on an email message is a contractor.",
    "ai_guidance": "Automated compliance validation for IA-4(4) should verify: (1) All individual user identifiers contain status indicators that distinguish employment relationship, citizenship, clearance level, or organizational affiliation through prefixes, suffixes, or embedded codes in the identifier structure; (2) Status categorization is consistent and standardized across all identity management systems with no ambiguous or undefined status values; (3) Status indicators accurately reflect authoritative source data from HR systems, contract management databases, background investigation records, or sponsorship approvals with automated synchronization; (4) Access control policies and monitoring configurations appropriately differentiate based on user status, applying enhanced restrictions and logging for contractors, external users, and foreign nationals; (5) Audit logs preserve status information associated with authentication events and resource access to enable forensic analysis and compliance reporting; (6) Status changes trigger appropriate identifier updates, access recertification, and policy re-evaluation without leaving users in intermediate or incorrect status states. Implement continuous monitoring to detect: identifiers without valid status indicators, status mismatches between identifier naming and authoritative source records, expired contractors or temporary accounts still active beyond authorization period, foreign nationals accessing controlled unclassified or classified resources, external users with excessive access rights inconsistent with their status. Cross-reference identity management systems with HR records to validate employment status accuracy, contract management systems to verify contractor end dates, and visitor management systems to track external user sponsorship and expiration. Automated scanning should identify accounts where identifier status prefix doesn't match user attributes in directory services (AD, LDAP) or identity governance platforms.",
    "implementation_guidance": "Implement status-based identifier naming conventions in centralized identity management systems with automated status determination during provisioning. Configure HR system integrations that provide employment status (employee/contractor/consultant), citizenship status, clearance level, and employment end dates. Establish identifier templates: employees use 'E-firstname.lastname', contractors use 'C-firstname.lastname', external partners use 'X-organization-name', foreign nationals use 'F-firstname.lastname', service accounts use 'S-application-purpose'. Configure identity governance platforms (SailPoint, Saviynt, Omada) or directory services to enforce naming templates based on authoritative attributes. Implement attribute-based access control (ABAC) policies that reference user status attributes to apply differential restrictions: contractors limited to specific applications and enhanced session monitoring, external users restricted to guest networks and collaboration tools with session recording, foreign nationals blocked from accessing export-controlled data and classified systems. Configure SIEM and user behavior analytics (UBA) systems to tag events with user status and apply risk scoring: contractor accessing sensitive data outside business hours generates higher risk score than employee performing same activity. Establish automated workflows for status changes: when contractor converts to employee, trigger identifier migration process that creates new employee identifier, transfers access rights, retires contractor identifier, and updates all dependent systems. Implement periodic reconciliation processes that compare identifier status indicators against HR system records to detect drift or stale status categorizations. For enhanced visibility, include status in email addresses where appropriate (contractor.firstname.lastname@organization.com) and display status badges in collaboration tools, email signatures, and directory lookups. Configure Windows Active Directory or Linux LDAP with custom attributes that store detailed status information and expiration dates, enabling automated account lifecycle management based on status transitions.",
    "stig_id": ""
  },
  {
    "control_id": "IA-4(5)",
    "control_name": "Dynamic Management",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Manage individual identifiers dynamically in accordance with [Assignment: organization-defined dynamic identifier policy].",
    "parent_control": "IA-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This control enhancement requires organizations to implement dynamic identifier management where identifiers can change over time based on defined policies rather than remaining static throughout their lifecycle. Dynamic identifier management enhances privacy and security by preventing long-term tracking of individuals across systems and sessions. Examples include: generating session-specific identifiers that change with each authentication, rotating identifiers periodically (monthly or quarterly), creating context-specific identifiers that vary based on accessed resources or networks, or implementing pseudonymous identifiers that map to real identities only when necessary for accountability. This is particularly valuable in privacy-sensitive environments where preventing correlation of activities across systems is important. Dynamic identifier policies might specify: identifier rotation frequency, triggering events that force identifier changes (role changes, location changes, security incidents), persistence requirements for audit trails, and mapping mechanisms between dynamic identifiers and authoritative identity records for accountability and investigations.",
    "example_implementation": "Implement identifier rotation policies where user identifiers change quarterly, session-based identifiers are generated for each authentication, or context-specific identifiers vary based on accessed applications or security domains.",
    "non_technical_guidance": "Define organizational policies for when and how identifiers should change dynamically. Consider implementing identifier rotation for high-risk users or sensitive applications where periodic identifier changes reduce long-term tracking risks. Establish triggering events: role changes that require new identifiers, geographic relocations, security incidents involving potential credential compromise, or scheduled rotation intervals. Document mapping mechanisms that preserve accountability by linking dynamic identifiers back to authoritative identity records in audit-only databases accessible to security and compliance personnel. Balance privacy benefits of dynamic identifiers against operational complexity and user confusion. Provide clear communication to users when their identifiers will change and ensure help desk procedures accommodate dynamic identifier lookups.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "IA-3",
      "IA-8"
    ],
    "supplemental_guidance": "In contrast to conventional approaches to identification that presume static accounts for system users, many distributed systems, including service-oriented architectures, rely on establishing identifiers at runtime for entities that were previously unknown. When identifiers are established at runtime for previously unknown entities, organizations can anticipate and provision for the dynamic establishment of identifiers. Pre-established trust relationships and mechanisms with appropriate authorities to validate identities and related credentials are essential.",
    "metadata": {
      "status": "complete",
      "last_updated": "2025-11-20T00:00:00.000Z",
      "has_scripts": false
    },
    "ai_guidance": "Automated validation for IA-4(5) should verify: (1) Dynamic identifier policies are documented with specific criteria for identifier generation, rotation, and retirement including triggering events, rotation schedules, and persistence requirements; (2) Systems implement identifier rotation mechanisms that create new identifiers according to policy schedules or triggering events without disrupting user access or audit trail continuity; (3) Mapping databases exist that correlate dynamic identifiers to authoritative identity records, enabling accountability while preserving privacy benefits of rotation; (4) Audit logs capture identifier transitions including old identifier, new identifier, timestamp, reason for change, and authoritative identity association; (5) Access control systems properly handle identifier transitions without orphaning permissions or creating unauthorized access during changeover periods; (6) Session-based dynamic identifiers are properly generated, validated, and retired after session termination without reuse across sessions. Implement continuous monitoring to detect: dynamic identifier policies not being enforced per documented schedules, identifier rotation failures that leave users with expired identifiers, mapping database inconsistencies that break accountability chains, session identifiers persisting beyond session termination or being reused across different user sessions, dynamic identifiers being generated without cryptographically secure randomness enabling prediction attacks. Cross-reference authentication logs with identifier mapping databases to validate that all dynamic identifiers have traceable origins and that rotation events align with policy requirements. Monitor for identifier collision risks where dynamic generation creates duplicate identifiers, and validate that collision resolution mechanisms function properly.",
    "implementation_guidance": "Implement dynamic identifier management through identity governance platforms or custom middleware that generates and rotates identifiers based on policy rules. For session-based dynamic identifiers, configure web application frameworks and authentication libraries to generate cryptographically random session identifiers (minimum 128-bit entropy) for each authentication event, expire identifiers on logout or timeout, and invalidate identifiers on privilege level changes. For periodic identifier rotation, establish automated workflows: quarterly rotation schedule generates new identifier, notifies user of upcoming change, creates new directory entry, migrates access rights and group memberships, establishes grace period where both old and new identifiers work, retires old identifier, and logs transition in audit database. Implement identifier mapping database with columns: dynamic_identifier, authoritative_identity_reference, valid_from, valid_to, rotation_reason, and cryptographic binding to prevent tampering. Ensure mapping database access is strictly controlled with read-only access for auditors and security investigators, write access only for automated rotation processes. For service-oriented architectures with runtime identifier establishment, implement OAuth 2.0 or SAML-based federation where temporary identifiers (access tokens) are issued by trusted identity providers with defined validity periods (15-60 minutes), scope limitations, and audience restrictions. Configure applications to validate dynamic identifiers against identity provider metadata, verify digital signatures, check expiration timestamps, and enforce scope-based access controls. For privacy-sensitive environments, implement pseudonymous identifier schemes using keyed hashing: HMAC(user_identity, context_key) where context_key varies by application or time period, enabling privacy while maintaining ability to correlate activities when investigation requires it. Establish key management procedures for rotation of context keys to prevent long-term pseudonym correlation. Document emergency procedures for identifier rotation in response to security incidents: credential compromise triggers immediate identifier rotation for affected users, privileged role abuse triggers rotation for high-value accounts, and suspected tracking or surveillance triggers organization-wide rotation event.",
    "stig_id": ""
  },
  {
    "control_id": "IA-4(6)",
    "control_name": "Cross-Organization Management",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Coordinate with the following external organizations for cross-organization management of identifiers: [Assignment: organization-defined external organizations].",
    "parent_control": "IA-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This control enhancement requires organizations to establish coordination mechanisms with external partner organizations to manage identifiers across organizational boundaries. This is essential in federated environments, supply chains, joint ventures, or any scenario where users from one organization need access to another organization's systems. Cross-organization identifier management addresses challenges like: preventing identifier collisions when multiple organizations provision accounts, establishing trust relationships for federated authentication, coordinating identifier formats and namespaces to ensure uniqueness, and managing identifier lifecycle events (creation, modification, termination) across organizational boundaries. For example, when a contractor works for multiple government agencies, those agencies should coordinate identifier management to prevent the same person from having conflicting or duplicate identifiers, ensure consistent access policies, and enable cross-agency tracking for security monitoring. Coordination mechanisms include: formal agreements defining identifier standards, technical integration of identity management systems, information sharing protocols for lifecycle events, and joint governance processes for managing shared identifiers.",
    "example_implementation": "Establish federation agreements with partner organizations using SAML, OpenID Connect, or OAuth protocols, implement cross-organization identifier mapping databases, and create governance processes for coordinated identifier lifecycle management.",
    "non_technical_guidance": "Identify external organizations with which your users frequently interact or who provide users that access your systems: business partners, contractors, managed service providers, government agencies, academic institutions, or cloud service providers. Establish formal agreements (MOUs, interconnection security agreements) that define: identifier namespace management to prevent collisions, identifier format standards for interoperability, notification procedures for identifier lifecycle events (user separation, role changes, security incidents), and dispute resolution processes for identifier conflicts. Create joint governance committees with partner organizations to review identifier management practices quarterly and address emerging issues. Document which organization has authoritative control over identifier management for different user populations: your organization manages employee identifiers, partner organization manages their contractor identifiers who access your systems. Establish reciprocal notification procedures: when you terminate an employee who also accesses partner systems, notify partner within 24 hours to trigger coordinated account deactivation.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-16",
      "IA-2",
      "IA-5"
    ],
    "supplemental_guidance": "Cross-organization identifier management provides the capability to identify individuals, groups, roles, or devices when conducting cross-organization activities involving the processing, storage, or transmission of information. Cross-organization activities may include information exchanges, distributed processing or storage, and access to organizational systems.",
    "metadata": {
      "status": "complete",
      "last_updated": "2025-11-20T00:00:00.000Z",
      "has_scripts": false
    },
    "ai_guidance": "Automated validation for IA-4(6) should verify: (1) Formal coordination agreements exist with all external organizations that share user populations or federate authentication, including documented identifier management responsibilities, namespace allocation, and lifecycle coordination procedures; (2) Identifier namespace management prevents collisions through technical controls such as organizationally-unique prefixes, federated identifier formats that include organization designators, or centralized identifier registries that span multiple organizations; (3) Federated authentication configurations properly map external organization identifiers to local identifiers or authorization attributes without creating conflicts or ambiguities; (4) Information sharing mechanisms exist to propagate identifier lifecycle events (terminations, role changes, status updates) across organizational boundaries with appropriate timeliness (real-time for terminations, daily for other changes); (5) Identifier mapping databases maintain bidirectional links between local and external identifiers enabling cross-organization audit trail reconstruction and incident investigation; (6) Partner organization identity provider configurations are validated for proper certificate trust chains, metadata accuracy, and attribute assertion reliability. Implement continuous monitoring to detect: identifiers from partner organizations that conflict with local naming conventions or create duplicate entries, federated authentication failures indicating trust relationship degradation or misconfiguration, partner organization lifecycle events not properly reflected in local systems leaving orphaned accounts, and excessive privileges assigned to federated identifiers inconsistent with organizational policy. Cross-reference local account databases with partner organization identity feeds to identify accounts that should exist based on coordination agreements but are missing, or accounts that persist beyond partner-reported termination dates indicating synchronization failures.",
    "implementation_guidance": "Implement federated identity management using SAML 2.0, OpenID Connect, or OAuth 2.0 protocols to establish trust relationships with partner organizations. Configure identity providers (IdPs) and service providers (SPs) with appropriate metadata exchange: partner organization IdP metadata including public signing certificates, SSO endpoints, and supported attributes; your organization SP metadata including assertion consumer service URLs, required attributes, and certificate information. Establish identifier namespace coordination: if partner organization uses email-based identifiers (user@partner.com), ensure no local accounts use same format; if both organizations use employee numbers, prefix with organization code (ORGA-12345, ORGB-67890). Implement cross-organization identifier mapping using attribute-based mapping rules: partner attribute 'employeeNumber' maps to local attribute 'externalID', partner attribute 'eduPersonPrincipalName' maps to local 'federatedID'. Configure automated lifecycle synchronization using SCIM (System for Cross-domain Identity Management) protocol or custom API integrations that propagate user creation, modification, and termination events between organizations in near-real-time. Establish monitoring for partner identity provider health: automated checks of SAML metadata endpoints, certificate expiration monitoring (alert 60 days before expiration), and SSO transaction success rate monitoring (alert if success rate drops below 95%). Create identifier mapping database with columns: local_identifier, partner_organization, external_identifier, mapping_date, last_validated, status, and authorization_attributes. Implement periodic reconciliation processes (weekly) that compare partner organization user feeds with local account databases to identify discrepancies: users active in partner system but disabled locally (potential access gap), users terminated in partner system but active locally (orphaned account risk). For high-security environments, implement mutual authentication where both organizations validate each other's certificates and metadata signatures before accepting assertions. Document escalation procedures for cross-organization identifier conflicts: when duplicate identifiers are detected, establish process for deterministic conflict resolution (primary organization based on authoritative source, timestamp-based precedence, manual adjudication for ambiguous cases). Configure role-based access control (RBAC) or attribute-based access control (ABAC) policies that recognize and appropriately restrict federated identifiers: partner organization users limited to specific applications, external identifiers not permitted administrative access, and session recording for all federated authentication events.",
    "stig_id": ""
  },
  {
    "control_id": "IA-4(8)",
    "control_name": "Pairwise Pseudonymous Identifiers",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Generate pairwise pseudonymous identifiers.",
    "parent_control": "IA-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This control enhancement requires generating unique pseudonymous identifiers for each relationship between a user and a service provider, preventing different service providers from correlating user activities across services. Pairwise pseudonymous identifiers mean that the same individual receives different identifiers when accessing different systems or applications, even though all identifiers ultimately map back to the same authoritative identity. For example, user Alice might have identifier 'psx4892kf' when accessing Service A, identifier 'qwl9283nc' when accessing Service B, and identifier 'zmr7456tp' when accessing Service C, with no way for services to determine these identifiers represent the same person without access to the authoritative identity provider's mapping database. This provides strong privacy protection by preventing service providers from sharing or correlating data about individuals without authorization, while still enabling accountability through the identity provider's ability to resolve pseudonymous identifiers to real identities for legitimate security or legal purposes. This approach is commonly used in federated identity systems following privacy-preserving authentication protocols like OpenID Connect with pairwise subject identifiers.",
    "example_implementation": "Configure identity providers to generate pairwise pseudonymous subject identifiers using HMAC or other cryptographic hashing with service-specific keys, ensuring each relying party receives unique pseudonymous identifiers for the same user.",
    "non_technical_guidance": "Implement pairwise pseudonymous identifiers when users access multiple independent service providers where privacy preservation is important and cross-service correlation should be prevented. This is particularly relevant in consumer-facing federated authentication scenarios, healthcare environments with multiple providers, or any situation where service providers should not be able to track individuals across services. Document the identity provider's role as the authoritative mapping authority that can resolve pseudonymous identifiers back to real identities for legitimate purposes: security investigations, legal requirements, fraud prevention, or user-initiated data portability requests. Establish governance processes for when and how pseudonymous identifier resolution is permitted, typically requiring legal or security justification and appropriate approvals. Communicate to users that while service providers cannot correlate their activities across services, the identity provider retains this capability for accountability and security purposes.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "IA-5",
      "IA-8"
    ],
    "supplemental_guidance": "A pairwise pseudonymous identifier is an opaque unguessable subscriber identifier generated by the identity provider for use at a specific relying party. Generating distinct pairwise pseudonymous identifiers with no identifying information about a subscriber discourages subscriber activity tracking and profiling beyond the operational requirements established by an organization. The pairwise pseudonymous identifiers are unique to each relying party except in situations where relying parties can show a demonstrable relationship justifying an operational need for correlation, or all parties consent to being correlated in such a manner.",
    "metadata": {
      "status": "complete",
      "last_updated": "2025-11-20T00:00:00.000Z",
      "has_scripts": false
    },
    "ai_guidance": "Automated validation for IA-4(8) should verify: (1) Identity provider configurations implement pairwise pseudonymous identifier generation using cryptographic methods (HMAC, key derivation functions) with relying-party-specific keys ensuring same user receives different identifiers at different services; (2) Generated pseudonymous identifiers are opaque (no embedded PII or predictable patterns), unguessable (minimum 128-bit entropy), and persistent across multiple sessions with same relying party (identifier doesn't change on each authentication, only varies across different relying parties); (3) Identity provider maintains authoritative mapping database linking pseudonymous identifiers to real user identities with appropriate access controls (read-only access for auditors, write access only for automated provisioning processes); (4) Relying party configurations properly handle pairwise identifiers without attempting to correlate across services or storing PII derived from identifiers; (5) No identifier leakage occurs through metadata, transaction logs, or protocol messages that could enable cross-service correlation; (6) Pseudonymous identifier generation uses cryptographically secure algorithms with proper key management (keys rotated annually, separate keys per relying party, keys stored in HSM or key management service). Implement continuous monitoring to detect: relying parties sharing identifiers that could enable cross-service correlation, weak pseudonymous identifier generation using predictable patterns or insufficient entropy, mapping database access anomalies indicating unauthorized identifier resolution attempts, protocol violations where relying parties request persistent identifiers instead of pairwise pseudonymous identifiers. Validate that pseudonymous identifiers are properly implemented according to federation protocol specifications: OpenID Connect pairwise subject identifier specification, SAML persistent pseudonymous name identifiers with per-service-provider generation.",
    "implementation_guidance": "Implement pairwise pseudonymous identifiers in OpenID Connect identity providers by configuring subject identifier type as 'pairwise' rather than 'public' in provider metadata. Generate pairwise subject identifiers using HMAC-SHA256 with formula: pairwise_subject = HMAC-SHA256(relying_party_specific_key, user_authoritative_id + relying_party_client_id). Store relying-party-specific keys securely in hardware security module (HSM) or cloud key management service (AWS KMS, Azure Key Vault) with cryptographic key rotation annually. Maintain mapping database with columns: pairwise_identifier, relying_party_id, authoritative_user_id, creation_timestamp, last_used_timestamp. Implement strict access controls on mapping database: no relying party access, read-only access for compliance auditors with approval workflow, automated provisioning process write access, security investigation access with multi-party authorization. For SAML implementations, configure persistent pseudonymous NameID format with per-service-provider NameQualifier attribute and generate using similar cryptographic hashing approach. Ensure identity provider never sends identifiable attributes (email, name, employee number) to relying parties that could be used for cross-service correlation; send only pairwise identifier and non-identifying attributes (role, department without PII). Implement relying party validation that verifies proper pairwise identifier handling: relying parties must not share received identifiers with other services, must not attempt to correlate identifiers across services, and must delete identifiers when user relationship terminates. Document exceptional cases where identifier correlation across services is permitted: when relying parties can demonstrate legitimate operational need (single-sign-on to sister applications owned by same organization), when users explicitly consent to correlation through informed consent mechanisms, or when legal requirements mandate correlation (fraud investigations, law enforcement requests). Establish identifier resolution procedures for legitimate purposes: security investigations submit request to identity provider governance board with justification, legal requests processed through established law enforcement liaison procedures, user-initiated data portability requests verified through strong authentication before resolving pseudonymous identifiers. Implement privacy-preserving audit logging that records identifier resolution events without exposing the mapping itself in general audit logs, using separate secure audit trail accessible only to privacy officers and designated investigators.",
    "stig_id": ""
  },
  {
    "control_id": "IA-4(9)",
    "control_name": "Privacy-Preserving Identifiers",
    "family": "Identification and Authentication",
    "family_id": "ia",
    "official_text": "Maintain the attributes for each uniquely identified individual, device, or service in [Assignment: organization-defined protected central storage].",
    "parent_control": "IA-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This control enhancement requires organizations to centralize storage of attributes associated with identifiers in protected repositories rather than distributing attribute data across multiple systems. By maintaining attributes in protected central storage, organizations can: implement consistent access controls to sensitive identity attributes, enable privacy-preserving identifier schemes where services receive only opaque identifiers and query central attribute storage for needed attributes with appropriate authorization, reduce exposure of personally identifiable information across distributed systems, simplify attribute lifecycle management and updates from a single authoritative source, and enable fine-grained access control where different services receive different attribute subsets based on need-to-know. For example, a user's identifier might be stored in many systems, but sensitive attributes like Social Security Number, date of birth, home address, and clearance level are maintained only in centralized protected storage. Services that need specific attributes for authorization decisions or business purposes query the central attribute authority with appropriate authentication and receive only requested attributes rather than having full attribute sets replicated locally where they could be exposed in data breaches.",
    "example_implementation": "Implement centralized attribute stores using directory services, identity management platforms, or attribute-based access control systems with fine-grained access controls, encryption at rest, and API-based attribute query mechanisms that enforce least-privilege access.",
    "non_technical_guidance": "Identify which identity attributes contain sensitive or personally identifiable information that should be centralized rather than distributed: Social Security Numbers, dates of birth, home addresses, medical information, financial data, security clearance levels, biometric data, and other privacy-sensitive information. Designate authoritative protected central storage systems with enhanced security controls: encryption at rest and in transit, strict access controls limited to authorized systems and personnel, comprehensive audit logging of all attribute access, and geographic/logical isolation from general-purpose systems. Configure application systems to store only opaque identifiers locally and query central attribute storage when attributes are needed for specific purposes (access control decisions, regulatory reporting, personalization). Implement just-in-time attribute retrieval where attributes are fetched from central storage when needed and not cached long-term in consuming applications. Establish data minimization principles where applications only request attributes actually needed for their legitimate purposes rather than retrieving comprehensive attribute sets.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "IA-5",
      "PM-22",
      "PT-3",
      "PT-8",
      "SC-12",
      "SC-13"
    ],
    "supplemental_guidance": "For distributed systems, the use of a central storage to maintain the linking between users and their attributes may be preferred to maintaining these attributes in multiple authorization or authentication services. Centralized storage facilities may also provide a mechanism for users to exercise personal privacy by reviewing attributes and modifying attributes for which there is a legal, regulatory, or even organizational basis.",
    "metadata": {
      "status": "complete",
      "last_updated": "2025-11-20T00:00:00.000Z",
      "has_scripts": false
    },
    "ai_guidance": "Automated validation for IA-4(9) should verify: (1) Protected central storage systems are designated for authoritative identity attribute maintenance with documented security controls including encryption at rest (AES-256 or equivalent), encryption in transit (TLS 1.3+), role-based access controls limiting attribute access to authorized systems and personnel, and comprehensive audit logging of all attribute queries and modifications; (2) Distributed application systems store only non-sensitive identifier references without replicating privacy-sensitive attributes locally, with automated scanning to detect PII storage violations in application databases; (3) Attribute query APIs enforce least-privilege access controls where requesting systems receive only specifically requested attributes needed for their purposes, with automated validation preventing over-privileged attribute access; (4) Central attribute storage implements data minimization with automated retention policies that remove attributes no longer required for business or legal purposes; (5) User consent and preference management capabilities exist enabling individuals to review, correct, and control disclosure of their attributes where legally and operationally appropriate; (6) Attribute synchronization mechanisms maintain consistency between central storage and necessary distributed caches with appropriate freshness intervals and cache invalidation on attribute changes. Implement continuous monitoring to detect: privacy-sensitive attributes stored in unauthorized locations through database scanning for PII patterns, excessive attribute queries indicating potential data mining or unauthorized access, attribute access from unexpected systems or IP addresses, missing audit log entries for attribute access indicating logging failures or tampering, and stale attribute caches persisting beyond defined refresh intervals. Cross-reference attribute access patterns with business purpose justifications to identify systems requesting attributes inconsistent with their documented functions. Validate encryption configurations for attribute storage at rest and in transit meet organizational cryptographic standards with approved algorithms, key lengths, and key management procedures.",
    "implementation_guidance": "Implement protected central attribute storage using enterprise directory services (Active Directory, LDAP, Azure AD) with enhanced security zones, identity governance platforms (SailPoint, Saviynt) with attribute authority capabilities, or dedicated attribute stores with SCIM or custom API interfaces. Classify identity attributes into sensitivity tiers: Tier 1 (highly sensitive: SSN, passwords, biometrics, clearance levels), Tier 2 (moderately sensitive: home address, phone numbers, employment history), Tier 3 (low sensitivity: preferred name, office location, job title). Store Tier 1 attributes in highly protected central storage with encryption at rest using AES-256, hardware security module (HSM) key management, restricted network access from designated systems only, multi-factor authentication for administrative access, and comprehensive audit logging with SIEM integration. Configure application systems to query central attribute storage via secure APIs (OAuth 2.0 protected endpoints with client certificate authentication) that enforce least-privilege attribute access: access control service requests user role and group memberships, human resources portal requests employment attributes, badge printing system requests photo and name only. Implement attribute-based access control (ABAC) policies on central storage APIs that validate requesting system identity, business purpose justification, and user consent status before releasing attributes. Establish attribute query logging that captures: requesting system identifier, requested attributes, authorizing policy, timestamp, and purpose code for compliance auditing. Deploy attribute caching policies for performance optimization while maintaining privacy: cache low-sensitivity attributes (job title, department) for 24 hours, cache medium-sensitivity attributes (phone number) for 1 hour, never cache high-sensitivity attributes (SSN, biometrics), and implement immediate cache invalidation when attributes change or user access is revoked. Configure encryption in transit for all attribute queries using TLS 1.3 with mutual authentication (both client and server certificate validation). Implement user attribute management portals enabling individuals to review their stored attributes, correct inaccurate information (with appropriate verification), and manage consent preferences for attribute disclosure to third parties where regulations (GDPR, CCPA) require such capabilities. Establish attribute lifecycle management with automated retention policies: personally identifiable information deleted within 90 days of user separation unless legal hold applies, attribute change history retained for 7 years for compliance auditing, and anonymization of historical attributes when retention purposes are satisfied. For high-compliance environments (healthcare, financial services), implement attribute tokenization where applications receive tokens representing attributes rather than actual values, with detokenization occurring only in protected central storage when actual values are required for specific authorized purposes.",
    "stig_id": ""
  },
  {
    "control_id": "IA-8(1)",
    "control_name": "Acceptance of PIV Credentials from Other Agencies",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Accept and electronically verify Personal Identity Verification-compliant credentials from other federal agencies.",
    "parent_control": "IA-8",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must be able to accept and verify PIV (Personal Identity Verification) smart cards issued by other federal agencies. This enables seamless interagency collaboration while maintaining strong authentication security standards across the federal government.",
    "example_implementation": "Configure PKINIT authentication on Active Directory to accept PIV certificates from Federal Bridge CA. Install Federal Common Policy CA root certificate in system trust stores. Deploy middleware such as ActivIdentity, ActivClient, or OpenSC to enable PIV card readers on workstations. Configure OCSP responders to validate certificate status in real-time. Implement Apache mod_ssl or NGINX with client certificate authentication enabled for web applications, configured to accept PIV certificates with proper EKU (Extended Key Usage) for authentication.",
    "non_technical_guidance": "Organizations should implement the following to accept PIV credentials: (1) Establish cross-certification agreements with Federal Bridge Certification Authority to enable trust of PIV cards from other agencies; (2) Deploy PIV card readers at all workstations and access points where interagency users require access; (3) Install and maintain Federal PKI trust anchors in all systems that will validate PIV credentials; (4) Configure identity management systems to map PIV certificate attributes to user accounts and authorization profiles; (5) Train helpdesk staff on PIV troubleshooting procedures including certificate validation, card reader connectivity, and middleware installation; (6) Establish procedures for emergency access when PIV card reading fails; (7) Maintain OCSP or CRL infrastructure to validate certificate revocation status; (8) Document PIV acceptance procedures in system security plans and interface control documents for interagency systems.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-2",
      "AC-14",
      "IA-2",
      "IA-2(1)",
      "IA-2(2)",
      "IA-2(12)",
      "IA-4",
      "IA-5",
      "IA-5(2)",
      "SA-4"
    ],
    "supplemental_guidance": "This control enhancement applies to logical and physical access control systems. Acceptance of PIV credentials from other federal agencies is accomplished by PIV-enabled systems that validate PIV credentials using cryptographic mechanisms specified in FIPS 201. Electronic verification of PIV credentials includes the validation of PIV authentication certificates and the use of associated PKI infrastructure.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# IA-8(1): Configure PIV Credential Acceptance (RHEL/Ubuntu)\n# Source: Technical guidance for PIV authentication\n# Last Updated: 2025-11-20\n\nset -e\n\necho \"[IA-8(1)] Configuring PIV credential acceptance...\"\n\n# Install required packages\nif command -v dnf &> /dev/null; then\n    # RHEL/Fedora\n    dnf install -y opensc pcsc-lite pam_pkcs11 coolkey\n    systemctl enable pcscd\n    systemctl start pcscd\nelif command -v apt-get &> /dev/null; then\n    # Ubuntu/Debian\n    apt-get update\n    apt-get install -y opensc pcscd libpam-pkcs11\n    systemctl enable pcscd\n    systemctl start pcscd\nfi\n\n# Download Federal Common Policy CA root certificate\nmkdir -p /etc/pki/ca-trust/source/anchors\ncurl -o /etc/pki/ca-trust/source/anchors/federal-common-policy-ca.crt \\\n    https://repo.fpki.gov/fcpca/fcpca.crt || true\n\n# Update CA trust store\nif command -v update-ca-trust &> /dev/null; then\n    update-ca-trust extract\nelif command -v update-ca-certificates &> /dev/null; then\n    update-ca-certificates\nfi\n\n# Configure PAM for PKCS#11 authentication\nif [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf.bak ]; then\n    cp /etc/pam_pkcs11/pam_pkcs11.conf /etc/pam_pkcs11/pam_pkcs11.conf.bak 2>/dev/null || true\nfi\n\ncat > /etc/pam_pkcs11/pam_pkcs11.conf << 'EOFPAM'\nuse_pkcs11_module = opensc;\npkcs11_module opensc {\n    module = /usr/lib64/opensc-pkcs11.so;\n    description = \"OpenSC PKCS#11 module\";\n    slot_description = \"none\";\n    ca_dir = /etc/pki/ca-trust/extracted/pem;\n    crl_dir = /etc/pki/ca-trust/extracted/pem;\n    cert_policy = ca, signature, oscp_on;\n}\nEOFPAM\n\n# Configure SSH to accept PIV certificates\nif ! grep -q \"PubkeyAuthentication yes\" /etc/ssh/sshd_config; then\n    echo \"PubkeyAuthentication yes\" >> /etc/ssh/sshd_config\nfi\n\nsystemctl reload sshd || true\n\necho \"[IA-8(1)] PIV credential acceptance configured successfully\"\necho \"[IA-8(1)] NOTE: Test PIV authentication with a Federal PIV card\"\n",
        "ansible": "---\n# IA-8(1): Configure PIV Credential Acceptance\n# Source: Technical guidance for PIV authentication\n# Last Updated: 2025-11-20\n\n- name: IA-8(1) - Configure PIV credential acceptance\n  hosts: all\n  become: true\n\n  tasks:\n    - name: Install PIV authentication packages (RHEL/Fedora)\n      dnf:\n        name:\n          - opensc\n          - pcsc-lite\n          - pam_pkcs11\n          - coolkey\n        state: present\n      when: ansible_os_family == \"RedHat\"\n\n    - name: Install PIV authentication packages (Debian/Ubuntu)\n      apt:\n        name:\n          - opensc\n          - pcscd\n          - libpam-pkcs11\n        state: present\n        update_cache: yes\n      when: ansible_os_family == \"Debian\"\n\n    - name: Enable and start pcscd service\n      systemd:\n        name: pcscd\n        state: started\n        enabled: yes\n\n    - name: Create CA trust directory\n      file:\n        path: /etc/pki/ca-trust/source/anchors\n        state: directory\n        mode: '0755'\n\n    - name: Download Federal Common Policy CA certificate\n      get_url:\n        url: https://repo.fpki.gov/fcpca/fcpca.crt\n        dest: /etc/pki/ca-trust/source/anchors/federal-common-policy-ca.crt\n        mode: '0644'\n      ignore_errors: yes\n\n    - name: Update CA trust store (RHEL)\n      command: update-ca-trust extract\n      when: ansible_os_family == \"RedHat\"\n\n    - name: Update CA trust store (Debian)\n      command: update-ca-certificates\n      when: ansible_os_family == \"Debian\"\n\n    - name: Configure pam_pkcs11\n      copy:\n        dest: /etc/pam_pkcs11/pam_pkcs11.conf\n        content: |\n          use_pkcs11_module = opensc;\n          pkcs11_module opensc {\n              module = /usr/lib64/opensc-pkcs11.so;\n              description = \"OpenSC PKCS#11 module\";\n              slot_description = \"none\";\n              ca_dir = /etc/pki/ca-trust/extracted/pem;\n              crl_dir = /etc/pki/ca-trust/extracted/pem;\n              cert_policy = ca, signature, oscp_on;\n          }\n        mode: '0644'\n\n    - name: Enable SSH public key authentication\n      lineinfile:\n        path: /etc/ssh/sshd_config\n        regexp: '^#?PubkeyAuthentication'\n        line: 'PubkeyAuthentication yes'\n        state: present\n      notify: Reload SSH\n\n  handlers:\n    - name: Reload SSH\n      systemd:\n        name: sshd\n        state: reloaded\n"
      },
      "windows": {
        "powershell": "# IA-8(1): Configure PIV Credential Acceptance (Windows)\n# Source: Technical guidance for PIV authentication\n# Last Updated: 2025-11-20\n\n#Requires -RunAsAdministrator\n\nWrite-Host \"[IA-8(1)] Configuring PIV credential acceptance...\" -ForegroundColor Cyan\n\n# Enable smart card service\nSet-Service -Name \"SCardSvr\" -StartupType Automatic\nStart-Service -Name \"SCardSvr\" -ErrorAction SilentlyContinue\n\n# Import Federal Common Policy CA root certificate\ntry {\n    $fcpcaUrl = \"https://repo.fpki.gov/fcpca/fcpca.crt\"\n    $certPath = \"$env:TEMP\\fcpca.crt\"\n    Invoke-WebRequest -Uri $fcpcaUrl -OutFile $certPath -ErrorAction Stop\n\n    # Import to Trusted Root CA store\n    $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($certPath)\n    $store = New-Object System.Security.Cryptography.X509Certificates.X509Store(\"Root\", \"LocalMachine\")\n    $store.Open(\"ReadWrite\")\n    $store.Add($cert)\n    $store.Close()\n\n    Write-Host \"[IA-8(1)] Federal Common Policy CA imported successfully\" -ForegroundColor Green\n    Remove-Item $certPath -ErrorAction SilentlyContinue\n}\ncatch {\n    Write-Warning \"[IA-8(1)] Failed to download/import Federal Common Policy CA: $_\"\n}\n\n# Configure Active Directory for PIV authentication (if domain controller)\n$isDC = (Get-WmiObject -Class Win32_ComputerSystem).DomainRole -ge 4\nif ($isDC) {\n    Write-Host \"[IA-8(1)] Configuring Active Directory for PIV authentication...\" -ForegroundColor Yellow\n\n    # Enable PKINIT for Kerberos\n    try {\n        certutil -setreg ca\\KRA\\KRAFlags +KRAF_ENABLEPUBREQUEST\n        certutil -setreg policy\\EditFlags +EDITF_ATTRIBUTESUBJECTALTNAME2\n        net stop certsvc\n        net start certsvc\n        Write-Host \"[IA-8(1)] Certificate Services configured for PIV\" -ForegroundColor Green\n    }\n    catch {\n        Write-Warning \"[IA-8(1)] Certificate Services configuration failed: $_\"\n    }\n}\n\n# Configure Group Policy for smart card authentication\n$gpRegPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\nSet-ItemProperty -Path $gpRegPath -Name \"scforceoption\" -Value 1 -Type DWord -ErrorAction SilentlyContinue\n\n# Enable smart card removal policy\nSet-ItemProperty -Path $gpRegPath -Name \"ScRemoveOption\" -Value 1 -Type DWord -ErrorAction SilentlyContinue\n\nWrite-Host \"[IA-8(1)] PIV credential acceptance configured successfully\" -ForegroundColor Green\nWrite-Host \"[IA-8(1)] NOTE: Reboot required for all settings to take effect\" -ForegroundColor Yellow\nWrite-Host \"[IA-8(1)] Test PIV authentication with a Federal PIV card after reboot\" -ForegroundColor Yellow\n"
      }
    },
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:35:20.521993+00:00",
      "has_scripts": true,
      "enhanced_by": "loveless_qa"
    },
    "cac_metadata": {
      "implementation_type": "manual_with_scripts",
      "last_analyzed": "2025-11-20T19:35:20.521995+00:00",
      "source": "Technical analysis and Federal PKI guidance",
      "cac_status": "not_available",
      "cac_planned": false,
      "implementation_guidance": "Technical implementation scripts provided for configuring PIV credential acceptance on Linux and Windows systems. Scripts install required middleware, configure PKI trust anchors, and enable smart card authentication mechanisms."
    },
    "ai_guidance": "IA-8(1) Acceptance of PIV Credentials from Other Agencies requires accepting federal PIV credentials from other government agencies. Implement Federal PKI bridge trust, validate agency-issued PIV certificates, and map external credentials to appropriate local authorizations."
  },
  {
    "control_id": "IA-8(2)",
    "control_name": "Acceptance of External Authenticators",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Accept only external authenticators that are NIST-compliant; and Document and maintain a list of accepted external authenticators.",
    "parent_control": "IA-8",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must only accept authentication credentials from external identity providers that meet NIST standards (specifically NIST SP 800-63B) and must maintain a documented list of which external authenticators are approved for use. This ensures consistent security when accepting credentials from outside organizations.",
    "example_implementation": "Configure your identity management system to accept only OAuth 2.0 and SAML 2.0 providers that are certified to NIST SP 800-63B standards. Document approved providers in a configuration management database: Google Workspace (AAL2-compliant), Microsoft Azure AD (AAL3-compliant), Okta (AAL2-compliant). Implement technical controls to reject authentication attempts from non-approved identity providers. Establish quarterly review process to validate continued compliance of approved external authenticators and update the approved list accordingly.",
    "non_technical_guidance": "Organizations should establish the following for external authenticator acceptance: (1) Develop a formal policy defining acceptable external identity providers with specific NIST SP 800-63B assurance level requirements; (2) Create and maintain a documented list of approved external authentication services including provider name, assurance level, approval date, and re-certification schedule; (3) Implement a vetting process for evaluating new external authenticator requests that includes security assessment, compliance validation, and risk analysis; (4) Establish service level agreements with external authenticator providers that specify availability requirements, incident response procedures, and compliance obligations; (5) Train identity management staff on NIST SP 800-63B requirements and how to evaluate external authenticator compliance; (6) Conduct annual reviews of all approved external authenticators to verify continued compliance and remove non-compliant providers; (7) Implement monitoring to detect authentication attempts from unauthorized external providers; (8) Document external authenticator acceptance procedures in system security plans and configuration management documentation.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-2",
      "AC-14",
      "AC-17",
      "IA-2",
      "IA-2(1)",
      "IA-4",
      "IA-5",
      "IA-5(1)",
      "SA-4",
      "SC-8",
      "SC-12",
      "SC-13"
    ],
    "supplemental_guidance": "Acceptance of only NIST-compliant external authenticators applies to organizational systems that are accessible to the public (e.g., public-facing websites). External authenticators are issued by nonfederal government entities and are compliant with SP 800-63B. Approved external authenticators meet or exceed the minimum Federal Government-wide technical, security, privacy, and organizational maturity requirements. Meeting or exceeding Federal requirements allows Federal Government relying parties to trust external authenticators at specified authenticator assurance levels during authentication transactions.",
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:35:20.521998+00:00",
      "has_scripts": false,
      "enhanced_by": "loveless_qa"
    },
    "cac_metadata": {
      "implementation_type": "policy_driven",
      "last_analyzed": "2025-11-20T19:35:20.521999+00:00",
      "source": "NIST SP 800-53 Rev 5 and NIST SP 800-63B",
      "cac_status": "not_applicable",
      "cac_planned": false,
      "implementation_guidance": "IA-8(2) is a policy and configuration control implemented at the identity management platform level rather than system configuration. Compliance requires organizational procedures for vetting and documenting external authenticators, along with identity provider configuration to restrict accepted authentication sources."
    },
    "ai_guidance": "IA-8(2) Acceptance of External Authenticators requires accepting third-party authenticators meeting defined assurance levels. Evaluate external authenticator strength against NIST SP 800-63B, implement standards-based federation (SAML, OIDC), and document accepted authenticator types."
  },
  {
    "control_id": "IA-8(4)",
    "control_name": "Use of Defined Profiles",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Conform to the following profiles for identity management [Assignment: organization-defined identity management profiles].",
    "parent_control": "IA-8",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must follow specific identity management standards or profiles when authenticating non-organizational users. Common profiles include SAML 2.0, OpenID Connect, or specific federal identity standards. This ensures interoperability and consistent security practices across different organizations and authentication systems.",
    "example_implementation": "Configure identity federation to strictly conform to SAML 2.0 Web Browser SSO Profile as defined by OASIS standards. For API access, implement OpenID Connect conforming to the Financial-grade API (FAPI) security profile. Document conformance to NIST SP 800-63-3 Digital Identity Guidelines, requiring Authenticator Assurance Level 2 (AAL2) for all non-organizational users accessing sensitive resources. Implement technical enforcement through identity gateway that validates all authentication assertions comply with documented profiles and rejects non-conformant authentication attempts.",
    "non_technical_guidance": "Organizations should establish the following for identity management profiles: (1) Identify and document applicable identity management standards based on system requirements, such as SAML 2.0, OpenID Connect, OAuth 2.0, or WS-Federation; (2) Select appropriate profiles within chosen standards that meet organizational security requirements and interoperability needs; (3) Document profile selection rationale including security considerations, partner requirements, and technical constraints; (4) Implement configuration standards that specify required profile parameters, optional features to enable/disable, and security-relevant settings; (5) Train identity management staff on selected profile requirements and proper configuration procedures; (6) Establish testing procedures to validate that identity management implementations conform to documented profiles; (7) Maintain profile conformance documentation that maps organizational controls to profile requirements; (8) Review and update profile selections annually or when threat landscape changes require enhanced security.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-2",
      "AC-4",
      "IA-2",
      "IA-4",
      "IA-5",
      "IA-9",
      "IA-10",
      "SA-4"
    ],
    "supplemental_guidance": "Organizations define identity management profiles based on mission and business requirements. Identity management profiles include specifications for identity assurance levels (IAL), authenticator assurance levels (AAL), and federation assurance levels (FAL). IALs, AALs, and FALs are defined in NIST SP 800-63. Conformance to profiles facilitates interoperability among organizations and promotes consistent application of authentication and authorization requirements.",
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:35:20.522004+00:00",
      "has_scripts": false,
      "enhanced_by": "loveless_qa"
    },
    "cac_metadata": {
      "implementation_type": "policy_driven",
      "last_analyzed": "2025-11-20T19:35:20.522006+00:00",
      "source": "NIST SP 800-53 Rev 5 and NIST SP 800-63-3",
      "cac_status": "not_applicable",
      "cac_planned": false,
      "implementation_guidance": "IA-8(4) requires organizational selection and documentation of identity management profiles with technical implementation at the identity platform level. Compliance is demonstrated through documented profile conformance specifications and identity system configurations that enforce profile requirements."
    },
    "ai_guidance": "IA-8(4) Use of Defined Profiles requires using organization-defined authentication profiles for non-organizational users. Implement FICAM-conformant profiles, define acceptable authentication methods for external parties, and enforce profile-based access decisions."
  },
  {
    "control_id": "IA-8(5)",
    "control_name": "Acceptance of PIV-I Credentials",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Accept and verify federated or PKI credentials that meet [Assignment: organization-defined policy].",
    "parent_control": "IA-8",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must be able to accept PIV-Interoperable (PIV-I) credentials, which are smart cards issued by non-federal entities (such as contractors or state governments) that meet the same technical standards as federal PIV cards. The organization defines what policies these credentials must meet before being accepted.",
    "example_implementation": "Configure authentication systems to accept PIV-I credentials from contractors by establishing trust with the PIV-I Certificate Authority through the Federal Bridge CA. Define organizational policy requiring PIV-I credentials to contain certificates issued under the X.509 Certificate Policy for the U.S. Federal PKI Common Policy Framework, with mandatory certificate path validation to the Federal Common Policy CA. Implement OCSP responders to validate certificate revocation status in real-time. Configure logical access control systems to extract the FASC-N or UUID from PIV-I card and map to user account with appropriate authorization profile.",
    "non_technical_guidance": "Organizations should establish the following for PIV-I credential acceptance: (1) Develop organizational policy defining acceptable PIV-I credential types, issuers, and certificate policies that credentials must conform to; (2) Establish trust relationships with PIV-I certificate authorities through Federal Bridge CA cross-certification or direct trust arrangements; (3) Define credential validation requirements including certificate path validation, revocation checking, and required certificate extensions; (4) Implement identity proofing procedures to verify PIV-I cardholders' identities and establish account associations before granting access; (5) Deploy physical and logical access control infrastructure capable of reading PIV-I credentials including card readers and middleware software; (6) Train security staff on differences between PIV and PIV-I credentials and appropriate validation procedures; (7) Establish procedures for handling PIV-I credential expiration, revocation, and reissuance scenarios; (8) Maintain documentation of approved PIV-I issuers and their certification status in security authorization packages.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-2",
      "AC-14",
      "IA-2",
      "IA-2(1)",
      "IA-2(2)",
      "IA-2(12)",
      "IA-4",
      "IA-5",
      "IA-5(2)",
      "IA-8(1)",
      "SA-4",
      "SC-8"
    ],
    "supplemental_guidance": "PIV-I credentials are PIV-compliant credentials issued by a non-Federal government entity. PIV-I credentials include commercial smart cards. The organization defines and approves specific policies that PIV-I credentials must satisfy or missions or business functions for which PIV-I credentials can be used. Acceptance of PIV-I credentials applies to logical and physical access control systems.",
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:35:20.522009+00:00",
      "has_scripts": false,
      "enhanced_by": "loveless_qa"
    },
    "cac_metadata": {
      "implementation_type": "manual_configuration",
      "last_analyzed": "2025-11-20T19:35:20.522011+00:00",
      "source": "NIST SP 800-53 Rev 5 and FIPS 201-3",
      "cac_status": "not_available",
      "cac_planned": false,
      "implementation_guidance": "IA-8(5) requires organizational policy definition and technical configuration of PKI trust relationships. Implementation involves identity management system configuration, PKI trust establishment, and access control system integration for PIV-I credential acceptance."
    },
    "ai_guidance": "IA-8(5) Acceptance of PIV-I Credentials requires accepting PIV-Interoperable credentials from non-federal issuers. Implement PIV-I certificate validation, verify NFI issuer trust, and map PIV-I credentials to appropriate access levels for non-federal users."
  },
  {
    "control_id": "IA-8(6)",
    "control_name": "Disassociability",
    "family": "Identification and Authentication",
    "family_id": "IA",
    "official_text": "Implement the following measures to disassociate user attributes or identifier assertion relationships among individuals, credential service providers, and relying parties: [Assignment: organization-defined measures].",
    "parent_control": "IA-8",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must implement privacy-enhancing technologies that prevent external identity providers from tracking which services a user is accessing. This protects user privacy by preventing the creation of detailed profiles about user behavior across multiple systems.",
    "example_implementation": "Implement a privacy-preserving identity broker that acts as an intermediary between external identity providers and organizational services. Use cryptographic blinding techniques such as blind signatures or zero-knowledge proofs to authenticate users without revealing the specific service being accessed to the identity provider. Implement pairwise pseudonymous identifiers (PPID) where each relying party receives a different identifier for the same user, preventing correlation across services. Deploy an identity gateway that generates ephemeral session tokens after authentication, preventing identity providers from observing subsequent service interactions. Use attribute aggregation services that combine attributes from multiple sources without revealing the requesting service to attribute providers.",
    "non_technical_guidance": "Organizations should establish the following for identity disassociability: (1) Conduct privacy impact assessments to identify risks of user tracking and profiling through federated authentication; (2) Implement technical controls such as identity brokers, anonymization proxies, or privacy-preserving cryptographic protocols to prevent correlation of user activities; (3) Configure federated identity systems to use pairwise pseudonymous identifiers rather than global identifiers that enable cross-service tracking; (4) Establish policies limiting what user attributes are shared with external identity providers during authentication; (5) Implement contract terms with external identity providers prohibiting tracking of user service access patterns; (6) Use transient identifiers or session tickets that prevent long-term tracking of user authentication patterns; (7) Conduct privacy testing to verify that disassociability controls effectively prevent user tracking; (8) Document disassociability measures in privacy documentation and system security plans, explaining how user privacy is protected during external authentication.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "IA-2",
      "IA-4",
      "IA-5",
      "IA-8(2)",
      "PT-1",
      "PT-2",
      "PT-3",
      "PT-7",
      "SA-8",
      "SC-8"
    ],
    "supplemental_guidance": "Federated identity solutions can create increased privacy risks due to the tracking and profiling of individuals. Using identifier mapping tables or cryptographic techniques to blind credential service providers and relying parties from each other or to make identity attributes less visible to transmitting parties can reduce these privacy risks. Organization-defined measures to disassociate user attributes or identifier assertion relationships among individuals, credential service providers, and relying parties include pairwise pseudonymous identifiers and attribute aggregation services.",
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T19:35:20.522014+00:00",
      "has_scripts": false,
      "enhanced_by": "loveless_qa"
    },
    "cac_metadata": {
      "implementation_type": "manual_configuration",
      "last_analyzed": "2025-11-20T19:35:20.522015+00:00",
      "source": "NIST SP 800-53 Rev 5",
      "cac_status": "not_available",
      "cac_planned": false,
      "implementation_guidance": "IA-8(6) requires specialized privacy-enhancing technologies implemented at the identity management platform level. This control is application-specific and requires custom implementation based on organizational privacy requirements and threat model."
    },
    "ai_guidance": "IA-8(6) Disassociability requires preventing correlation of non-organizational user activities across interactions. Use pseudonymous identifiers, implement privacy-preserving authentication, and limit unnecessary collection of identifying information."
  }
]