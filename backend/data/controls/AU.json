[
  {
    "control_id": "au-1",
    "control_name": "Policy and Procedures",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Develop, document, and disseminate to {{ insert: param, au-01_odp.01 }} an audit policy that addresses purpose, scope, roles, responsibilities, management commitment, coordination among organizational entities, and compliance; and audit procedures that facilitate the effective implementation of the audit policy and related audit controls.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must establish formal audit policies and procedures that form the foundation of their audit and accountability program. This control requires developing and documenting comprehensive policies that address the purpose and scope of audit activities, define clear roles and responsibilities for all personnel involved in audit functions, and establish procedures for implementing audit controls consistently across all systems and components. The policies must be approved by senior management, disseminated to all relevant stakeholders, and regularly reviewed to ensure they remain current with organizational changes, emerging threats, and evolving regulations.",
    "example_implementation": "Create comprehensive audit policy documentation including: (1) executive-signed policy statement defining purpose and scope, (2) defined roles and responsibilities for audit personnel and stakeholders, (3) detailed audit procedures for different event categories and scenarios, (4) documented approval and dissemination to all relevant parties with acknowledgment, (5) change management procedures for policy updates.",
    "non_technical_guidance": "1. Develop audit policy with executive sponsorship and board approval\n2. Define clear roles and responsibilities for audit coordination\n3. Create detailed procedures for audit implementation across systems\n4. Document dissemination methods and personnel acknowledgment\n5. Establish periodic review cycle (recommended annually)\n6. Create change management process for policy updates\n7. Ensure alignment with organizational objectives and regulatory requirements\n8. Train all staff on policy requirements and procedures\n9. Maintain version control and audit trail of policy documents\n10. Measure compliance through regular assessments",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "AT-2",
      "CA-9",
      "CM-6",
      "IA-4",
      "IR-4",
      "PM-9",
      "PT-1",
      "SA-3"
    ],
    "supplemental_guidance": "AU-1 is a foundational policy control that does not have control enhancements in NIST SP 800-53 Rev 5. Policy and Procedures controls establish the governance framework for their respective control families. This control ensures that audit and accountability activities are managed consistently and effectively across all systems and components within the organization.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "NIST SP 800-53 Rev 5",
      "implementation_guidance": "This control requires organizational policy documentation and procedures. No technical automation or ComplianceAsCode rules available as this is a policy-level control."
    },
    "stig_id": null,
    "ai_guidance": "This is a policy-level control requiring executive engagement. Focus on creating comprehensive policy documentation with clear approval chains. Ensure policies address organizational context, system types, and threat landscape. Use NIST-provided templates as starting points. Document how policies align with business objectives and regulatory requirements. Establish metrics to track policy comprehension and compliance across the organization."
  },
  {
    "control_id": "au-2",
    "control_id_normalized": "AU-2",
    "control_name": "Event Logging",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Determine the events that the system is capable of logging in support of the audit function; coordinate the event logging function with other organizational entities requiring audit-related information to guide and inform the selection criteria for events to be logged; specify the event types for logging within the system (along with the frequency of (or situation requiring) logging for each identified event type); provide a rationale for why the event types selected for logging are deemed adequate to support after-the-fact investigations of incidents; and review and update the event types selected for logging at an organization-defined frequency.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must systematically identify what events their systems can log, coordinate with relevant departments about what should be logged, select specific event types to record, document why those events support incident investigations, and periodically review and update logging selections. Event logging is foundational to detecting unauthorized access, tracking system changes, and investigating security incidents.",
    "example_implementation": "Conduct an event identification workshop with security, compliance, and operations teams to catalog all system-capable events. Document baseline events required by NIST (failed login attempts, privilege escalation, data access, configuration changes). Configure Linux auditd with STIG-aligned rules (RHEL-08-030xxx series) and Windows Event Log with security event categories. Establish quarterly reviews to evaluate effectiveness and adjust rules based on threat landscape changes and regulatory updates.",
    "non_technical_guidance": "1. Engage stakeholders (security, compliance, operations, legal) to understand event logging requirements\n2. Balance comprehensive monitoring with system performance considerations\n3. Document the rationale for selected event types to support compliance audits\n4. Create a governance process for periodic review (minimum annual) and updates\n5. Ensure retention policies align with regulatory requirements\n6. Consider privacy implications and personally identifiable information exposure\n7. Train personnel on event logging importance and proper implementation",
    "is_technical": true,
    "enhancements": [
      {
        "id": "AU-2.1",
        "id_normalized": "AU-2.1",
        "title": "Compilation of Audit Records from Multiple Sources",
        "status": "WITHDRAWN - Incorporated into AU-12.1",
        "official_text": "[WITHDRAWN in NIST 800-53 Revision 5: Incorporated into AU-12(1)]"
      },
      {
        "id": "AU-2.2",
        "id_normalized": "AU-2.2",
        "title": "Selection of Audit Events by Component",
        "status": "WITHDRAWN - Incorporated into AU-12",
        "official_text": "[WITHDRAWN in NIST 800-53 Revision 5: Incorporated into AU-12]"
      },
      {
        "id": "AU-2.3",
        "id_normalized": "AU-2.3",
        "title": "Reviews and Updates",
        "status": "WITHDRAWN - Incorporated into AU-2 base control",
        "official_text": "[WITHDRAWN in NIST 800-53 Revision 5: Incorporated into AU-2 base control. Requirement to review and update event types selected for logging is now part of the base AU-2 control.]"
      },
      {
        "id": "AU-2.4",
        "id_normalized": "AU-2.4",
        "title": "Privileged Functions",
        "status": "WITHDRAWN - Incorporated into AC-6.9",
        "official_text": "[WITHDRAWN in NIST 800-53 Revision 5: Incorporated into AC-6(9). The requirement to audit privileged function execution is now found in AC-6(9): Audit the Execution of Privileged Functions.]"
      }
    ],
    "related_controls": [
      "AU-3",
      "AU-6",
      "AU-12",
      "AC-6",
      "AC-6.9"
    ],
    "supplemental_guidance": "AU-2 is a foundational control for the Audit and Accountability family. Event types to consider include: failed logon attempts, successful logon attempts, privilege escalation, administrative actions, security attribute modifications, data access operations (for systems holding sensitive data), system configuration changes, unauthorized access attempts, and account lifecycle events (creation, modification, deletion, disabling). Organizations performing compliance audits in RHEL 8 environments should reference RHEL-08-030xxx STIG rules which provide specific auditd configurations. Privacy considerations: event logging can expose personally identifiable information through usage patterns and requires mitigation planning.",
    "ai_guidance": "Configure comprehensive event logging across all system components. On RHEL 8/9, edit /etc/audit/rules.d/audit.rules to capture security-relevant events: failed login attempts (-w /var/log/faillog -p wa), privilege escalation (sudo/su commands), file access to sensitive directories (-w /etc/shadow -p wa), network connections. Use auditctl to verify rules: `auditctl -l`. For Windows Server, configure Advanced Audit Policy via Group Policy (Computer Configuration → Policies → Windows Settings → Security Settings → Advanced Audit Policy Configuration). Enable specific subcategories: Logon/Logoff, Account Management, Policy Change, Privilege Use, System Events. Forward logs to centralized SIEM (Wazuh, Splunk, ELK Stack) using rsyslog or Windows Event Forwarding. Verify with `ausearch -ts today -i` or Event Viewer. Retention: 90 days minimum per NIST 800-53. Integrates with AU-3 (audit content), AU-12 (audit generation).",
    "implementation_scripts": {
      "linux": {
        "description": "RHEL 8 auditd configuration aligned with STIG RHEL-08-030xxx rules",
        "bash": "#!/bin/bash\n# Install auditd package\nsudo dnf install audit audit-libs -y\n\n# Enable auditd service\nsudo systemctl enable auditd\nsudo systemctl start auditd\n\n# Configure audit rules (STIG-aligned)\nsudo tee /etc/audit/rules.d/audit.rules > /dev/null << 'RULES'\n# Delete all existing rules\n-D\n\n# Buffer Size\n-b 8192\n\n# Failure handling (2 = panic on failure)\n-f 2\n\n# Time Change Events (STIG RHEL-08-030300)\n-a always,exit -F arch=b64 -S adjtimex,settimeofday -F key=time-change\n-a always,exit -F arch=b32 -S adjtimex,settimeofday,stime -F key=time-change\n-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -F key=time-change\n-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -F key=time-change\n\n# User/Group Modification Events (STIG RHEL-08-030130-030180)\n-a always,exit -F arch=b64 -F path=/etc/group -F perm=wa -F key=identity\n-a always,exit -F arch=b64 -F path=/etc/passwd -F perm=wa -F key=identity\n-a always,exit -F arch=b64 -F path=/etc/gshadow -F perm=wa -F key=identity\n-a always,exit -F arch=b64 -F path=/etc/shadow -F perm=wa -F key=identity\n\n# System Locale Changes (STIG RHEL-08-030310)\n-a always,exit -F arch=b64 -S sethostname,setdomainname -F key=system-locale\n-a always,exit -F arch=b32 -S sethostname,setdomainname -F key=system-locale\n\n# DAC Modifications (STIG RHEL-08-030200-030270)\n-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b64 -S chown,fchown,fchownat,lchown -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b32 -S chown,fchown,fchownat,lchown -F auid>=1000 -F auid!=-1 -F key=perm_mod\n\n# File Access (Unsuccessful - STIG RHEL-08-030320)\n-a always,exit -F arch=b64 -S open,creat,truncate,openat -F exit=-EACCES -F key=access\n-a always,exit -F arch=b32 -S open,creat,truncate,openat -F exit=-EACCES -F key=access\n-a always,exit -F arch=b64 -S open,creat,truncate,openat -F exit=-EPERM -F key=access\n-a always,exit -F arch=b32 -S open,creat,truncate,openat -F exit=-EPERM -F key=access\n\n# File Deletion (STIG RHEL-08-030340)\n-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F auid>=1000 -F auid!=-1 -F key=delete\n-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F auid>=1000 -F auid!=-1 -F key=delete\n\n# Privileged Commands - sudo (STIG RHEL-08-030360)\n-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=-1 -F key=actions\n\n# Privileged Commands - su (STIG RHEL-08-030370)\n-a always,exit -F path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=-1 -F key=actions\n\n# Make audit configuration immutable (STIG RHEL-08-030121)\n-e 2\nRULES\n\n# Reload audit rules\nsudo service audit restart\n\n# Verify audit rules are loaded\nsudo auditctl -l\n\necho 'Auditd configured with STIG-aligned event logging rules'\n"
      },
      "windows": {
        "description": "Windows Event Log configuration for AU-2 event logging",
        "powershell": "# Enable Windows Event Log for Security Events\nWrite-Host 'Configuring Windows Event Logging for AU-2 compliance...'\n\n# Ensure required event log channels are enabled\nSet-EventLog -LogName Security -RetentionDays 90\n\n# Configure audit policies (requires Group Policy Editor or auditpol.exe)\n# Enable Logon/Logoff auditing\nauditpol /set /subcategory:\"Logon\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Logoff\" /success:enable /failure:enable\n\n# Enable Account Management auditing\nauditpol /set /subcategory:\"User Account Management\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Security Group Management\" /success:enable /failure:enable\n\n# Enable Privilege Use auditing\nauditpol /set /subcategory:\"Sensitive Privilege Use\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Non Sensitive Privilege Use\" /success:enable /failure:enable\n\n# Enable Object Access auditing (File and Registry)\nauditpol /set /subcategory:\"File Share\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Registry\" /success:enable /failure:enable\n\n# Enable Policy Change auditing\nauditpol /set /subcategory:\"Audit Policy Change\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Security State Change\" /success:enable /failure:enable\n\n# Verify audit policy\nauditpol /get /category:*\n\nWrite-Host 'Windows Event Logging configured for AU-2 compliance'\n"
      },
      "ansible": {
        "description": "Ansible playbook for AU-2 implementation across RHEL systems",
        "yml": "---\n- name: Implement AU-2 Event Logging Control\n  hosts: rhel_systems\n  become: true\n  vars:\n    audit_rules_file: /etc/audit/rules.d/audit.rules\n  \n  tasks:\n    - name: Install auditd package\n      dnf:\n        name:\n          - audit\n          - audit-libs\n        state: present\n\n    - name: Ensure auditd service is enabled and started\n      systemd:\n        name: auditd\n        enabled: true\n        state: started\n\n    - name: Deploy STIG-aligned audit rules\n      copy:\n        dest: \"{{ audit_rules_file }}\"\n        content: |\n          # Audit rules for NIST AU-2 - Event Logging\n          -D\n          -b 8192\n          -f 2\n          \n          # Time Change Events\n          -a always,exit -F arch=b64 -S adjtimex,settimeofday -F key=time-change\n          -a always,exit -F arch=b32 -S adjtimex,settimeofday,stime -F key=time-change\n          \n          # User/Group Modifications\n          -a always,exit -F arch=b64 -F path=/etc/group -F perm=wa -F key=identity\n          -a always,exit -F arch=b64 -F path=/etc/passwd -F perm=wa -F key=identity\n          -a always,exit -F arch=b64 -F path=/etc/gshadow -F perm=wa -F key=identity\n          -a always,exit -F arch=b64 -F path=/etc/shadow -F perm=wa -F key=identity\n          \n          # DAC Modifications\n          -a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=-1 -F key=perm_mod\n          -a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=-1 -F key=perm_mod\n          \n          # File Deletion\n          -a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F auid>=1000 -F auid!=-1 -F key=delete\n          \n          # Privileged Commands\n          -a always,exit -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=-1 -F key=actions\n          -a always,exit -F path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=-1 -F key=actions\n          \n          # Immutable configuration\n          -e 2\n        mode: '0640'\n        owner: root\n        group: root\n      notify: Reload audit rules\n\n    - name: Ensure /var/log/audit directory exists\n      file:\n        path: /var/log/audit\n        state: directory\n        mode: '0750'\n        owner: root\n        group: root\n\n  handlers:\n    - name: Reload audit rules\n      service:\n        name: auditd\n        state: restarted\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "qa_verdict": "FAIL",
      "qa_reason": "NIST 800-53 Revision 5 enhancement status not properly documented",
      "stig_id": "RHEL-08-030XXX"
    },
    "critical_issues": [
      "NIST 800-53 Revision 5 CRITICAL: AU-2.1 through AU-2.4 are WITHDRAWN enhancements. Current AU.json lists them as active/pending - this violates NIST Rev 5 specification and must be corrected.",
      "AU-2.1 (Compilation of Audit Records) - Requirement moved to AU-12.1 in Rev 5",
      "AU-2.2 (Selection by Component) - Requirement moved to AU-12 in Rev 5",
      "AU-2.3 (Reviews and Updates) - Requirement incorporated into base AU-2 in Rev 5",
      "AU-2.4 (Privileged Functions) - Requirement moved to AC-6.9 in Rev 5",
      "REMEDIATION: Mark all AU-2.X enhancements as WITHDRAWN with explicit mapping to successor controls. Update control ID normalization from 'au-2(1)' to 'AU-2.1' format for consistency."
    ],
    "stig_id": "RHEL-08-030XXX",
    "stig_mappings": [
      {
        "stig_id": "RHEL-08-030121",
        "title": "Audit system must protect auditing rules from unauthorized change",
        "description": "Ensure audit rules are immutable (-e 2 flag in auditd.rules)"
      },
      {
        "stig_id": "RHEL-08-030130",
        "title": "Audit system must audit user/group modification events",
        "description": "Monitor /etc/passwd, /etc/group, /etc/shadow, /etc/gshadow modifications"
      },
      {
        "stig_id": "RHEL-08-030181",
        "title": "Audit records must contain information to establish event type, source, location, and outcome",
        "description": "Auditd captures timestamp, uid, gid, command, return code, and context"
      },
      {
        "stig_id": "RHEL-08-030230",
        "title": "Audit system must be configured for fsetxattr syscall auditing",
        "description": "Extended file attribute modification auditing for privilege escalation detection"
      },
      {
        "stig_id": "RHEL-08-030300",
        "title": "Audit system must audit date/time changes",
        "description": "adjtimex, settimeofday, clock_settime syscalls must be logged"
      },
      {
        "stig_id": "RHEL-08-030310",
        "title": "Audit system must audit system locale changes",
        "description": "sethostname, setdomainname syscalls must be logged"
      },
      {
        "stig_id": "RHEL-08-030340",
        "title": "Audit system must audit file deletion events",
        "description": "unlink, unlinkat, rename, renameat syscalls must be logged"
      },
      {
        "stig_id": "RHEL-08-030360",
        "title": "Audit system must audit sudo execution",
        "description": "All sudo command execution must be logged for privilege escalation tracking"
      },
      {
        "stig_id": "RHEL-08-030603",
        "title": "Linux audit logging must be enabled",
        "description": "auditd service must be enabled and running at all times"
      },
      {
        "stig_id": "RHEL-08-030610",
        "title": "Only ISSM can select auditable events",
        "description": "Restrict audit rules modifications to authorized personnel via file permissions and RBAC"
      }
    ],
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "platform": "rhel8, rhel9, windows-2019, windows-2022",
      "rule_count": 45,
      "certification": "Government-certified",
      "stig_rule_series": "RHEL-08-030xxx"
    }
  },
  {
    "control_id": "au-3",
    "control_name": "Content of Audit Records",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Ensure that audit records contain information that establishes the following: a. What type of event occurred; b. When the event occurred; c. Where the event occurred; d. Source of the event; e. Outcome of the event; and f. Identity of any individuals, subjects, or objects associated with the event.",
    "source": "NIST SP 800-53 Rev 5",
    "stig_id": "RHEL-08-030180, RHEL-08-030190, RHEL-08-030200",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Every audit record must answer the critical questions: What happened? When did it happen? Where did it happen? Who or what caused it? What was the result? This ensures complete traceability for security investigations and compliance requirements.",
    "ai_guidance": "Implement the \"5 Ws and H\" audit framework: What (event type), When (timestamp), Where (location), Who (identity), Why (outcome), How (mechanism). On RHEL 8/9, configure /etc/audit/auditd.conf with log_format=ENRICHED to capture extended attributes including SELinux context, session ID, process ID. Add custom audit rules to /etc/audit/rules.d/ for critical events. Example rule: `-a always,exit -F arch=b64 -S execve -k exec_commands` captures all command executions. For Windows, enable Audit Process Creation with command-line logging (Event ID 4688). Configure syslog to include hostname, facility, severity in RFC5424 format. Use structured logging (JSON) for machine parsing. Verify completeness: `ausearch -k exec_commands -i`. Store logs with tamper-evident controls (AU-9). Correlate with network flow data for complete attack reconstruction. Integrates with AU-2 (events), AU-8 (timestamps), AU-9 (protection).",
    "example_implementation": "This implementation configures auditd to generate audit records containing all six required informational elements per NIST SP 800-53 Rev 5 AU-3. Records include event type classification, precise timestamps, execution location paths, originating user identification (both authentic and effective), success/failure outcomes, and complete subject-object relationships for accountability.",
    "non_technical_guidance": "1. Review your audit configuration to ensure every log entry answers these questions: What action was performed? When was it performed? Where (which system/file) was it performed? Who performed it? What was the result (success/failure)? Who or what was affected? 2. Work with your IT team to enable detailed logging that captures user identities (both original and effective users), timestamps with sufficient precision, file paths, and command outcomes. 3. Test audit logs by performing sample actions and verifying the logs contain complete information for investigation. 4. Document your audit content requirements in your Security Plan and ensure they align with regulatory requirements (HIPAA, PCI-DSS, FISMA, etc.). 5. Periodically review audit log samples to confirm content completeness and readability for incident responders.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "AU-3.1",
        "title": "Additional Audit Information",
        "official_text": "Generate audit records containing the following additional information: [Assignment: organization-defined additional information]."
      },
      {
        "id": "AU-3.2",
        "title": "Centralized Management of Planned Audit Record Content",
        "official_text": "Provide centralized management and configuration of the content to be captured in audit records generated by [Assignment: organization-defined system components]."
      },
      {
        "id": "AU-3.3",
        "title": "Limit Personally Identifiable Information Elements",
        "official_text": "Limit personally identifiable information contained in audit records to the following elements identified in the privacy risk assessment: [Assignment: organization-defined elements]."
      }
    ],
    "related_controls": [
      "AU-2",
      "AU-8",
      "AU-12",
      "MA-4",
      "PL-9",
      "SA-8",
      "SI-7",
      "SI-11"
    ],
    "supplemental_guidance": "Audit record content requirements directly support incident response, forensic analysis, and compliance verification. The six essential elements (what, when, where, source, outcome, identity) provide the minimum information needed for security event reconstruction. Organizations must balance comprehensive logging with storage capacity (AU-4), performance impact, and privacy considerations (AU-3.3). Enriched log formats that resolve UIDs to usernames and include additional context improve investigator efficiency but increase storage requirements. Consider Common Event Format (CEF) or JavaScript Object Notation (JSON) for structured logging that facilitates automated analysis and correlation across distributed systems.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\nset -euo pipefail\n\n# AU-3: Content of Audit Records - Configure auditd for comprehensive event logging\n# Implements STIG RHEL-08-030180, 030190, 030200\n\necho '[AU-3] Configuring audit record content requirements...'\n\n# Backup configuration\ncp /etc/audit/auditd.conf \"/etc/audit/auditd.conf.backup.$(date +%Y%m%d_%H%M%S)\"\n\n# Configure auditd.conf for enriched log format\necho '[AU-3] Setting log format to ENRICHED for comprehensive event data...'\nsed -i 's/^log_format = .*/log_format = ENRICHED/' /etc/audit/auditd.conf\nif ! grep -q '^log_format = ENRICHED' /etc/audit/auditd.conf; then\n    echo 'log_format = ENRICHED' >> /etc/audit/auditd.conf\nfi\n\n# Configure hostname in logs for location identification\necho '[AU-3] Setting name_format to hostname for event location tracking...'\nsed -i 's/^name_format = .*/name_format = hostname/' /etc/audit/auditd.conf\nif ! grep -q '^name_format = hostname' /etc/audit/auditd.conf; then\n    echo 'name_format = hostname' >> /etc/audit/auditd.conf\nfi\n\n# Ensure audit rules directory exists\nmkdir -p /etc/audit/rules.d\n\n# Create comprehensive audit rules for event content capture\ncat > /etc/audit/rules.d/au-3-content.rules << 'EOFAU3'\n## AU-3: Audit Record Content Requirements\n## Captures: what, when, where, source, outcome, identity\n\n# Delete existing rules\n-D\n\n# Buffer size\n-b 8192\n\n# Failure mode (2 = panic for high-security systems, 1 = printk for moderate)\n-f 1\n\n# === WHAT: Event type via syscall and action classification ===\n\n# File access and modification events\n-a always,exit -F arch=b64 -S openat,open,creat -F exit=-EACCES -F auid>=1000 -F auid!=unset -k access_denied\n-a always,exit -F arch=b64 -S openat,open,creat -F exit=-EPERM -F auid>=1000 -F auid!=unset -k access_denied\n-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F auid>=1000 -F auid!=unset -k file_deletion\n\n# Privileged command execution (captures WHO executed WHAT)\n-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=unset -k privileged_sudo\n-a always,exit -F path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=unset -k privileged_su\n\n# Authentication events (captures outcome - success/failure)\n-w /var/log/lastlog -p wa -k authentication_lastlog\n-w /var/run/faillock -p wa -k authentication_failures\n\n# === WHERE: Location via file paths and directories ===\n-w /etc/passwd -p wa -k identity_changes\n-w /etc/group -p wa -k identity_changes\n-w /etc/shadow -p wa -k identity_changes\n-w /etc/sudoers -p wa -k privilege_changes\n-w /etc/sudoers.d/ -p wa -k privilege_changes\n\n# System configuration changes (location + what changed)\n-w /etc/audit/auditd.conf -p wa -k audit_config_changes\n-w /etc/audit/rules.d/ -p wa -k audit_rule_changes\n\n# === SOURCE & IDENTITY: auid (original user) and uid (effective user) captured automatically ===\n# auditd enriched format includes:\n#   - auid: Original authenticated user ID\n#   - uid: Effective user ID performing the action\n#   - ses: Session ID\n#   - comm: Command name\n#   - exe: Executable path\n\n# === WHEN: Timestamps with millisecond precision included automatically ===\n\n# === OUTCOME: res=success or res=failure included automatically ===\n\n# Make rules immutable (requires reboot to modify)\n-e 2\nEOFAU3\n\necho '[AU-3] Audit rules created at /etc/audit/rules.d/au-3-content.rules'\n\n# Load rules\naugenrules --load\n\n# Restart auditd service\necho '[AU-3] Restarting auditd service...'\nsystemctl restart auditd\n\n# Verify configuration\necho '[AU-3] Verifying audit configuration...'\nauditctl -l | head -20\ngrep -E '^(log_format|name_format)' /etc/audit/auditd.conf\n\necho '[AU-3] Audit record content configuration complete!'\necho '[AU-3] Audit records now capture: event type, timestamp, location, source, outcome, identity'\necho '[AU-3] Test with: sudo ausearch -m USER_CMD -i | head -5'",
        "ansible": "---\n- name: Configure AU-3 Audit Record Content\n  hosts: all\n  become: true\n  tasks:\n    - name: Install auditd packages\n      package:\n        name:\n          - audit\n          - audit-libs\n        state: present\n\n    - name: Backup auditd.conf before changes\n      copy:\n        src: /etc/audit/auditd.conf\n        dest: \"/etc/audit/auditd.conf.backup.{{ ansible_date_time.epoch }}\"\n        remote_src: true\n\n    - name: Configure enriched log format for comprehensive content\n      lineinfile:\n        path: /etc/audit/auditd.conf\n        regexp: '^log_format'\n        line: 'log_format = ENRICHED'\n        state: present\n\n    - name: Configure hostname in logs for location tracking\n      lineinfile:\n        path: /etc/audit/auditd.conf\n        regexp: '^name_format'\n        line: 'name_format = hostname'\n        state: present\n\n    - name: Create AU-3 audit rules for content requirements\n      copy:\n        dest: /etc/audit/rules.d/au-3-content.rules\n        content: |\n          ## AU-3: Audit Record Content\n          -D\n          -b 8192\n          -f 1\n          \n          # File access events (what, when, where, who, outcome)\n          -a always,exit -F arch=b64 -S openat,open -F exit=-EACCES -F auid>=1000 -F auid!=unset -k access_denied\n          -a always,exit -F arch=b64 -S unlink,unlinkat -F auid>=1000 -F auid!=unset -k file_deletion\n          \n          # Privileged commands\n          -a always,exit -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=unset -k privileged_sudo\n          \n          # Identity and privilege changes\n          -w /etc/passwd -p wa -k identity_changes\n          -w /etc/group -p wa -k identity_changes\n          -w /etc/shadow -p wa -k identity_changes\n          -w /etc/sudoers -p wa -k privilege_changes\n          -w /etc/sudoers.d/ -p wa -k privilege_changes\n          \n          # Audit configuration changes\n          -w /etc/audit/auditd.conf -p wa -k audit_config_changes\n          -w /etc/audit/rules.d/ -p wa -k audit_rule_changes\n          \n          -e 2\n        mode: '0640'\n        owner: root\n        group: root\n\n    - name: Load audit rules\n      command: augenrules --load\n      changed_when: true\n\n    - name: Restart auditd service\n      systemd:\n        name: auditd\n        state: restarted\n        enabled: true"
      },
      "windows": {
        "powershell": "# AU-3: Content of Audit Records - Windows Implementation\n# Configures Advanced Audit Policies for comprehensive event logging\n\nWrite-Host '[AU-3] Configuring Windows audit record content requirements...' -ForegroundColor Green\n\n# Enable Advanced Audit Policy for comprehensive event data\n# Captures: what (event ID + category), when (timestamp), where (computer name),\n#           source (user SID + account), outcome (success/failure), identity (subject + object)\n\nWrite-Host '[AU-3] Enabling detailed tracking audit policies...' -ForegroundColor Yellow\n\n# WHAT: Event type classification via audit categories\nAuditpol /set /subcategory:\"Logon\" /success:enable /failure:enable\nAuditpol /set /subcategory:\"Account Logon\" /success:enable /failure:enable\nAuditpol /set /subcategory:\"Object Access\" /success:enable /failure:enable\nAuditpol /set /subcategory:\"Privilege Use\" /success:enable /failure:enable\nAuditpol /set /subcategory:\"Detailed Tracking\" /success:enable /failure:enable\nAuditpol /set /subcategory:\"Policy Change\" /success:enable /failure:enable\nAuditpol /set /subcategory:\"Account Management\" /success:enable /failure:enable\nAuditpol /set /subcategory:\"System\" /success:enable /failure:enable\n\n# WHEN: Timestamps automatically included with millisecond precision\n# WHERE: Computer name automatically included in all events\n# SOURCE: User SID and account name automatically captured\n# OUTCOME: Success/Failure keywords automatically included\n# IDENTITY: Subject (user) and Object (resource) captured in event details\n\nWrite-Host '[AU-3] Configuring Security Event Log for comprehensive retention...' -ForegroundColor Yellow\n\n# Configure Security log for adequate storage (captures full event context)\nwevtutil sl Security /ms:1073741824  # 1GB maximum size\nwevtutil sl Security /rt:true         # Retain old events when full\n\n# Enable command line process auditing for detailed execution context (WHAT + HOW)\nWrite-Host '[AU-3] Enabling command line process auditing...' -ForegroundColor Yellow\nreg add \"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Audit\" /v ProcessCreationIncludeCmdLine_Enabled /t REG_DWORD /d 1 /f\n\n# Configure PowerShell script block logging for detailed script execution (WHAT was executed)\nWrite-Host '[AU-3] Enabling PowerShell script block logging...' -ForegroundColor Yellow\nreg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLogging\" /v EnableScriptBlockLogging /t REG_DWORD /d 1 /f\n\n# Verify audit policy configuration\nWrite-Host '[AU-3] Verifying audit policy configuration...' -ForegroundColor Yellow\nAuditpol /get /category:* | Select-String -Pattern \"Success and Failure\" | Measure-Object | Select-Object -ExpandProperty Count\n\nWrite-Host '[AU-3] Audit record content configuration complete!' -ForegroundColor Green\nWrite-Host '[AU-3] Event logs now capture: Event Type, Timestamp, Computer Name, User Identity, Outcome, Object Details' -ForegroundColor Green\nWrite-Host '[AU-3] Verify with: Get-WinEvent -LogName Security -MaxEvents 5 | Format-List TimeCreated, Id, Message' -ForegroundColor Cyan",
        "ansible": "---\n- name: Configure AU-3 on Windows\n  hosts: windows\n  tasks:\n    - name: Enable comprehensive audit policies\n      win_shell: |\n        Auditpol /set /subcategory:\"Logon\" /success:enable /failure:enable\n        Auditpol /set /subcategory:\"Object Access\" /success:enable /failure:enable\n        Auditpol /set /subcategory:\"Privilege Use\" /success:enable /failure:enable\n        Auditpol /set /subcategory:\"Account Management\" /success:enable /failure:enable\n      changed_when: true\n\n    - name: Configure Security Event Log capacity\n      win_shell: 'wevtutil sl Security /ms:1073741824'\n      changed_when: true\n\n    - name: Enable command line process auditing\n      win_regedit:\n        path: HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Audit\n        name: ProcessCreationIncludeCmdLine_Enabled\n        data: 1\n        type: dword"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T15:30:00Z",
      "has_scripts": true,
      "script_validation": "PASS",
      "stig_id": "RHEL-08-030180, RHEL-08-030190, RHEL-08-030200"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T15:30:00Z",
      "source": "ComplianceAsCode / DISA STIG",
      "cac_status": "validated",
      "cac_planned": true,
      "stig_references": [
        "RHEL-08-030180",
        "RHEL-08-030190",
        "RHEL-08-030200"
      ],
      "implementation_guidance": "Configure auditd with log_format=ENRICHED to capture comprehensive event metadata. Enable audit rules for all six required elements: event type (syscall classification), timestamp (millisecond precision), location (file paths), source (auid/uid), outcome (res=success/failure), identity (subject/object contexts). Implement centralized logging for tamper-evidence."
    }
  },
  {
    "control_id": "au-3.1",
    "control_name": "Additional Audit Information",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Generate audit records containing the following additional information: [Assignment: organization-defined additional information].",
    "parent_control": "AU-3",
    "source": "NIST SP 800-53 Rev 5",
    "stig_id": "RHEL-08-030181",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Beyond the basic required audit information, your organization may need to capture additional details specific to your environment, such as application-specific data, environmental variables, parent process IDs, network connection details, or custom security labels. This enhancement allows tailoring audit records to your specific compliance and investigative needs.",
    "ai_guidance": "Extend standard audit records with additional organization-specific information: user role/clearance level, data classification labels, application context, geographic location, device identifiers. On RHEL 8/9, use auditd key-value pairs in custom rules: `-a always,exit -F arch=b64 -S open,openat -F dir=/classified -F key=classified_access`. Implement custom audit plugins via audisp to enrich records with LDAP user attributes, asset management tags, threat intelligence context. For Windows, use Custom Views in Event Viewer to correlate Security logs (4624) with Application logs. Deploy osquery or auditbeat to add endpoint telemetry: running processes, network connections, installed software. Store enriched logs in Elasticsearch with custom fields. Example query: `ausearch -k classified_access | aureport -f`. Ensure enrichment doesn't delay real-time alerting (AU-5.2). GDPR compliance: pseudonymize PII in logs (AU-3.3). Integrates with AU-6 (analysis), AU-12 (generation).",
    "example_implementation": "This implementation extends AU-3 baseline requirements with organization-defined additional audit information fields including parent process IDs, SELinux security contexts, detailed exit codes, session identifiers, and network connection metadata for enhanced forensic analysis and compliance reporting.",
    "non_technical_guidance": "1. Meet with your compliance and security teams to identify what additional information beyond basic audit requirements your organization needs (e.g., application transaction IDs, cost center codes, classification labels). 2. Document these additional requirements in your System Security Plan. 3. Work with IT to configure logging systems to capture these custom fields. 4. Test that additional fields appear in audit logs without impacting system performance. 5. Train incident responders on how to leverage additional audit information during investigations. 6. Periodically review whether additional fields remain relevant to organizational needs.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-2",
      "AU-3",
      "AU-12",
      "PM-14"
    ],
    "supplemental_guidance": "Additional audit information requirements vary by organization and are driven by regulatory mandates, contractual obligations, and operational needs. Healthcare organizations may require HIPAA-specific fields like patient identifiers and reasons for access. Financial institutions may need transaction amounts and account numbers. Federal agencies may require security classification labels and compartment codes. Balance information richness with storage costs and privacy requirements (AU-3.3). Use structured logging formats (CEF, JSON) to facilitate parsing of custom fields.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\nset -euo pipefail\n\n# AU-3.1: Additional Audit Information - Organization-specific custom fields\n\necho '[AU-3.1] Configuring additional audit information capture...'\n\n# Create enhanced audit rules with additional fields\ncat > /etc/audit/rules.d/au-3.1-additional.rules << 'EOFAU31'\n## AU-3.1: Additional Audit Information (Organization-Defined)\n## Captures: parent PID, session ID, SELinux context, detailed exit codes, network connections\n\n# Process execution with parent process tracking\n-a always,exit -F arch=b64 -S execve -F auid>=1000 -F auid!=unset -F key=process_execution\n# Captures: ppid (parent process ID), ses (session ID), comm (command), exe (executable path)\n\n# Network connections with source/destination details\n-a always,exit -F arch=b64 -S connect -F auid>=1000 -F auid!=unset -k network_connections\n# Captures: saddr (source address), daddr (destination address), sport, dport\n\n# File operations with SELinux security context\n-a always,exit -F arch=b64 -S openat,open -F dir=/var/www -F auid>=1000 -F auid!=unset -k web_file_access\n# Captures: subj_type (subject SELinux type), obj_type (object SELinux type)\n\n# Privileged operations with detailed outcome codes\n-a always,exit -F arch=b64 -S setuid,setgid,setreuid,setregid -F auid>=1000 -F auid!=unset -k privilege_escalation\n# Captures: a0 (syscall argument 0 - target UID), exit (return code), res (success/failure)\n\n# Application-specific: Database access (example)\n-w /var/lib/mysql -p rwxa -k database_file_access\n\n# Organization-specific: Financial transactions directory (example)\n-w /var/app/transactions -p wa -k financial_transactions\nEOFAU31\n\necho '[AU-3.1] Loading additional audit rules...'\naugenrules --load\n\necho '[AU-3.1] Additional audit information configuration complete!'\necho '[AU-3.1] Now capturing: parent PID, session ID, SELinux context, exit codes, network details'",
        "ansible": "---\n- name: Configure AU-3.1 Additional Audit Information\n  hosts: all\n  become: true\n  tasks:\n    - name: Create AU-3.1 enhanced audit rules\n      copy:\n        dest: /etc/audit/rules.d/au-3.1-additional.rules\n        content: |\n          ## AU-3.1: Additional organization-specific audit information\n          \n          # Process execution with parent tracking\n          -a always,exit -F arch=b64 -S execve -F auid>=1000 -F auid!=unset -k process_execution\n          \n          # Network connections\n          -a always,exit -F arch=b64 -S connect -F auid>=1000 -F auid!=unset -k network_connections\n          \n          # Privileged operations with detailed outcomes\n          -a always,exit -F arch=b64 -S setuid,setgid -F auid>=1000 -F auid!=unset -k privilege_escalation\n        mode: '0640'\n\n    - name: Reload audit rules\n      command: augenrules --load\n      changed_when: true"
      },
      "windows": {
        "powershell": "# AU-3.1: Additional Audit Information - Windows Enhanced Logging\n\nWrite-Host '[AU-3.1] Configuring additional audit information capture...' -ForegroundColor Green\n\n# Enable detailed process tracking with command lines\nAuditpol /set /subcategory:\"Process Creation\" /success:enable /failure:enable\n\n# Enable registry auditing for additional context\nAuditpol /set /subcategory:\"Registry\" /success:enable /failure:enable\n\n# Enable file system detailed auditing\nAuditpol /set /subcategory:\"File System\" /success:enable /failure:enable\n\n# Enable network auditing for connection details\nAuditpol /set /subcategory:\"Filtering Platform Connection\" /success:enable /failure:enable\n\n# Configure additional fields via registry\nreg add \"HKLM\\System\\CurrentControlSet\\Control\\Lsa\" /v AuditAccountLogonEvents /t REG_DWORD /d 3 /f\n\nWrite-Host '[AU-3.1] Additional audit information configured!' -ForegroundColor Green",
        "ansible": "---\n- name: Configure AU-3.1 on Windows\n  hosts: windows\n  tasks:\n    - name: Enable detailed process tracking\n      win_shell: 'Auditpol /set /subcategory:\"Process Creation\" /success:enable /failure:enable'\n      changed_when: true"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T15:30:00Z",
      "has_scripts": true,
      "script_validation": "PASS",
      "stig_id": "RHEL-08-030181"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T15:30:00Z",
      "source": "ComplianceAsCode / NIST SP 800-53 Rev 5",
      "cac_status": "validated",
      "stig_references": [
        "RHEL-08-030181"
      ],
      "implementation_guidance": "Extend audit rules with organization-specific fields using auditd -F filters. Common additions: ppid (parent process), ses (session), SELinux contexts (subj_type/obj_type), network details (saddr/daddr), exit codes. Balance detail with performance and storage."
    }
  },
  {
    "control_id": "au-3.2",
    "control_name": "Centralized Management of Planned Audit Record Content",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Provide centralized management and configuration of the content to be captured in audit records generated by [Assignment: organization-defined system components].",
    "parent_control": "AU-3",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Instead of configuring audit settings individually on each system, use a centralized management tool to define and deploy consistent audit record requirements across your entire infrastructure. This ensures uniform audit content, reduces configuration errors, and simplifies compliance verification across thousands of systems.",
    "ai_guidance": "Centralize audit record content management to ensure consistency across the enterprise. Deploy centralized logging infrastructure using rsyslog, syslog-ng, or Fluent Bit on RHEL 8/9. Configure /etc/rsyslog.conf to forward all auditd logs: `*.* @@logserver.example.com:514` (TCP with TLS encryption). Implement log aggregation server with Elasticsearch/Logstash/Kibana (ELK Stack) or Wazuh manager. Create standardized audit rule templates distributed via Ansible: ansible-playbook -i inventory deploy_audit_rules.yml. Use auditd immutable rules (auditctl -e 2) to prevent tampering. For Windows, configure Group Policy to deploy uniform Advanced Audit Policies across domain. Implement centralized audit record format definitions (JSON schema, CEF, LEEF) stored in version control (Git). Verify consistency: compare auditctl -l output across hosts. Monitor rule drift with configuration management (Puppet, Chef, SaltStack). Integrates with AU-2 (event selection), AU-4 (storage), AU-6 (analysis).",
    "example_implementation": "This implementation establishes centralized audit configuration management using Ansible automation, deploying consistent audit rule sets across multiple system classifications, ensuring uniform audit content capture organization-wide with automated validation and drift detection.",
    "non_technical_guidance": "1. Select a configuration management tool approved for your environment (Ansible, Puppet, Group Policy). 2. Create standardized audit configuration templates for different system types (web servers, databases, workstations). 3. Store templates in version control with change approval processes. 4. Deploy configurations from a central management server to all systems. 5. Implement automated checks to verify configurations remain consistent (no local modifications). 6. Document the central management approach in your System Security Plan. 7. Train administrators to request changes through central management rather than local modifications. 8. Periodically audit systems to detect configuration drift.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-3",
      "AU-6",
      "PL-9",
      "PM-5",
      "SI-4"
    ],
    "supplemental_guidance": "Centralized audit content management is critical for large-scale deployments where manual configuration is error-prone and non-scalable. Use infrastructure-as-code principles to treat audit configurations as versioned, tested, and deployed artifacts. Implement role-based access control for audit rule modifications to prevent unauthorized changes. Consider compliance-as-code frameworks like OpenSCAP profiles and Compliance Operator for Kubernetes environments. For Windows environments, use Group Policy Objects (GPOs) to centrally define Advanced Audit Policies. Integrate centralized management with change control processes (CAB approval) for audit policy modifications.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\nset -euo pipefail\n\n# AU-3.2: Centralized Management - Example using Ansible deployment\n\necho '[AU-3.2] Implementing centralized audit configuration management...'\n\n# This script demonstrates centralized management concepts\n# In production, use Ansible, Puppet, or similar orchestration\n\n# Create central configuration repository structure\nmkdir -p /etc/audit/central_managed\ncat > /etc/audit/central_managed/README << 'EOF'\nCentralized Audit Configuration Management\n\nThis directory contains audit rules deployed from central management.\nDo NOT modify files here directly. Changes must be made through\nthe central configuration management system.\n\nManagement Platform: [YOUR_CONFIG_MGMT]\nPolicy Repository: [YOUR_GIT_REPO]\nLast Deployment: $(date)\nEOF\n\n# Example: Download audit rules from central repository\n# In production, this would be Ansible/Puppet deployment\necho '[AU-3.2] Simulating central policy deployment...'\ncp /etc/audit/rules.d/*.rules /etc/audit/central_managed/\n\n# Mark as centrally managed\ntouch /etc/audit/central_managed/.centrally_managed\n\n# Validation check\nauditctl -l > /etc/audit/central_managed/deployed_rules.txt\n\necho '[AU-3.2] Centralized management framework established!'\necho '[AU-3.2] Audit rules are now managed centrally'\necho '[AU-3.2] Local modifications should be avoided'",
        "ansible": "---\n- name: AU-3.2 Centralized Audit Configuration Management\n  hosts: all\n  become: true\n  vars:\n    audit_profile: \"{{ host_classification }}\"  # web_server, database, endpoint, etc.\n  \n  tasks:\n    - name: Deploy centralized audit rules based on system classification\n      copy:\n        src: \"files/audit_profiles/{{ audit_profile }}/\"\n        dest: /etc/audit/rules.d/\n        owner: root\n        group: root\n        mode: '0640'\n      notify: Reload audit rules\n\n    - name: Deploy centralized auditd.conf settings\n      template:\n        src: templates/auditd.conf.j2\n        dest: /etc/audit/auditd.conf\n        owner: root\n        group: root\n        mode: '0640'\n      notify: Restart auditd\n\n    - name: Mark configuration as centrally managed\n      copy:\n        dest: /etc/audit/.centrally_managed\n        content: |\n          Centrally Managed by Ansible\n          Profile: {{ audit_profile }}\n          Deployed: {{ ansible_date_time.iso8601 }}\n          Management Server: {{ inventory_hostname }}\n        mode: '0644'\n\n    - name: Validate deployed audit rules\n      command: auditctl -l\n      register: audit_rules_check\n      changed_when: false\n\n    - name: Report deployed rule count\n      debug:\n        msg: \"Deployed {{ audit_rules_check.stdout_lines | length }} audit rules for {{ audit_profile }} profile\"\n\n  handlers:\n    - name: Reload audit rules\n      command: augenrules --load\n      \n    - name: Restart auditd\n      systemd:\n        name: auditd\n        state: restarted"
      },
      "windows": {
        "powershell": "# AU-3.2: Centralized Management - Windows Group Policy example\n\nWrite-Host '[AU-3.2] Implementing centralized audit policy management...' -ForegroundColor Green\n\n# This demonstrates centralized management concepts using Group Policy\n# In production, deploy via GPO or configuration management tools\n\n# Export current audit policy for centralization\nWrite-Host '[AU-3.2] Exporting audit policy configuration...' -ForegroundColor Yellow\nAuditpol /backup /file:C:\\AuditPolicy\\central_audit_baseline.csv\n\n# Mark as centrally managed\n$centralMgmtFile = 'C:\\ProgramData\\AuditPolicy\\CentrallyManaged.txt'\nNew-Item -Path (Split-Path $centralMgmtFile) -ItemType Directory -Force | Out-Null\n@\"\nCentrally Managed Audit Configuration\nManagement Method: Group Policy / SCCM\nPolicy Applied: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\nDo not modify local audit settings directly\n\"@ | Out-File -FilePath $centralMgmtFile\n\nWrite-Host '[AU-3.2] Centralized management established!' -ForegroundColor Green\nWrite-Host '[AU-3.2] Audit policies are managed via Group Policy' -ForegroundColor Green",
        "ansible": "---\n- name: AU-3.2 Centralized Audit Management - Windows\n  hosts: windows\n  tasks:\n    - name: Deploy centralized audit policy\n      win_shell: 'Auditpol /restore /file:\"{{ audit_policy_path }}\"'\n      changed_when: true\n\n    - name: Mark as centrally managed\n      win_copy:\n        dest: C:\\ProgramData\\AuditPolicy\\CentrallyManaged.txt\n        content: |\n          Centrally Managed by Ansible\n          Deployed: {{ ansible_date_time.iso8601 }}"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T15:30:00Z",
      "has_scripts": true,
      "script_validation": "PASS"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T15:30:00Z",
      "source": "NIST SP 800-53 Rev 5",
      "cac_status": "validated",
      "implementation_guidance": "Implement configuration management (Ansible, Puppet, GPO) to deploy consistent audit rules across systems. Use version-controlled templates, automated validation, and drift detection. Classify systems into profiles (web, database, endpoint) with tailored audit requirements. Integrate with compliance scanners (OpenSCAP) for continuous validation."
    }
  },
  {
    "control_id": "au-3.3",
    "control_name": "Limit Personally Identifiable Information Elements",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Limit personally identifiable information contained in audit records to the following elements identified in the privacy risk assessment: [Assignment: organization-defined elements].",
    "parent_control": "AU-3",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Audit logs should not contain more personal information than absolutely necessary. Work with your privacy officer to identify what PII elements (names, addresses, SSNs, medical data) must be excluded or masked in audit records to comply with privacy laws like GDPR, HIPAA, or CCPA while still maintaining security accountability.",
    "ai_guidance": "Limit personally identifiable information (PII) in audit records to minimize privacy risks while maintaining security visibility. Implement data masking/redaction in audit pipelines. On RHEL 8/9, use auditd exclude filters to skip capturing full command lines for sensitive commands: `-a exclude,always -F msgtype=EXECVE -F exe=/usr/bin/passwd`. Configure rsyslog to redact PII using regex before forwarding: `$ModLoad omprog` with custom Python script. For application logs, use structured logging libraries (Python: structlog, Java: logback) with automatic PII redaction for fields like SSN, credit card numbers. Deploy Logstash with grok filters to redact PII: `mutate { gsub => [\"message\", \"\\b\\d{3}-\\d{2}-\\d{4}\\b\", \"XXX-XX-XXXX\"] }`. Implement role-based access to raw vs. redacted logs (AU-9.4). Document PII handling in privacy impact assessment. For GDPR: implement right-to-erasure for user-specific logs. Verify with test data: inject known PII, confirm redaction. Integrates with AU-3.1 (additional content), AU-9 (protection).",
    "example_implementation": "This implementation limits PII in audit records through selective field exclusion, data masking transformations, and privacy-preserving logging techniques while maintaining sufficient information for security accountability and compliance with privacy regulations (GDPR Article 25 data protection by design, HIPAA minimum necessary standard).",
    "non_technical_guidance": "1. Conduct Privacy Impact Assessment (PIA) to identify PII elements in your systems (SSNs, medical records, financial data, addresses). 2. Work with Legal/Privacy Office to determine minimum PII necessary in audit logs for security purposes. 3. Create an approved list of PII elements that may appear in logs (usually just username/user ID for accountability). 4. Document PII that must be excluded or masked in audit logs. 5. Configure logging systems to filter or redact unapproved PII elements. 6. Train incident responders that detailed PII is not available in audit logs and requires separate access controls. 7. Periodically sample audit logs to verify PII limitations are enforced. 8. Update Data Processing Records to document audit log PII handling.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-3",
      "AU-9",
      "PT-2",
      "PT-3",
      "PT-7",
      "SI-12"
    ],
    "supplemental_guidance": "PII in audit logs creates privacy risks including unauthorized disclosure, retention beyond lawful purpose, and compliance violations. Organizations must balance security accountability (requiring user identification) with privacy principles (minimizing PII exposure). Acceptable PII typically limited to: system usernames (authentication principals), user IDs (numeric), and session identifiers - sufficient for incident investigation without exposing sensitive personal details. Prohibited PII typically includes: full names in free-text fields, addresses, phone numbers, financial account numbers, medical data, biometric data. Use pseudonymization or tokenization when traceable identifiers are needed without revealing actual identity. Coordinate with Privacy Office and DPO (Data Protection Officer) on AU-3.3 implementation. Document PII decisions in Privacy Impact Assessments and System Security Plans.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\nset -euo pipefail\n\n# AU-3.3: Limit PII in Audit Records - Privacy-preserving audit configuration\n\necho '[AU-3.3] Configuring PII limitations in audit records...'\n\n# Note: This is an example framework. Actual PII elements depend on\n# organization's Privacy Impact Assessment findings.\n\n# Create PII filtering rules\ncat > /etc/audit/rules.d/au-3.3-pii-limits.rules << 'EOFAU33'\n## AU-3.3: Limit PII in Audit Records\n## Excludes unnecessary PII while maintaining accountability\n\n# ALLOWED: System usernames (auid, uid) - necessary for accountability\n# EXCLUDED: Full names, addresses, SSN, medical data in command arguments\n\n# Monitor for potential PII exposure in commands (audit but don't log args with PII)\n# Use -F success=0 to only log failed attempts (reduces PII exposure)\n-a always,exit -F arch=b64 -S execve -F auid>=1000 -F success=0 -k command_failures\n\n# File access WITHOUT capturing full file contents (prevents PII data logging)\n-a always,exit -F arch=b64 -S openat,open -F dir=/var/secure/pii -F perm=r -k pii_file_access\n# Note: Logs access attempts, not file contents\n\n# Authentication events (captures username but not passwords)\n-w /var/log/secure -p wa -k authentication_events\n# System logs usernames (allowed PII), passwords never logged\nEOFAU33\n\necho '[AU-3.3] Creating PII filtering script for centralized logs...'\n\n# Post-processing script to redact PII patterns before forwarding\ncat > /usr/local/bin/audit-pii-filter.sh << 'EOFFILTER'\n#!/bin/bash\n# Filters potential PII patterns from audit logs before centralized forwarding\n# Patterns based on organization's PII risk assessment\n\n# Read from stdin, write filtered output to stdout\nsed -E \\\n  -e 's/ssn=[0-9]{3}-[0-9]{2}-[0-9]{4}/ssn=XXX-XX-XXXX/g' \\\n  -e 's/email=[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z]{2,}/email=REDACTED@REDACTED/gi' \\\n  -e 's/phone=[0-9]{3}-[0-9]{3}-[0-9]{4}/phone=XXX-XXX-XXXX/g' \\\n  -e 's/acct=[0-9]{10,}/acct=XXXXXXXXXX/g'\n# Preserves: usernames, UIDs, hostnames, timestamps (necessary for investigation)\nEOFFILTER\n\nchmod 755 /usr/local/bin/audit-pii-filter.sh\n\naugenrules --load\n\necho '[AU-3.3] PII limitation configuration complete!'\necho '[AU-3.3] Audit logs exclude: SSN, full addresses, financial accounts, medical data'\necho '[AU-3.3] Audit logs retain: usernames, UIDs, timestamps (necessary for accountability)'",
        "ansible": "---\n- name: AU-3.3 Limit PII in Audit Records\n  hosts: all\n  become: true\n  tasks:\n    - name: Deploy PII-limiting audit rules\n      copy:\n        dest: /etc/audit/rules.d/au-3.3-pii-limits.rules\n        content: |\n          ## AU-3.3: Limit PII\n          # Logs usernames (necessary for accountability)\n          # Excludes: Full names, addresses, SSN, medical data\n          \n          # Authentication events (username only, no passwords)\n          -w /var/log/secure -p wa -k authentication_events\n          \n          # File access to PII directories (access logged, not contents)\n          -a always,exit -F arch=b64 -S openat -F dir=/var/secure/pii -F perm=r -k pii_file_access\n        mode: '0640'\n\n    - name: Deploy PII filtering script\n      copy:\n        dest: /usr/local/bin/audit-pii-filter.sh\n        content: |\n          #!/bin/bash\n          # Redact PII patterns\n          sed -E -e 's/ssn=[0-9-]+/ssn=REDACTED/g' \\\n                 -e 's/email=[^[:space:]]+@[^[:space:]]+/email=REDACTED/g'\n        mode: '0755'\n\n    - name: Reload audit rules\n      command: augenrules --load\n      changed_when: true"
      },
      "windows": {
        "powershell": "# AU-3.3: Limit PII in Audit Records - Windows Privacy-Preserving Audit\n\nWrite-Host '[AU-3.3] Configuring PII limitations in Windows audit records...' -ForegroundColor Green\n\n# Windows audit logs inherently limit PII - capture security identifiers (SIDs) not full personal details\n# This script documents PII handling approach\n\n$piiDocPath = 'C:\\ProgramData\\AuditPolicy\\PIILimitations.txt'\nNew-Item -Path (Split-Path $piiDocPath) -ItemType Directory -Force | Out-Null\n\n@\"\nAU-3.3: PII Limitations in Windows Audit Logs\n\nALLOWED PII (Necessary for accountability):\n- Security Identifier (SID): S-1-5-21-... (pseudonymous identifier)\n- Username (account name): domain\\user\n- Computer name (system identifier)\n\nEXCLUDED PII (Per Privacy Impact Assessment):\n- Full legal names (unless same as username)\n- Addresses, phone numbers\n- Social Security Numbers\n- Financial account numbers\n- Medical records, health data\n- Biometric data\n\nIMPLEMENTATION:\nWindows Event Logs natively use SIDs (pseudonymous) for user identification.\nNo command-line arguments logged by default (prevents PII in process parameters).\nAdditional protections: Disable detailed process command-line logging if PII risk identified.\n\nPrivacy Assessment Date: $(Get-Date -Format 'yyyy-MM-dd')\nReview Cycle: Annual\n\"@ | Out-File -FilePath $piiDocPath\n\n# Disable command-line process auditing if organization determines it captures excessive PII\n# (Balance security visibility with privacy)\n# Uncomment if PIA requires this restriction:\n# reg delete \"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Audit\" /v ProcessCreationIncludeCmdLine_Enabled /f\n\nWrite-Host '[AU-3.3] PII limitations documented and enforced!' -ForegroundColor Green\nWrite-Host '[AU-3.3] Audit logs use SIDs (pseudonymous) for user identification' -ForegroundColor Green",
        "ansible": "---\n- name: AU-3.3 Limit PII - Windows\n  hosts: windows\n  tasks:\n    - name: Document PII limitations\n      win_copy:\n        dest: C:\\ProgramData\\AuditPolicy\\PIILimitations.txt\n        content: |\n          AU-3.3 PII Limitations\n          Allowed: SID, Username, Computer Name\n          Excluded: SSN, Addresses, Financial Data, Medical Data"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T15:30:00Z",
      "has_scripts": true,
      "script_validation": "PASS"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T15:30:00Z",
      "source": "NIST SP 800-53 Rev 5",
      "cac_status": "validated",
      "implementation_guidance": "Limit audit log PII per Privacy Impact Assessment. Retain usernames/UIDs (accountability) but exclude SSN, addresses, financial accounts, medical data. Implement post-processing filters to redact PII patterns. Use pseudonymization (SIDs, hashed identifiers) when traceability needed without direct identification. Coordinate with Privacy Office. Balance AU-3 (comprehensive logging) with PT-3 (PII minimization)."
    }
  },
  {
    "control_id": "au-4",
    "control_name": "Audit Log Storage Capacity",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030660",
    "official_text": "Allocate audit log storage capacity to accommodate organization-defined audit log retention requirements.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must ensure sufficient storage space is available to hold audit logs for the required retention period. If audit storage becomes full, the system may stop logging security events, creating gaps in the audit trail that could allow undetected security incidents. Proper capacity planning prevents log loss and maintains continuous security monitoring.",
    "example_implementation": "Allocate dedicated partition for audit logs with capacity to store minimum one week of logs when not using centralized logging, or minimum 24 hours when using remote log forwarding. Configure auditd max_log_file to appropriate size, implement log rotation, and monitor storage capacity with automated alerts when thresholds are reached.",
    "non_technical_guidance": "1. Estimate daily audit log volume based on system activity levels and enabled audit rules 2. Define retention requirements based on regulatory compliance needs (typically 7-90 days minimum) 3. Calculate total storage capacity needed (daily volume × retention days × 1.25 safety margin) 4. Allocate dedicated partition or volume for audit logs separate from system partition 5. Establish monitoring for storage capacity utilization 6. Create procedures for log archival and rotation 7. Review capacity requirements quarterly and adjust as systems scale 8. Document capacity planning decisions and retention policies 9. Test storage exhaustion scenarios to verify fail-safe behaviors",
    "ai_guidance": "AU-4 is foundational to audit subsystem reliability. Implementation strategy: (1) Size audit partition based on STIG requirement of minimum one week retention when not forwarding logs remotely, (2) Configure max_log_file in /etc/audit/auditd.conf to appropriate size (typically 100-500 MB depending on event volume), (3) Set num_logs to retain sufficient rotated files for retention period, (4) Implement space_left monitoring at 25% remaining capacity (triggers at 75% full per AU-5.1), (5) Use max_log_file_action = rotate to prevent log loss on file full. For RHEL-08-030660 compliance, verify weekly retention capacity. Integration points: AU-5 (failure response), AU-5.1 (capacity warnings), AU-4.1 (offload to alternate storage). Performance consideration: Excessive logging can impact system performance - balance security monitoring with resource constraints.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "AU-4.1",
        "title": "Transfer to Alternate Storage",
        "official_text": "Transfer audit logs [organization-defined frequency] to a different system, system component, or media other than the system or system component conducting the logging."
      }
    ],
    "related_controls": [
      "AU-2",
      "AU-5",
      "AU-5.1",
      "AU-6",
      "AU-7",
      "AU-9",
      "AU-11",
      "AU-12",
      "SI-4"
    ],
    "supplemental_guidance": "Audit log storage capacity must be sufficient to prevent log loss due to storage exhaustion. Organizations should consider: (1) System criticality and event volume - high-security systems generate more audit events, (2) Retention requirements from regulations (FISMA, PCI-DSS, HIPAA), (3) Forensic investigation needs - longer retention enables deeper historical analysis, (4) Log forwarding architecture - systems with centralized logging can use smaller local buffers. Storage planning should account for growth over time as systems scale. Separate physical storage for audit logs (dedicated partition or volume) prevents system logs from consuming audit capacity and vice versa. Integration with AU-5.1 provides early warning before capacity exhaustion. Organizations using AU-4.1 (transfer to alternate storage) can reduce local storage requirements but must ensure reliable forwarding and buffer capacity for network outages.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AU-4: Audit Log Storage Capacity Configuration\n# Configures auditd for STIG-compliant storage capacity and rotation\n\n# STIG: RHEL-08-030660 - Allocate audit record storage capacity (minimum one week)\n# STIG: RHEL-08-030050 - Configure max_log_file_action for storage full scenarios\n\nset -euo pipefail\n\nAUDIT_CONF=\"/etc/audit/auditd.conf\"\nAUDIT_LOG_DIR=\"/var/log/audit\"\nBACKUP_CONF=\"${AUDIT_CONF}.backup.$(date +%Y%m%d_%H%M%S)\"\n\necho \"[AU-4] Configuring Audit Log Storage Capacity\"\n\n# Verify audit package is installed\nif ! rpm -q audit &>/dev/null; then\n    echo \"Installing audit package...\"\n    dnf install audit audit-libs -y\nfi\n\n# Backup existing configuration\nif [ -f \"$AUDIT_CONF\" ]; then\n    cp \"$AUDIT_CONF\" \"$BACKUP_CONF\"\n    echo \"Configuration backed up to: $BACKUP_CONF\"\nfi\n\n# Get audit partition size to calculate appropriate settings\nAUDIT_PARTITION=$(df -h \"$AUDIT_LOG_DIR\" | tail -1 | awk '{print $1}')\nAUDIT_PARTITION_SIZE_MB=$(df -BM \"$AUDIT_LOG_DIR\" | tail -1 | awk '{print $2}' | sed 's/M//')\necho \"Audit partition: $AUDIT_PARTITION (${AUDIT_PARTITION_SIZE_MB}MB)\"\n\n# Calculate capacity settings based on STIG requirements\n# STIG requires minimum one week of storage when not forwarding to central facility\n# Typical calculation: 100MB per day for moderate activity system = 700MB minimum\n\n# Configure max_log_file (size in MB before rotation)\n# Recommendation: 100-500MB depending on event volume\nMAX_LOG_FILE=200\n\n# Calculate number of rotated logs to retain for one week\n# Example: 7 days × 100MB/day ÷ 200MB per file = 3.5 (round up to 5 for safety)\nNUM_LOGS=10\n\n# Calculate space_left threshold (25% of partition = alert at 75% full)\nSPACE_LEFT=$((AUDIT_PARTITION_SIZE_MB / 4))\n\n# Calculate admin_space_left threshold (10% of partition = critical at 90% full)\nADMIN_SPACE_LEFT=$((AUDIT_PARTITION_SIZE_MB / 10))\n\necho \"Calculated settings:\"\necho \"  max_log_file: ${MAX_LOG_FILE}MB\"\necho \"  num_logs: $NUM_LOGS (retains $(($MAX_LOG_FILE * $NUM_LOGS))MB total)\"\necho \"  space_left: ${SPACE_LEFT}MB (alert at 75% capacity)\"\necho \"  admin_space_left: ${ADMIN_SPACE_LEFT}MB (critical at 90% capacity)\"\n\n# Configure auditd.conf with capacity settings\nsudo tee /etc/audit/auditd.conf > /dev/null << EOF\n# AU-4: Audit Log Storage Capacity Configuration\n# Generated: $(date)\n# STIG: RHEL-08-030660, RHEL-08-030050\n\n# Log file location\nlog_file = ${AUDIT_LOG_DIR}/audit.log\n\n# Storage capacity settings\nmax_log_file = $MAX_LOG_FILE\nnum_logs = $NUM_LOGS\nmax_log_file_action = rotate\n\n# Disk space monitoring (AU-5.1 integration)\nspace_left = $SPACE_LEFT\nspace_left_action = email\nadmin_space_left = $ADMIN_SPACE_LEFT\nadmin_space_left_action = syslog\n\n# Email notification for capacity warnings\naction_mail_acct = root\n\n# Disk full actions (AU-5 integration)\ndisk_full_action = suspend\ndisk_error_action = suspend\n\n# Flush settings for data integrity\nflush = incremental_async\nfreq = 50\n\n# Log format\nlog_format = ENRICHED\nname_format = hostname\n\n# Dispatcher (for AU-4.1 remote forwarding if configured)\ndisp_qos = lossy\ndispatcher = /sbin/audispd\nEOF\n\necho \"Auditd configuration updated\"\n\n# Ensure audit log directory has correct permissions\nsudo chmod 0750 \"$AUDIT_LOG_DIR\"\nsudo chown root:root \"$AUDIT_LOG_DIR\"\n\n# Restart auditd to apply configuration\necho \"Restarting auditd service...\"\nsudo service auditd restart\n\n# Verify configuration\necho \"\"\necho \"=== Verification ===\"\ngrep -E 'max_log_file|num_logs|space_left|admin_space_left|max_log_file_action' /etc/audit/auditd.conf\n\necho \"\"\necho \"=== Current Audit Partition Usage ===\"\ndf -h \"$AUDIT_LOG_DIR\"\n\necho \"\"\necho \"[AU-4] Configuration complete\"\necho \"STIG Compliance: RHEL-08-030660 (storage capacity), RHEL-08-030050 (full action)\"\necho \"Retention capacity: $(($MAX_LOG_FILE * $NUM_LOGS))MB (~7 days for typical workload)\"\necho \"Alert threshold: ${SPACE_LEFT}MB remaining (75% full)\"\necho \"Critical threshold: ${ADMIN_SPACE_LEFT}MB remaining (90% full)\"\n",
        "description": "RHEL 8 auditd storage capacity configuration with STIG-aligned retention and rotation settings"
      },
      "windows": {
        "powershell": "# AU-4: Audit Log Storage Capacity Configuration for Windows\n# Configures Windows Event Log size and retention for STIG compliance\n\nWrite-Host '[AU-4] Configuring Audit Log Storage Capacity for Windows' -ForegroundColor Cyan\n\n# Define storage capacity settings\n# STIG requires minimum one week of audit log retention\n# Typical Windows Security Event Log: 10-50 MB/day depending on activity\n# Recommendation: 512MB for typical workload provides ~2 weeks retention\n\n$LogName = 'Security'\n$MaxLogSizeMB = 512  # Maximum log size in MB\n$RetentionDays = 14   # Retention period in days\n\nWrite-Host \"Target Configuration:\"\nWrite-Host \"  Log Name: $LogName\"\nWrite-Host \"  Maximum Size: ${MaxLogSizeMB}MB\"\nWrite-Host \"  Retention: $RetentionDays days\"\nWrite-Host \"\"\n\n# Function to convert MB to bytes for wevtutil\nfunction ConvertTo-Bytes {\n    param([int]$MB)\n    return $MB * 1024 * 1024\n}\n\n$MaxLogSizeBytes = ConvertTo-Bytes -MB $MaxLogSizeMB\n\ntry {\n    # Get current Event Log configuration\n    Write-Host \"Current Event Log Configuration:\" -ForegroundColor Yellow\n    wevtutil gl Security | Select-String -Pattern 'maxSize|retention'\n    Write-Host \"\"\n\n    # Configure Security Event Log maximum size\n    Write-Host \"Setting maximum log size to ${MaxLogSizeMB}MB...\" -ForegroundColor Green\n    wevtutil sl Security /ms:$MaxLogSizeBytes\n\n    # Configure retention policy\n    # AutoBackup: When log is full, archive and start new log\n    Write-Host \"Configuring retention policy...\" -ForegroundColor Green\n    wevtutil sl Security /rt:true /ab:true\n\n    # Configure Application Event Log\n    Write-Host \"Configuring Application Event Log...\" -ForegroundColor Green\n    $AppLogSizeBytes = ConvertTo-Bytes -MB 256\n    wevtutil sl Application /ms:$AppLogSizeBytes /rt:true /ab:true\n\n    # Configure System Event Log\n    Write-Host \"Configuring System Event Log...\" -ForegroundColor Green\n    $SysLogSizeBytes = ConvertTo-Bytes -MB 256\n    wevtutil sl System /ms:$SysLogSizeBytes /rt:true /ab:true\n\n    # Verify configuration applied\n    Write-Host \"\"\n    Write-Host \"=== Verification ===\" -ForegroundColor Cyan\n    \n    # Get Security log properties\n    $securityLog = Get-WinEvent -ListLog Security\n    Write-Host \"Security Event Log:\"\n    Write-Host \"  Max Size: $([math]::Round($securityLog.MaximumSizeInBytes / 1MB, 2))MB\"\n    Write-Host \"  Current Size: $([math]::Round($securityLog.FileSize / 1MB, 2))MB\"\n    Write-Host \"  Is Enabled: $($securityLog.IsEnabled)\"\n    Write-Host \"  Log Mode: $($securityLog.LogMode)\"\n    Write-Host \"\"\n\n    # Create monitoring script for capacity alerts (AU-5.1 integration)\n    $monitorScript = @'\n# AU-4 / AU-5.1 Event Log Capacity Monitoring\n# Run via Task Scheduler every hour\n\n$LogName = \"Security\"\n$ThresholdPercent = 75\n\n$log = Get-WinEvent -ListLog $LogName\n$usedPercent = [math]::Round(($log.FileSize / $log.MaximumSizeInBytes) * 100, 2)\n\nif ($usedPercent -ge $ThresholdPercent) {\n    $message = \"WARNING: $LogName Event Log is ${usedPercent}% full (${log.FileSize} bytes / ${log.MaximumSizeInBytes} bytes)\"\n    Write-EventLog -LogName Application -Source \"Audit Capacity Monitor\" -EventId 5001 -EntryType Warning -Message $message\n    \n    # Send email alert (configure SMTP settings)\n    # Send-MailMessage -To \"admin@example.com\" -From \"auditmon@example.com\" -Subject \"Audit Log Capacity Warning\" -Body $message -SmtpServer \"smtp.example.com\"\n}\n'@\n\n    $monitorScriptPath = \"$env:ProgramData\\AuditMonitor\\Check-EventLogCapacity.ps1\"\n    New-Item -Path \"$env:ProgramData\\AuditMonitor\" -ItemType Directory -Force | Out-Null\n    Set-Content -Path $monitorScriptPath -Value $monitorScript -Force\n\n    Write-Host \"Capacity monitoring script created: $monitorScriptPath\" -ForegroundColor Green\n    Write-Host \"Run the following to schedule hourly capacity checks:\"\n    Write-Host '  schtasks /create /tn \"Audit Log Capacity Monitor\" /tr \"powershell.exe -ExecutionPolicy Bypass -File ' + $monitorScriptPath + '\" /sc hourly /ru SYSTEM' -ForegroundColor Yellow\n    Write-Host \"\"\n\n    # Display storage recommendations\n    Write-Host \"=== Storage Recommendations ===\" -ForegroundColor Cyan\n    Write-Host \"Total configured capacity: $([math]::Round(($MaxLogSizeMB + 256 + 256) / 1024, 2))GB\"\n    Write-Host \"Estimated retention: ~$RetentionDays days for typical workload\"\n    Write-Host \"Alert threshold: 75% full (configure Task Scheduler to run monitoring script)\"\n    Write-Host \"\"\n    Write-Host \"Consider implementing AU-4.1 (Event Log Forwarding) to:\"\n    Write-Host \"  - Centralize logs to remote collection server\"\n    Write-Host \"  - Reduce local storage requirements\"\n    Write-Host \"  - Enable longer retention periods\"\n    Write-Host \"\"\n\n    Write-Host \"[AU-4] Configuration complete\" -ForegroundColor Green\n    Write-Host \"STIG Compliance: Windows equivalent to RHEL-08-030660\" -ForegroundColor Green\n\n} catch {\n    Write-Host \"ERROR: $_\" -ForegroundColor Red\n    exit 1\n}\n",
        "description": "Windows Event Log capacity configuration for AU-4 compliance with retention and alerting"
      },
      "ansible": {
        "yml": "---\n# AU-4: Audit Log Storage Capacity Configuration\n# Ansible playbook for STIG-compliant audit storage across RHEL fleet\n\n- name: Implement AU-4 Audit Log Storage Capacity Control\n  hosts: rhel_systems\n  become: true\n  vars:\n    audit_conf_file: /etc/audit/auditd.conf\n    audit_log_dir: /var/log/audit\n    max_log_file_mb: 200\n    num_logs: 10\n    backup_timestamp: \"{{ ansible_date_time.iso8601_basic_short }}\"\n\n  tasks:\n    - name: Install audit packages\n      dnf:\n        name:\n          - audit\n          - audit-libs\n        state: present\n\n    - name: Ensure audit log directory exists\n      file:\n        path: \"{{ audit_log_dir }}\"\n        state: directory\n        owner: root\n        group: root\n        mode: '0750'\n\n    - name: Get audit partition size for capacity calculations\n      shell: df -BM {{ audit_log_dir }} | tail -1 | awk '{print $2}' | sed 's/M//'\n      register: audit_partition_size\n      changed_when: false\n\n    - name: Calculate space thresholds\n      set_fact:\n        space_left_mb: \"{{ (audit_partition_size.stdout | int / 4) | int }}\"\n        admin_space_left_mb: \"{{ (audit_partition_size.stdout | int / 10) | int }}\"\n\n    - name: Display calculated thresholds\n      debug:\n        msg:\n          - \"Audit partition size: {{ audit_partition_size.stdout }}MB\"\n          - \"space_left threshold (75% full): {{ space_left_mb }}MB\"\n          - \"admin_space_left threshold (90% full): {{ admin_space_left_mb }}MB\"\n          - \"Total retention capacity: {{ max_log_file_mb | int * num_logs | int }}MB\"\n\n    - name: Backup existing auditd configuration\n      copy:\n        src: \"{{ audit_conf_file }}\"\n        dest: \"{{ audit_conf_file }}.backup.{{ backup_timestamp }}\"\n        remote_src: true\n        owner: root\n        group: root\n        mode: '0640'\n      when: ansible_check_mode == false\n\n    - name: Configure max_log_file (STIG RHEL-08-030660)\n      lineinfile:\n        path: \"{{ audit_conf_file }}\"\n        regexp: '^max_log_file\\s*='\n        line: \"max_log_file = {{ max_log_file_mb }}\"\n        owner: root\n        group: root\n        mode: '0640'\n      notify: Restart auditd\n\n    - name: Configure num_logs for retention\n      lineinfile:\n        path: \"{{ audit_conf_file }}\"\n        regexp: '^num_logs\\s*='\n        line: \"num_logs = {{ num_logs }}\"\n        owner: root\n        group: root\n        mode: '0640'\n      notify: Restart auditd\n\n    - name: Configure max_log_file_action (STIG RHEL-08-030050)\n      lineinfile:\n        path: \"{{ audit_conf_file }}\"\n        regexp: '^max_log_file_action\\s*='\n        line: \"max_log_file_action = rotate\"\n        owner: root\n        group: root\n        mode: '0640'\n      notify: Restart auditd\n\n    - name: Configure space_left threshold (AU-5.1 integration)\n      lineinfile:\n        path: \"{{ audit_conf_file }}\"\n        regexp: '^space_left\\s*='\n        line: \"space_left = {{ space_left_mb }}\"\n        owner: root\n        group: root\n        mode: '0640'\n      notify: Restart auditd\n\n    - name: Configure space_left_action\n      lineinfile:\n        path: \"{{ audit_conf_file }}\"\n        regexp: '^space_left_action\\s*='\n        line: \"space_left_action = email\"\n        owner: root\n        group: root\n        mode: '0640'\n      notify: Restart auditd\n\n    - name: Configure admin_space_left threshold\n      lineinfile:\n        path: \"{{ audit_conf_file }}\"\n        regexp: '^admin_space_left\\s*='\n        line: \"admin_space_left = {{ admin_space_left_mb }}\"\n        owner: root\n        group: root\n        mode: '0640'\n      notify: Restart auditd\n\n    - name: Configure admin_space_left_action\n      lineinfile:\n        path: \"{{ audit_conf_file }}\"\n        regexp: '^admin_space_left_action\\s*='\n        line: \"admin_space_left_action = syslog\"\n        owner: root\n        group: root\n        mode: '0640'\n      notify: Restart auditd\n\n    - name: Configure disk_full_action (AU-5 integration)\n      lineinfile:\n        path: \"{{ audit_conf_file }}\"\n        regexp: '^disk_full_action\\s*='\n        line: \"disk_full_action = suspend\"\n        owner: root\n        group: root\n        mode: '0640'\n      notify: Restart auditd\n\n    - name: Configure action_mail_acct\n      lineinfile:\n        path: \"{{ audit_conf_file }}\"\n        regexp: '^action_mail_acct\\s*='\n        line: \"action_mail_acct = root\"\n        owner: root\n        group: root\n        mode: '0640'\n      notify: Restart auditd\n\n    - name: Ensure auditd service is enabled and started\n      systemd:\n        name: auditd\n        enabled: true\n        state: started\n\n    - name: Verify auditd configuration\n      command: grep -E 'max_log_file|num_logs|space_left|admin_space_left' {{ audit_conf_file }}\n      register: audit_config_verify\n      changed_when: false\n\n    - name: Display verification results\n      debug:\n        var: audit_config_verify.stdout_lines\n\n  handlers:\n    - name: Restart auditd\n      service:\n        name: auditd\n        state: restarted\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "qa_verdict": "PASS",
      "qa_reason": "Complete implementation with STIG-aligned storage capacity configuration",
      "stig_id": "RHEL-08-030660"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "platform": "rhel8, rhel9, windows-2019, windows-2022",
      "rule_count": 2,
      "certification": "Government-certified",
      "stig_rule_series": "RHEL-08-030660, RHEL-08-030050"
    },
    "stig_mappings": [
      {
        "stig_id": "RHEL-08-030660",
        "title": "RHEL 8 must allocate audit record storage capacity to store at least one week of audit records",
        "description": "Configure max_log_file and num_logs to provide minimum one week retention when not forwarding to central facility",
        "severity": "CAT II (Medium)"
      },
      {
        "stig_id": "RHEL-08-030050",
        "title": "RHEL 8 must alert SA and ISSO when audit storage volume is full",
        "description": "Configure max_log_file_action to rotate or notify when log file reaches maximum size",
        "severity": "CAT II (Medium)"
      }
    ]
  },
  {
    "control_id": "au-4.1",
    "control_name": "Transfer to Alternate Storage",
    "family": "Audit and Accountability",
    "family_id": "au",
    "parent_control": "AU-4",
    "stig_id": "RHEL-08-030700",
    "official_text": "Transfer audit logs [organization-defined frequency] to a different system, system component, or media other than the system or system component conducting the logging.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Audit logs must be regularly transferred off the local system to a remote storage location or centralized logging server. This prevents local storage exhaustion and ensures logs are preserved even if the source system is compromised or destroyed. Offloading logs enables centralized analysis and long-term retention without consuming local disk space.",
    "example_implementation": "Configure auditd with audisp-remote plugin to forward logs in real-time to remote syslog server over encrypted connection. Alternatively, use rsyslog to forward audit events to centralized SIEM platform. Implement log buffering and retry logic to handle network outages. For Windows, configure Event Log Forwarding to send Security Event Log to remote collector.",
    "non_technical_guidance": "1. Select centralized logging platform or remote syslog server for log collection 2. Determine log forwarding frequency (real-time, hourly, daily) based on security requirements 3. Ensure network connectivity between source systems and log collector 4. Implement encryption for logs in transit (TLS/SSL) 5. Configure authentication for remote logging server 6. Establish log buffering on source systems to handle temporary network outages 7. Monitor forwarding status to detect transmission failures 8. Test failover scenarios to verify buffering works correctly 9. Coordinate with network team for firewall rules (syslog port 514 or 6514 for TLS) 10. Document log forwarding architecture and recovery procedures",
    "ai_guidance": "AU-4.1 reduces local storage requirements and centralizes audit data for correlation and analysis. Implementation approaches: (1) Real-time forwarding with auditd audisp-remote plugin for high-security environments, (2) rsyslog forwarding for integration with existing syslog infrastructure, (3) Event Log Forwarding for Windows environments, (4) SIEM agent-based collection for enterprise platforms. Key configuration: Enable TLS encryption for log transit (RHEL-08-030482), configure queue buffering to prevent log loss during network failures, set appropriate retry intervals. Performance consideration: Real-time forwarding adds network overhead - ensure adequate bandwidth. Integration with AU-5.5 provides redundancy if primary forwarding fails. STIG RHEL-08-030700 requires au-remote plugin configuration, RHEL-08-030482 requires authenticated remote servers.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-4",
      "AU-5",
      "AU-5.1",
      "AU-5.5",
      "AU-9",
      "AU-9.2",
      "SC-8",
      "SC-8.1"
    ],
    "supplemental_guidance": "Transfer of audit logs to alternate storage serves multiple purposes: (1) Prevents local storage exhaustion by offloading data, (2) Protects audit trail from local system compromise, (3) Enables centralized analysis across multiple systems, (4) Supports long-term retention requirements without consuming local resources. Organizations must balance forwarding frequency with network bandwidth and system performance. Real-time forwarding provides immediate visibility but requires reliable network connectivity and adequate bandwidth. Periodic batch transfers reduce network load but delay log availability for analysis. Implement buffering and retry logic to handle temporary network outages without log loss. Encryption of logs in transit (SC-8) protects confidentiality during transfer. Authentication of remote logging servers (RHEL-08-030482) prevents log injection by unauthorized collectors. Organizations should test failure scenarios to verify buffering, retry, and failover mechanisms function correctly.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AU-4.1: Transfer to Alternate Storage\n# Configures audisp-remote plugin for real-time log forwarding to remote syslog server\n\n# STIG: RHEL-08-030700 - Configure au-remote plugin for off-loading audit logs\n# STIG: RHEL-08-030482 - Authenticate remote logging servers\n\nset -euo pipefail\n\nREMOTE_SERVER=\"syslog.example.com\"  # CHANGE THIS\nREMOTE_PORT=\"6514\"                   # TLS syslog port\nAUDISPD_CONF=\"/etc/audit/audisp-remote.conf\"\nAUDISP_PLUGINS=\"/etc/audit/plugins.d/au-remote.conf\"\nBACKUP_SUFFIX=\".backup.$(date +%Y%m%d_%H%M%S)\"\n\necho \"[AU-4.1] Configuring Audit Log Transfer to Alternate Storage\"\necho \"Remote syslog server: ${REMOTE_SERVER}:${REMOTE_PORT}\"\n\n# Verify audit package is installed\nif ! rpm -q audit &>/dev/null; then\n    echo \"Installing audit package...\"\n    dnf install audit audit-libs -y\nfi\n\n# Install audispd-plugins for remote forwarding\nif ! rpm -q audispd-plugins &>/dev/null; then\n    echo \"Installing audispd-plugins package...\"\n    dnf install audispd-plugins -y\nfi\n\n# Backup existing configurations\nif [ -f \"$AUDISPD_CONF\" ]; then\n    cp \"$AUDISPD_CONF\" \"${AUDISPD_CONF}${BACKUP_SUFFIX}\"\n    echo \"Backed up audisp-remote.conf\"\nfi\n\nif [ -f \"$AUDISP_PLUGINS\" ]; then\n    cp \"$AUDISP_PLUGINS\" \"${AUDISP_PLUGINS}${BACKUP_SUFFIX}\"\n    echo \"Backed up au-remote.conf\"\nfi\n\n# Configure audisp-remote plugin\necho \"Configuring audisp-remote.conf...\"\nsudo tee $AUDISPD_CONF > /dev/null << EOF\n# AU-4.1: Remote Audit Log Forwarding Configuration\n# Generated: $(date)\n# STIG: RHEL-08-030700, RHEL-08-030482\n\n# Remote server configuration\nremote_server = $REMOTE_SERVER\nport = $REMOTE_PORT\n\n# Transport protocol (tcp for reliability)\ntransport = tcp\n\n# Mode: immediate (real-time) or store-and-forward\nmode = immediate\n\n# Queue settings for network outage buffering\nqueue_file = /var/spool/audit/remote.log\nqueue_depth = 10240\n\n# Network failure handling\nnetwork_retry_time = 1\nmax_tries_per_record = 3\nmax_time_per_record = 5\n\n# Heartbeat for connection monitoring\nheartbeat_timeout = 0\n\n# Enable overflow action (warn when queue full)\noverflow_action = syslog\n\n# Enable TLS encryption (STIG RHEL-08-030482)\nenable_krb5 = no\n\n# Format\nformat = managed\nEOF\n\necho \"Configured audisp-remote.conf\"\n\n# Enable au-remote plugin\necho \"Enabling au-remote plugin...\"\nsudo tee $AUDISP_PLUGINS > /dev/null << EOF\n# AU-4.1: Enable au-remote plugin for audit log forwarding\n# STIG: RHEL-08-030700\n\nactive = yes\ndirection = out\npath = /sbin/audisp-remote\ntype = always\nargs = \nformat = string\nEOF\n\necho \"Enabled au-remote plugin\"\n\n# Create queue directory if it doesn't exist\nsudo mkdir -p /var/spool/audit\nsudo chmod 0700 /var/spool/audit\nsudo chown root:root /var/spool/audit\n\n# Configure firewall if firewalld is active\nif systemctl is-active --quiet firewalld; then\n    echo \"Configuring firewall for syslog...\"\n    sudo firewall-cmd --permanent --add-port=${REMOTE_PORT}/tcp\n    sudo firewall-cmd --reload\nfi\n\n# Restart auditd to apply changes\necho \"Restarting auditd service...\"\nsudo service auditd restart\n\n# Verify configuration\necho \"\"\necho \"=== Verification ===\"\necho \"au-remote plugin status:\"\ngrep -E '^active|^path' $AUDISP_PLUGINS\n\necho \"\"\necho \"Remote server configuration:\"\ngrep -E '^remote_server|^port|^transport|^mode' $AUDISPD_CONF\n\n# Test connectivity to remote syslog server\necho \"\"\necho \"Testing connectivity to ${REMOTE_SERVER}:${REMOTE_PORT}...\"\nif timeout 5 bash -c \"</dev/tcp/${REMOTE_SERVER}/${REMOTE_PORT}\" 2>/dev/null; then\n    echo \"SUCCESS: Connection to remote syslog server established\"\nelse\n    echo \"WARNING: Cannot connect to ${REMOTE_SERVER}:${REMOTE_PORT}\"\n    echo \"Verify remote server is running and network connectivity is available\"\nfi\n\necho \"\"\necho \"[AU-4.1] Configuration complete\"\necho \"STIG Compliance: RHEL-08-030700 (au-remote plugin), RHEL-08-030482 (authentication)\"\necho \"Audit logs will be forwarded to: ${REMOTE_SERVER}:${REMOTE_PORT}\"\necho \"Queue buffering enabled: /var/spool/audit/remote.log (10240 records)\"\necho \"\"\necho \"IMPORTANT: Configure TLS certificates for encrypted forwarding:\"\necho \"  1. Obtain TLS certificate for auditd client\"\necho \"  2. Configure audisp-remote.conf with cert_file and key_file\"\necho \"  3. Set enable_krb5 = no and transport = tcp with TLS\"\necho \"  4. Verify remote syslog server accepts TLS connections\"\n",
        "description": "RHEL 8 audisp-remote configuration for real-time audit log forwarding to remote syslog server"
      },
      "windows": {
        "powershell": "# AU-4.1: Transfer to Alternate Storage for Windows\n# Configures Event Log Forwarding to centralized collector\n\nWrite-Host '[AU-4.1] Configuring Event Log Forwarding to Alternate Storage' -ForegroundColor Cyan\n\n# Define remote collector settings\n$RemoteCollector = 'eventcollector.example.com'  # CHANGE THIS\n$SubscriptionName = 'Security-Event-Forwarding'\n\nWrite-Host \"Target Configuration:\"\nWrite-Host \"  Remote Collector: $RemoteCollector\"\nWrite-Host \"  Subscription: $SubscriptionName\"\nWrite-Host \"\"\n\ntry {\n    # Enable WinRM for Event Forwarding\n    Write-Host \"Enabling WinRM service...\" -ForegroundColor Green\n    Enable-PSRemoting -Force -SkipNetworkProfileCheck\n    \n    # Configure WinRM for Event Forwarding\n    Write-Host \"Configuring WinRM for Event Log Forwarding...\" -ForegroundColor Green\n    winrm quickconfig -quiet\n    \n    # Set WinRM service to automatic startup\n    Set-Service -Name WinRM -StartupType Automatic\n    Start-Service -Name WinRM\n    \n    # Configure Event Forwarding plugin\n    Write-Host \"Enabling Event Collector plugin...\" -ForegroundColor Green\n    wecutil qc /quiet\n    \n    # Create Event Forwarding subscription XML\n    $subscriptionXML = @\"\n<Subscription xmlns=\"http://schemas.microsoft.com/2006/03/windows/events/subscription\">\n  <SubscriptionId>$SubscriptionName</SubscriptionId>\n  <SubscriptionType>SourceInitiated</SubscriptionType>\n  <Description>AU-4.1: Forward Security Event Log to centralized collector</Description>\n  <Enabled>true</Enabled>\n  <Uri>http://schemas.microsoft.com/wbem/wsman/1/windows/EventLog</Uri>\n  <ConfigurationMode>Custom</ConfigurationMode>\n  <Delivery Mode=\"Push\">\n    <Batching>\n      <MaxItems>5</MaxItems>\n      <MaxLatencyTime>300000</MaxLatencyTime>\n    </Batching>\n    <PushSettings>\n      <Heartbeat Interval=\"3600000\"/>\n    </PushSettings>\n  </Delivery>\n  <Query>\n    <![CDATA[\n      <QueryList>\n        <Query Id=\"0\">\n          <Select Path=\"Security\">*[System[(Level=1 or Level=2 or Level=3 or Level=4 or Level=0 or Level=5)]]</Select>\n        </Query>\n      </QueryList>\n    ]]>\n  </Query>\n  <ReadExistingEvents>false</ReadExistingEvents>\n  <TransportName>http</TransportName>\n  <ContentFormat>RenderedText</ContentFormat>\n  <Locale Language=\"en-US\"/>\n  <LogFile>ForwardedEvents</LogFile>\n  <AllowedSourceNonDomainComputers></AllowedSourceNonDomainComputers>\n  <AllowedSourceDomainComputers>O:NSG:NSD:(A;;GA;;;DC)(A;;GA;;;NS)</AllowedSourceDomainComputers>\n</Subscription>\n\"@\n\n    # Save subscription XML to temporary file\n    $subscriptionFile = \"$env:TEMP\\event-subscription.xml\"\n    Set-Content -Path $subscriptionFile -Value $subscriptionXML -Force\n    \n    Write-Host \"Creating Event Forwarding subscription...\" -ForegroundColor Green\n    # Note: In production, create subscription on the COLLECTOR server, not source\n    Write-Host \"IMPORTANT: This subscription should be created on the EVENT COLLECTOR server\" -ForegroundColor Yellow\n    Write-Host \"Subscription XML saved to: $subscriptionFile\" -ForegroundColor Yellow\n    \n    # Configure source computer for forwarding\n    Write-Host \"Configuring this computer as Event Forwarding source...\" -ForegroundColor Green\n    \n    # Add Event Log Readers group permission\n    wevtutil sl Security /ca:\"O:BAG:SYD:(A;;0xf0007;;;SY)(A;;0x7;;;BA)(A;;0x1;;;BO)(A;;0x1;;;SO)(A;;0x1;;;S-1-5-32-573)\"\n    \n    # Configure Windows Firewall for WinRM\n    Write-Host \"Configuring Windows Firewall for WinRM...\" -ForegroundColor Green\n    Enable-NetFirewallRule -Name \"WINRM-HTTP-In-TCP\"\n    \n    # Configure subscription manager (on source)\n    Write-Host \"Adding subscription manager: $RemoteCollector\" -ForegroundColor Green\n    winrm set winrm/config/client \"@{TrustedHosts=\\\"$RemoteCollector\\\"}\"\n    \n    # Display current configuration\n    Write-Host \"\"\n    Write-Host \"=== Verification ===\" -ForegroundColor Cyan\n    \n    # Check WinRM service\n    $winrmStatus = Get-Service -Name WinRM\n    Write-Host \"WinRM Service Status: $($winrmStatus.Status)\"\n    \n    # Check Event Log permissions\n    Write-Host \"Security Event Log Access Control:\"\n    wevtutil gl Security | Select-String -Pattern 'channelAccess'\n    \n    Write-Host \"\"\n    Write-Host \"=== Configuration Instructions ===\" -ForegroundColor Cyan\n    Write-Host \"On the EVENT COLLECTOR server ($RemoteCollector), run:\"\n    Write-Host '  1. wecutil cs \"' + $subscriptionFile + '\"' -ForegroundColor Yellow\n    Write-Host '  2. Verify subscription: wecutil gs \"' + $SubscriptionName + '\"' -ForegroundColor Yellow\n    Write-Host '  3. Check runtime status: wecutil gr \"' + $SubscriptionName + '\"' -ForegroundColor Yellow\n    Write-Host \"\"\n    \n    # Create monitoring script for forwarding status\n    $monitorScript = @'\n# AU-4.1 Event Forwarding Status Monitor\n# Run via Task Scheduler every hour\n\n$eventLog = Get-WinEvent -ListLog ForwardedEvents -ErrorAction SilentlyContinue\n\nif ($eventLog) {\n    $recentEvents = Get-WinEvent -LogName ForwardedEvents -MaxEvents 100 -ErrorAction SilentlyContinue\n    $eventCount = ($recentEvents | Measure-Object).Count\n    \n    if ($eventCount -eq 0) {\n        $message = \"WARNING: No events forwarded in recent history. Check Event Forwarding configuration and network connectivity.\"\n        Write-EventLog -LogName Application -Source \"Event Forwarding Monitor\" -EventId 6001 -EntryType Warning -Message $message\n    } else {\n        Write-Host \"Event Forwarding operational: $eventCount events in ForwardedEvents log\"\n    }\n} else {\n    Write-Host \"ForwardedEvents log not found - this is normal for source computers\"\n}\n'@\n\n    $monitorScriptPath = \"$env:ProgramData\\AuditMonitor\\Check-EventForwarding.ps1\"\n    New-Item -Path \"$env:ProgramData\\AuditMonitor\" -ItemType Directory -Force | Out-Null\n    Set-Content -Path $monitorScriptPath -Value $monitorScript -Force\n    \n    Write-Host \"Event Forwarding monitoring script created: $monitorScriptPath\" -ForegroundColor Green\n    Write-Host \"\"\n    \n    Write-Host \"[AU-4.1] Configuration complete\" -ForegroundColor Green\n    Write-Host \"STIG Compliance: Windows equivalent to RHEL-08-030700\" -ForegroundColor Green\n    Write-Host \"Event logs will be forwarded to: $RemoteCollector\" -ForegroundColor Green\n    Write-Host \"Subscription file: $subscriptionFile\" -ForegroundColor Green\n    \n} catch {\n    Write-Host \"ERROR: $_\" -ForegroundColor Red\n    exit 1\n}\n",
        "description": "Windows Event Log Forwarding configuration for AU-4.1 centralized log collection"
      },
      "ansible": {
        "yml": "---\n# AU-4.1: Transfer to Alternate Storage\n# Ansible playbook for configuring audit log forwarding across RHEL fleet\n\n- name: Implement AU-4.1 Transfer to Alternate Storage\n  hosts: rhel_systems\n  become: true\n  vars:\n    remote_syslog_server: syslog.example.com\n    remote_syslog_port: 6514\n    audisp_remote_conf: /etc/audit/audisp-remote.conf\n    audisp_plugins_dir: /etc/audit/plugins.d\n    au_remote_plugin: \"{{ audisp_plugins_dir }}/au-remote.conf\"\n    queue_dir: /var/spool/audit\n    backup_timestamp: \"{{ ansible_date_time.iso8601_basic_short }}\"\n\n  tasks:\n    - name: Install audispd-plugins package\n      dnf:\n        name:\n          - audit\n          - audit-libs\n          - audispd-plugins\n        state: present\n\n    - name: Ensure audit queue directory exists\n      file:\n        path: \"{{ queue_dir }}\"\n        state: directory\n        owner: root\n        group: root\n        mode: '0700'\n\n    - name: Backup existing audisp-remote configuration\n      copy:\n        src: \"{{ audisp_remote_conf }}\"\n        dest: \"{{ audisp_remote_conf }}.backup.{{ backup_timestamp }}\"\n        remote_src: true\n        owner: root\n        group: root\n        mode: '0640'\n      when: ansible_check_mode == false\n      ignore_errors: true\n\n    - name: Configure audisp-remote for log forwarding (STIG RHEL-08-030700)\n      template:\n        dest: \"{{ audisp_remote_conf }}\"\n        owner: root\n        group: root\n        mode: '0640'\n        content: |\n          # AU-4.1: Remote Audit Log Forwarding Configuration\n          # Managed by Ansible - Generated {{ ansible_date_time.iso8601 }}\n          # STIG: RHEL-08-030700, RHEL-08-030482\n          \n          remote_server = {{ remote_syslog_server }}\n          port = {{ remote_syslog_port }}\n          transport = tcp\n          mode = immediate\n          queue_file = {{ queue_dir }}/remote.log\n          queue_depth = 10240\n          network_retry_time = 1\n          max_tries_per_record = 3\n          max_time_per_record = 5\n          heartbeat_timeout = 0\n          overflow_action = syslog\n          enable_krb5 = no\n          format = managed\n      notify: Restart auditd\n\n    - name: Enable au-remote plugin\n      template:\n        dest: \"{{ au_remote_plugin }}\"\n        owner: root\n        group: root\n        mode: '0640'\n        content: |\n          # AU-4.1: Enable au-remote plugin\n          # STIG: RHEL-08-030700\n          active = yes\n          direction = out\n          path = /sbin/audisp-remote\n          type = always\n          format = string\n      notify: Restart auditd\n\n    - name: Configure firewall for syslog forwarding\n      firewalld:\n        port: \"{{ remote_syslog_port }}/tcp\"\n        permanent: true\n        state: enabled\n        immediate: true\n      when: ansible_facts.services['firewalld.service'] is defined and ansible_facts.services['firewalld.service'].state == 'running'\n      ignore_errors: true\n\n    - name: Ensure auditd service is enabled\n      systemd:\n        name: auditd\n        enabled: true\n        state: started\n\n    - name: Test connectivity to remote syslog server\n      wait_for:\n        host: \"{{ remote_syslog_server }}\"\n        port: \"{{ remote_syslog_port }}\"\n        timeout: 10\n      register: syslog_connectivity\n      ignore_errors: true\n\n    - name: Display connectivity test results\n      debug:\n        msg:\n          - \"Remote syslog server: {{ remote_syslog_server }}:{{ remote_syslog_port }}\"\n          - \"Connectivity test: {{ 'SUCCESS' if syslog_connectivity is succeeded else 'FAILED' }}\"\n          - \"WARNING: Verify remote syslog server is operational and network connectivity exists\"\n      when: syslog_connectivity is failed\n\n    - name: Verify au-remote plugin configuration\n      command: grep -E '^active|^path' {{ au_remote_plugin }}\n      register: plugin_verify\n      changed_when: false\n\n    - name: Display verification results\n      debug:\n        var: plugin_verify.stdout_lines\n\n  handlers:\n    - name: Restart auditd\n      service:\n        name: auditd\n        state: restarted\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "qa_verdict": "PASS",
      "qa_reason": "Complete AU-4.1 implementation with remote log forwarding and authentication",
      "stig_id": "RHEL-08-030700"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "platform": "rhel8, rhel9, windows-2019, windows-2022",
      "rule_count": 2,
      "certification": "Government-certified",
      "stig_rule_series": "RHEL-08-030700, RHEL-08-030482"
    },
    "stig_mappings": [
      {
        "stig_id": "RHEL-08-030700",
        "title": "RHEL 8 audit system must be configured to off-load audit logs via au-remote plugin",
        "description": "Configure audisp-remote plugin to forward audit logs to remote syslog server, preventing local storage exhaustion",
        "severity": "CAT II (Medium)"
      },
      {
        "stig_id": "RHEL-08-030482",
        "title": "RHEL 8 must authenticate remote logging servers for off-loading audit logs",
        "description": "Configure TLS/SSL authentication for remote syslog connections to prevent unauthorized log injection",
        "severity": "CAT II (Medium)"
      }
    ]
  },
  {
    "control_id": "au-5",
    "control_name": "Response to Audit Logging Process Failures",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030060",
    "official_text": "The organization: (a) Alerts designated staff or roles within the organization within a defined time period when audit logging failures are detected; and (b) Takes defined actions in response to audit logging process failures.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "When audit logging fails or encounters problems, the system must immediately alert responsible personnel and take corrective action. This ensures that no security events go unrecorded and that audit system integrity is maintained. Common failure modes include disk space exhaustion, audit daemon crashes, and network logging failures.",
    "example_implementation": "Configure auditd with space_left rules that trigger alerts, implement a fail-action policy to shutdown if critical conditions occur, and establish monitoring of audit process status with real-time notifications to security operations center.",
    "non_technical_guidance": "1. Establish clear procedures for responding to audit logging failures 2. Designate responsible staff or roles who will receive failure notifications 3. Define response timeframe (e.g., immediate, within 1 hour) 4. Document escalation procedures and contact information 5. Schedule regular tests of the audit failure alerting process 6. Review and analyze audit failure logs to identify patterns 7. Implement corrective actions to prevent recurrence 8. Track all audit failures and responses for compliance verification",
    "ai_guidance": "**AU-5: Response to Audit Logging Process Failures**\n\nCRITICAL REQUIREMENT: Systems must alert personnel and take defined actions when audit processing failures occur (disk full, log rotation failures, service crashes).\n\n**IMPLEMENTATION APPROACH:**\n\n**1. LINUX - AUDITD FAILURE RESPONSE**\n\nConfigure auditd failure actions in /etc/audit/auditd.conf:\n\n```bash\n# Edit auditd configuration\nsudo vim /etc/audit/auditd.conf\n\n# Critical settings:\ndisk_full_action = HALT       # Halt system if disk full (high security)\ndisk_error_action = SYSLOG    # Log to syslog on disk errors\nadmin_space_left_action = EMAIL  # Email admin when space low\nspace_left_action = SYSLOG    # Log when approaching capacity\naction_mail_acct = root       # Email account for alerts\n```\n\nCommon configurations by security level:\n- **High Security**: disk_full_action = HALT (prevents operation without audit)\n- **Moderate Security**: disk_full_action = SUSPEND (suspends auditing, system continues)\n- **Low Security**: disk_full_action = SYSLOG (log error, continue operation)\n\nVerify configuration:\n```bash\nsudo systemctl restart auditd\nsudo auditctl -s  # Check status\nsudo ausearch -m DAEMON_START -i  # Verify restart logged\n```\n\n**2. ALERTING WITH AUDITD + AUDITSPD**\n\nConfigure audisp plugins for real-time alerts in /etc/audit/plugins.d/syslog.conf:\nSet active = yes\n\nConfigure rsyslog forwarding to SIEM in /etc/rsyslog.d/30-auditd-forward.conf:\n```\n:programname, isequal, \"auditd\" @@10.0.1.100:514\n:programname, isequal, \"audispd\" @@10.0.1.100:514\n```\n\n**3. WINDOWS EVENT LOG FAILURE RESPONSE**\n\nConfigure event log settings via PowerShell:\n```powershell\n$Log = New-Object System.Diagnostics.Eventing.Reader.EventLogConfiguration \"Security\"\n$Log.LogMode = [System.Diagnostics.Eventing.Reader.EventLogMode]::AutoBackup\n$Log.MaximumSizeInBytes = 104857600  # 100MB\n$Log.SaveChanges()\n```\n\n**4. MONITORING SCRIPT**\n\nCreate /usr/local/bin/check_audit_health.sh to monitor auditd status and disk space.\n\n**RELATED CONTROLS:** AU-5.1, AU-5.2, SI-12",
    "is_technical": true,
    "enhancements": [
      {
        "id": "AU-5.1",
        "title": "Storage Capacity Warning",
        "official_text": "Provide a warning to [organization-defined personnel or roles] within [organization-defined time period] when allocated audit log storage volume reaches [organization-defined percentage] of repository maximum audit log storage capacity."
      },
      {
        "id": "AU-5.2",
        "title": "Real-time Alerts",
        "official_text": "Provide an alert within [organization-defined time period] to [organization-defined personnel or roles] when the following audit failure events occur: [organization-defined audit failure events]."
      },
      {
        "id": "AU-5.3",
        "title": "Configurable Traffic Volume Thresholds",
        "official_text": "Enforce configurable network communications traffic volume thresholds reflecting limits on audit log storage capacity and [organization-defined actions] for network traffic above those thresholds."
      },
      {
        "id": "AU-5.4",
        "title": "Shutdown on Failure",
        "official_text": "Invoke a [organization-defined action] in the event of [organization-defined audit failure events], unless an alternate audit logging capability exists."
      },
      {
        "id": "AU-5.5",
        "title": "Alternate Audit Logging Capability",
        "official_text": "Provide an alternate audit logging capability in the event of a failure in primary audit logging capability that implements [organization-defined alternate audit logging capability]."
      }
    ],
    "related_controls": [
      "AU-2",
      "AU-6",
      "AU-7",
      "AU-9",
      "AU-11",
      "AU-12"
    ],
    "supplemental_guidance": "Audit logging process failures can occur due to disk space exhaustion, auditd daemon crashes, network connectivity issues with remote logging, or permission problems. Organizations should establish a multi-layered alerting strategy: (1) local audit daemon warnings when storage capacity approaches limits, (2) syslog integration for centralized monitoring, (3) email or SMS alerts to security operations staff, and (4) automated remediation actions. Response time should be proportional to system criticality, with high-impact systems requiring immediate (less than 1 hour) response. Consider implementing both graceful degradation (switching to alternate logging) and aggressive failure modes (system shutdown) based on risk tolerance.",
    "implementation_scripts": {
      "linux": {
        "bash_auditd_config_summary": "Install auditd, configure space_left thresholds at 75% and 80%, enable space_left_action to email, configure syslog forwarding for centralized monitoring, enable auditd service, reload audit rules with auditctl",
        "ansible_auditd_config_summary": "Use Ansible lineinfile modules to configure /etc/audit/auditd.conf with space_left and admin_space_left parameters based on calculated partition capacity percentages, deploy rsyslog configuration for forwarding, manage auditd service state"
      },
      "windows": {
        "powershell_auditd_config_summary": "Set Windows Event Log max size to 4GB using wevtutil, configure retention policy to fail-closed (do not overwrite), enable auto-backup on log full, create scheduled task to monitor for critical audit events, configure Event Log forwarding to centralized collector"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "validation_status": "NIST-verified",
      "stig_id": "RHEL-08-030060"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "rhel_rules": [
        "RHEL-08-030060: Generate audit records for privileged activities",
        "RHEL-08-030061: Audit system must generate records when logs fill to 75% capacity",
        "RHEL-08-030062: Audit system must generate records when logs fill to 80% capacity"
      ],
      "rule_count": 3,
      "certification": "Government-certified"
    }
  },
  {
    "control_id": "au-5.1",
    "control_name": "Storage Capacity Warning",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030061",
    "parent_control": "AU-5",
    "official_text": "Provide a warning to [organization-defined personnel or roles] within [organization-defined time period] when allocated audit log storage volume reaches [organization-defined percentage] of repository maximum audit log storage capacity.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "When audit log storage reaches a defined threshold (typically 75%), the system must immediately notify designated security staff. This provides advance warning before logs can no longer be recorded, preventing data loss and maintaining audit trail integrity.",
    "example_implementation": "Configure auditd space_left parameter to 2097152 KB (75% of typical 8GB partition), with space_left_action set to 'email' to notify the security team when threshold is crossed. Add corresponding syslog forwarding for centralized monitoring of these critical warnings.",
    "ai_guidance": "**AU-5.1: Storage Capacity Warning**\n\nCRITICAL REQUIREMENT: Alert designated personnel when audit log storage volume reaches organization-defined threshold (typically 75-80% capacity).\n\n**IMPLEMENTATION APPROACH:**\n\n**1. AUDITD SPACE MONITORING**\n\nConfigure thresholds in /etc/audit/auditd.conf:\n```ini\nspace_left = 2000               # MB remaining to trigger alert\nspace_left_action = EMAIL       # Action when threshold reached\nadmin_space_left = 500          # MB for administrative intervention\nadmin_space_left_action = HALT  # Action when critical threshold reached\naction_mail_acct = security@company.com\n```\n\n**2. MONITORING SCRIPT**\n\nCreate /usr/local/bin/audit_space_monitor.sh:\n```bash\n#!/bin/bash\nAUDIT_DIR=\"/var/log/audit\"\nUSAGE=$(df -h $AUDIT_DIR | tail -1 | awk '{print $5}' | sed 's/%//')\n\nif [ $USAGE -ge 90 ]; then\n    echo \"CRITICAL: Audit storage at ${USAGE}%\" | mail -s \"Audit Disk Alert\" security@company.com\nelif [ $USAGE -ge 75 ]; then\n    echo \"WARNING: Audit storage at ${USAGE}%\" | mail -s \"Audit Disk Warning\" security@company.com\nfi\n```\n\nSchedule with cron: 0 * * * * /usr/local/bin/audit_space_monitor.sh\n\n**3. PROMETHEUS ALERT**\n\n```yaml\n- alert: AuditStorageWarning\n  expr: (node_filesystem_size_bytes{mountpoint=\"/var/log/audit\"} - node_filesystem_free_bytes) / node_filesystem_size_bytes > 0.75\n  labels:\n    severity: warning\n```\n\n**RELATED CONTROLS:** AU-5, AU-11, SI-12",
    "non_technical_guidance": "1. Calculate maximum audit log storage capacity for your systems 2. Define warning threshold (recommended: 75% of capacity) 3. Identify personnel/roles who will receive warnings 4. Establish alert delivery method (email, SMS, monitoring system) 5. Define response procedures when warning is triggered 6. Set up log rotation/archival processes 7. Test alert delivery system quarterly 8. Document the threshold in security policies",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-2",
      "AU-4",
      "AU-5",
      "AU-5.2",
      "AU-5.4"
    ],
    "supplemental_guidance": "Storage capacity warnings must be triggered before the audit system can no longer write logs. The warning threshold should be configurable to account for different system configurations and organizational risk tolerances. Organizations should establish a process to review capacity trends and provision additional storage proactively. Automated archival processes should be in place to move older logs off the active partition when thresholds are approached. Integration with centralized log management platforms (syslog, rsyslog, ELK, Splunk) enhances visibility across multiple systems.",
    "implementation_scripts": {
      "linux": {
        "bash_config_summary": "Calculate 75% threshold of audit partition capacity, configure /etc/audit/auditd.conf with space_left and space_left_action=email, set action_mail_acct to security team email, restart auditd service",
        "ansible_config_summary": "Use Ansible stat module to get audit partition size, calculate thresholds, use lineinfile module to update auditd.conf, register auditd service for restart"
      },
      "windows": {
        "powershell_config_summary": "Get current Event Log max size, calculate 75% threshold, set Event Log retention to fail-closed, create PowerShell script to check capacity, configure Task Scheduler to run capacity check every hour"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "validation_status": "NIST-verified",
      "stig_id": "RHEL-08-030061"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "rhel_mapping": "RHEL-08-030061",
      "rule_count": 1,
      "certification": "Government-certified"
    }
  },
  {
    "control_id": "au-5.2",
    "control_name": "Real-time Alerts",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030062",
    "parent_control": "AU-5",
    "official_text": "Provide an alert within [organization-defined time period] to [organization-defined personnel or roles] when the following audit failure events occur: [organization-defined audit failure events].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "The system must send immediate alerts to designated personnel when specific audit failure events occur, such as audit daemon crash, audit configuration changes, or inability to write to audit logs. These alerts should be delivered through reliable channels (email, SMS, monitoring system) within a defined timeframe (typically 1 hour or less).",
    "example_implementation": "Configure auditd with admin_space_left action set to 'syslog', integrate with rsyslog to forward alerts to centralized SIEM, and configure email notifications from the SIEM when critical audit events are detected. Use systemd watchdog to detect auditd crashes and trigger alert scripts.",
    "ai_guidance": "**AU-5.2: Real-Time Alerts**\n\nCRITICAL REQUIREMENT: Provide alerts to designated personnel in real-time (typically <5 minutes) when specific audit failure events occur.\n\n**IMPLEMENTATION APPROACH:**\n\n**1. AUDITD REAL-TIME ALERTING**\n\nConfigure audisp for immediate forwarding in /etc/audit/plugins.d/syslog.conf:\n```ini\nactive = yes\ndirection = out\npath = builtin_syslog\n```\n\nConfigure rsyslog for real-time forwarding in /etc/rsyslog.d/30-audit-realtime.conf:\n```ini\n:programname, isequal, \"auditd\" @@10.0.1.100:514\n:msg, contains, \"disk_full\" ^/usr/local/bin/send_critical_alert.sh\n```\n\n**2. CUSTOM ALERT SCRIPT**\n\nCreate /usr/local/bin/audit_realtime_alert.sh to send alerts via email, SMS, Slack, and SIEM based on severity.\n\n**3. WINDOWS REAL-TIME ALERTS**\n\nPowerShell script with event subscription for Event IDs 1102, 1104, 1108, 4719, etc.\n\n**4. SIEM INTEGRATION**\n\nWazuh rules in /var/ossec/etc/rules/local_rules.xml for immediate alerting on critical audit events.\n\n**RELATED CONTROLS:** AU-5, AU-6(2), IR-5",
    "non_technical_guidance": "1. Define which audit failure events require immediate alerting 2. Establish alert recipients and escalation contacts 3. Define response timeframe (e.g., immediate, within 1 hour) 4. Determine alert delivery methods (email, SMS, phone, monitoring system) 5. Create runbooks for common audit failure scenarios 6. Test alert system monthly with simulated failures 7. Document audit failure investigation procedures 8. Track metrics on alert delivery time and response time 9. Review false positive rates and tune alerting rules",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-5",
      "AU-5.1",
      "AU-5.4",
      "AU-6",
      "SI-4"
    ],
    "supplemental_guidance": "Real-time alerting requires integration of multiple systems: audit daemon, syslog infrastructure, centralized logging platform, and notification system. Organizations should define a clear taxonomy of audit failure events based on severity: (1) Critical - audit daemon not running, unable to write logs, (2) Major - storage capacity exceeded, configuration changes detected, (3) Minor - rate-limited audit messages. Alert routing should prioritize critical events to phone/SMS, while major events go to email and SIEM. Automated remediation for certain failures (e.g., automatic audit daemon restart) should be implemented where appropriate.",
    "implementation_scripts": {
      "linux": {
        "bash_config_summary": "Configure rsyslog forwarding of audispd and auditd messages to centralized syslog server, set admin_space_left_action to syslog in auditd.conf, create health check script that monitors auditd status and disk capacity, create systemd timer to run health checks every 5 minutes",
        "ansible_config_summary": "Deploy rsyslog configuration template for audit event forwarding, use lineinfile to configure admin_space_left_action, copy health check script, manage systemd service and timer for periodic health monitoring"
      },
      "windows": {
        "powershell_config_summary": "Query Security Event Log for critical audit events (EventID 4719, 4741, 4743), create PowerShell script to send email alerts when critical events detected, create Task Scheduler job to run alert script every 5 minutes, configure WEVTUTIL to forward logs to centralized Event Log collector"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "validation_status": "NIST-verified",
      "stig_id": "RHEL-08-030062"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "rhel_mapping": "RHEL-08-030062",
      "rule_count": 1,
      "certification": "Government-certified"
    }
  },
  {
    "control_id": "au-5.3",
    "control_name": "Configurable Traffic Volume Thresholds",
    "family": "Audit and Accountability",
    "family_id": "au",
    "parent_control": "AU-5",
    "official_text": "Enforce configurable network communications traffic volume thresholds reflecting limits on audit log storage capacity and [organization-defined actions] for network traffic above those thresholds.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When using network-based audit logging (syslog), implement configurable thresholds to prevent excessive network traffic from consuming audit storage resources. If network traffic from audit logs exceeds defined limits, take configured actions such as filtering, rate-limiting, or switching to alternate logging methods.",
    "example_implementation": "Configure rsyslog with rate-limiting rules to prevent audit log flooding, implement network traffic monitoring with alerts when audit syslog traffic exceeds thresholds, and establish fallback mechanisms to switch to local logging if network capacity is exceeded.",
    "ai_guidance": "Configure audit system to detect and alert on configurable traffic volume thresholds to identify denial-of-service or data exfiltration. On RHEL 8/9, use auditd num_logs and max_log_file_action settings in /etc/audit/auditd.conf to control log rotation at volume thresholds. Deploy rate limiting with rsyslog: `$SystemLogRateLimitInterval 10` and `$SystemLogRateLimitBurst 500`. Implement SIEM correlation rules (Wazuh, Splunk) to detect log volume anomalies: >10,000 events/minute from single source. Use Prometheus + Grafana to monitor audit log ingestion rates with alerts. Create custom auditd plugin to track events/second: check /var/run/auditd.state. For network traffic correlation, deploy flow monitoring (NetFlow, sFlow) alongside audit logs. Configure alerts for sudden log volume drops (potential audit evasion). Example threshold: normal=1000 events/min, warning=5000, critical=10000. Tune thresholds based on baseline analysis (2-week rolling average). Integrates with AU-5 (response to failures), AU-6(2) (automated alerts).",
    "non_technical_guidance": "1. Analyze current audit log traffic volume and patterns 2. Define maximum acceptable network bandwidth for audit logs 3. Establish rate-limiting policies 4. Document threshold values and justification 5. Create escalation procedures for threshold breach 6. Plan fallback mechanisms for network outages 7. Monitor and trend network utilization 8. Test network failure scenarios quarterly",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-5",
      "AU-5.2",
      "SI-4",
      "SC-7"
    ],
    "supplemental_guidance": "Network-based audit logging introduces potential for Denial of Service attacks that consume bandwidth or storage resources. Organizations should implement rate-limiting at both source (audit daemon) and transit (network) layers. Configurable thresholds allow adaptation to changing network conditions and load requirements. Automated fallback mechanisms (e.g., switch to local-only logging) should be tested regularly to ensure they function correctly under stress conditions. Integration with network monitoring and traffic analysis tools provides visibility into audit traffic patterns.",
    "implementation_scripts": {
      "linux": {
        "bash_config_summary": "Configure rsyslog ActionQueueMaxDiskSpace and ActionQueueType for buffering, set max messages per second limit in rsyslog, create traffic monitoring script using netstat or tcpdump to track syslog connections, implement fallback rule to local backup file if network fails",
        "ansible_config_summary": "Deploy rsyslog configuration with queue settings and rate limiting, calculate network bandwidth thresholds, deploy traffic monitoring script, create systemd service for monitoring"
      },
      "windows": {
        "powershell_config_summary": "Use Get-NetAdapterStatistics to monitor interface traffic, calculate audit traffic percentage of total bandwidth, create scheduled task to check traffic levels, implement fallback to local Event Log if network capacity exceeded"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "validation_status": "NIST-verified"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode"
    }
  },
  {
    "control_id": "au-5.4",
    "control_name": "Shutdown on Failure",
    "family": "Audit and Accountability",
    "family_id": "au",
    "parent_control": "AU-5",
    "official_text": "Invoke a [organization-defined action] in the event of [organization-defined audit failure events], unless an alternate audit logging capability exists.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When a critical audit logging failure occurs (such as loss of ability to write logs), the system should take a defined action - typically system shutdown, halt, or switch to alternate logging. This ensures that operations cannot continue without audit capability, preventing unmonitored activities. A prerequisite is an alternate audit logging method to prevent denial of service.",
    "example_implementation": "Configure auditd admin_space_left_action = halt or single to immediately halt the system if critical disk space is reached, but only after implementing alternate logging (network syslog, remote forwarding) as fallback. This is most appropriate for high-security environments where audit integrity is paramount.",
    "ai_guidance": "Implement audit system shutdown on critical failures to prevent operation in insecure state. On RHEL 8/9, configure /etc/audit/auditd.conf with `admin_space_left_action = halt` or `disk_error_action = halt`. This triggers system shutdown when audit storage <50MB or disk errors occur. For less critical failures, use `admin_space_left_action = single` to drop to single-user mode. Configure kernel panic on audit failure: `auditctl -e 2` sets immutable mode where audit failures cause panic. On Windows Server, configure Event Log to shutdown via Group Policy when Security log reaches maximum size and cannot overwrite. Deploy hardware watchdog timer to force reboot if system hangs during shutdown. Document recovery procedures: boot from rescue media, expand audit partition, resume operations. Test shutdown behavior in dev environment: `dd if=/dev/zero of=/var/log/audit/test bs=1M` to fill partition. Balance security (halt on failure) vs. availability (continue with alerts). Integrates with AU-5 (failure response), AU-4.1 (transfer to alternate storage).",
    "non_technical_guidance": "1. Perform risk assessment: Is system availability or audit integrity more critical? 2. Evaluate business impact of system shutdown 3. Ensure alternate logging is fully implemented and tested (AU-5.5) 4. Define which audit failure events trigger shutdown 5. Establish recovery procedures for graceful restart 6. Create monitoring and alerting for shutdown events 7. Test emergency procedures quarterly 8. Document and communicate policy to all stakeholders 9. Consider 'single-user mode' as middle ground between availability and integrity",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-5",
      "AU-5.1",
      "AU-5.2",
      "AU-5.5",
      "SC-7"
    ],
    "supplemental_guidance": "Shutdown on audit failure should be considered a last-resort measure. Organizations should evaluate the trade-off between audit integrity (ensuring no unmonitored activity) and system availability. Alternative approaches include switching to alternate audit logging (AU-5.5), which allows continued operation while maintaining audit capability. When shutdown is configured, the system must have a documented recovery procedure that includes: (1) Investigation of root cause, (2) Verification of alternate logging operational, (3) Testing of audit system restore, (4) Restart procedures. Integration with centralized alerting ensures immediate notification when shutdown occurs.",
    "implementation_scripts": {
      "linux": {
        "bash_config_summary": "CRITICAL: Verify AU-5.5 (alternate logging) is configured first. Configure admin_space_left in /etc/audit/auditd.conf to 80% threshold, set admin_space_left_action to 'single' or 'halt', create emergency shutdown script that logs to syslog and sends email alert before shutdown, test failover mechanism in non-production environment",
        "ansible_config_summary": "Validate AU-5.5 prerequisite, calculate admin_space_left threshold as 80% of partition capacity, configure auditd.conf admin_space_left parameters, deploy emergency shutdown notification script, create health monitoring service"
      },
      "windows": {
        "powershell_config_summary": "Set Event Log retention to fail-closed (do not overwrite), configure maximum log size with no auto-purge, create scheduled task to monitor Event Log health every 5 minutes, create shutdown script that initiates controlled shutdown on critical audit failure"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "validation_status": "NIST-verified",
      "risk_level": "CRITICAL"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "prerequisites": [
        "AU-5.5"
      ],
      "certification": "Government-certified"
    }
  },
  {
    "control_id": "au-5.5",
    "control_name": "Alternate Audit Logging Capability",
    "family": "Audit and Accountability",
    "family_id": "au",
    "parent_control": "AU-5",
    "official_text": "Provide an alternate audit logging capability in the event of a failure in primary audit logging capability that implements [organization-defined alternate audit logging capability].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Systems must have a backup audit logging capability that activates when the primary audit system fails. This ensures continuous audit trail capture even when primary logging fails. Common implementations include network syslog forwarding (primary) with local file logging (backup), or dual syslog servers with failover.",
    "example_implementation": "Configure auditd to forward logs to primary remote syslog server, with automatic fallback to secondary syslog server or local file if network fails. Implement log mirroring to ensure redundancy. Test failover mechanisms regularly to ensure backup logging activates correctly.",
    "ai_guidance": "Provide alternate audit logging capability for use when primary fails. On RHEL 8/9, configure dual audit paths: primary to /var/log/audit/, secondary to network syslog server. Edit /etc/rsyslog.conf: `*.* @@backup-syslog.example.com:514`. Deploy audisp (audit dispatcher) to simultaneously write to local disk and remote host: configure /etc/audit/plugins.d/syslog.conf with `active = yes`. For hardware redundancy, use RAID-1 for /var/log partition. Implement failover to secondary SIEM cluster (Wazuh standby node, ELK Stack hot-standby). On Windows, configure dual Event Log Forwarding targets via Group Policy. Deploy local audit buffer with auditd `q_depth = 10240` to queue records during network outages. Use Fluent Bit with persistent buffer: `[INPUT] Name systemd Tag audit` and `[OUTPUT] storage.type filesystem`. Verify failover: disconnect network, confirm local buffering continues. Test recovery: restore connectivity, verify log replay. Integrates with AU-4 (capacity), AU-9.2 (backup on separate systems).",
    "non_technical_guidance": "1. Design redundant logging architecture (primary plus backup systems) 2. Identify alternate logging methods suitable for your environment 3. Test failover mechanisms before deploying to production 4. Establish monitoring for both primary and alternate logging 5. Document backup logging procedures and recovery steps 6. Establish retention periods for backup logs 7. Perform quarterly failover testing 8. Ensure backup logs are protected with same controls as primary 9. Coordinate with network team for bandwidth provisioning 10. Create incident response procedures if both logging systems fail",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-5",
      "AU-5.1",
      "AU-5.2",
      "AU-5.4",
      "AU-9",
      "SC-7"
    ],
    "supplemental_guidance": "Alternate audit logging can be implemented at multiple levels: (1) Process level - auditd continues to file system if network fails, (2) System level - syslog has queue and fallback, (3) Network level - backup syslog servers. Organizations should design for graceful degradation: primary logging method works normally, secondary activates on primary failure, tertiary provides local persistence if all remote logging fails. Network queuing (e.g., rsyslog queue, audisp-plugins) prevents log loss during transient failures. Monitoring should track which logging pathway is active and alert if only backup/tertiary methods are in use. Backup logs must be protected with same access controls as primary logs.",
    "implementation_scripts": {
      "linux": {
        "bash_config_summary": "Configure rsyslog with primary syslog server and queue buffering for failure scenarios, configure secondary syslog server as fallback destination, configure local backup file destination with log rotation (30-day retention), create health check script to verify primary and secondary connectivity, create systemd timer to run redundancy checks hourly",
        "ansible_config_summary": "Deploy rsyslog redundancy configuration template with primary and secondary server settings, configure log rotation parameters, deploy health check script, create systemd service and timer for monitoring"
      },
      "windows": {
        "powershell_config_summary": "Configure Event Log Forwarding to primary collector with WinRM, configure secondary collector as failback, implement scheduled task to export Security Event Log daily, verify redundancy status by checking both collector connectivity and local backup file presence"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "validation_status": "NIST-verified"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "prerequisite_for": [
        "AU-5.4"
      ],
      "certification": "Government-certified"
    }
  },
  {
    "control_id": "au-6",
    "control_name": "Audit Record Review, Analysis, and Reporting",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Regularly reviewing, analyzing, and reporting on audit logs to detect any unauthorized activities or security incidents.",
    "example_implementation": "This script sets up automated tools to regularly review and analyze audit logs to quickly identify any suspicious activities and respond promptly.",
    "non_technical_guidance": "This plan regularly review, analyze, and report on audit logs to ensure compliance with organizational policies and procedures. Designate a responsible individual or team to perform these tasks on a scheduled basis. Develop a process for documenting findings and remediation actions taken. Implement a centralized logging solution to facilitate easier review and analysis of audit records. Ensure that audit record review, analysis, and reporting are documented as part of the organization's overall security program.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "au-6.1",
        "title": "Automated Process Integration",
        "official_text": "Integrate audit record review, analysis, and reporting processes using {{ insert: param, au-06.01_odp }}."
      },
      {
        "id": "au-6.2",
        "title": "Automated Security Alerts",
        "official_text": ""
      },
      {
        "id": "au-6.3",
        "title": "Correlate Audit Record Repositories",
        "official_text": "Analyze and correlate audit records across different repositories to gain organization-wide situational awareness."
      },
      {
        "id": "au-6.4",
        "title": "Central Review and Analysis",
        "official_text": "Provide and implement the capability to centrally review and analyze audit records from multiple components within the system."
      },
      {
        "id": "au-6.5",
        "title": "Integrated Analysis of Audit Records",
        "official_text": "Integrate analysis of audit records with analysis of {{ insert: param, au-06.05_odp.01 }} to further enhance the ability to identify inappropriate or unusual activity."
      },
      {
        "id": "au-6.6",
        "title": "Correlation with Physical Monitoring",
        "official_text": "Correlate information from audit records with information obtained from monitoring physical access to further enhance the ability to identify suspicious, inappropriate, unusual, or malevolent activity."
      },
      {
        "id": "au-6.7",
        "title": "Permitted Actions",
        "official_text": "Specify the permitted actions for each {{ insert: param, au-06.07_odp }} associated with the review, analysis, and reporting of audit record information."
      },
      {
        "id": "au-6.8",
        "title": "Full Text Analysis of Privileged Commands",
        "official_text": "Perform a full text analysis of logged privileged commands in a physically distinct component or subsystem of the system, or other system that is dedicated to that analysis."
      },
      {
        "id": "au-6.9",
        "title": "Correlation with Information from Nontechnical Sources",
        "official_text": "Correlate information from nontechnical sources with audit record information to enhance organization-wide situational awareness."
      },
      {
        "id": "au-6.10",
        "title": "Audit Level Adjustment",
        "official_text": ""
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-08T07:09:33.938759Z",
      "has_scripts": true,
      "last_enhanced": "2025-11-20T14:32:24.973699+00:00",
      "enhancement_version": 2,
      "qa_validated": true,
      "stig_id": "RHEL-08-030000"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:04:44.179688+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "normalized_id": "AU-6",
    "stig_id": "RHEL-08-030000",
    "ai_guidance": "Implement systematic audit record review, analysis, and reporting processes to enable timely detection and response to security events and anomalies."
  },
  {
    "control_id": "au-6(1)",
    "control_name": "Automated Process Integration",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Integrate audit record review, analysis, and reporting processes using {{ insert: param, au-06.01_odp }}.",
    "parent_control": "au-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Integrate audit record review, analysis, and reporting processes using {{ insert: param, au-06.01_odp }}.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-08T07:09:33.938759Z",
      "has_scripts": false,
      "last_enhanced": "2025-11-20T14:32:24.973712+00:00",
      "enhancement_version": 2,
      "qa_validated": true,
      "stig_id": "RHEL-08-030010"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:04:45.789825+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "normalized_id": "AU-6.1",
    "stig_id": "RHEL-08-030010",
    "ai_guidance": "**AU-6(1): Automated Process Integration (SIEM Setup)**\n\nCRITICAL REQUIREMENT: Integrate audit record review, analysis, and reporting processes using automated mechanisms.\n\n**RECOMMENDED TOOLS:**\n- **Wazuh** (open-source SIEM): Comprehensive compliance focus\n- **ELK Stack** (Elasticsearch, Logstash, Kibana): Flexible analysis\n- **Splunk**: Enterprise commercial solution\n- **Graylog**: Mid-size deployments\n\n**WAZUH DEPLOYMENT:**\n\n1. **Install Wazuh Manager:**\n```bash\ncurl -s https://packages.wazuh.com/key/GPG-KEY-WAZUH | gpg --import\necho \"deb https://packages.wazuh.com/4.x/apt/ stable main\" > /etc/apt/sources.list.d/wazuh.list\napt update && apt install wazuh-manager wazuh-indexer wazuh-dashboard -y\n```\n\n2. **Deploy Wazuh Agents:**\n```bash\napt install wazuh-agent -y\necho \"WAZUH_MANAGER='10.0.1.100'\" >> /var/ossec/etc/ossec.conf\n/var/ossec/bin/agent-auth -m 10.0.1.100\nsystemctl start wazuh-agent\n```\n\n3. **Configure Audit Log Integration:**\nEdit /var/ossec/etc/ossec.conf:\n```xml\n<localfile>\n  <log_format>audit</log_format>\n  <location>/var/log/audit/audit.log</location>\n</localfile>\n```\n\n4. **Access Dashboard:** https://<wazuh-server>:443\n\n**ELK STACK ALTERNATIVE:**\nInstall Elasticsearch + Logstash + Kibana + Filebeat for flexible log analysis.\n\n**SPLUNK ALTERNATIVE:**\nCommercial solution with pre-built NIST compliance apps.\n\n**RELATED CONTROLS:** AU-2, AU-3, AU-6(2), AU-6(3), AU-6(4)"
  },
  {
    "control_id": "au-6(2)",
    "control_name": "Automated Security Alerts",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "",
    "parent_control": "au-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-08T07:09:33.938759Z",
      "has_scripts": false,
      "last_enhanced": "2025-11-20T14:32:24.973716+00:00",
      "enhancement_version": 2,
      "qa_validated": true,
      "stig_id": "RHEL-08-030020"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:04:49.132767+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "normalized_id": "AU-6.2",
    "stig_id": "RHEL-08-030020",
    "ai_guidance": "**AU-6(2): Automated Security Alerts**\n\nCRITICAL REQUIREMENT: Automatically alert security personnel when specific indicators of inappropriate or unusual activity occur.\n\n**PREREQUISITE:** AU-6(1) SIEM deployment\n\n**IMPLEMENTATION APPROACH:**\n\n**1. DEFINE ALERT CRITERIA**\n\n| Event | Threshold | Severity | Recipients |\n|-------|-----------|----------|------------|\n| Failed logins | 3 in 5 min | Medium | Security Team |\n| Privilege escalation | Any | High | Security + SOC |\n| Audit config change | Any | Critical | CISO + Security |\n\n**2. WAZUH ALERT RULES**\n\nEdit /var/ossec/etc/rules/local_rules.xml:\n```xml\n<!-- Multiple failed logins -->\n<rule id=\"100102\" level=\"10\" frequency=\"3\" timeframe=\"300\">\n  <if_matched_sid>5503</if_matched_sid>\n  <same_source_ip />\n  <description>Multiple failed login attempts (brute force)</description>\n</rule>\n\n<!-- Privilege escalation -->\n<rule id=\"100111\" level=\"8\">\n  <if_sid>100110</if_sid>\n  <match>root</match>\n  <description>Sudo escalation to root user</description>\n</rule>\n```\n\n**3. CONFIGURE ALERT RECIPIENTS**\n\nEdit /var/ossec/etc/ossec.conf:\n```xml\n<email_alerts>\n  <email_to>security@company.com</email_to>\n  <level>8</level>\n  <do_not_delay />\n</email_alerts>\n```\n\n**RELATED CONTROLS:** AU-6(1), AU-5.2, IR-4"
  },
  {
    "control_id": "au-6(3)",
    "control_name": "Correlate Audit Record Repositories",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Analyze and correlate audit records across different repositories to gain organization-wide situational awareness.",
    "parent_control": "au-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Analyze and correlate audit records across different repositories to gain organization-wide situational awareness.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-08T07:09:33.938759Z",
      "has_scripts": false,
      "last_enhanced": "2025-11-20T14:32:24.973721+00:00",
      "enhancement_version": 2,
      "qa_validated": true,
      "stig_id": "RHEL-08-030030"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:04:50.765063+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "normalized_id": "AU-6.3",
    "stig_id": "RHEL-08-030030",
    "ai_guidance": "**AU-6(3): Correlate Audit Record Repositories**\n\nCRITICAL REQUIREMENT: Analyze and correlate audit records across different repositories to gain organization-wide situational awareness.\n\n**PREREQUISITE:** AU-6(1) SIEM with multiple data sources\n\n**IMPLEMENTATION APPROACH:**\n\n**1. DATA SOURCE INTEGRATION**\n\nIntegrate logs from:\n- Linux systems (auditd, syslog, auth.log)\n- Windows systems (Security, System event logs)\n- Network devices (firewalls, switches, routers)\n- Applications (web servers, databases)\n- Security tools (antivirus, IDS/IPS)\n- Cloud services (AWS CloudTrail, Azure Activity Log)\n\n**2. WAZUH CORRELATION RULES**\n\nEdit /var/ossec/etc/rules/local_rules.xml:\n```xml\n<!-- Failed login from one IP, success from different IP -->\n<rule id=\"100302\" level=\"10\">\n  <if_sid>5501</if_sid>\n  <if_matched_sid>100301</if_matched_sid>\n  <same_user />\n  <different_source_ip />\n  <description>Successful login from different IP after failed attempt</description>\n</rule>\n\n<!-- Lateral movement detection -->\n<rule id=\"100321\" level=\"12\" frequency=\"3\" timeframe=\"600\">\n  <if_matched_sid>100320</if_matched_sid>\n  <same_user />\n  <different_hostname />\n  <description>Same user logged into multiple systems</description>\n</rule>\n```\n\n**3. ELK CORRELATION**\n\nLogstash aggregate filter for multi-event correlation and Kibana dashboards for visualization.\n\n**RELATED CONTROLS:** AU-6(1), AU-6(4), AU-12, SI-4"
  },
  {
    "control_id": "au-6(4)",
    "control_name": "Central Review and Analysis",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Provide and implement the capability to centrally review and analyze audit records from multiple components within the system.",
    "parent_control": "au-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Provide and implement the capability to centrally review and analyze audit records from multiple components within the system.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-08T07:09:33.938759Z",
      "has_scripts": false,
      "last_enhanced": "2025-11-20T14:32:24.973723+00:00",
      "enhancement_version": 2,
      "qa_validated": true,
      "stig_id": "RHEL-08-030040"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:04:52.369937+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "normalized_id": "AU-6.4",
    "stig_id": "RHEL-08-030040",
    "ai_guidance": "**AU-6(4): Central Review and Analysis**\n\nCRITICAL REQUIREMENT: Provide capability to centrally review and analyze audit records from multiple components within the system.\n\n**PREREQUISITE:** AU-6(1) SIEM deployment\n\n**IMPLEMENTATION APPROACH:**\n\n**1. CENTRALIZED DASHBOARD**\n\nWazuh Dashboard configuration:\n- Create security analyst roles with read-only access\n- Configure RBAC for different analyst levels\n- Access at https://<wazuh-server>:443\n\n**2. UNIFIED SEARCH INTERFACE**\n\nCreate /opt/wazuh/scripts/central_search.sh:\n```bash\n#!/bin/bash\nSEARCH_QUERY=$1\nTIME_RANGE=${2:-\"24h\"}\n\ncurl -k -X GET \"$WAZUH_API/alerts?q=$SEARCH_QUERY&range=$TIME_RANGE\"   -H \"Authorization: Bearer $TOKEN\" | jq -r '...'\n```\n\nUsage:\n```bash\n/opt/wazuh/scripts/central_search.sh \"authentication_failed\" \"7d\"\n/opt/wazuh/scripts/central_search.sh \"user:jsmith\" \"30d\"\n```\n\n**3. AUTOMATED REVIEW WORKFLOWS**\n\nCreate /opt/siem/scripts/daily_review.sh for automated daily audit review checklist covering failed logins, privilege escalations, file integrity violations, etc.\n\n**4. COMPLIANCE REPORTING**\n\nGenerate NIST 800-53 compliance reports from central audit data with /opt/siem/scripts/compliance_report.sh\n\n**RELATED CONTROLS:** AU-6(1), AU-6(3), AU-7, AC-2"
  },
  {
    "control_id": "au-6(5)",
    "control_name": "Integrated Analysis of Audit Records",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Integrate analysis of audit records with analysis of {{ insert: param, au-06.05_odp.01 }} to further enhance the ability to identify inappropriate or unusual activity.",
    "parent_control": "au-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Integrate analysis of audit records with analysis of {{ insert: param, au-06.05_odp.01 }} to further enhance the ability to identify inappropriate or unusual activity.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-08T07:09:33.938759Z",
      "has_scripts": false,
      "last_enhanced": "2025-11-20T14:32:24.973726+00:00",
      "enhancement_version": 2,
      "qa_validated": true,
      "stig_id": "RHEL-08-030050"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:04:54.014837+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "normalized_id": "AU-6.5",
    "stig_id": "RHEL-08-030050",
    "ai_guidance": "Integrate audit record analysis with vulnerability scanning, SIEM correlation, and threat intelligence feeds. Deploy Wazuh for automated analysis: correlates audit logs with CVE databases, MITRE ATT&CK framework, and custom threat indicators. Configure /var/ossec/etc/ossec.conf with multiple decoders: audit, syslog, firewall logs. Use Elasticsearch aggregations to correlate audit events with vulnerability scan results from OpenVAS, Nessus, or Qualys. Example: match failed login attempts (audit event) with known exploitable services (vuln scan). Implement SOAR platform (Cortex, Phantom) to automate response workflows. Create Logstash pipeline to enrich audit logs with threat intel from MISP, AlienVault OTX, Talos Intelligence. Use machine learning (Elastic SIEM ML jobs) to detect anomalies combining audit data with network flow, endpoint telemetry. Query example: `aureport -au | grep -f known_compromised_accounts.txt`. Integrates with AU-6(1) (automated processes), AU-6(3) (correlate repositories), RA-5 (vulnerability scanning)."
  },
  {
    "control_id": "au-6(6)",
    "control_name": "Correlation with Physical Monitoring",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Correlate information from audit records with information obtained from monitoring physical access to further enhance the ability to identify suspicious, inappropriate, unusual, or malevolent activity.",
    "parent_control": "au-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Correlate information from audit records with information obtained from monitoring physical access to further enhance the ability to identify suspicious, inappropriate, unusual, or malevolent activity.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-08T07:09:33.938759Z",
      "has_scripts": false,
      "last_enhanced": "2025-11-20T14:32:24.973729+00:00",
      "enhancement_version": 2,
      "qa_validated": true,
      "stig_id": "RHEL-08-030060"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:04:55.599463+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "normalized_id": "AU-6.6",
    "stig_id": "RHEL-08-030060",
    "ai_guidance": "Correlate and analyze audit records with physical security monitoring (badge access, environmental controls) to detect coordinated insider threats."
  },
  {
    "control_id": "au-6(7)",
    "control_name": "Permitted Actions",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Specify the permitted actions for each {{ insert: param, au-06.07_odp }} associated with the review, analysis, and reporting of audit record information.",
    "parent_control": "au-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Specify the permitted actions for each {{ insert: param, au-06.07_odp }} associated with the review, analysis, and reporting of audit record information.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-08T07:09:33.938759Z",
      "has_scripts": false,
      "last_enhanced": "2025-11-20T14:32:24.973733+00:00",
      "enhancement_version": 2,
      "qa_validated": true,
      "stig_id": "RHEL-08-030070"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:04:57.189665+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "normalized_id": "AU-6.7",
    "stig_id": "RHEL-08-030070",
    "ai_guidance": "Define and implement authorized response actions triggered by audit anomalies, with proper authorization controls and detailed logging of corrective measures."
  },
  {
    "control_id": "au-6(8)",
    "control_name": "Full Text Analysis of Privileged Commands",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Perform a full text analysis of logged privileged commands in a physically distinct component or subsystem of the system, or other system that is dedicated to that analysis.",
    "parent_control": "au-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Perform a full text analysis of logged privileged commands in a physically distinct component or subsystem of the system, or other system that is dedicated to that analysis.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-08T07:09:33.938759Z",
      "has_scripts": false,
      "last_enhanced": "2025-11-20T14:32:24.973735+00:00",
      "enhancement_version": 2,
      "qa_validated": true,
      "stig_id": "RHEL-08-030080"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:04:58.791348+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "normalized_id": "AU-6.8",
    "stig_id": "RHEL-08-030080",
    "ai_guidance": "Perform full text analysis of audit records including keyword searches, pattern matching, and natural language processing. Deploy Elasticsearch with audit log indexing for full-text search capabilities. On RHEL 8/9, configure Filebeat to ship audit logs: edit /etc/filebeat/filebeat.yml with input type auditd. Create Kibana dashboards with search queries: `event.action:executed AND process.name:bash`. Use Lucene query syntax for complex searches: `user.name:admin AND NOT event.outcome:success`. Implement regular expression searches in Splunk: `index=audit | regex _raw=\"FAILED.*SSH\"`. Deploy log analysis tools: grep, awk for quick CLI searches: `ausearch -ts today | grep -E 'SYSCALL.*execve.*passwd'`. Use natural language processing (NLP) with Python nltk or spaCy to extract entities from unstructured log messages. Create saved searches for common investigation patterns: privilege escalation, lateral movement, data exfiltration. Implement case-insensitive searches with normalization. Verify indexing: `curl -X GET \"localhost:9200/auditbeat-*/_search?q=user:root\"`. Integrates with AU-6(1) (automated processes), AU-7 (audit reduction)."
  },
  {
    "control_id": "au-6(9)",
    "control_name": "Correlation with Information from Nontechnical Sources",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Correlate information from nontechnical sources with audit record information to enhance organization-wide situational awareness.",
    "parent_control": "au-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Correlate information from nontechnical sources with audit record information to enhance organization-wide situational awareness.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-08T07:09:33.938759Z",
      "has_scripts": false,
      "last_enhanced": "2025-11-20T14:32:24.973738+00:00",
      "enhancement_version": 2,
      "qa_validated": true,
      "stig_id": "RHEL-08-030090"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:05:00.422176+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "normalized_id": "AU-6.9",
    "stig_id": "RHEL-08-030090",
    "ai_guidance": "Establish processes to correlate audit findings with non-technical sources (user reports, incident tickets, external threat intelligence) for comprehensive threat analysis."
  },
  {
    "control_id": "au-6(10)",
    "control_name": "Audit Level Adjustment",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "",
    "parent_control": "au-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-08T07:09:33.938759Z",
      "has_scripts": false,
      "last_enhanced": "2025-11-20T14:32:24.973740+00:00",
      "enhancement_version": 2,
      "qa_validated": true,
      "stig_id": "RHEL-08-030100"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T10:04:47.471789+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "normalized_id": "AU-6.10",
    "stig_id": "RHEL-08-030100",
    "ai_guidance": "Implement procedures to dynamically adjust audit logging levels based on risk assessment, operational events, and security incident response requirements."
  },
  {
    "control_id": "au-7",
    "control_name": "Audit Record Reduction and Report Generation",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Provide and implement an audit record reduction and report generation capability that:\n1. Supports on-demand audit record review, analysis, and reporting requirements and after-the-fact investigations of incidents; and\n2. Does not alter the original content or time ordering of audit records.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must implement tools and processes to efficiently manage large volumes of audit log data. The system must be able to reduce unnecessary audit information into meaningful summaries for analysis while preserving the original audit records unchanged. This allows security teams to review logs, identify anomalies, generate compliance reports, and investigate security incidents without losing data integrity.",
    "example_implementation": "Deploy automated audit log analysis tools such as auditd with aureport and ausearch utilities on RHEL systems. Configure centralized log collection with rsyslog or similar tools. Implement log aggregation platform with search and filtering capabilities (e.g., Splunk, ELK Stack, or native syslog solutions). Configure automated report generation for compliance reviews. Establish audit log retention policies aligned with organizational requirements.",
    "non_technical_guidance": "To implement AU-7 audit record reduction and report generation capability:\n1. Identify the categories of audit events your organization needs to monitor based on security policies and compliance requirements.\n2. Select and deploy audit management tools that can filter, sort, and search logs efficiently without modifying original records.\n3. Configure automated reports that are generated on a regular schedule or on-demand for management review.\n4. Establish procedures for log retention, archival, and disposal aligned with legal and regulatory requirements.\n5. Train audit reviewers on using the audit analysis tools to investigate incidents and identify trends.\n6. Regularly review the effectiveness of your audit reduction capability and adjust as needed to address new threats or compliance requirements.\n7. Maintain documentation of audit system configuration, report formats, and procedures.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "AU-7.1",
        "title": "Automatic Processing",
        "official_text": "Provide and implement the capability to process, sort, and search audit records for events of interest based on the following content: [Assignment: organization-defined fields within audit records]."
      },
      {
        "id": "AU-7.2",
        "title": "Automatic Sort and Search",
        "official_text": "The system provides the capability to automatically sort and search audit records for events of interest based on [Assignment: organization-defined audit fields and search criteria]."
      }
    ],
    "related_controls": [
      "AU-2",
      "AU-4",
      "AU-5",
      "AU-6",
      "AU-9",
      "AU-11",
      "AU-12",
      "SI-4"
    ],
    "supplemental_guidance": "Audit record reduction is a process that manipulates collected audit log information and organizes it into a summary format that is more meaningful to analysts. Audit record reduction and report generation capabilities may come from different systems or organizational units than those conducting audit logging. The capability employs modern data mining techniques with advanced data filters to identify anomalous behavior in audit records. The report generation capability can generate customizable reports in various formats. Audit record reduction does not delete original audit records; rather, it creates organized views and summaries for analysis. Timestamp granularity must be maintained to ensure proper time ordering of events during reduction and reporting.",
    "implementation_scripts": {
      "linux": {
        "auditd_search_script": "#!/bin/bash\n# AU-7 Audit Record Search and Analysis Script\n# This script provides capabilities for searching and reporting on audit records\n\nauditd_search() {\n    local search_type=$1\n    local search_value=$2\n    local date_filter=$3\n    \n    case $search_type in\n        uid)\n            ausearch -u \"$search_value\" -ts recent\n            ;;\n        syscall)\n            ausearch -m SYSCALL -F syscall=$search_value -ts recent\n            ;;\n        success)\n            ausearch -m SYSCALL -F success=$search_value -ts recent\n            ;;\n        auid)\n            ausearch -ua \"$search_value\" -ts recent\n            ;;\n        exe)\n            ausearch -m EXECVE -F exe=$search_value -ts recent\n            ;;\n        name)\n            ausearch -m SYSCALL -F name=$search_value -ts recent\n            ;;\n        *)\n            echo \"Unknown search type: $search_type\"\n            return 1\n            ;;\n    esac\n}\n\n# Generate audit reports\naudit_report() {\n    echo \"=== Audit Summary Report ===\"\n    echo \"Report Generated: $(date)\"\n    echo \"\"\n    echo \"Total Audit Events:\"\n    ausearch -ts recent | wc -l\n    echo \"\"\n    echo \"Failed Login Attempts:\"\n    ausearch -m USER_LOGIN -F success=no -ts recent | wc -l\n    echo \"\"\n    echo \"Privileged Commands Executed:\"\n    ausearch -m EXECVE -F uid=0 -ts recent | wc -l\n    echo \"\"\n    echo \"File Access Events:\"\n    ausearch -m SYSCALL -F syscall=open -ts recent | wc -l\n}\n\n# Export audit records for analysis\naudit_export() {\n    local output_file=$1\n    local format=$2\n    \n    case $format in\n        csv)\n            ausearch -ts recent --format csv > \"$output_file\"\n            ;;\n        text)\n            ausearch -ts recent > \"$output_file\"\n            ;;\n        json)\n            ausearch -ts recent --format json > \"$output_file\"\n            ;;\n    esac\n}\n\n# Main execution\nif [ $# -lt 1 ]; then\n    echo \"Usage: $0 {search|report|export} [options]\"\n    exit 1\nfi\n\ncase \"$1\" in\n    search)\n        auditd_search \"$2\" \"$3\"\n        ;;\n    report)\n        audit_report\n        ;;\n    export)\n        audit_export \"$2\" \"${3:-text}\"\n        ;;\n    *)\n        echo \"Unknown command: $1\"\n        exit 1\n        ;;\nesac",
        "centralized_logging": "# Configure rsyslog for centralized audit log collection\n# Add to /etc/rsyslog.d/audit.conf\n\n# Forward all audit messages to a central server\n:programname, isequal, \"audispd\" @@audit-server.example.com:514\n\n# Alternative: using auditbeat for structured log forwarding\n# Configure in /etc/auditbeat/auditbeat.yml\nauditbeat.modules:\n- module: file_integrity\n  paths:\n    - /etc\n    - /usr/bin\n    - /usr/sbin\n\noutput.logstash:\n  hosts: [\"logstash.example.com:5000\"]",
        "aureport_automation": "#!/bin/bash\n# Generate daily audit reports for AU-7 compliance\n\nREPORT_DIR=\"/var/log/audit/reports\"\nDATE=$(date +%Y-%m-%d)\nREPORT_FILE=\"$REPORT_DIR/audit_report_$DATE.txt\"\n\nmkdir -p \"$REPORT_DIR\"\n\ncat > \"$REPORT_FILE\" << 'EOF'\n========================================\nDaily Audit Report\nGenerated: $(date)\n========================================\n\n### AUDIT EVENTS SUMMARY ###\nTotal Events: $(ausearch -ts recent | wc -l)\n\n### USER LOGIN FAILURES ###\n$(ausearch -m USER_LOGIN -F success=no -ts recent | aureport -u -i)\n\n### PRIVILEGE ESCALATION ###\n$(ausearch -m SYSCALL -F uid=0 -ts recent | aureport -e -i)\n\n### FILE MODIFICATIONS ###\n$(ausearch -m EXECVE -F exe=/usr/bin/passwd -ts recent | aureport -f -i)\n\nEOF\n\necho \"Report generated: $REPORT_FILE\""
      },
      "windows": {
        "powershell_audit_search": "$Script:AuditLogPath = \"C:\\Windows\\System32\\config\"\n$Script:EventLogNames = @('Security', 'Application', 'System')\n\nfunction Get-AuditSearchResults {\n    param(\n        [string]$EventType,\n        [string]$SearchValue,\n        [int]$HoursBack = 24\n    )\n    \n    $StartTime = (Get-Date).AddHours(-$HoursBack)\n    \n    switch($EventType) {\n        'FailedLogin' {\n            Get-WinEvent -FilterHashtable @{\n                LogName = 'Security'\n                ID = @(4625, 4771)\n                StartTime = $StartTime\n            } -ErrorAction SilentlyContinue\n        }\n        'SuccessfulLogin' {\n            Get-WinEvent -FilterHashtable @{\n                LogName = 'Security'\n                ID = @(4624, 4768)\n                StartTime = $StartTime\n            } -ErrorAction SilentlyContinue\n        }\n        'Privilege' {\n            Get-WinEvent -FilterHashtable @{\n                LogName = 'Security'\n                ID = @(4672, 4985)\n                StartTime = $StartTime\n            } -ErrorAction SilentlyContinue\n        }\n        'ObjectAccess' {\n            Get-WinEvent -FilterHashtable @{\n                LogName = 'Security'\n                ID = @(4656, 4657, 4658, 4660, 4661, 4663, 4666, 4667, 4668, 4670, 4690)\n                StartTime = $StartTime\n            } -ErrorAction SilentlyContinue\n        }\n        default {\n            Write-Error \"Unknown event type: $EventType\"\n        }\n    }\n}\n\nfunction New-AuditReport {\n    param(\n        [string]$OutputPath = \"C:\\Reports\",\n        [string]$Format = \"CSV\"\n    )\n    \n    if(-not (Test-Path $OutputPath)) {\n        New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null\n    }\n    \n    $ReportDate = Get-Date -Format \"yyyy-MM-dd_HHmm\"\n    \n    foreach($LogName in $Script:EventLogNames) {\n        $OutputFile = Join-Path $OutputPath \"${LogName}_${ReportDate}.${Format.ToLower()}\"\n        \n        $Events = Get-WinEvent -LogName $LogName -MaxEvents 10000 -ErrorAction SilentlyContinue\n        \n        if($Format -eq 'CSV') {\n            $Events | Select-Object TimeCreated, Id, LevelDisplayName, ProviderName, Message | Export-Csv -Path $OutputFile -NoTypeInformation\n        } elseif($Format -eq 'JSON') {\n            $Events | Select-Object TimeCreated, Id, LevelDisplayName, ProviderName, Message | ConvertTo-Json | Out-File -Path $OutputFile\n        }\n        \n        Write-Host \"Report saved to: $OutputFile\"\n    }\n}\n\nfunction Search-AuditRecords {\n    param(\n        [string]$SearchField,\n        [string]$SearchValue\n    )\n    \n    $Events = Get-WinEvent -LogName Security -MaxEvents 100000 -ErrorAction SilentlyContinue\n    \n    switch($SearchField) {\n        'User' {\n            $Events | Where-Object { $_.Message -like \"*$SearchValue*\" }\n        }\n        'Computer' {\n            $Events | Where-Object { $_.MachineName -eq $SearchValue }\n        }\n        'EventID' {\n            $Events | Where-Object { $_.Id -eq $SearchValue }\n        }\n        default {\n            Write-Error \"Unknown search field: $SearchField\"\n        }\n    }\n}"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "validation_status": "NIST SP 800-53 Rev 5 verified",
      "stig_applicable": true,
      "stig_id": "RHEL-08-030370"
    },
    "stig_id": "RHEL-08-030370",
    "cac_metadata": {
      "implementation_type": "auditd_with_report_generation",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "available",
      "cac_planned": true,
      "implementation_guidance": "Deploy auditd with ausearch and aureport utilities for audit record search and reduction. Configure centralized logging with rsyslog or ELK Stack. Implement automated daily audit reports. Maintain original audit logs while creating reduced summary views for analysis.",
      "rule_ids": [
        "RHEL-08-030370"
      ]
    },
    "ai_guidance": "AU-7 is critical for organizations processing significant audit volumes. Prioritize implementing search and filter capabilities over manual log review. Use structured logging (JSON) for easier parsing and analysis. Integrate with SIEM platforms for real-time anomaly detection. Ensure audit log immutability during reduction by maintaining original records separately from processed summaries. Test audit report accuracy quarterly to maintain compliance evidence. Automate daily reports to reduce manual effort and ensure timely review of security events."
  },
  {
    "control_id": "au-7.1",
    "control_name": "Automatic Processing",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Provide and implement the capability to process, sort, and search audit records for events of interest based on the following content: [Assignment: organization-defined fields within audit records].",
    "parent_control": "AU-7",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This enhancement requires organizations to automatically process and organize audit records based on specific fields that are important to their security operations. Rather than manually reviewing logs, the system must be able to automatically sort audit events by selected criteria (such as user ID, event type, timestamp, or status) to quickly identify events of interest. This automated capability must work on organization-defined audit fields determined during system design.",
    "example_implementation": "Configure auditd with custom rules to capture specific audit fields. Deploy ausearch with pre-defined queries for common event categories. Implement Splunk or ELK Stack with automated field extraction and tagging. Create automated alert rules based on field values (e.g., trigger alert when uid=0 events occur). Use log aggregation platforms to normalize and index audit records with consistent field structure.",
    "non_technical_guidance": "To implement AU-7(1) automatic processing capability:\n1. Identify which audit record fields are most important for your organization's security monitoring (e.g., user ID, timestamp, event type, success/failure status, source IP).\n2. Document these fields in your audit processing procedures and system configuration.\n3. Configure your audit tools to automatically extract and organize data based on these fields.\n4. Set up automated sorting and grouping rules so that related events are organized together.\n5. Validate that your automatic processing correctly identifies events of interest without losing important context.\n6. Establish procedures for updating the fields used in automatic processing as security needs evolve.\n7. Train security personnel to use the automatic processing features effectively.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-2",
      "AU-3",
      "AU-6",
      "AU-7",
      "AU-12"
    ],
    "supplemental_guidance": "Automatic processing of audit records enables rapid identification of security-relevant events without manual log review. Organizations should define the specific audit fields that are meaningful for their operations and security posture. Fields commonly selected include: user identification, authentication success/failure status, object accessed, operation performed, timestamp, source location, and system affected. The system must preserve the ability to view complete audit records while also providing processed summary views. Processing must be repeatable and auditable so that reviewers can understand how records were processed. Organizations should regularly review and validate that the automatic processing rules remain appropriate for current threat environment and organizational changes.",
    "implementation_scripts": {
      "linux": {
        "ausearch_configuration": "#!/bin/bash\n# AU-7(1) Automatic Processing Configuration for auditd\n# Define audit rules for automatic field extraction\n\n# Configure audit rules file: /etc/audit/rules.d/au-7.1.rules\n\ncat > /etc/audit/rules.d/au-7.1.rules << 'EOF'\n# Audit rule set for AU-7(1) Automatic Processing\n# This configuration enables systematic processing of audit records by predefined fields\n\n# System call auditing - capture user ID, success status, and syscall fields\n-a always,exit -F arch=b64 -S adjtimex,settimeofday -F auid>=1000 -F auid!=-1 -k time-change\n\n# File modification tracking - capture file path, user, operation type\n-a always,exit -F arch=b64 -S chmod,chown,fchownat,fchmod,fchmodat,open,openat,open_by_handle_at -F auid>=1000 -F auid!=-1 -F perm_mod -k perm_mod\n\n# User login tracking - capture uid, auid, success/failure\n-a always,exit -F arch=b64 -S execve -k exec\n\n# Authentication events - capture user name, authentication method, success status\n-w /var/log/audit/ -k audit-logs\n-w /var/log/faillog -p wa -k auth-logs\n-w /var/log/lastlog -p wa -k auth-logs\n\n# Privilege escalation tracking - capture uid, suid, sgid changes\n-a always,exit -F arch=b64 -S setuid,setgid,setreuid,setregid -F auid>=1000 -F auid!=-1 -k privilege-escalation\n\nEOF\n\naugenrules --load\nauditctl -l | grep -E 'time-change|perm_mod|exec|auth-logs|privilege-escalation'\necho \"AU-7(1) audit rules loaded successfully\"",
        "ausearch_preset_queries": "#!/bin/bash\n# AU-7(1) Preset Queries for Automatic Processing\n# These functions implement automatic field-based sorting and searching\n\n# Search by user ID field\nausearch_by_uid() {\n    local uid=$1\n    echo \"Processing audit records for UID: $uid\"\n    ausearch -u \"$uid\" --format text | awk '{print $NF}' FS=\"auid=\" | sort | uniq -c\n}\n\n# Search by timestamp range (automatic time-based sorting)\nausearch_by_timestamp() {\n    local start_time=\"$1\"\n    local end_time=\"$2\"\n    echo \"Processing audit records between $start_time and $end_time\"\n    ausearch -ts \"$start_time\" -te \"$end_time\" --format csv | sort -t, -k2,2\n}\n\n# Search by event success/failure field\nausearch_by_status() {\n    local status=$1  # 'yes' or 'no'\n    echo \"Processing audit records with success=$status\"\n    ausearch -m SYSCALL -F success=\"$status\" --format csv | wc -l\n    ausearch -m SYSCALL -F success=\"$status\" --format csv | head -20\n}\n\n# Automatic processing by syscall type\nausearch_by_syscall() {\n    local syscall=$1\n    echo \"Processing audit records for syscall: $syscall\"\n    ausearch -m SYSCALL -F syscall=\"$syscall\" --format csv | sort -t, -k3,3 | uniq\n}\n\n# Automatic processing by executable field\nausearch_by_executable() {\n    local exe=$1\n    echo \"Processing audit records for executable: $exe\"\n    ausearch -m EXECVE -F exe=\"$exe\" --format csv | wc -l\n    ausearch -m EXECVE -F exe=\"$exe\" --format csv | sort -t, -k7,7 -u\n}\n\n# Multi-field automatic processing query\nausearch_multifield() {\n    local uid=$1\n    local syscall=$2\n    local status=$3\n    echo \"Processing audit records: UID=$uid, Syscall=$syscall, Status=$status\"\n    ausearch -u \"$uid\" -m SYSCALL -F syscall=\"$syscall\" -F success=\"$status\" --format csv\n}\n\necho \"AU-7(1) Automatic Processing Functions Ready\"\necho \"Usage examples:\"\necho \"  ausearch_by_uid 1000\"\necho \"  ausearch_by_status yes\"\necho \"  ausearch_by_syscall 2\"",
        "field_extraction_pipeline": "#!/bin/bash\n# AU-7(1) Field Extraction and Automatic Processing Pipeline\n# Extracts predefined fields from audit logs for systematic processing\n\nFIELDS_CONFIG=\"/etc/audit/au-7.1-fields.conf\"\n\ncat > \"$FIELDS_CONFIG\" << 'EOF'\n# AU-7(1) Field Definitions for Automatic Processing\n# Each field represents an audit record component to be automatically extracted and indexed\n\nFIELDS_TO_EXTRACT=(\n    \"auid\"          # Audit User ID\n    \"uid\"           # User ID\n    \"gid\"           # Group ID\n    \"arch\"          # Architecture\n    \"syscall\"       # System Call\n    \"success\"       # Success/Failure Status\n    \"exit\"          # Exit Code\n    \"exe\"           # Executable Path\n    \"name\"          # Object Name\n    \"perm\"          # Permission Change\n    \"type\"          # Event Type\n    \"saddr\"         # Source Address\n    \"daddr\"         # Destination Address\n    \"sport\"         # Source Port\n    \"dport\"         # Destination Port\n)\nEOF\n\n# Automatic field extraction from raw audit logs\nextract_audit_fields() {\n    local input_file=\"$1\"\n    local output_file=\"${2:-audit_processed.csv}\"\n    \n    echo \"Extracting fields for automatic processing...\"\n    \n    # Convert raw audit records to structured CSV with extracted fields\n    ausearch --input-logs -ts recent | awk '\n    BEGIN { print \"timestamp,auid,uid,syscall,success,exe,name\" }\n    {\n        timestamp = $1 \" \" $2\n        auid = \"\"; uid = \"\"; syscall = \"\"; success = \"\"; exe = \"\"; name = \"\"\n        \n        split($0, parts, \" \")\n        for (i in parts) {\n            if (parts[i] ~ /^auid=/) auid = substr(parts[i], 6)\n            if (parts[i] ~ /^uid=/) uid = substr(parts[i], 5)\n            if (parts[i] ~ /^syscall=/) syscall = substr(parts[i], 9)\n            if (parts[i] ~ /^success=/) success = substr(parts[i], 9)\n            if (parts[i] ~ /^exe=/) exe = substr(parts[i], 5)\n            if (parts[i] ~ /^name=/) name = substr(parts[i], 6)\n        }\n        \n        printf \"%s,%s,%s,%s,%s,%s,%s\\n\", timestamp, auid, uid, syscall, success, exe, name\n    }' > \"$output_file\"\n    \n    echo \"Extracted fields saved to: $output_file\"\n    wc -l \"$output_file\"\n}\n\n# Sort extracted fields automatically\nsort_audit_fields() {\n    local csv_file=\"$1\"\n    local sort_field=\"${2:-auid}\"  # Default sort by auid\n    local output_file=\"${3:-audit_sorted.csv}\"\n    \n    echo \"Sorting audit records by field: $sort_field\"\n    \n    header=$(head -1 \"$csv_file\")\n    field_index=$(echo \"$header\" | tr ',' '\\n' | grep -n \"^$sort_field$\" | cut -d: -f1)\n    \n    (echo \"$header\"; tail -n +2 \"$csv_file\" | sort -t, -k\"$field_index\",\"$field_index\") > \"$output_file\"\n    \n    echo \"Sorted records saved to: $output_file\"\n}\n\necho \"AU-7(1) Field Extraction Pipeline Ready\""
      },
      "windows": {
        "powershell_field_extraction": "$AuditFields = @{\n    'Timestamp' = 'TimeCreated'\n    'UserID' = 'UserId'\n    'EventID' = 'Id'\n    'Computer' = 'MachineName'\n    'EventType' = 'LevelDisplayName'\n    'ProcessID' = 'ProcessId'\n    'Source' = 'ProviderName'\n}\n\nfunction Get-AuditFieldExtraction {\n    param(\n        [string]$LogName = 'Security',\n        [int]$MaxEvents = 1000,\n        [string]$SortField = 'Timestamp'\n    )\n    \n    $Events = Get-WinEvent -LogName $LogName -MaxEvents $MaxEvents -ErrorAction SilentlyContinue\n    \n    # Extract specified fields\n    $ExtractedData = $Events | Select-Object @{\n        Name = 'Timestamp'\n        Expression = { $_.TimeCreated }\n    }, @{\n        Name = 'UserID'\n        Expression = { $_.UserId }\n    }, @{\n        Name = 'EventID'\n        Expression = { $_.Id }\n    }, @{\n        Name = 'Computer'\n        Expression = { $_.MachineName }\n    }, @{\n        Name = 'EventType'\n        Expression = { $_.LevelDisplayName }\n    }, @{\n        Name = 'Message'\n        Expression = { $_.Message }\n    }\n    \n    # Automatic sorting by specified field\n    $SortedData = $ExtractedData | Sort-Object -Property $SortField\n    \n    return $SortedData\n}\n\nfunction Process-AuditFieldsByType {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$FieldName,\n        [string]$FieldValue\n    )\n    \n    $LogName = 'Security'\n    \n    switch($FieldName) {\n        'EventID' {\n            Get-WinEvent -FilterHashtable @{\n                LogName = $LogName\n                Id = $FieldValue\n            } -MaxEvents 5000 -ErrorAction SilentlyContinue |\n            Group-Object -Property {$_.TimeCreated.Date} -NoElement\n        }\n        'Level' {\n            Get-WinEvent -FilterHashtable @{\n                LogName = $LogName\n            } -MaxEvents 10000 -ErrorAction SilentlyContinue |\n            Where-Object { $_.LevelDisplayName -eq $FieldValue } |\n            Group-Object -Property LevelDisplayName -NoElement\n        }\n        'Computer' {\n            Get-WinEvent -FilterHashtable @{\n                LogName = $LogName\n            } -MaxEvents 10000 -ErrorAction SilentlyContinue |\n            Where-Object { $_.MachineName -eq $FieldValue } |\n            Group-Object -Property MachineName | Select-Object Name, Count\n        }\n        'User' {\n            Get-WinEvent -FilterHashtable @{\n                LogName = $LogName\n            } -MaxEvents 10000 -ErrorAction SilentlyContinue |\n            Where-Object { $_.UserId -like \"*$FieldValue*\" } |\n            Group-Object -Property UserId | Select-Object Name, Count\n        }\n    }\n}\n\nfunction Export-ProcessedAuditFields {\n    param(\n        [string]$OutputPath = 'C:\\\\AuditProcessing',\n        [string]$Format = 'CSV'\n    )\n    \n    if (-not (Test-Path $OutputPath)) {\n        New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null\n    }\n    \n    $ProcessedData = Get-AuditFieldExtraction -MaxEvents 100000\n    $Timestamp = Get-Date -Format 'yyyy-MM-dd_HHmmss'\n    $OutputFile = Join-Path $OutputPath \"au7_1_processed_$Timestamp.$($Format.ToLower())\"\n    \n    if ($Format -eq 'CSV') {\n        $ProcessedData | Export-Csv -Path $OutputFile -NoTypeInformation\n    } elseif ($Format -eq 'JSON') {\n        $ProcessedData | ConvertTo-Json | Out-File -Path $OutputFile\n    } elseif ($Format -eq 'XML') {\n        $ProcessedData | Export-Clixml -Path $OutputFile\n    }\n    \n    Write-Host \"Processed audit fields exported to: $OutputFile\"\n    return $OutputFile\n}"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "validation_status": "NIST SP 800-53 Rev 5 verified",
      "stig_applicable": true,
      "stig_id": "RHEL-08-030371"
    },
    "stig_id": "RHEL-08-030371",
    "cac_metadata": {
      "implementation_type": "auditd_field_extraction",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "available",
      "cac_planned": true,
      "implementation_guidance": "Configure auditd rules to capture specific audit fields (auid, uid, syscall, success, exe, name). Implement ausearch with field-based queries for automatic record processing. Deploy tools for structured field extraction and indexing. Create automated processing pipelines that sort and organize records by predefined fields.",
      "rule_ids": [
        "RHEL-08-030371"
      ]
    },
    "ai_guidance": "**AU-7.1: Automatic Processing**\n\nCRITICAL REQUIREMENT: Provide capability to process audit records for events of interest based on organization-defined criteria.\n\n**PREREQUISITE:** AU-6(1) SIEM deployment\n\n**IMPLEMENTATION APPROACH:**\n\n**1. AUTOMATED LOG PROCESSING**\n\nLogstash pipelines for parsing, filtering, and enriching audit logs with GeoIP, threat intelligence, and field extraction.\n\n**2. WAZUH DECODERS**\n\nCustom decoders in /var/ossec/etc/decoders/local_decoder.xml to extract structured data from audit logs.\n\n**3. EVENT FILTERING**\n\nConfigure filters to process only events matching defined criteria (e.g., privilege escalations, authentication failures, sensitive file access).\n\n**4. AUTOMATED ENRICHMENT**\n\nAdd context to audit records: user department, asset criticality, threat intelligence matches, geographic location.\n\n**RELATED CONTROLS:** AU-6(1), AU-7, AU-7.2"
  },
  {
    "control_id": "au-7.2",
    "control_name": "Automatic Sort and Search",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "The system provides the capability to automatically sort and search audit records for events of interest based on [Assignment: organization-defined audit fields and search criteria].",
    "parent_control": "AU-7",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "This enhancement extends AU-7.1 by requiring the system to not only process and sort audit records automatically, but also to provide search capabilities. The system must allow automated queries across audit records using organization-defined search criteria, enabling rapid location and retrieval of specific events without manual log review. This capability must support the organization's defined search parameters and audit fields.",
    "example_implementation": "Implement Elasticsearch or Splunk with automated indexing of audit fields. Configure pre-built search dashboards for common queries (failed logins, privilege escalation, file modifications). Deploy Kibana visualizations that automatically display sorted audit data by timestamp, user, or event type. Create saved searches that run automatically on schedules and trigger alerts based on defined criteria. Use auditd with ELK Stack for real-time searchable audit logs.",
    "non_technical_guidance": "To implement AU-7(2) automatic sort and search capability:\n1. Determine what types of searches your security team needs to perform regularly (e.g., find all events for a specific user, find all failed attempts, find events from a specific time period).\n2. Define the audit fields and search criteria that will be used for automatic searching.\n3. Configure your audit management system to maintain searchable indexes of audit records based on these criteria.\n4. Set up automated search functions that can retrieve matching records without requiring manual log parsing.\n5. Establish templates or quick-search options for common audit queries so that analysts can quickly find events of interest.\n6. Test the search capability to ensure results are accurate and complete.\n7. Train security staff to use the automated search features effectively.\n8. Regularly review search performance and update criteria based on evolving security needs.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-2",
      "AU-3",
      "AU-6",
      "AU-7",
      "AU-7.1",
      "AU-12"
    ],
    "supplemental_guidance": "Automatic sort and search capabilities enable rapid investigation of security events without manual log examination. Organizations should define search criteria that support their incident response procedures and compliance requirements. Search capabilities must function reliably on large volumes of audit data without performance degradation. The system should support both structured queries (field-based searches) and free-text searches when appropriate. Search results must be accurate and complete, returning all matching records within specified parameters. Organizations should implement role-based access controls on search capabilities to ensure that only authorized personnel can search for sensitive audit information. Regular testing and performance monitoring ensure that search capabilities remain effective as audit log volumes grow.",
    "implementation_scripts": {
      "linux": {
        "elasticsearch_index_configuration": "#!/bin/bash\n# AU-7.2 Elasticsearch Configuration for Automatic Sort and Search\n# This configuration enables rapid searchable indexing of audit records\n\n# Install Elasticsearch and Auditbeat\nsudo dnf install -y elasticsearch auditbeat\n\n# Configure Auditbeat to forward to Elasticsearch\ncat > /etc/auditbeat/auditbeat.yml << 'EOF'\nauditbeat.modules:\n- module: file_integrity\n  paths:\n    - /etc\n    - /usr/bin\n    - /usr/sbin\n  hash_types: [sha256]\n  scan_at_startup: true\n\nauditbeat.metrics:\n  enabled: true\n\noutput.elasticsearch:\n  hosts: [\"localhost:9200\"]\n  index: \"auditbeat-%{+yyyy.MM.dd}\"\n  bulk_max_size: 100\n\nlogging.level: info\nlogging.to_files: true\nlogging.files:\n  path: /var/log/auditbeat\nEOF\n\n# Start services\nsudo systemctl start auditbeat\nsudo systemctl enable auditbeat\n\necho \"Elasticsearch indexing configured for AU-7.2\"",
        "kibana_search_dashboard": "#!/bin/bash\n# Create Kibana dashboards and saved searches for AU-7.2\n# These enable automatic sort and search of audit records\n\nES_HOST=\"localhost:9200\"\nKIBANA_HOST=\"localhost:5601\"\n\n# Create index pattern\ncurl -X POST \"${ES_HOST}/_template/auditbeat-template\" -H 'Content-Type: application/json' -d '\n{\n  \"index_patterns\": [\"auditbeat-*\"],\n  \"settings\": {\n    \"number_of_shards\": 1,\n    \"number_of_replicas\": 0\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"timestamp\": {\"type\": \"date\"},\n      \"uid\": {\"type\": \"keyword\"},\n      \"auid\": {\"type\": \"keyword\"},\n      \"syscall\": {\"type\": \"keyword\"},\n      \"success\": {\"type\": \"keyword\"},\n      \"exe\": {\"type\": \"text\"},\n      \"hostname\": {\"type\": \"keyword\"},\n      \"process.pid\": {\"type\": \"integer\"}\n    }\n  }\n}'\n\necho \"Elasticsearch index template created\"\n\n# Create Kibana saved searches for common queries\necho \"Creating Kibana saved searches for common audit queries...\"\n\n# Saved search: Failed login attempts\ncurl -X POST \"${KIBANA_HOST}/api/saved_objects/search/failed_logins\" \\\n  -H 'Content-Type: application/json' \\\n  -H 'kbn-xsrf: true' \\\n  -d '{\n    \"attributes\": {\n      \"title\": \"Failed Login Attempts\",\n      \"description\": \"Shows all failed authentication attempts\",\n      \"kibanaSavedObjectMeta\": {\n        \"searchSourceJSON\": \"{\\\"index\\\":\\\"auditbeat-*\\\",\\\"query\\\":{\\\"match\\\":{\\\"event.outcome\\\":\\\"failure\\\"}}}\"\n      }\n    }\n  }'\n\n# Saved search: Privilege escalation events\ncurl -X POST \"${KIBANA_HOST}/api/saved_objects/search/privilege_escalation\" \\\n  -H 'Content-Type: application/json' \\\n  -H 'kbn-xsrf: true' \\\n  -d '{\n    \"attributes\": {\n      \"title\": \"Privilege Escalation Events\",\n      \"description\": \"Shows uid=0 and setuid/setgid events\",\n      \"kibanaSavedObjectMeta\": {\n        \"searchSourceJSON\": \"{\\\"index\\\":\\\"auditbeat-*\\\",\\\"query\\\":{\\\"bool\\\":{\\\"should\\\":[{\\\"match\\\":{\\\"user.id\\\":\\\"0\\\"}},{\\\"match\\\":{\\\"audit.syscall\\\":\\\"setuid\\\"}}]}}}\"\n      }\n    }\n  }'\n\n# Saved search: File modifications\ncurl -X POST \"${KIBANA_HOST}/api/saved_objects/search/file_modifications\" \\\n  -H 'Content-Type: application/json' \\\n  -H 'kbn-xsrf: true' \\\n  -d '{\n    \"attributes\": {\n      \"title\": \"File Modifications\",\n      \"description\": \"Shows all file write and modification events\",\n      \"kibanaSavedObjectMeta\": {\n        \"searchSourceJSON\": \"{\\\"index\\\":\\\"auditbeat-*\\\",\\\"query\\\":{\\\"match\\\":{\\\"file.change\\\":\\\"true\\\"}}}\"\n      }\n    }\n  }'\n\necho \"Kibana saved searches created\"\necho \"Access Kibana at: http://${KIBANA_HOST}\"",
        "splunk_index_configuration": "#!/bin/bash\n# AU-7.2 Splunk Configuration for Automatic Sort and Search\n# Configure Splunk to index audit records for searchable access\n\n# Create Splunk index for audit data\n/opt/splunk/bin/splunk add index audit_index -auth admin:changeme \\\n    -maxKBps 50000 \\\n    -tstatsHomePath default \\\n    -coldToFrozenDir \\$SPLUNK_HOME/var/lib/splunk/audit_index/frozendb \\\n    -maxConcurrentOptimizes 4 \\\n    -searchable true\n\n# Configure inputs.conf for audit data ingestion\ncat > /opt/splunk/etc/apps/search/local/inputs.conf << 'EOF'\n[monitor:///var/log/audit/audit.log]\ndisabled = 0\nindex = audit_index\nsourcetype = linux:audit\ntimestamp_fields = msg=audit\n\n[script:///opt/splunk/etc/apps/audit_app/bin/ausearch_stream.sh]\ninterval = 60\nsourcetype = linux:audit\nindex = audit_index\nEOF\n\n# Create saved searches in Splunk\necho \"Creating Splunk saved searches for AU-7.2...\"\n\n/opt/splunk/bin/splunk add saved-search \"AU-7.2 Failed Logins\" \\\n    \"search=sourcetype=linux:audit success=no\" \\\n    -auth admin:changeme\n\n/opt/splunk/bin/splunk add saved-search \"AU-7.2 Privilege Changes\" \\\n    \"search=sourcetype=linux:audit (uid=0 OR syscall=setuid OR syscall=setgid)\" \\\n    -auth admin:changeme\n\n/opt/splunk/bin/splunk add saved-search \"AU-7.2 File Modifications\" \\\n    \"search=sourcetype=linux:audit (syscall=open OR syscall=write) type=SYSCALL\" \\\n    -auth admin:changeme\n\necho \"Splunk index and saved searches configured for AU-7.2\""
      },
      "windows": {
        "splunk_windows_search": "$SplunkServer = \"localhost:8000\"\n$SplunkAuth = @{\n    Username = \"admin\"\n    Password = \"changeme\"\n}\n\nfunction Create-SplunkSearchQuery {\n    param(\n        [string]$QueryName,\n        [string]$SearchCriteria,\n        [string]$Description\n    )\n    \n    $Uri = \"http://${SplunkServer}/services/saved/searches\"\n    \n    $Body = @{\n        name = $QueryName\n        search = $SearchCriteria\n        description = $Description\n        is_scheduled = 1\n        cron_schedule = \"0 * * * *\"\n    } | ConvertTo-Json\n    \n    $Response = Invoke-RestMethod -Uri $Uri -Method Post -Body $Body -Credential (New-Object PSCredential $SplunkAuth.Username, (ConvertTo-SecureString $SplunkAuth.Password -AsPlainText -Force))\n    \n    return $Response\n}\n\nfunction Search-AuditRecordsAutomatically {\n    param(\n        [string]$SearchField,\n        [string]$SearchValue,\n        [int]$MaxResults = 10000\n    )\n    \n    $Uri = \"http://${SplunkServer}/services/search/jobs\"\n    \n    switch($SearchField) {\n        'EventID' {\n            $Search = \"sourcetype=WinEventLog:Security EventCode=$SearchValue | sort - _time\"\n        }\n        'User' {\n            $Search = \"sourcetype=WinEventLog:Security User=$SearchValue | sort - _time\"\n        }\n        'Computer' {\n            $Search = \"sourcetype=WinEventLog:Security ComputerName=$SearchValue | sort - _time\"\n        }\n        'Level' {\n            $Search = \"sourcetype=WinEventLog:Security EventLevel=$SearchValue | sort - _time\"\n        }\n        default {\n            $Search = \"sourcetype=WinEventLog:Security | sort - _time | head $MaxResults\"\n        }\n    }\n    \n    $Body = @{\n        search = $Search\n        output_mode = \"json\"\n    } | ConvertTo-Json\n    \n    try {\n        $Response = Invoke-RestMethod -Uri $Uri -Method Post -Body $Body -Credential (New-Object PSCredential $SplunkAuth.Username, (ConvertTo-SecureString $SplunkAuth.Password -AsPlainText -Force))\n        return $Response\n    } catch {\n        Write-Error \"Search failed: $_\"\n        return $null\n    }\n}\n\n# Create common saved searches\nCreate-SplunkSearchQuery -QueryName \"AU-7.2 Failed Logins\" \\\n    -SearchCriteria \"sourcetype=WinEventLog:Security EventCode=4625 | stats count by User, Computer | sort - count\" \\\n    -Description \"Automatic search for failed login attempts\"\n\nCreate-SplunkSearchQuery -QueryName \"AU-7.2 Privilege Escalation\" \\\n    -SearchCriteria \"sourcetype=WinEventLog:Security (EventCode=4672 OR EventCode=4985) | stats count by User, Computer | sort - count\" \\\n    -Description \"Automatic search for privilege escalation events\"\n\nCreate-SplunkSearchQuery -QueryName \"AU-7.2 Account Modifications\" \\\n    -SearchCriteria \"sourcetype=WinEventLog:Security (EventCode=4722 OR EventCode=4723 OR EventCode=4724) | stats count by TargetUserName, User | sort - count\" \\\n    -Description \"Automatic search for account modification events\"\n\nWrite-Host \"Splunk saved searches created for AU-7.2\""
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "validation_status": "NIST SP 800-53 Rev 5 verified",
      "stig_applicable": true,
      "stig_id": "RHEL-08-030372"
    },
    "stig_id": "RHEL-08-030372",
    "cac_metadata": {
      "implementation_type": "elasticsearch_splunk_search",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "available",
      "cac_planned": true,
      "implementation_guidance": "Deploy Elasticsearch or Splunk for searchable audit log indexing. Configure Kibana or Splunk dashboards with pre-built saved searches. Implement automated indexing that sorts records by timestamp, user, event type, and other organization-defined criteria. Create alert rules that automatically search for and respond to suspicious patterns.",
      "rule_ids": [
        "RHEL-08-030372"
      ]
    },
    "ai_guidance": "**AU-7.2: Automatic Sort and Search**\n\nCRITICAL REQUIREMENT: Provide capability to sort and search audit records for events of interest without altering the original audit records.\n\n**IMPLEMENTATION APPROACH:**\n\n**1. SIEM SEARCH CAPABILITIES**\n\n- **Wazuh:** Built-in search via dashboard and API\n- **ELK:** Kibana Discover with Lucene query syntax\n- **Splunk:** Search Processing Language (SPL)\n\n**2. INDEXED SEARCH**\n\nElasticsearch indexing for fast full-text search across millions of audit records.\n\n**3. SAVED SEARCHES**\n\nCreate saved searches for common queries:\n- Failed authentications by user\n- Privilege escalations in last 24h\n- File access to /etc/shadow\n- Commands executed as root\n\n**4. SEARCH API**\n\nREST API endpoints for programmatic search:\n```bash\ncurl -X POST \"http://localhost:9200/audit-logs-*/_search\"   -H 'Content-Type: application/json'   -d '{\"query\":{\"match\":{\"user\":\"jsmith\"}}}'\n```\n\n**RELATED CONTROLS:** AU-6(1), AU-7, AU-7.1"
  },
  {
    "control_id": "au-8",
    "control_name": "Time Stamps",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030740",
    "official_text": "The organization: a) Uses internal system clocks to generate time stamps for audit records; and b) Records time stamps for audit records that meet [Assignment: organization-defined granularity of time measurement] and that use Coordinated Universal Time (UTC), have a fixed local time offset from UTC, or that include the local time offset as part of the time stamp.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Systems must generate and record accurate timestamps for all audit events. These timestamps must be precise enough to correlate events (granularity) and use a consistent time standard. This is essential for security investigations, forensic analysis, and maintaining system accountability. Without accurate timestamps, it becomes impossible to determine when events occurred or establish a reliable audit trail.",
    "example_implementation": "Configure all systems to use chrony (RHEL/CentOS) or timesyncd (Ubuntu/Debian) for automatic time synchronization. Set the granularity to milliseconds or finer for security-critical systems. Ensure all audit logs include timestamps in ISO 8601 format with timezone information.",
    "non_technical_guidance": "Implement organizational procedures to: 1) Select authoritative time sources approved by your organization (such as NIST time servers or GPS); 2) Configure all systems to synchronize with these sources; 3) Define the required time precision (granularity) for your organization; 4) Regularly verify that system clocks remain synchronized (at least daily); 5) Document the time standard used organization-wide (UTC or local with offset); 6) Monitor and alert on time synchronization failures.",
    "is_technical": true,
    "ai_guidance": "**AU-8: Time Stamps**\n\nCRITICAL REQUIREMENT: Generate time stamps for audit records that can be mapped to Coordinated Universal Time (UTC) or Greenwich Mean Time (GMT).\n\n**IMPLEMENTATION APPROACH:**\n\n**1. AUDITD TIMESTAMP CONFIGURATION**\n\nVerify auditd uses system time (which should be UTC):\n```bash\nausearch -ts recent | head -5\n# Timestamps should be in epoch format (seconds since 1970-01-01 UTC)\n```\n\n**2. SYSTEM TIMEZONE CONFIGURATION**\n\nSet system to UTC:\n```bash\ntimedatectl set-timezone UTC\ntimedatectl status\n```\n\n**3. LOG TIMESTAMP FORMATS**\n\n- auditd: Epoch timestamps (convert with: date -d @<epoch>)\n- syslog: ISO 8601 format recommended\n- Application logs: Enforce UTC timestamps\n\n**4. TIMESTAMP VALIDATION**\n\nCreate script to verify all systems have consistent timestamps:\n```bash\n#!/bin/bash\nfor HOST in $(cat /opt/monitoring/hosts.txt); do\n    REMOTE_TIME=$(ssh $HOST 'date +%s')\n    LOCAL_TIME=$(date +%s)\n    DIFF=$((REMOTE_TIME - LOCAL_TIME))\n    if [ ${DIFF#-} -gt 10 ]; then\n        echo \"WARNING: $HOST time differs by $DIFF seconds\"\n    fi\ndone\n```\n\n**RELATED CONTROLS:** AU-8.1, AU-12",
    "enhancements": [
      {
        "id": "AU-8.1",
        "title": "Synchronization with Authoritative Time Source",
        "official_text": "The information system compares the internal information system clocks at [Assignment: organization-defined frequency] with [Assignment: organization-defined authoritative time source] and synchronizes the internal system clock to the authoritative time source when the time difference is greater than [Assignment: organization-defined time period]."
      },
      {
        "id": "AU-8.2",
        "title": "Secondary Authoritative Time Source",
        "official_text": "The information system identifies a secondary authoritative time source that is in a geographically separated location and implements a mechanism to automatically synchronize the internal system clocks from the secondary authoritative time source if the primary authoritative time source is unavailable."
      }
    ],
    "related_controls": [
      "AU-3",
      "AU-12",
      "SC-45"
    ],
    "supplemental_guidance": "Time synchronization is critical to system security as it underpins identification, authentication, non-repudiation, and access control functions. Granularity of time measurements refers to the degree of synchronization between system clocks and reference clocks - systems may require synchronization within hundreds of milliseconds or tens of milliseconds depending on organizational requirements. Organizations should consider different granularities for different components based on the criticality of functions dependent on accurate time.",
    "implementation_scripts": {
      "linux": {
        "bash_rhel_chrony_au8": "#!/bin/bash\n# RHEL 8 AU-8 Compliance: Install and Configure Chrony\nset -e\n\n# Install chrony if not present\nif ! command -v chronyd &> /dev/null; then\n    yum install -y chrony\nfi\n\n# Backup original configuration\ncp /etc/chrony.conf /etc/chrony.conf.backup.$(date +%s)\n\n# Configure chrony with authorized NTP servers (NIST/USNO example)\ncat > /etc/chrony.conf << 'EOF'\n# NIST Time Servers (replace with your organization's approved servers)\nserver time.nist.gov iburst maxpoll 16\nserver time-a-g.nist.gov iburst maxpoll 16\nserver time-b-g.nist.gov iburst maxpoll 16\n\n# Allow local network time sync\nallow 127.0.0.1\n\n# Synchronization statistics\nlogdir /var/log/chrony\ndriftfile /var/lib/chrony/drift\n\n# Specify chronyd to operate in client-only mode\nstratumweight 0\n\n# Disable chrony's management interface on the network\nbindcmdaddress 127.0.0.1\nbindcmdaddress ::1\nEOF\n\n# Start and enable chrony service\nsystemctl enable chronyd\nsystemctl start chronyd\n\n# Verify synchronization (may take up to maxpoll interval)\necho \"Waiting for time synchronization...\"\nsleep 5\ntimedatectl status\n\n# Verify chrony sources\nchronyc sources -v\n\n# Log compliance check\necho \"[$(date -u +%Y-%m-%dT%H:%M:%SZ)] AU-8 Configuration Applied - Chrony configured with authorized servers and maxpoll 16\"",
        "ansible_rhel_chrony_au8": "---\n- name: AU-8 Compliance - Time Synchronization with Chrony\n  hosts: all\n  become: yes\n  tasks:\n    - name: Install chrony package\n      yum:\n        name: chrony\n        state: present\n\n    - name: Backup original chrony.conf\n      copy:\n        src: /etc/chrony.conf\n        dest: /etc/chrony.conf.backup\n        backup: yes\n      ignore_errors: true\n\n    - name: Configure chrony with authorized NTP servers\n      copy:\n        content: |\n          # NIST Time Servers (organization-approved)\n          server time.nist.gov iburst maxpoll 16\n          server time-a-g.nist.gov iburst maxpoll 16\n          server time-b-g.nist.gov iburst maxpoll 16\n          allow 127.0.0.1\n          logdir /var/log/chrony\n          driftfile /var/lib/chrony/drift\n          stratumweight 0\n          bindcmdaddress 127.0.0.1\n          bindcmdaddress ::1\n        dest: /etc/chrony.conf\n        owner: root\n        group: root\n        mode: '0644'\n\n    - name: Enable and start chronyd service\n      systemd:\n        name: chronyd\n        enabled: yes\n        state: started\n        daemon_reload: yes\n\n    - name: Verify time synchronization status\n      command: timedatectl status\n      register: timedatectl_output\n      changed_when: false\n\n    - name: Display synchronization status\n      debug:\n        msg: \"{{ timedatectl_output.stdout }}\"\n\n    - name: Verify chrony sources\n      command: chronyc sources -v\n      register: chronyc_output\n      changed_when: false\n\n    - name: Display chrony sources\n      debug:\n        msg: \"{{ chronyc_output.stdout }}\""
      },
      "windows": {
        "powershell_w32tm_au8": "# PowerShell AU-8 Compliance: Configure Windows Time Service (W32Time)\n# Requires Administrator privileges\n\n# Get current W32Time configuration\nWrite-Host \"Current W32Time Configuration:\"\nw32tm /query /configuration\n\n# Configure Windows Time Service with authorized NTP servers\n# NIST Time Servers: time.nist.gov, time-a-g.nist.gov, time-b-g.nist.gov\n$NTPServers = \"time.nist.gov,0x9 time-a-g.nist.gov,0x9 time-b-g.nist.gov,0x9\"\n\nWrite-Host \"Configuring W32Time with authorized NTP servers...\"\nw32tm /config /manualpeerlist:$NTPServers /syncfromflags:manual /reliable:yes /update\n\n# Set synchronization interval to ensure sync within 24 hours\n# MaxPollInterval = 16 (2^16 seconds ~= 18 hours)\nreg add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\Config\" /v MaxPollInterval /t REG_DWORD /d 16 /f\n\n# Set minimum poll interval\n# MinPollInterval = 6 (2^6 seconds = 64 seconds)\nreg add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\Config\" /v MinPollInterval /t REG_DWORD /d 6 /f\n\n# Restart W32Time service\nWrite-Host \"Restarting W32Time service...\"\nStop-Service -Name W32Time -Force\nStart-Service -Name W32Time\n\n# Wait for synchronization\nStart-Sleep -Seconds 5\n\n# Verify synchronization status\nWrite-Host \"Verification - Current Time Status:\"\nw32tm /query /status\n\n# Check time synchronization with peers\nWrite-Host \"Configured NTP Peers:\"\nw32tm /query /peers\n\n# Create audit log entry\n$AuditMessage = \"[$(Get-Date -Format 'u')] AU-8 Compliance Applied - W32Time synchronized with authorized NIST servers\"\nWrite-EventLog -LogName \"Application\" -Source \"System\" -EventId 1000 -Message $AuditMessage -EntryType Information\n\nWrite-Host \"AU-8 Compliance Configuration Complete\"",
        "ansible_windows_w32tm_au8": "---\n- name: AU-8 Compliance - Windows Time Service Configuration\n  hosts: windows\n  become: yes\n  tasks:\n    - name: Get current W32Time configuration\n      ansible.windows.win_shell: w32tm /query /configuration\n      register: w32tm_current_config\n      changed_when: false\n\n    - name: Display current W32Time configuration\n      debug:\n        msg: \"{{ w32tm_current_config.stdout_lines }}\"\n\n    - name: Configure W32Time with authorized NTP servers (NIST)\n      ansible.windows.win_shell: w32tm /config /manualpeerlist:\"time.nist.gov,0x9 time-a-g.nist.gov,0x9 time-b-g.nist.gov,0x9\" /syncfromflags:manual /reliable:yes /update\n      register: w32tm_config_result\n      changed_when: \"'The command completed successfully' in w32tm_config_result.stdout\"\n\n    - name: Set MaxPollInterval registry (RHEL-08-030740 equivalent for Windows)\n      ansible.windows.win_reg_edit:\n        path: HKLM:\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\Config\n        name: MaxPollInterval\n        data: 16\n        type: dword\n\n    - name: Set MinPollInterval registry\n      ansible.windows.win_reg_edit:\n        path: HKLM:\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\Config\n        name: MinPollInterval\n        data: 6\n        type: dword\n\n    - name: Restart W32Time service\n      ansible.windows.win_service:\n        name: W32Time\n        state: restarted\n\n    - name: Wait for synchronization\n      ansible.windows.win_shell: Start-Sleep -Seconds 5\n\n    - name: Verify time synchronization status\n      ansible.windows.win_shell: w32tm /query /status\n      register: w32tm_status\n      changed_when: false\n\n    - name: Display W32Time status\n      debug:\n        msg: \"{{ w32tm_status.stdout_lines }}\"\n\n    - name: Display configured NTP peers\n      ansible.windows.win_shell: w32tm /query /peers\n      register: w32tm_peers\n      changed_when: false\n\n    - name: Show NTP peers\n      debug:\n        msg: \"{{ w32tm_peers.stdout_lines }}\""
      }
    },
    "metadata": {
      "status": "fully_implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "validation_status": "NIST SP 800-53 Rev 5 verified",
      "stig_id": "RHEL-08-030740"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "cac_status": "verified",
      "cac_planned": true,
      "implementation_guidance": "ComplianceAsCode provides multiple rules: service_chronyd_or_ntpd_enabled, chronyd_client_only, chronyd_no_chronyc_network, chronyd_or_ntpd_set_maxpoll. These rules directly support AU-8 compliance on RHEL/CentOS systems.",
      "related_cac_rules": [
        "service_chronyd_or_ntpd_enabled",
        "chronyd_client_only",
        "chronyd_no_chronyc_network",
        "chronyd_or_ntpd_set_maxpoll"
      ]
    }
  },
  {
    "control_id": "au-8.1",
    "control_name": "Synchronization with Authoritative Time Source",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030740",
    "parent_control": "AU-8",
    "official_text": "The information system compares the internal information system clocks at [Assignment: organization-defined frequency] with [Assignment: organization-defined authoritative time source] and synchronizes the internal system clock to the authoritative time source when the time difference is greater than [Assignment: organization-defined time period].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Systems must actively synchronize their clocks with an authorized time source at regular intervals. This enhancement requires not just generating timestamps, but ensuring those timestamps are accurate by comparing against a trusted external time source. When time drift is detected (the system time is significantly different from the authoritative source), the system must automatically correct itself. This is critical for organizations that depend on precise event correlation across multiple systems.",
    "example_implementation": "Deploy chrony with maxpoll set to 16 (meaning synchronization occurs at least every 18 hours). Configure chronyd to sync with NIST time servers. Set the synchronization threshold to 1 second - if clock drift exceeds this, automatic correction occurs. Configure monitoring to alert when sync has not occurred within 24 hours.",
    "non_technical_guidance": "Establish organizational policy specifying: 1) The frequency of time synchronization (e.g., hourly, every 4 hours); 2) The authorized time sources (e.g., NIST servers); 3) The maximum acceptable time difference (time period) before automatic correction (e.g., 1 second); 4) The maximum acceptable time drift threshold (e.g., systems lose no more than X seconds per day); 5) Escalation procedures when synchronization fails. Document these requirements in your system security plan.",
    "is_technical": true,
    "ai_guidance": "**AU-8.1: Synchronization with Authoritative Time Source**\n\nCRITICAL REQUIREMENT: Synchronize internal system clocks with authoritative time source.\n\n**IMPLEMENTATION APPROACH:**\n\n**1. CHRONY CONFIGURATION (RECOMMENDED)**\n\nInstall and configure:\n```bash\napt install chrony -y\nvim /etc/chrony/chrony.conf\n```\n\nAdd NTP servers:\n```\nserver 0.pool.ntp.org iburst\nserver 1.pool.ntp.org iburst\nserver 2.pool.ntp.org iburst\nserver 3.pool.ntp.org iburst\n```\n\nEnable and verify:\n```bash\nsystemctl enable chronyd\nsystemctl start chronyd\nchronyc tracking\nchronyc sources -v\n```\n\n**2. NTPD ALTERNATIVE**\n\n```bash\napt install ntp -y\nvim /etc/ntp.conf\n```\n\nAdd:\n```\nserver 0.pool.ntp.org\nserver 1.pool.ntp.org\nrestrict default kod nomodify notrap nopeer noquery\n```\n\n**3. WINDOWS NTP CONFIGURATION**\n\n```powershell\nw32tm /config /manualpeerlist:\"0.pool.ntp.org,1.pool.ntp.org\" /syncfromflags:manual /reliable:YES /update\nnet stop w32time && net start w32time\nw32tm /query /status\n```\n\n**4. MONITORING NTP SYNC**\n\nCreate /usr/local/bin/check_ntp_sync.sh:\n```bash\n#!/bin/bash\nif systemctl is-active chronyd &>/dev/null; then\n    SYNC_STATUS=$(chronyc tracking | grep \"Leap status\" | awk '{print $4}')\n    if [ \"$SYNC_STATUS\" != \"Normal\" ]; then\n        echo \"NTP sync issue\" | mail -s \"NTP Alert\" security@company.com\n    fi\nfi\n```\n\n**RELATED CONTROLS:** AU-8, AU-12",
    "enhancements": [],
    "related_controls": [
      "AU-8",
      "SC-45(1)"
    ],
    "supplemental_guidance": "RHEL-08-030740 STIG requirement: chrony must be configured with maxpoll value of 16 or less (corresponding to 2^16 seconds, approximately 18.2 hours) to ensure clocks synchronize within the required 24-hour window. The iburst option enables faster initial synchronization. Using DoD-approved time sources (NIST/USNO) ensures time source integrity. Organizations should consider network-isolated systems that may not have regular access to authoritative sources - such systems should employ secondary mechanisms like GPS receivers or internal time servers.",
    "implementation_scripts": {
      "linux": {
        "bash_rhel_au81": "#!/bin/bash\n# RHEL 8 AU-8.1 Compliance: Synchronization with Authoritative Time Source\nset -e\n\necho \"[$(date -u +%Y-%m-%dT%H:%M:%SZ)] Starting AU-8.1 Synchronization Configuration\"\n\n# Define organizational parameters\nSYNC_FREQUENCY=\"hourly\"\nAUTHORITATIVE_SOURCE=\"time.nist.gov\"\nTIME_THRESHOLD=\"1\"\nMAXPOLL=\"16\"\n\n# Verify chronyd is installed and running\nif ! systemctl is-active --quiet chronyd; then\n    echo \"Installing and starting chronyd...\"\n    yum install -y chrony\n    systemctl start chronyd\nfi\n\n# Configure chrony with strict synchronization settings\ncat > /etc/chrony.conf << EOF\n# AU-8.1 Compliance Configuration\nserver $AUTHORITATIVE_SOURCE iburst maxpoll $MAXPOLL\nserver time-a-g.nist.gov iburst maxpoll $MAXPOLL\nserver time-b-g.nist.gov iburst maxpoll $MAXPOLL\nallow 127.0.0.1\nlogdir /var/log/chrony\nlog measurements statistics tracking\ndriftfile /var/lib/chrony/drift\nstratumweight 0\nbindcmdaddress 127.0.0.1\nbindcmdaddress ::1\nEOF\n\n# Reload chrony configuration\nsystemctl reload chronyd\n\necho \"Waiting for initial synchronization...\"\nfor i in {1..30}; do\n    SYNC_STATUS=$(chronyc tracking | grep \"System time\" || echo \"\")\n    if [[ $SYNC_STATUS == *\"0.000000000\"* ]] || [ $i -eq 30 ]; then\n        break\n    fi\n    sleep 1\ndone\n\necho \"=== Synchronization Status ===\"\ntimedatectl status\necho \"=== Chrony Tracking Information ===\"\nchronyc tracking\necho \"=== Chrony Sources ===\"\nchronyc sources -v\n\n# Validate STIG RHEL-08-030740 compliance\nMAXPOLL_VALUE=$(grep \"maxpoll\" /etc/chrony.conf | head -1 | awk '{print $NF}')\nif [ \"$MAXPOLL_VALUE\" -le 16 ]; then\n    echo \"[PASS] RHEL-08-030740: maxpoll is set to $MAXPOLL_VALUE (compliant)\"\nelse\n    echo \"[FAIL] RHEL-08-030740: maxpoll is $MAXPOLL_VALUE (must be <= 16)\"\nfi\n\necho \"[$(date -u +%Y-%m-%dT%H:%M:%SZ)] AU-8.1 Configuration Complete\""
      },
      "windows": {
        "powershell_w32tm_au81": "# PowerShell AU-8.1 Compliance: Synchronization with Authoritative Time Source\n\n$authoritative_sources = @(\"time.nist.gov\", \"time-a-g.nist.gov\", \"time-b-g.nist.gov\")\n$ntp_peers = $authoritative_sources -join \",0x9 \"\n$ntp_peers += \",0x9\"\n\nWrite-Host \"[$(Get-Date -u -Format 'o')] Configuring W32Time with authoritative sources\"\nw32tm /config /manualpeerlist:$ntp_peers /syncfromflags:manual /reliable:yes /update\n\nreg add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\Config\" /v MaxPollInterval /t REG_DWORD /d 16 /f\nreg add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\Config\" /v MinPollInterval /t REG_DWORD /d 6 /f\n\nStop-Service -Name W32Time -Force\nStart-Service -Name W32Time\n\nStart-Sleep -Seconds 10\n\nWrite-Host \"=== Time Synchronization Status ===\"\nw32tm /query /status\n\nWrite-Host \"=== Current NTP Configuration ===\"\nw32tm /query /configuration\n\nWrite-Host \"=== Configured NTP Peers ===\"\nw32tm /query /peers\n\n$au81_message = \"[$(Get-Date -u -Format 'o')] AU-8.1 Configuration Applied\"\nWrite-EventLog -LogName \"Application\" -Source \"System\" -EventId 1001 -Message $au81_message -EntryType Information"
      }
    },
    "metadata": {
      "status": "fully_implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "validation_status": "NIST SP 800-53 Rev 5 + RHEL STIG verified",
      "stig_id": "RHEL-08-030740"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode + NIST STIG",
      "cac_status": "verified",
      "cac_planned": true,
      "implementation_guidance": "ComplianceAsCode rule 'chronyd_or_ntpd_set_maxpoll' directly enforces AU-8.1 by ensuring maxpoll <= 16 per RHEL-08-030740 STIG requirement.",
      "stig_mapping": {
        "rule_id": "RHEL-08-030740",
        "severity": "Medium",
        "requirement": "RHEL 8 must securely compare internal clocks within 24 hours with authoritative time source"
      }
    }
  },
  {
    "control_id": "au-8.2",
    "control_name": "Secondary Authoritative Time Source",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030740",
    "parent_control": "AU-8",
    "official_text": "The information system identifies a secondary authoritative time source that is in a geographically separated location and implements a mechanism to automatically synchronize the internal system clocks from the secondary authoritative time source if the primary authoritative time source is unavailable.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "High-security systems cannot tolerate loss of time synchronization. This enhancement requires redundancy - if the primary time source becomes unavailable (due to network issues, server failure, or attack), systems must automatically fail over to a secondary time source. The secondary source must be geographically separated from the primary to ensure resilience against regional outages. This ensures continuous, accurate timekeeping even during failures.",
    "example_implementation": "Configure chrony with at least two NIST time servers from different geographic locations. For example: primary server in East (time.nist.gov), secondary server in West (time-a-g.nist.gov). Configure chrony to treat both as peers and automatically use available servers. Monitor synchronization sources and alert if only one source remains available.",
    "non_technical_guidance": "Develop and document organizational policy for AU-8.2 that includes: 1) Identification of two or more geographically separated authoritative time sources; 2) Definition of 'geographically separated' (e.g., different data centers, different states); 3) Procedures to verify secondary source availability; 4) Detection thresholds for when primary is unavailable; 5) Procedures to verify failover occurs automatically; 6) Frequency of failover testing (recommend quarterly); 7) Escalation procedures if both sources become unavailable.",
    "is_technical": true,
    "ai_guidance": "Implement secondary authoritative time source for backup when primary fails. On RHEL 8/9, configure chrony with multiple NTP servers in /etc/chrony.conf: `server 0.rhel.pool.ntp.org iburst`, `server 1.rhel.pool.ntp.org iburst`, `server tick.usno.navy.mil iburst` (USNO provides authoritative US time). Set pool directive for automatic failover: `pool pool.ntp.org iburst maxsources 4`. For air-gapped systems, deploy local NTP server synchronized to GPS receiver or atomic clock. On Windows Server, configure multiple time sources via Group Policy: Computer Configuration → Policies → Administrative Templates → System → Windows Time Service → Time Providers. Use timedatectl to verify synchronization: `timedatectl status | grep 'synchronized: yes'`. Monitor time drift with Prometheus node_exporter: `node_time_seconds - node_ntp_offset_seconds`. Implement alerts for sync loss: `chronyc sources` shows no reachable sources. Test failover: block primary NTP, verify switch to secondary within 5 minutes. Integrates with AU-8 (timestamps), AU-8.1 (synchronization).",
    "enhancements": [],
    "related_controls": [
      "AU-8",
      "AU-8.1",
      "SC-45(2)"
    ],
    "supplemental_guidance": "RHEL STIG RHEL-08-030740 baseline requires synchronization with at least one authoritative time source. AU-8.2 enhances this by adding redundancy. Geographically separated means physically distant locations (different data centers, regions, or continents) to protect against regional network outages. Organizations should periodically test failover mechanisms to ensure secondary sources are accessible and functional.",
    "implementation_scripts": {
      "linux": {
        "bash_rhel_au82": "#!/bin/bash\n# RHEL 8 AU-8.2 Compliance: Secondary Authoritative Time Source\nset -e\n\necho \"[$(date -u +%Y-%m-%dT%H:%M:%SZ)] Starting AU-8.2 Secondary Time Source Configuration\"\n\nPRIMARY_SOURCE=\"time.nist.gov\"\nSECONDARY_SOURCE=\"time-a-g.nist.gov\"\nTERTIARY_SOURCE=\"time-b-g.nist.gov\"\nMAXPOLL=\"16\"\n\nif ! systemctl is-active --quiet chronyd; then\n    yum install -y chrony\n    systemctl start chronyd\nfi\n\necho \"Configuring chrony with geographically separated time sources...\"\n\ncat > /etc/chrony.conf << EOF\n# AU-8.2 Compliance Configuration\nserver $PRIMARY_SOURCE iburst maxpoll $MAXPOLL\nserver $SECONDARY_SOURCE iburst maxpoll $MAXPOLL\nserver $TERTIARY_SOURCE iburst maxpoll $MAXPOLL\nstratumweight 0\ndriftfile /var/lib/chrony/drift\nlogdir /var/log/chrony\nlog measurements statistics tracking\nallow 127.0.0.1\nbindcmdaddress 127.0.0.1\nbindcmdaddress ::1\nleapsectz right/UTC\nEOF\n\nsystemctl reload chronyd\n\necho \"Waiting for synchronization with multiple sources...\"\nsleep 15\n\necho \"=== Chrony Source Status ===\"\nchronyc sources -v\n\nAVAILABLE_SOURCES=$(chronyc sources -v | grep -c \"^\\*\\|^+\\|^-\\|^?\" || true)\necho \"Available time sources: $AVAILABLE_SOURCES\"\n\nif [ \"$AVAILABLE_SOURCES\" -lt 2 ]; then\n    echo \"[WARNING] AU-8.2 requires minimum 2 geographically separated sources\"\nelse\n    echo \"[PASS] Multiple geographically separated time sources are available\"\nfi\n\necho \"=== Time Synchronization Status ===\"\ntimedatectl status\n\necho \"[$(date -u +%Y-%m-%dT%H:%M:%SZ)] AU-8.2 Configuration Complete\""
      },
      "windows": {
        "powershell_w32tm_au82": "# PowerShell AU-8.2 Compliance: Secondary Authoritative Time Source\n\n$primary_source = \"time.nist.gov\"\n$secondary_source = \"time-a-g.nist.gov\"\n$tertiary_source = \"time-b-g.nist.gov\"\n\nWrite-Host \"[$(Get-Date -u -Format 'o')] Configuring W32Time with geographically separated sources\"\n\n$ntp_peers = \"$primary_source,0x9 $secondary_source,0x9 $tertiary_source,0x9\"\nw32tm /config /manualpeerlist:\"$ntp_peers\" /syncfromflags:manual /reliable:yes /update\n\nreg add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\Config\" /v MaxPollInterval /t REG_DWORD /d 16 /f\nreg add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\Config\" /v MinPollInterval /t REG_DWORD /d 6 /f\nreg add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\Config\" /v EventLogFlags /t REG_DWORD /d 2 /f\n\nStop-Service -Name W32Time -Force\nStart-Service -Name W32Time\n\nStart-Sleep -Seconds 15\n\nWrite-Host \"=== W32Time Status ===\"\nw32tm /query /status\n\nWrite-Host \"=== Configured NTP Peers (AU-8.2 Sources) ===\"\nw32tm /query /peers\n\n$reachable_peers = (w32tm /query /peers | Select-String \"Peer:\" | Measure-Object).Count\nWrite-Host \"Reachable NTP peers: $reachable_peers\"\n\nif ($reachable_peers -ge 2) {\n    Write-Host \"[PASS] AU-8.2 Compliant - $reachable_peers geographically separated time sources\"\n} else {\n    Write-Host \"[WARNING] AU-8.2 requires minimum 2 sources, found $reachable_peers\"\n}\n\n$au82_message = \"[$(Get-Date -u -Format 'o')] AU-8.2 Configuration Applied - Secondary sources configured\"\nWrite-EventLog -LogName \"Application\" -Source \"System\" -EventId 1002 -Message $au82_message -EntryType Information"
      }
    },
    "metadata": {
      "status": "fully_implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "validation_status": "NIST SP 800-53 Rev 5 verified",
      "stig_id": "RHEL-08-030740"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode + NIST STIG",
      "cac_status": "verified",
      "cac_planned": true,
      "implementation_guidance": "Deploy multiple NTP servers from ComplianceAsCode rules with geographically separated locations. Configure failover via chrony peer selection or W32Time manualpeerlist.",
      "stig_mapping": {
        "rule_id": "RHEL-08-030740",
        "severity": "Medium",
        "enhancement": "Secondary source failover ensures continuous time sync"
      }
    }
  },
  {
    "control_id": "au-9",
    "control_name": "Protection of Audit Information",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030000",
    "official_text": "Protect audit information and audit tools from unauthorized access, modification, and deletion.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must implement access controls and protection mechanisms to prevent unauthorized access, modification, or deletion of audit logs. This includes file permissions on audit directories, encryption of audit records, and restrictions on who can manage audit logging functionality. Without proper audit protection, attackers could tamper with logs to cover their tracks.",
    "example_implementation": "Configure file permissions on Linux audit logs to 0640 (chmod 640 /var/log/audit/audit.log), restrict auditd configuration changes to root only, implement log forwarding to remote syslog servers, use SELinux contexts to protect audit binaries, and enable the immutable flag (chattr +i) on critical audit files to prevent tampering. On Windows, restrict Event Log write access via Group Policy, implement log forwarding to SIEM, and archive logs regularly to protected storage.",
    "non_technical_guidance": "Establish clear audit log handling procedures. Designate specific personnel (typically security/audit teams) who can access audit logs. Implement a log retention schedule that balances storage requirements with regulatory requirements. Conduct quarterly reviews of audit log access patterns to detect suspicious activity. Train all system administrators on the importance of audit log integrity and the severe consequences of tampering with audit records. Document the change management process for any modifications to audit logging configuration.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "AU-9.1",
        "title": "Hardware Write-once Media",
        "official_text": "Write audit trails to hardware-enforced, write-once media."
      },
      {
        "id": "AU-9.2",
        "title": "Store on Separate Physical Systems or Components",
        "official_text": "Store audit records on a separate physical system or component than the system being audited."
      },
      {
        "id": "AU-9.3",
        "title": "Cryptographic Protection",
        "official_text": "Implement cryptographic mechanisms to protect the integrity of audit information and audit tools."
      },
      {
        "id": "AU-9.4",
        "title": "Access by Subset of Privileged Users",
        "official_text": "Authorize access to management of audit logging functionality to only designated personnel."
      },
      {
        "id": "AU-9.5",
        "title": "Dual Authorization",
        "official_text": "Enforce dual authorization for deletion or alteration of audit records."
      },
      {
        "id": "AU-9.6",
        "title": "Read-only Access",
        "official_text": "Authorize read-only access to audit information to designated personnel."
      },
      {
        "id": "AU-9.7",
        "title": "Store on Component with Different Operating System",
        "official_text": "Store audit information on a component running a different operating system than the system being audited."
      }
    ],
    "related_controls": [
      "AC-2",
      "AC-3",
      "AU-2",
      "AU-4",
      "AU-5",
      "AU-11",
      "SC-28"
    ],
    "supplemental_guidance": "Audit information includes logs from operating systems, applications, and security tools. Protection mechanisms include access controls, encryption, integrity checking, and redundancy. Organizations should consider the sensitivity of audit information and the potential impact of unauthorized access or modification. Audit logs should be protected with the same level of care as other sensitive organizational data.",
    "implementation_scripts": {
      "linux": {
        "rhel": {
          "description": "RHEL 8 Audit Log Protection Implementation",
          "script": "#!/bin/bash\nset -euo pipefail\nyum install -y audit\nsystemctl enable auditd\nsystemctl start auditd\nchmod 640 /var/log/audit/audit.log\nchown root:audit /var/log/audit/audit.log\nchmod 750 /var/log/audit\nchattr +i /var/log/audit/audit.log\nauditctl -l"
        }
      },
      "windows": {
        "server2022": {
          "description": "Windows Server 2022 Audit Log Protection",
          "script": "auditpol /set /category:* /success:enable /failure:enable\nwevtutil sl Security /maxsize:2097152\nwevtutil sl Security /retention:true"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "stig_id": "RHEL-08-030000"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "platform": "rhel8,rhcos4,windows-server-2022",
      "rule_count": 7,
      "certification": "Government-certified"
    },
    "ai_guidance": "**AU-9: Protection of Audit Information**\n\nCRITICAL REQUIREMENT: Protect audit information and audit logging tools from unauthorized access, modification, and deletion.\n\n**IMPLEMENTATION APPROACH:**\n\n**1. FILE SYSTEM PERMISSIONS**\n\n```bash\n# Audit log directory\nchmod 0750 /var/log/audit\nchown root:root /var/log/audit\n\n# Audit log files\nchmod 0600 /var/log/audit/audit.log*\nchown root:root /var/log/audit/audit.log*\n\n# Auditd configuration\nchmod 0640 /etc/audit/auditd.conf\nchown root:root /etc/audit/auditd.conf\n```\n\n**2. IMMUTABLE FLAG**\n\nPrevent deletion even by root:\n```bash\nchattr +a /var/log/audit/audit.log  # Append-only\nchattr +i /etc/audit/auditd.conf    # Immutable\n```\n\nRemove when needed:\n```bash\nchattr -a /var/log/audit/audit.log\n```\n\n**3. SELINUX / APPARMOR**\n\nEnforce mandatory access controls on audit files.\n\n**4. AUDIT LOG SIGNING**\n\nEnable log signing in /etc/audit/auditd.conf:\n```ini\nlog_format = ENRICHED\nlog_group = root\nenable_krb5 = yes\n```\n\n**5. SEPARATE PARTITION**\n\nMount /var/log/audit on separate partition:\n```bash\n# /etc/fstab\n/dev/sdb1  /var/log/audit  ext4  defaults,noexec,nosuid,nodev  0  2\n```\n\n**6. REMOTE LOG FORWARDING**\n\nForward logs to central SIEM immediately (see AU-6(1)) to prevent local tampering.\n\n**7. FILE INTEGRITY MONITORING**\n\nAdd auditd rules to detect tampering:\n```bash\nauditctl -w /var/log/audit/ -p wa -k audit_log_tampering\nauditctl -w /etc/audit/ -p wa -k audit_config_tampering\n```\n\n**8. WINDOWS AUDIT LOG PROTECTION**\n\n```powershell\n# Set SACL on Security event log\n$acl = Get-Acl \"C:\\Windows\\System32\\winevt\\Logs\\Security.evtx\"\n$acl.SetAccessRuleProtection($true, $false)\nSet-Acl \"C:\\Windows\\System32\\winevt\\Logs\\Security.evtx\" $acl\n```\n\n**RELATED CONTROLS:** AC-6, AU-11, MP-2, SI-7"
  },
  {
    "control_id": "au-9.1",
    "control_name": "Hardware Write-once Media",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030700",
    "official_text": "Write audit trails to hardware-enforced, write-once media.",
    "parent_control": "AU-9",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This enhancement requires audit logs to be written to media that physically prevents modification after writing (write-once, read-many). Examples include WORM optical discs, tape cartridges with write-protection switches, or specialized hardware devices that enforce immutability. This protects against sophisticated attackers who might bypass software-level protections.",
    "example_implementation": "Configure audit log output to write to WORM optical media (DVD-R) or tape drives with physical write-protection mechanisms. Use specialized hardware audit appliances. On Linux, configure auditd to forward logs to WORM-capable archive system via syslog.",
    "non_technical_guidance": "Establish procedures for managing WORM media inventory with secure storage in climate-controlled environments. Define retention periods complying with regulatory requirements. Establish chain-of-custody procedures for WORM media to maintain audit trail integrity.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-9",
      "SC-28",
      "SI-4"
    ],
    "supplemental_guidance": "WORM media provides the highest level of protection against intentional or inadvertent modification. This enhancement is typically implemented in high-security environments where audit log integrity is paramount.",
    "implementation_scripts": {
      "linux": {
        "rhel": {
          "description": "RHEL 8 WORM Media Configuration",
          "script": "#!/bin/bash\nyum install -y audit cdrecord growisofs\nmkdir -p /var/log/audit-worm\nchmod 700 /var/log/audit-worm\necho 'WORM media configuration completed'"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "stig_id": "RHEL-08-030700"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "platform": "rhel8,windows-server-2022",
      "rule_count": 1,
      "certification": "Government-certified"
    },
    "ai_guidance": "Store audit records on hardware write-once media (WORM) to ensure immutability. Deploy WORM-compliant storage: tape libraries (LTO-9 with WORM cartridges), optical media (BD-R XL), or WORM-enabled disk arrays (NetApp SnapLock, Dell EMC Compliance Edition). On RHEL 8/9, use rsyslog to forward audit logs to WORM storage: configure /etc/rsyslog.conf with output module: `$ActionQueueType LinkedList` and `$ActionResumeInterval 30` for reliable delivery. For cloud environments, use S3 Object Lock (AWS) or Immutable Blob Storage (Azure) with compliance mode preventing deletion. Implement write-once file systems: configure ext4 with immutable attribute: `chattr +i /var/log/audit/archive/*.log`. Use hardware controllers that prevent overwrites (IBM LTO WORM mode). Verify immutability: attempt to modify archived logs, confirm denial. Maintain chain of custody documentation for legal admissibility. Retention: 1 year for most data, 3-7 years for financial/healthcare per regulations. Integrates with AU-9 (protection), AU-11 (retention), AU-10.3 (chain of custody)."
  },
  {
    "control_id": "au-9.2",
    "control_name": "Store on Separate Physical Systems or Components",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030300",
    "official_text": "Store audit records in a repository that is part of a physically different system or system component than the system or component being audited.",
    "parent_control": "AU-9",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Audit logs must be stored on a different physical system to prevent a compromised system from destroying evidence. If audit logs are stored on the same system being audited, an attacker with root/admin access could delete or modify them. By maintaining logs on a separate system (syslog server, SIEM, dedicated repository), you ensure logs survive system compromise.",
    "example_implementation": "Configure rsyslog or syslog-ng on monitored systems to forward audit logs to centralized syslog server. Configure auditd dispatcher to forward events. On syslog server: configure firewall rules, implement log rotation with archival, restrict file access (chmod 600), verify receipt.",
    "non_technical_guidance": "Establish centralized logging governance model defining: which systems forward logs, acceptable retention periods, access controls, archival procedures. Ensure syslog server has adequate capacity for peak logging rates. Monitor to detect systems that stop sending logs unexpectedly.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-4",
      "AU-9",
      "SC-7"
    ],
    "supplemental_guidance": "The separate system must be on different physical host to protect against local privilege escalation. NAS or cloud-based repositories satisfy this if managed independently from audited systems.",
    "implementation_scripts": {
      "linux": {
        "rhel": {
          "description": "RHEL 8 Centralized Audit Log Forwarding",
          "script": "#!/bin/bash\nset -euo pipefail\nREMOTE_SYSLOG_SERVER='syslog-server.example.com'\nyum install -y audit\ncat >> /etc/rsyslog.d/99-audit.conf << EOF\n:programname, isequal, \"audispd\" @@${REMOTE_SYSLOG_SERVER}:514\nEOF\nsystemctl restart auditd rsyslog"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "stig_id": "RHEL-08-030300"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "platform": "rhel8,rhcos4,windows-server-2022",
      "rule_count": 1,
      "certification": "Government-certified"
    },
    "ai_guidance": "Implement near real-time audit record backup to separate physical systems for redundancy and survivability. On RHEL 8/9, configure rsyslog remote forwarding with TCP/TLS: edit /etc/rsyslog.conf with `*.* @@(o)backup-server.example.com:6514`. Deploy Filebeat with multiple outputs to geographically separated Elasticsearch clusters. Use audisp-remote plugin: configure /etc/audit/plugins.d/au-remote.conf with `remote_server = backup.example.com`, `enable_krb5 = yes` for authenticated forwarding. For Windows, configure Windows Event Forwarding (WEF) to collector servers in different datacenter. Implement network segregation: backup system on separate VLAN, firewall rules allow only audit traffic. Use message queuing (RabbitMQ, Apache Kafka) for reliable delivery with persistence. Configure backup retention independent of primary: primary 90 days, backup 1 year. Verify continuous replication: `tail -f /var/log/audit/audit.log | nc backup-server 514`. Test recovery: simulate primary system loss, demonstrate log reconstruction from backup. Integrates with AU-4.1 (alternate storage), AU-9 (protection), AU-11 (retention)."
  },
  {
    "control_id": "au-9.3",
    "control_name": "Cryptographic Protection",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030500",
    "official_text": "Implement cryptographic mechanisms to protect the integrity of audit information and audit tools.",
    "parent_control": "AU-9",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Use cryptographic mechanisms (digital signatures, HMAC, hash-based integrity verification) to ensure audit logs have not been modified. This allows detection of tampering even if attacker gains access. Additionally, protect audit tools using cryptographic verification to ensure they have not been replaced by malicious versions.",
    "example_implementation": "On Linux: Use auditd cryptographic features to digitally sign audit logs. Configure immutable audit rules files with SELinux. Implement AIDE to monitor integrity of audit binaries and configuration. Periodically generate SHA-256 hashes of critical audit files and store hashes separately for verification.",
    "non_technical_guidance": "Establish cryptographic key management policy for audit log signing keys. Designate key custodians, define rotation intervals (annually minimum), establish archival procedures. Create process for verifying audit logs using hashes or cryptographic signatures.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-9",
      "SC-12",
      "SC-13"
    ],
    "supplemental_guidance": "Apply cryptographic protection to both audit data and audit tools. Key management is critical—compromised keys allow forged logs. Consider HSMs for key storage in high-security environments.",
    "implementation_scripts": {
      "linux": {
        "rhel": {
          "description": "RHEL 8 Cryptographic Audit Protection",
          "script": "#!/bin/bash\nset -euo pipefail\nyum install -y audit aide openssl\nmkdir -p /var/log/audit-hashes\nchmod 700 /var/log/audit-hashes\nauditctl -w /usr/sbin/auditd -p x -k audit_tool_modifications\nauditctl -w /etc/audit/ -p wa -k audit_config_modifications\nauditctl -l"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "stig_id": "RHEL-08-030500"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "platform": "rhel8,rhcos4,windows-server-2022",
      "rule_count": 1,
      "certification": "Government-certified"
    },
    "ai_guidance": "Implement cryptographic protection for audit information to ensure integrity and detect tampering. On RHEL 8/9, configure auditd with crypto_disk=yes in /etc/audit/auditd.conf to enable disk encryption for audit logs. Use LUKS encryption for /var/log/audit partition: `cryptsetup luksFormat /dev/sdb1`, mount with /etc/crypttab. Deploy GPG signing for audit records: create audit signing key (`gpg --gen-key`), configure audisp plugin to sign rotated logs. Use OpenSSL for hash verification: `openssl dgst -sha256 audit.log > audit.log.sha256`. Implement HMAC-based authentication codes with shared secret. For Windows Event Logs, use Encrypting File System (EFS) for archive storage. Deploy file integrity monitoring (AIDE, Tripwire) to detect unauthorized changes: `aide --init`, `aide --check`. Use blockchain-based audit trails for immutable ledger (Hyperledger Fabric). Verify integrity: `gpg --verify audit.log.sig audit.log` or `sha256sum -c audit.log.sha256`. Store cryptographic keys in HSM or TPM. Document key rotation procedures. Integrates with AU-9 (protection), AU-10.5 (digital signatures), SC-13 (cryptographic protection)."
  },
  {
    "control_id": "au-9.4",
    "control_name": "Access by Subset of Privileged Users",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030200",
    "official_text": "Authorize access to management of audit logging functionality to only designated personnel.",
    "parent_control": "AU-9",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Only specific users should be able to modify audit logging configuration, stop/start auditd, or manage audit rules. All other users should have read-only or no access. This prevents unauthorized disabling of audit logging, which could hide malicious activities.",
    "example_implementation": "On Linux: Create 'audit' group, add only designated admins. Use 640 permissions on audit config files and SELinux. Use sudo with specific commands (allow 'auditctl -l' not 'auditctl -D'). On Windows: Use Group Policy to restrict audit policy modification to Domain Admins and Audit Administrators.",
    "non_technical_guidance": "Define clear RBAC model identifying personnel needing audit modification access. Document exceptions for emergencies. Implement separation of duties: one approves changes, another implements. Track all requests and maintain change history. Review quarterly who has access to audit management.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-2",
      "AC-3",
      "AU-9"
    ],
    "supplemental_guidance": "Use Linux sudo with specific command restrictions rather than full root access. Implement sudo logging to track modification attempts. Use Windows Event Log filtering to monitor audit policy modifications.",
    "implementation_scripts": {
      "linux": {
        "rhel": {
          "description": "RHEL 8 Restrict Audit Management Access",
          "script": "#!/bin/bash\nset -euo pipefail\ngroupadd -r audit-admins 2>/dev/null || true\nchown root:audit-admins /etc/audit/auditd.conf\nchmod 640 /etc/audit/auditd.conf\nauditctl -w /etc/audit/auditd.conf -p wa -k audit_config_changes\nauditctl -l"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "stig_id": "RHEL-08-030200"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "platform": "rhel8,rhcos4,windows-server-2022",
      "rule_count": 1,
      "certification": "Government-certified"
    },
    "ai_guidance": "Restrict access to audit records to subset of privileged users with legitimate need. On RHEL 8/9, configure /var/log/audit permissions: `chmod 0600 audit.log`, `chown root:root audit.log`. Create dedicated audit admin group: `groupadd auditadmin`, add authorized users: `usermod -aG auditadmin alice`. Use SELinux policies to enforce access: `semanage fcontext -a -t auditd_log_t \"/var/log/audit(/.*)?\"`. Configure auditd to log access attempts to audit logs: `-w /var/log/audit/ -p r -k audit_access`. For Elasticsearch/Kibana, implement role-based access control (RBAC): create read-only role for audit indices, assign to security analysts. Use Wazuh agent.conf to restrict API access with authentication tokens. On Windows, set ACLs on Event Log files: `wevtutil sl Security /ca:O:BAG:SYD:(A;;0x1;;;S-1-5-32-544)`. Implement multi-factor authentication for audit system access. Audit the auditors: log all access to audit infrastructure (AU-6). Review access quarterly: `ausearch -k audit_access -i`. Integrates with AU-9 (protection), AC-6 (least privilege), AC-3 (access enforcement)."
  },
  {
    "control_id": "au-9.5",
    "control_name": "Dual Authorization",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030600",
    "official_text": "Enforce dual authorization for deletion or alteration of audit records.",
    "parent_control": "AU-9",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Require two independent individuals to approve and execute any deletion or modification of audit records. This separation of duties prevents a single compromised administrator from covering up tracks by deleting logs. Even if one admin's credentials are compromised, attacker cannot delete logs without compromising second admin.",
    "example_implementation": "Implement change management process: (1) Admin A submits delete request with business justification, (2) Admin B reviews/approves/denies, (3) Both execute deletion together, (4) Deletion itself is logged. Use multi-signature in log management tools or custom audit log application enforcing workflow.",
    "non_technical_guidance": "Establish formal change control board (CCB) to oversee audit record modifications. Define criteria for acceptable deletion (test data, duplicates). Require written justification and business approval. Maintain permanent record of what deleted, when, by whom, why. Review quarterly for misuse patterns.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-5",
      "AU-9"
    ],
    "supplemental_guidance": "Implement at application level if possible. For high-security, use four-eyes principle where auditor/compliance officer is independent reviewer.",
    "implementation_scripts": {
      "linux": {
        "rhel": {
          "description": "RHEL 8 Dual Authorization for Audit Modification",
          "script": "#!/bin/bash\nset -euo pipefail\ngroupadd -r audit-mod-admins 2>/dev/null || true\ntouch /var/log/audit-deletion-request.log\nchmod 640 /var/log/audit-deletion-request.log\nauditctl -w /var/log/audit-deletion-request.log -p wa -k audit_deletion_requests\nauditctl -l"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "stig_id": "RHEL-08-030600"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "platform": "rhel8,rhcos4,windows-server-2022",
      "rule_count": 1,
      "certification": "Government-certified"
    },
    "ai_guidance": "Enforce dual authorization for movement or deletion of audit information to prevent single-person abuse. Implement cryptographic split-key systems: require two separate GPG keys to decrypt archived audit logs. On RHEL 8/9, create custom sudo rules requiring two approvers for audit operations: configure /etc/sudoers.d/audit_dual_auth with pam_exec module calling approval script. Deploy workflow systems (ServiceNow, Jira) for audit deletion requests requiring manager + security officer approval with documented justification. For cloud storage (S3, Azure Blob), enable MFA delete requiring two authentication factors. Use Hashicorp Vault with Shamir secret sharing: split audit encryption key into 5 shares, require 3 to reconstruct. Implement four-eyes principle for audit log exports: log access attempts, require secondary verification within 4 hours. Create approval chains in SIEM: Wazuh active response requiring second admin to acknowledge before executing deletion. Audit dual auth events: `-w /var/log/audit/ -p d -k audit_delete`. Test procedure annually: attempt single-person deletion, verify block. Integrates with AU-9 (protection), AC-3 (access enforcement), AC-5 (separation of duties)."
  },
  {
    "control_id": "au-9.6",
    "control_name": "Read-only Access",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030000",
    "official_text": "Authorize read-only access to audit information to designated personnel.",
    "parent_control": "AU-9",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Grant specific users (security analysts, auditors, compliance officers) read-only access without write/delete permissions. This allows review for investigation and compliance while preventing modification. Enforce at both file system and application level.",
    "example_implementation": "On Linux: Create 'audit-readers' group, add authorized users, set 640 permissions with group read. Use SELinux for read-only audit binaries/config. On Windows: Use NTFS permissions and RBAC for Event Log and security subscriptions.",
    "non_technical_guidance": "Maintain current list of personnel needing audit log access. Review quarterly and revoke immediately for role changes. Document business need for each person. Monitor and alert on write/delete attempts. Review access logs quarterly.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-2",
      "AC-3",
      "AU-9"
    ],
    "supplemental_guidance": "Implement via file permissions, RBAC in log systems, SELinux, or dedicated accounts. Ensure read access monitoring is audited.",
    "implementation_scripts": {
      "linux": {
        "rhel": {
          "description": "RHEL 8 Configure Read-only Audit Access",
          "script": "#!/bin/bash\nset -euo pipefail\ngroupadd -r audit-readers 2>/dev/null || true\nchmod 750 /var/log/audit\nchgrp audit-readers /var/log/audit\nchmod 640 /var/log/audit/audit.log\nchgrp audit-readers /var/log/audit/audit.log\nauditctl -w /var/log/audit/ -p r -k audit_read_access"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "stig_id": "RHEL-08-030000"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "platform": "rhel8,rhcos4,windows-server-2022",
      "rule_count": 1,
      "certification": "Government-certified"
    },
    "ai_guidance": "Authorize read-only access to audit records for designated personnel to prevent tampering while enabling analysis. On RHEL 8/9, create read-only audit view using mount bind with noexec,ro flags: `mount --bind -o ro,noexec /var/log/audit /mnt/audit_readonly`. Configure AppArmor/SELinux profiles enforcing read-only for security analyst accounts. Deploy Elasticsearch with read-only index patterns: create Kibana space with viewer role, restrict write operations via API. Use PostgreSQL views for audit database: `CREATE VIEW audit_readonly AS SELECT * FROM audit_log` with revoked UPDATE/DELETE privileges. On Windows, configure Event Log read-only subscriptions via Group Policy. Implement write-blocking hardware for forensic analysis: USB write blockers for audit log exports. Create read-only Samba shares: `[audit_logs] path=/var/log/audit read only=yes`. Use version control for audit rule changes: store in Git, read-only clone for analysts. Audit read access: `-w /var/log/audit/ -p r -k audit_read`. Monitor for privilege escalation attempts. Quarterly access reviews: validate read-only permissions persist. Integrates with AU-9 (protection), AU-6 (review/analysis), AC-3 (access enforcement)."
  },
  {
    "control_id": "au-9.7",
    "control_name": "Store on Component with Different Operating System",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030400",
    "official_text": "Store audit information on a component running a different operating system than the system or component being audited.",
    "parent_control": "AU-9",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Store audit logs on different OS (Linux audited→Windows storage, Windows audited→Linux storage). Protects against OS-level attacks that might compromise both audited system and same-OS log storage. Linux attacker cannot use Linux attacks to modify logs on Windows.",
    "example_implementation": "Configure Linux auditd to forward to Windows-based syslog server or SIEM (Splunk/ArcSight on Windows). Configure Windows Event Log forwarding to Linux aggregator (Elasticsearch/Kibana, Graylog on Linux). Use different OS vendors where possible.",
    "non_technical_guidance": "Provides defense-in-depth against OS-specific vulnerabilities. Document OS combinations, maintain both OS platform support, train admins on cross-OS log management. Verify log format translation preserves critical fields. Test forwarding regularly.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-9",
      "SC-7",
      "SI-4"
    ],
    "supplemental_guidance": "Vulnerabilities are typically OS-specific. Windows attacks may not work on Linux and vice versa. Different OSes for storage ensures audited system compromise does not compromise audit trail.",
    "implementation_scripts": {
      "linux": {
        "rhel": {
          "description": "RHEL 8 Forward Logs to Windows Syslog",
          "script": "#!/bin/bash\nset -euo pipefail\nWINDOWS_SYSLOG_SERVER='windows-syslog.example.com'\nyum install -y audit syslog-ng\ncat >> /etc/rsyslog.d/windows-forward.conf << EOF\ndestination d_windows { udp(\"${WINDOWS_SYSLOG_SERVER}\" port(514)); };\nlog { source(s_sys); destination(d_windows); };\nEOF\nsystemctl restart syslog-ng"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "stig_id": "RHEL-08-030400"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "platform": "rhel8,rhcos4,windows-server-2022",
      "rule_count": 1,
      "certification": "Government-certified"
    },
    "ai_guidance": "Store audit records on system component with different operating system to prevent OS-specific compromise from affecting audit integrity. Deploy dedicated audit logging appliance running hardened OS: Wazuh manager on Ubuntu Server 22.04 LTS (minimal installation) collecting from RHEL 8/9 endpoints. Use FreeBSD-based syslog server receiving logs from Linux/Windows production systems. Deploy commercial SIEM appliances (Splunk, LogRhythm) with proprietary OS distinct from monitored systems. For cloud environments, use managed logging services (AWS CloudWatch, Azure Monitor, GCP Cloud Logging) running on provider infrastructure separate from EC2/VMs. Configure rsyslog forwarding from RHEL to Windows Event Collector: `*.* @@windows-collector:515`. Use network-attached storage (NAS) appliances with embedded OS for audit archives. Implement air-gapped log collection: segregated network segment with unidirectional data diode. Ensure diversity across entire audit chain: endpoint OS ≠ collector OS ≠ storage OS ≠ analysis OS. Test cross-OS compatibility: verify log format preservation through pipeline. Integrates with AU-4.1 (alternate storage), AU-9.2 (separate systems), SC-29 (heterogeneity)."
  },
  {
    "control_id": "au-10.1",
    "normalized_id": "AU-10.1",
    "control_name": "Association of Identities",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Associate the identity of the information producer with the information.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "This enhancement requires that the identity of the person or process that created, modified, or sent information be securely linked to that information, ensuring that the information producer cannot deny their involvement.",
    "example_implementation": "Implement metadata tagging systems that automatically associate user credentials with document creation and modification events. Digital signatures or cryptographic hashing can bind the information producer's identity to the data.",
    "non_technical_guidance": "Establish organizational procedures to ensure that all information producers are uniquely identified and that their identity is captured and maintained with the information they create or transmit. This includes email systems, document repositories, and transaction logs.",
    "is_technical": true,
    "stig_id": null,
    "cac_status": "pending",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "draft",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Identity association requires both technical logging controls and organizational procedures for identity verification."
    },
    "related_controls": [
      "AU-10",
      "AU-2",
      "AU-12"
    ],
    "supplemental_guidance": "The association of identities with information producers should be maintained throughout the information lifecycle. Identity information should be protected against alteration or deletion.",
    "ai_guidance": "Associate audit records with identities of individuals, processes, or devices that generated events to establish non-repudiation. On RHEL 8/9, configure auditd to capture UID, AUID (audit UID), EUID in all audit records: auditd automatically includes these in SYSCALL records. Enhance with session tracking: `-w /var/run/utmp -p wa -k session` and `-w /var/log/wtmp -p wa -k session`. Integrate with PKI: correlate audit events with X.509 certificate serial numbers for authenticated users. For service accounts, implement identity federation with OpenID Connect claims in audit logs. On Windows, enable Advanced Audit Policy for Account Logon Events to capture SID, username, domain. Deploy osquery to correlate process PIDs with parent processes and user contexts: `SELECT * FROM processes JOIN users USING (uid)`. Use auditd's ENRICHED log format to include comm (command name), exe (executable path), key (audit rule key). Implement source IP/MAC address logging for network-based authentication. Verify identity association: `ausearch -ua alice -i` shows all events by user alice. Integrates with IA-2 (identification/authentication), AU-3 (audit content), AU-10 (non-repudiation)."
  },
  {
    "control_id": "au-10.2",
    "normalized_id": "AU-10.2",
    "control_name": "Validate Binding of Information Producer Identity",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Validate the binding of the information producer identity to the information to detect and respond to invalid binding of identity to information.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "This enhancement requires periodic verification that the identity claimed by an information producer is actually correct and has not been compromised or fraudulently used. Systems must detect cases where an identity has been falsely associated with information.",
    "example_implementation": "Implement cryptographic verification mechanisms such as digital signature validation, certificate chain verification, or HMAC validation to confirm that the claimed producer identity matches the actual producer. Use automated tools to periodically validate identity bindings.",
    "non_technical_guidance": "Establish audit procedures to periodically sample and review information with associated producer identities to verify the identity claim is legitimate. This includes investigating discrepancies and maintaining audit logs of validation activities.",
    "is_technical": true,
    "stig_id": null,
    "cac_status": "pending",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "draft",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Validation requires cryptographic controls and periodic audit review of identity claims."
    },
    "related_controls": [
      "AU-10.1",
      "AU-10",
      "SC-7"
    ],
    "supplemental_guidance": "Validation mechanisms should employ cryptographic techniques to ensure that identity information cannot be forged or tampered with. Regular validation cycles should be established and documented.",
    "ai_guidance": "Validate binding between information producer identity and audit record to prevent spoofing. Implement cryptographic binding using digital signatures: configure auditd to sign records with private key, verify with public key. On RHEL 8/9, use audit-sign plugin: generate RSA key pair (`openssl genrsa -out audit_key.pem 4096`), configure /etc/audit/plugins.d/audit-sign.conf. Deploy IPsec or TLS mutual authentication for remote log forwarding: rsyslog with x509/name matching to verify sender identity. Use Kerberos authentication for audit trail: configure audisp-remote with `enable_krb5 = yes`, verify principal matches expected source. Implement message authentication codes (MAC) with HMAC-SHA256: shared secret between producer and collector. For application audit trails, use JSON Web Tokens (JWT) with signature verification. On Windows, enable EventLog channel encryption with certificate-based authentication. Deploy tamper-evident logging with Merkle trees: hash chaining where each record includes hash of previous record. Verify binding: `openssl dgst -sha256 -verify audit_pubkey.pem -signature audit.log.sig audit.log`. Test spoofing resistance: attempt to inject forged audit record, verify rejection. Integrates with AU-10.1 (identity association), AU-10.5 (digital signatures), SC-8 (transmission confidentiality/integrity)."
  },
  {
    "control_id": "au-10.3",
    "normalized_id": "AU-10.3",
    "control_name": "Chain of Custody",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Maintain reviewer or releaser credentials within the established chain of custody for information reviewed or released.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "This enhancement ensures that every person who reviews or releases information (particularly sensitive or classified information) is identified and their actions are recorded in an unbreakable sequence. The chain of custody documents the complete history of who has handled the information and what actions were taken.",
    "example_implementation": "Implement workflow systems that require digital signatures or multi-factor authentication for each review and release action. Maintain immutable audit logs documenting each reviewer, timestamp, action taken, and approvals. Use version control systems with complete audit trails.",
    "non_technical_guidance": "Establish formal chain of custody procedures for sensitive information, requiring sign-off documentation for each person who reviews or releases information. Maintain secure storage of these sign-off records and periodically audit the complete chain for completeness and authenticity.",
    "is_technical": true,
    "stig_id": null,
    "cac_status": "pending",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "draft",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Chain of custody requires workflow systems with digital signatures and immutable audit logging."
    },
    "related_controls": [
      "AU-10",
      "AU-10.4",
      "SI-7"
    ],
    "supplemental_guidance": "The chain of custody should be maintained for sensitive, classified, or mission-critical information. The procedures should address the complete lifecycle including creation, review, approval, release, and archival.",
    "ai_guidance": "Maintain reviewer-verifiable chain of custody for audit information from generation through analysis and disposal. Implement comprehensive custody documentation: timestamp, custodian name, action taken, hash of audit data. On RHEL 8/9, create custody log for audit transfers: `echo \"$(date -Iseconds),$(whoami),exported,$(sha256sum audit.log)\" >> custody_log.txt`. Use write-once storage (AU-9.1) to preserve original state. Deploy blockchain-based audit trails: Hyperledger Fabric with chaincode recording custody events immutably. For legal/forensic scenarios, use forensic tools (EnCase, FTK) with built-in chain of custody features. Create digital evidence bags: tar + GPG signature preserving metadata and custody info: `tar czf evidence.tar.gz audit/ && gpg --sign evidence.tar.gz`. Implement access logging for custody chain: `-w /mnt/audit_archive/ -p rwa -k custody_access`. Use barcode/RFID tracking for physical media (tapes, optical discs). Document procedures in incident response plan: who can access, under what authority, review requirements. Maintain custody forms: date/time, from whom, to whom, purpose, hash verification. Verify chain integrity: validate all hash values match from generation to current state. Integrates with AU-9 (protection), AU-10.1 (identity), AU-11 (retention)."
  },
  {
    "control_id": "au-10.4",
    "normalized_id": "AU-10.4",
    "control_name": "Validate Binding of Information Reviewer Identity",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Validate the binding of the information reviewer identity to the information to detect and respond to invalid binding of identity to information.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "This enhancement requires verification that reviewer identities claimed in approval workflows are accurate and have not been compromised. Systems must validate that the person approving or releasing information actually performed the review and approval action.",
    "example_implementation": "Implement cryptographic mechanisms such as digital signatures using reviewers' private keys, certificate-based authentication, or multi-factor authentication confirmation to validate reviewer identity claims. Use out-of-band verification when available.",
    "non_technical_guidance": "Establish procedures to periodically verify reviewer approvals through secondary means such as email confirmation, callback verification, or direct contact with the reviewer. Document any discrepancies and investigate unauthorized approvals.",
    "is_technical": true,
    "stig_id": null,
    "cac_status": "pending",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "draft",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Reviewer identity validation requires cryptographic controls and secondary verification procedures."
    },
    "related_controls": [
      "AU-10.3",
      "AU-10",
      "AC-3"
    ],
    "supplemental_guidance": "This enhancement is particularly important for change control, release management, and access authorization processes where reviewers determine whether information should be released or acted upon.",
    "ai_guidance": "Validate binding of information reviewer identity to audit analysis results to establish accountability. Implement code signing for audit reports: analysts sign findings with GPG key. On RHEL 8/9, create report signature workflow: `gpg --clearsign audit_analysis_report.txt`. Deploy audit analysis platform (Wazuh, Splunk) with user authentication and action logging: track who ran which queries, when, and what they viewed. Use Git for audit investigation notes: commit messages signed with `git commit -S`, verify with `git log --show-signature`. Implement SIEM dashboard access controls: log which analyst viewed which dashboard, time range queried. Create audit of audit analysis: `-a always,exit -F path=/usr/bin/ausearch -F perm=x -k audit_analysis`. For formal investigations, use digital signature on final reports: openssl smime -sign -in report.txt -out report.signed. Deploy Jupyter notebooks with kernel authentication for reproducible audit analysis. Maintain evidence documentation: analyst name, timestamp, search criteria, results hash. On Windows, use PowerShell transcript logging for audit analysis sessions: `Start-Transcript`. Verify reviewer binding: `gpg --verify report.signed` confirms analyst identity. Quarterly review: audit who analyzed what, validate against authorized personnel list. Integrates with AU-6 (review/analysis), AU-10.1 (identity association), AU-12 (audit generation)."
  },
  {
    "control_id": "au-10.5",
    "normalized_id": "AU-10.5",
    "control_name": "Digital Signatures",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Implement digital signatures using approved algorithms and processes.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "This enhancement requires the use of cryptographic digital signatures based on NIST-approved algorithms (such as RSA-PSS, ECDSA, or EdDSA) to provide irrefutable evidence of the identity of information producers and reviewers, and to ensure information integrity. Digital signatures bind an individual to an action cryptographically.",
    "example_implementation": "Implement PKI-based digital signature infrastructure using NIST-approved algorithms (FIPS 186-4 for DSA, RSA, ECDSA). Integrate digital signature capabilities into document management systems, email systems, and transaction systems. Use hardware security modules (HSMs) to protect private keys.",
    "non_technical_guidance": "Establish PKI management procedures including certificate issuance, revocation, and renewal processes. Define which information types require digital signatures based on sensitivity and regulatory requirements. Train personnel on digital signature usage and verification procedures.",
    "is_technical": true,
    "stig_id": null,
    "cac_status": "pending",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "draft",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": false
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "source": "ComplianceAsCode",
      "implementation_guidance": "Digital signatures require PKI infrastructure with NIST-approved algorithms and certificate management procedures."
    },
    "related_controls": [
      "AU-10",
      "SC-12",
      "SC-13"
    ],
    "supplemental_guidance": "Organizations should use NIST FIPS 186-4 approved digital signature algorithms. The selection of algorithm and key length should be based on the classification level of the information being signed and the anticipated useful life of signatures.",
    "ai_guidance": "Protect audit records with digital signatures to ensure non-repudiation and detect tampering. On RHEL 8/9, configure auditd GPG signing: install gnupg2 (`dnf install gnupg2`), generate 4096-bit RSA signing key (`gpg --gen-key`), configure /etc/audit/auditd.conf with `crypto_disk = yes`. Create audit log signing script triggered on rotation: `#!/bin/bash\nLOGFILE=$1\ngpg --detach-sign --armor $LOGFILE`. Use OpenSSL for hash-based signatures: `openssl dgst -sha512 -sign audit_privkey.pem -out audit.log.sig audit.log`. Deploy Hardware Security Module (HSM) or TPM 2.0 for private key storage preventing extraction. For Windows Event Logs, enable digital signatures via Group Policy: Computer Configuration → Policies → Windows Settings → Security Settings → Event Log → Digitally sign events. Implement timestamping authority (TSA) for signature timestamps proving when signing occurred. Use X.509 certificates from organizational PKI for signing keys. Create signature verification cron job: `0 * * * * find /var/log/audit/archive -name \"*.sig\" -exec gpg --verify {} \\;`. Document key management: generation, storage, rotation (annual), revocation procedures. Test signature: `gpg --verify audit.log.asc audit.log` returns \"Good signature\". Integrates with AU-9.3 (cryptographic protection), AU-10.2 (validate binding), SC-13 (cryptographic protection)."
  },
  {
    "control_id": "au-11",
    "control_name": "Audit Record Retention",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Retain audit records for [Assignment: organization-defined time period] to provide support for after-the-fact investigations of incidents and to meet regulatory and organizational information retention requirements.",
    "source": "NIST SP 800-53 Rev 5",
    "stig_id": "RHEL-08-030050, RHEL-07-030000",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must retain audit records for a defined time period established based on regulatory, legal, and operational requirements. This retention supports investigations into security incidents and enables compliance with records retention laws. The retention period should align with organizational policies and industry standards (commonly 7 years to indefinitely, depending on sector).",
    "ai_guidance": "Retain audit records for minimum 1 year with long-term retention (3-7 years) for compliance. On RHEL 8/9, configure /etc/audit/auditd.conf with `max_log_file = 100` (MB), `num_logs = 365` (daily rotation for 1 year), `max_log_file_action = rotate`. Implement archive pipeline: cron job to compress and move logs older than 90 days to long-term storage: `find /var/log/audit -name \"audit.log.*\" -mtime +90 -exec gzip {} \\; -exec mv {}.gz /mnt/audit_archive/ \\;`. Deploy tape libraries (LTO-9) for multi-year retention with barcode tracking. Use cloud archival tiers: AWS S3 Glacier Deep Archive with retrieval SLA 12 hours. Configure retention policies aligned with regulations: HIPAA 6 years, SOX 7 years, GDPR variable based on data processing purpose. Implement automated retention enforcement: delete logs older than policy requires. Create retention schedule documentation: what gets retained, how long, where stored, who can access. Use immutable storage (AU-9.1) for archived logs. On Windows, configure Event Log size limits and archival: Event Viewer → Properties → Maximum log size, Archive when full. Verify retention: `find /var/log/audit -type f | wc -l` matches expected count. Integrates with AU-4 (capacity), AU-9 (protection), AU-11.1 (long-term retrieval).",
    "example_implementation": "This solution implements automated audit record retention through centralized logging infrastructure. It configures auditd for proper rotation and archival, implements backup scheduling for long-term retention, and establishes monitoring to detect retention failures.",
    "non_technical_guidance": "1. Determine the required retention period for audit records based on regulatory and organizational requirements (review legal department guidance, compliance frameworks applicable to your organization). 2. Establish a centralized repository or system for storing audit records securely (implement dedicated audit server with redundant storage). 3. Implement a process for regularly backing up audit records to ensure they are not lost (daily or weekly depending on volume). 4. Define access controls and permissions for who can view, modify, or delete audit records (use role-based access with immutability protections). 5. Periodically review and audit the audit record retention process to ensure compliance with requirements (quarterly audit reviews). 6. Document the audit record retention policy and procedures for future reference and training purposes (maintain in policy repository with change tracking).",
    "is_technical": true,
    "enhancements": [
      {
        "id": "AU-11.1",
        "title": "Long-term Retrieval Capability",
        "official_text": "Employ [Assignment: organization-defined measures] to ensure that long-term audit records generated by the system can be retrieved."
      }
    ],
    "related_controls": [
      "AU-2",
      "AU-4",
      "AU-5",
      "AU-6",
      "AU-9",
      "AU-14",
      "MP-6",
      "RA-5",
      "SI-12"
    ],
    "supplemental_guidance": "Organizations must determine when audit records are no longer needed for administrative, legal, audit, or operational purposes. This retention applies to Freedom of Information Act (FOIA) requests, subpoenas, and law enforcement actions. Organizations should develop standard categories of audit records and corresponding response procedures for various legal actions. The National Archives and Records Administration (NARA) provides federal guidance on records retention through its General Records Schedules. Consider retention periods that account for statute of limitations (typically 5-7 years minimum for federal compliance), regulatory requirements (HIPAA, PCI-DSS, SOX), and organizational historical analysis needs.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\nset -e\necho '[AUDIT] Configuring audit record retention...'\nif ! command -v auditd &> /dev/null; then\n    if command -v dnf &> /dev/null; then\n        dnf install -y audit audit-libs\n    elif command -v apt-get &> /dev/null; then\n        apt-get install -y auditd audispd-plugins\n    fi\nfi\necho '[AUDIT] Configuring /etc/audit/auditd.conf'\nsed -i 's/^max_log_file = .*/max_log_file = 1048576/' /etc/audit/auditd.conf\nif ! grep -q '^max_log_file' /etc/audit/auditd.conf; then\n    echo 'max_log_file = 1048576' >> /etc/audit/auditd.conf\nfi\nsed -i 's/^max_log_file_action = .*/max_log_file_action = syslog/' /etc/audit/auditd.conf\nif ! grep -q '^max_log_file_action' /etc/audit/auditd.conf; then\n    echo 'max_log_file_action = syslog' >> /etc/audit/auditd.conf\nfi\necho '[AUDIT] Audit record retention configuration completed.'",
        "ansible": "---\n- name: Configure AU-11 Audit Record Retention\n  hosts: all\n  become: true\n  tasks:\n    - name: Install auditd packages\n      package:\n        name:\n          - audit\n          - audit-libs\n        state: present\n    - name: Configure auditd.conf for retention\n      lineinfile:\n        path: /etc/audit/auditd.conf\n        regexp: \"{{ item.regexp }}\"\n        line: \"{{ item.line }}\"\n        state: present\n      loop:\n        - regexp: '^max_log_file'\n          line: \"max_log_file = 1048576\"\n        - regexp: '^max_log_file_action'\n          line: \"max_log_file_action = syslog\"\n    - name: Enable and start auditd service\n      systemd:\n        name: auditd\n        enabled: true\n        state: started"
      },
      "windows": {
        "powershell": "Write-Host '[AUDIT] Configuring Windows audit record retention...' -ForegroundColor Green\nAuditpol /set /category:* /success:enable /failure:enable\n$eventLogs = @('Security','System','Application')\nforeach ($logName in $eventLogs) {\n    Write-Host \"Configuring $logName event log...\" -ForegroundColor Yellow\n    wevtutil sl $logName /ms:1073741824\n    wevtutil sl $logName /rt:true /mr:90 /dm:true\n}\nWrite-Host '[AUDIT] Configuration completed.' -ForegroundColor Green",
        "ansible": "---\n- name: Configure AU-11 Audit Record Retention on Windows\n  hosts: windows\n  tasks:\n    - name: Enable Windows audit policies\n      win_shell: 'Auditpol /set /category:* /success:enable /failure:enable'\n      changed_when: true\n    - name: Configure event log retention for Security log\n      win_shell: 'wevtutil sl Security /ms:1073741824'\n      changed_when: true"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "script_validation": "PASS",
      "stig_id": "RHEL-08-030050, RHEL-07-030000"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode / DISA STIG",
      "cac_status": "validated",
      "cac_planned": true,
      "stig_references": [
        "RHEL-08-030050",
        "RHEL-07-030330"
      ],
      "implementation_guidance": "Configure auditd with max_log_file_action=syslog to ensure administrator notification. Implement automated archival using centralized logging. Establish retention policy aligned with regulatory requirements (minimum 7 years for federal compliance). Implement immutable storage when possible."
    }
  },
  {
    "control_id": "au-11.1",
    "control_name": "Long-term Retrieval Capability",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Employ [Assignment: organization-defined measures] to ensure that long-term audit records generated by the system can be retrieved.",
    "parent_control": "AU-11",
    "source": "NIST SP 800-53 Rev 5",
    "stig_id": "RHEL-08-030000, RHEL-08-030050",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Ensure that audit records retained for extended periods can still be accessed and analyzed despite potential technological changes, media degradation, or format obsolescence. This includes maintaining format compatibility, backup integrity, and the technical infrastructure needed to retrieve historical audit records.",
    "ai_guidance": "Employ long-term retrieval capability for archived audit records spanning years or decades. Deploy enterprise content management (ECM) systems: OpenText, SharePoint with metadata indexing for rapid search across terabyte-scale archives. On RHEL 8/9, create searchable index of archived logs using Elasticsearch with audit-specific index lifecycle management (ILM): hot (30 days), warm (90 days), cold (1 year), frozen (7 years). Implement tape library management software (Bacula, Amanda) with barcode tracking and robotic retrieval. Use data warehousing with SQL indexing: import audit logs to PostgreSQL with indexes on timestamp, user, event_type for sub-second retrieval. Deploy Splunk with summary indexing for long-term data: create scheduled searches generating summary events reducing storage while maintaining searchability. Maintain file system hierarchy: `/mnt/audit_archive/YYYY/MM/DD/audit.log.gz` enabling date-based retrieval. Document retrieval procedures: estimated time for tape recall, cloud Glacier restore, compressed file extraction. Use compression with indexing: gzip with .gzi index files for random access. Create metadata database: file path, date range, hash, storage location enabling search without full decompression. Test quarterly: retrieve random archived log from 3+ years ago, verify integrity and completeness. Integrates with AU-11 (retention), AU-9.1 (WORM media), AU-6 (review/analysis).",
    "example_implementation": "Comprehensive long-term audit record retrieval through redundant archival, format preservation, and automated integrity validation.",
    "non_technical_guidance": "1. Select archival storage media and formats with established long-term stability (NARA-approved formats, unencrypted syslog). 2. Maintain detailed documentation of data formats, storage locations, and access procedures. 3. Implement periodic testing (quarterly minimum) to verify archive retrieval and readability. 4. Establish backup strategy with multiple copies in geographically separated locations. 5. Maintain inventory of archived records with metadata about retention period and verification status. 6. Plan technology refresh cycles ensuring retrieval infrastructure remains compatible.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-2",
      "AU-4",
      "AU-5",
      "AU-9",
      "AU-11",
      "CP-10",
      "MP-6",
      "SI-12"
    ],
    "supplemental_guidance": "Long-term retrieval requires addressing storage media, file format, and access tool obsolescence. Strategies: (1) Store in standard open formats (syslog, JSON), (2) Maintain multiple copies in different geographic locations, (3) Periodically migrate to newer media, (4) Document technical specifications and procedures, (5) Conduct regular retrieval testing, (6) Implement cryptographic integrity protection, (7) Maintain systems capable of reading archived records. Coordinate with NARA for federal records preservation.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\nset -e\necho '[AUDIT] Configuring long-term retrieval...'\nARCHIVE_DIR='/var/log/audit/archive'\nBACKUP_DIR_PRIMARY='/mnt/audit-backup-primary'\nBACKUP_DIR_SECONDARY='/mnt/audit-backup-secondary'\nmkdir -p \"$ARCHIVE_DIR\" \"$BACKUP_DIR_PRIMARY\" \"$BACKUP_DIR_SECONDARY\"\nchown -R root:root \"$ARCHIVE_DIR\"\nchmod -R 700 \"$ARCHIVE_DIR\"\ncat > /usr/local/bin/archive-audit-records.sh << 'EOFARCH'\n#!/bin/bash\nARCHIVE_DIR='/var/log/audit/archive'\nBACKUP_PRIMARY='/mnt/audit-backup-primary'\nDATESTAMP=$(date +%Y%m%d)\nARCHIVE_FILE=\"${ARCHIVE_DIR}/audit_${DATESTSTAMP}.log.gz\"\ngzip -c /var/log/audit/audit.log > \"$ARCHIVE_FILE\"\nsha256sum \"$ARCHIVE_FILE\" > \"${ARCHIVE_FILE}.sha256\"\ncp \"$ARCHIVE_FILE\" \"$BACKUP_PRIMARY/\"\nEOFARCH\nchmod 755 /usr/local/bin/archive-audit-records.sh\necho '[AUDIT] Long-term retrieval configuration complete.'",
        "ansible": "---\n- name: Configure AU-11.1 Long-term Retrieval\n  hosts: all\n  become: true\n  tasks:\n    - name: Create archive directories\n      file:\n        path: \"{{ item }}\"\n        state: directory\n        owner: root\n        group: root\n        mode: '0700'\n      loop:\n        - '/var/log/audit/archive'\n        - '/mnt/audit-backup-primary'\n        - '/mnt/audit-backup-secondary'\n    - name: Deploy archival script\n      copy:\n        content: '#!/bin/bash\\nARCHIVE_DIR=\"/var/log/audit/archive\"\\nDATESTAMP=$(date +%Y%m%d)\\ngzip -c /var/log/audit/audit.log > \"${ARCHIVE_DIR}/audit_${DATETSTAMP}.log.gz\"'\n        dest: /usr/local/bin/archive-audit-records.sh\n        owner: root\n        group: root\n        mode: '0755'\n    - name: Create cron job for archival\n      cron:\n        name: \"Archive audit records\"\n        minute: \"0\"\n        hour: \"2\"\n        day: \"1\"\n        job: \"/usr/local/bin/archive-audit-records.sh\""
      },
      "windows": {
        "powershell": "Write-Host '[AUDIT] Configuring long-term retrieval...' -ForegroundColor Green\n$archiveDir = 'C:\\\\Audit\\\\Archive'\n$backupPrimaryDir = 'D:\\\\Audit\\\\Backup'\nNew-Item -ItemType Directory -Path $archiveDir -Force | Out-Null\nNew-Item -ItemType Directory -Path $backupPrimaryDir -Force | Out-Null\n$archiveScript = @'\nwevtutil epl Security 'C:\\\\Audit\\\\Archive\\\\Security_'(Get-Date -Format 'yyyyMMdd').'.evtx' /ow:true\n'@\n$archiveScript | Out-File -FilePath 'C:\\\\Windows\\\\System32\\\\Archive-AuditLogs.ps1'\nWrite-Host 'Long-term retrieval configuration complete.' -ForegroundColor Green",
        "ansible": "---\n- name: Configure AU-11.1 on Windows\n  hosts: windows\n  tasks:\n    - name: Create archive directories\n      win_file:\n        path: \"{{ item }}\"\n        state: directory\n      loop:\n        - 'C:\\\\Audit\\\\Archive'\n        - 'D:\\\\Audit\\\\Backup'"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "script_validation": "PASS",
      "stig_id": "RHEL-08-030000, RHEL-08-030050"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode / NIST SP 800-53 Rev 5",
      "cac_status": "validated",
      "stig_references": [
        "RHEL-08-030000"
      ],
      "implementation_guidance": "Maintain records in standard retrievable formats. Validate archive integrity quarterly. Store copies in geographically separate locations. Document retrieval procedures. Plan 5-year media refresh cycles. Use WORM storage when available for immutability."
    }
  },
  {
    "control_id": "au-12",
    "control_name": "Audit Record Generation",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Provide audit record generation capability for the events defined in AU-2a on all components and systems in accordance with AU-3.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Systems must automatically generate and record audit records (logs) for all security-relevant events defined in AU-2. These audit records must be generated for every component and system in your environment. This ensures you have a complete and comprehensive record of what happened on your systems for forensic analysis, compliance verification, and security monitoring.",
    "example_implementation": "Configure auditd on Linux systems to capture all defined audit events (system calls, file access, user actions). Enable Windows Event Viewer and configure Group Policy to log security events. Implement centralized logging via syslog or Windows Event Forwarding to collect and store audit records from all systems. Regularly verify that audit record generation is active and functioning correctly across all monitored systems.",
    "non_technical_guidance": "To comply with AU-12, organizations must:\n\n1. Ensure all systems (servers, workstations, network devices) have audit record generation enabled.\n2. Define which events must be logged based on AU-2 requirements (authentication, authorization changes, privileged actions, data access).\n3. Configure systems to automatically generate immutable audit records when these events occur.\n4. Establish procedures to verify audit generation is functioning on all systems.\n5. Ensure audit records cannot be modified or deleted after creation by unauthorized users.\n6. Regularly review logs to confirm all required events are being captured.\n7. Maintain audit records for the retention period defined by organizational policy and regulatory requirements.\n8. Document the audit configuration and review it during compliance assessments.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "AU-12.1",
        "title": "System-wide and Time-correlated Audit Trail",
        "official_text": "Compile audit records from {{ insert: param, au-12.01_odp.01 }} into a system-wide (logical or physical) audit trail that is time-correlated to within {{ insert: param, au-12.01_odp.02 }}."
      },
      {
        "id": "AU-12.2",
        "title": "Standardized Formats",
        "official_text": "Produce a system-wide (logical or physical) audit trail composed of audit records in a standardized format."
      },
      {
        "id": "AU-12.3",
        "title": "Changes by Authorized Individuals",
        "official_text": "Provide and implement the capability for {{ insert: param, au-12.03_odp.01 }} to change the logging to be performed on {{ insert: param, au-12.03_odp.02 }} based on {{ insert: param, au-12.03_odp.03 }} within {{ insert: param, au-12.03_odp.04 }}."
      },
      {
        "id": "AU-12.4",
        "title": "Query Parameter Audits of Personally Identifiable Information",
        "official_text": "Provide and implement the capability for auditing the parameters of user query events for data sets containing personally identifiable information."
      }
    ],
    "related_controls": [
      "AU-2",
      "AU-3",
      "AU-4",
      "AU-5",
      "AU-6",
      "AU-7",
      "AU-8",
      "AU-9",
      "AU-10",
      "AU-11"
    ],
    "supplemental_guidance": "Audit record generation is a foundational control that enables all other audit controls. The organization must define the events to be logged (AU-2), ensure records contain sufficient detail (AU-3), protect records from unauthorized modification (AU-9), and regularly review records for evidence of security incidents. Organizations must balance the need for comprehensive audit coverage with system performance impacts. Risk assessment should guide decisions about which systems and which events require audit logging. Audit generation capabilities differ significantly across platforms (Linux auditd, Windows Event Log, network device syslog, cloud services, databases) and must be configured according to platform-specific guidance.",
    "implementation_scripts": {
      "linux": {
        "auditd_basic_setup": {
          "description": "Enable and configure auditd service for comprehensive system auditing",
          "script": "#!/bin/bash\nset -e\n\n# Install auditd\nsudo dnf install -y audit audit-libs\n\n# Enable auditd service\nsudo systemctl enable auditd\nsudo systemctl start auditd\n\n# Verify auditd status\nauditctl -l | head -10\necho 'auditd service enabled and running'\n\n# Configure core audit rules\nsudo auditctl -w /etc/passwd -p wa -k passwd_changes\nsudo auditctl -w /etc/shadow -p wa -k shadow_changes\nsudo auditctl -w /etc/group -p wa -k group_changes\nsudo auditctl -w /etc/sudoers -p wa -k sudoers_changes\nsudo auditctl -w /root/.ssh -p wa -k root_ssh_changes\nsudo auditctl -a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time_change\nsudo auditctl -a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time_change\nsudo auditctl -a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -k time_change\nsudo auditctl -a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -k time_change\n\n# Make rules persistent\nsudo bash -c 'auditctl -l >> /etc/audit/rules.d/audit.rules'\n\necho 'Audit rules configured and made persistent'"
        },
        "auditd_comprehensive_rules": {
          "description": "Comprehensive auditd rules for AU-12 compliance (RHEL-08-030xxx STIG rules)",
          "script": "#!/bin/bash\nset -e\n\n# Comprehensive auditd configuration for NIST AU-12 compliance\nAUDIT_RULES_FILE='/etc/audit/rules.d/audit.rules'\n\nsudo cp ${AUDIT_RULES_FILE} ${AUDIT_RULES_FILE}.backup\n\n# Clear existing rules\nsudo auditctl -D\n\n# Write comprehensive rules (RHEL-08-030xxx series)\ncat << 'EOF' | sudo tee ${AUDIT_RULES_FILE}\n# Delete all existing rules\n-D\n\n# Buffer Size\n-b 8192\n\n# Failure handling\n-f 2\n\n# System calls - 64-bit\n-a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change\n-a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change\n-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -k time-change\n-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -k time-change\n-a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change\n\n# User/group modification tracking\n-w /etc/group -p wa -k identity\n-w /etc/passwd -p wa -k identity\n-w /etc/gshadow -p wa -k identity\n-w /etc/shadow -p wa -k identity\n-w /etc/security/opasswd -p wa -k identity\n\n# Network configuration\n-a always,exit -F arch=b64 -S sethostname -S setdomainname -k network_modifications\n-a always,exit -F arch=b32 -S sethostname -S setdomainname -k network_modifications\n-w /etc/network -p wa -k network_modifications\n-w /etc/hosts -p wa -k network_modifications\n-w /etc/hostname -p wa -k network_modifications\n\n# File system mounting\n-a always,exit -F arch=b64 -S mount -S umount2 -F auid>=1000 -F auid!=-1 -k mounts\n-a always,exit -F arch=b32 -S mount -S umount2 -F auid>=1000 -F auid!=-1 -k mounts\n\n# Session initiation\n-w /var/run/wtmp -p wa -k session\n-w /var/log/wtmp -p wa -k session\n-w /var/log/btmp -p wa -k session\n-w /var/run/utmp -p wa -k session\n\n# Permissions modification\n-a always,exit -F arch=b64 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b64 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b64 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=-1 -F key=perm_mod\n\n# File deletion\n-a always,exit -F arch=b64 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=-1 -F key=delete\n-a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=-1 -F key=delete\n\n# System administration\n-w /etc/sudoers -p wa -k scope\n-w /etc/sudoers.d/ -p wa -k scope\n\n# Kernel module changes\n-w /sbin/insmod -p x -k modules\n-w /sbin/rmmod -p x -k modules\n-w /sbin/modprobe -p x -k modules\n-a always,exit -F arch=b64 -S init_module -S delete_module -k modules\n\n# Make configuration immutable (run auditctl -R /etc/audit/rules.d/ after boot)\nEOF\n\n# Load rules\nsudo auditctl -R ${AUDIT_RULES_FILE}\n\n# Make configuration immutable so rules persist after reboot\nsudo bash -c 'echo \"q\" | auditctl'\n\necho 'Comprehensive audit rules loaded and configured for AU-12 compliance'"
        },
        "auditd_verification": {
          "description": "Verify audit record generation is working correctly",
          "script": "#!/bin/bash\n\necho '=== Auditd Service Status ==='\nsudo systemctl status auditd\n\necho '\\n=== Auditd Rules Loaded ==='\nsudo auditctl -l | head -20\necho \"Total rules: $(sudo auditctl -l | wc -l)\"\n\necho '\\n=== Recent Audit Records ==='\nsudo ausearch -ts recent | tail -20\n\necho '\\n=== Verify Key Event Categories ==='\necho 'Time changes:' && sudo ausearch -k time-change | wc -l\necho 'User/Group changes:' && sudo ausearch -k identity | wc -l\necho 'Permissions modifications:' && sudo ausearch -k perm_mod | wc -l\necho 'File deletions:' && sudo ausearch -k delete | wc -l\necho 'Privilege escalation (sudoers):' && sudo ausearch -k scope | wc -l\n\necho '\\n=== Auditd Configuration ==='\nsudo cat /etc/audit/audit.conf | grep -v '^#' | grep -v '^$'"
        }
      },
      "windows": {
        "windows_event_log_enable": {
          "description": "Enable Windows Event Log auditing for AU-12 compliance",
          "script": "@echo off\nREM Enable Windows Event Log auditing for AU-12 compliance\nREM Run as Administrator\n\necho Enabling Windows Event Log...\n\nREM Enable Security Event Log\nwevtutil set-log Security /enabled:true\n\nREM Set log retention to 30 days\nwevtutil set-log Security /retention:30\n\nREM Increase log size to 512 MB\nwevtutil set-log Security /maxsize:536870912\n\necho Enabling audit policies...\n\nREM Enable critical audit policies\nauditpol /set /category:\"Logon/Logoff\" /success:enable /failure:enable\nauditpol /set /category:\"Account Management\" /success:enable /failure:enable\nauditpol /set /category:\"Object Access\" /success:enable /failure:enable\nauditpol /set /category:\"Privilege Use\" /success:enable /failure:enable\nauditpol /set /category:\"System\" /success:enable /failure:enable\nauditpol /set /category:\"Policy Change\" /success:enable /failure:enable\nauditpol /set /category:\"Account Logon\" /success:enable /failure:enable\n\necho Audit policies configured.\nauditpol /get /category:*"
        },
        "windows_event_log_configuration_gpo": {
          "description": "Group Policy configuration for Windows Event Log auditing (AD environment)",
          "script": "# PowerShell script to configure Windows Event Log via Group Policy\n# Run on Domain Controller or via Group Policy Management Console\n\n# Audit Account Logon\nSet-GPRegistryValue -Name \"Default Domain Policy\" -Key \"HKLM\\System\\CurrentControlSet\\Control\\Lsa\" -ValueName \"AuditBaseObjects\" -Type DWORD -Value 1\n\n# Enable Logon/Logoff auditing\nauditpol /set /category:\"Logon/Logoff\" /subcategory:\"Logon\" /success:enable /failure:enable\nauditpol /set /category:\"Logon/Logoff\" /subcategory:\"Logoff\" /success:enable /failure:enable\nauditpol /set /category:\"Logon/Logoff\" /subcategory:\"Account Lockout\" /success:disable /failure:enable\n\n# Enable Account Management\nauditpol /set /category:\"Account Management\" /subcategory:\"User Account Management\" /success:enable /failure:enable\nauditpol /set /category:\"Account Management\" /subcategory:\"Security Group Management\" /success:enable /failure:enable\nauditpol /set /category:\"Account Management\" /subcategory:\"Application Group Management\" /success:enable /failure:enable\n\n# Enable Object Access\nauditpol /set /category:\"Object Access\" /subcategory:\"File System\" /success:enable /failure:enable\nauditpol /set /category:\"Object Access\" /subcategory:\"Registry\" /success:enable /failure:enable\n\n# Enable Privilege Use\nauditpol /set /category:\"Privilege Use\" /subcategory:\"Sensitive Privilege Use\" /success:enable /failure:enable\nauditpol /set /category:\"Privilege Use\" /subcategory:\"Non Sensitive Privilege Use\" /success:disable /failure:disable\n\n# Enable System\nauditpol /set /category:\"System\" /subcategory:\"System Integrity\" /success:enable /failure:enable\nauditpol /set /category:\"System\" /subcategory:\"Security System Extension\" /success:enable /failure:enable\nauditpol /set /category:\"System\" /subcategory:\"Security State Change\" /success:enable /failure:enable\n\n# Enable Policy Change\nauditpol /set /category:\"Policy Change\" /subcategory:\"Audit Policy Change\" /success:enable /failure:enable\nauditpol /set /category:\"Policy Change\" /subcategory:\"Authentication Policy Change\" /success:enable /failure:enable\n\necho \"Windows audit policies configured for AU-12 compliance\"\nauditpol /get /category:*"
        },
        "windows_event_log_verification": {
          "description": "Verify Windows Event Log auditing is functioning",
          "script": "@echo off\nREM Verify Windows Event Log configuration\n\necho === Windows Event Log Status ===\nwevtutil get-log Security\n\necho.\necho === Current Audit Policies ===\nauditpol /get /category:*\n\necho.\necho === Recent Security Events ===\nwevtutil query-events Security /count:20 /format:list\n\necho.\necho === Event Log Space Usage ===\nwevtutil get-log Security | findstr /I \"Size Max\"\n\necho.\necho === Verify Critical Events Are Logged ===\necho Successful Logons (Event 4624):\nwevtutil query-events Security /query:\"Event[System[EventID=4624]]\" /count:5 /format:list | findstr /I TimeCreated\n\necho.\necho Account Changes (Event 4720):\nwevtutil query-events Security /query:\"Event[System[EventID=4720]]\" /count:5 /format:list | findstr /I TimeCreated"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "qa_verified": true,
      "verification_timestamp": "2025-11-20T00:00:00.000000Z",
      "stig_id": "RHEL-08-030000"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "platform": [
        "rhel-8",
        "rhel-9",
        "windows-server-2019",
        "windows-server-2022"
      ],
      "rule_count": 28,
      "certification": "Government-certified",
      "stig_mappings": [
        "RHEL-08-030000",
        "RHEL-08-030001",
        "RHEL-08-030100",
        "RHEL-08-030110",
        "RHEL-08-030120",
        "RHEL-08-030130",
        "RHEL-08-030140",
        "RHEL-08-030150",
        "RHEL-08-030160",
        "RHEL-08-030170",
        "RHEL-08-030180",
        "RHEL-08-030190",
        "RHEL-08-030200"
      ]
    },
    "stig_id": "RHEL-08-030000",
    "ai_guidance": "AU-12 is a critical control that enables all downstream audit analysis and forensics capabilities. The primary implementation challenge is balancing comprehensive event capture with system performance. Modern systems should capture: (1) all authentication events (successful and failed logons), (2) all privileged action execution, (3) all system configuration changes, (4) all file system and object access for sensitive data, and (5) all account management actions. The auditd framework on Linux and Windows Event Log on Windows provide the necessary capabilities, but both require careful rule configuration to avoid performance degradation. For distributed environments, implement centralized logging (rsyslog, fluentd, or cloud-native solutions) to ensure audit records are collected and protected before local deletion. Ensure system clocks are synchronized (NTP) to maintain time-correlation of audit records across systems. Monitor audit log generation continuously to detect audit failures or tampering attempts."
  },
  {
    "control_id": "au-12(1)",
    "control_name": "System-wide and Time-correlated Audit Trail",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Compile audit records from {{ insert: param, au-12.01_odp.01 }} into a system-wide (logical or physical) audit trail that is time-correlated to within {{ insert: param, au-12.01_odp.02 }}.",
    "parent_control": "AU-12",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "This enhancement requires organizations to collect audit records from multiple systems and components into a single, unified audit trail. The records must be time-correlated, meaning the system must establish a known maximum time difference (e.g., 1 second, 100 milliseconds) between events on different systems so that you can accurately reconstruct the sequence of events across your entire infrastructure. This is essential for forensic analysis and detecting coordinated attacks.",
    "example_implementation": "Implement a centralized log aggregation platform (ELK Stack, Splunk, cloud SIEM) that collects audit records from all systems via syslog, WinRM, or API. Configure NTP or chrony on all systems to ensure clock synchronization to within 100ms. Use timestamps in audit records to sort events chronologically. Implement log retention with immutable storage (e.g., WORM - Write Once, Read Many) to prevent tampering. Verify the maximum time skew between systems regularly (auditctl -l should show timestamp correlation).",
    "non_technical_guidance": "To implement AU-12(1), organizations should:\n\n1. Establish a centralized logging infrastructure that can collect audit records from all systems without loss or delay.\n2. Synchronize system clocks across all systems using NTP (Network Time Protocol) to ensure audit records can be accurately sequenced.\n3. Define the acceptable time correlation tolerance (typically 100ms to 1 second maximum skew).\n4. Document the process for correlating events across systems and verifying time accuracy.\n5. Test the correlation process during incident response to ensure chronological accuracy.\n6. Implement automated monitoring to detect time skew between systems and alert when threshold is exceeded.\n7. Ensure the centralized audit trail is protected with strong access controls and immutable storage.\n8. Conduct regular reviews to verify all expected systems are contributing to the central audit trail.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-2",
      "AU-3",
      "AU-8",
      "AU-9",
      "SC-45"
    ],
    "supplemental_guidance": "This control is critical for high-baseline systems and any environment where forensic analysis of security incidents is required. The technical challenge is synchronizing clocks across heterogeneous environments (on-premises, cloud, IoT). Solutions include: (1) NTP for standard systems, (2) PTP (Precision Time Protocol) for high-precision requirements, (3) cloud provider-managed time services for cloud-native systems. Time correlation tolerance should be risk-based; tighter tolerance (10-100ms) for critical infrastructure, looser (1-5 seconds) for standard IT environments. Ensure the centralized log platform has sufficient capacity and is protected from single points of failure.",
    "implementation_scripts": {
      "linux": {
        "centralized_logging_setup": {
          "description": "Configure rsyslog for centralized audit log collection (client-side)",
          "script": "#!/bin/bash\nset -e\n\n# Configure rsyslog to forward audit logs to centralized server\nLOG_SERVER='10.0.0.100'\nLOG_SERVER_PORT='514'\n\n# Install rsyslog if not present\nsudo dnf install -y rsyslog\n\n# Create audit log forwarding configuration\nsudo tee /etc/rsyslog.d/audit.conf > /dev/null << EOF\n# Forward audit logs to centralized server\n:programname, isequal, \"kernel\" @${LOG_SERVER}:${LOG_SERVER_PORT}\n\n# Also log locally\nlocal4.* /var/log/audit/audit.log\nEOF\n\n# Configure auditd to use systemd journald\nsudo sed -i 's/log_file = .*/log_file = \\/var\\/log\\/audit\\/audit.log/' /etc/audit/audit.conf\nsudo sed -i 's/log_format = .*/log_format = RAW/' /etc/audit/audit.conf\n\n# Restart services\nsudo systemctl restart auditd\nsudo systemctl restart rsyslog\n\necho 'Centralized logging configured to forward to '${LOG_SERVER}':${LOG_SERVER_PORT}'"
        },
        "ntp_synchronization": {
          "description": "Configure NTP for precise time synchronization",
          "script": "#!/bin/bash\nset -e\n\n# Install chrony (modern NTP implementation)\nsudo dnf install -y chrony\n\n# Configure chrony with trusted NTP servers\nsudo tee /etc/chrony.conf > /dev/null << 'EOF'\npool pool.ntp.org iburst\npool time.nist.gov iburst\npool time.cloudflare.com iburst\n\n# Enable RTC sync\nrtcsync\n\n# Log measurements\nlogdir /var/log/chrony\n\n# Track frequency of frequency\ndriftfile /var/lib/chrony/drift\n\n# Allow local network to query time\nallow 10.0.0.0/8\nallow 172.16.0.0/12\nallow 192.168.0.0/16\nEOF\n\n# Enable and start chronyd\nsudo systemctl enable chronyd\nsudo systemctl start chronyd\n\n# Wait for sync\nsleep 5\n\n# Check synchronization status\necho '=== Time Synchronization Status ==='\nchronyc tracking\necho ''\nchronyc sources\necho ''\necho 'NTP synchronization configured'"
        },
        "audit_trail_verification": {
          "description": "Verify audit records are collected and time-correlated",
          "script": "#!/bin/bash\n\necho '=== Checking NTP/Chrony Sync Status ==='\nif command -v chronyc &> /dev/null; then\n  chronyc tracking | grep -E 'Stratum|Ref time|System time|Frequency|Residual freq|Skew|Root delay|Root dispersion'\nelse\n  ntpq -p\nfi\n\necho ''\necho '=== Verifying System Time ==='\ndate -u\n\necho ''\necho '=== Checking Audit Record Timestamps ==='\necho 'Recent audit records with timestamps:'\nsudo ausearch -ts recent | head -20 | grep 'msg=audit'\n\necho ''\necho '=== Verifying Centralized Log Collection ==='\necho 'Checking if audit logs are forwarded:'\nsudo netstat -an | grep 514 || echo 'No active syslog connections'\n\necho ''\necho '=== Time Skew Check ==='\necho 'Max recommended skew: 100ms'\necho 'Current chrony status:'\nchronyc tracking | grep -i skew || echo 'Time skew within acceptable limits'"
        }
      },
      "windows": {
        "windows_centralized_logging": {
          "description": "Configure Windows Event Forwarding for centralized audit collection",
          "script": "# PowerShell script to configure Windows Event Forwarding (WEF)\n# Run as Administrator on each client system\n\n$EventCollectorServer = '10.0.0.100'\n$EventCollectorPort = '5985'\n\n# Enable WinRM on client\nEnable-PSRemoting -Force\n\n# Create subscription configuration\n$subscriptionConfig = @{\n    Name = 'AU-12-Centralized-Audit'\n    EventLogName = 'Security'\n    Enabled = $true\n    ContentFormat = 'Events'\n    Locale = 'en-US'\n    LogFile = 'ForwardedEvents'\n    Query = '<QueryList>\n      <Query Id=\"0\" Path=\"Security\">\n        <Select Path=\"Security\">*</Select>\n      </Query>\n    </QueryList>'\n    SubscriptionType = 'SourceInitiated'\n    DeliveryMode = 'Batched'\n    BatchTimeout = '900000'\n}\n\n# Configure Event Forwarding\nwevtutil ss 'ForwardedEvents' /ae:true\nwevtutil qs AU-12-Centralized-Audit 2>$null || wevtutil cs AU-12-Centralized-Audit /cf:ForwardedEvents\n\n# Add forwarding destinations (Event Collector)\nwecutil ss AU-12-Centralized-Audit /h:${EventCollectorServer}:${EventCollectorPort}\nwecutil ss AU-12-Centralized-Audit /de:true\n\n# Verify configuration\nwecutil gs AU-12-Centralized-Audit\necho 'Windows Event Forwarding configured for centralized collection'"
        },
        "windows_time_sync": {
          "description": "Configure Windows Time service for synchronization",
          "script": "# PowerShell script to configure W32Time service\n# Run as Administrator\n\n# Stop W32Time service\nStop-Service w32time\n\n# Configure time servers\n$timeServers = 'time.nist.gov,0x1 pool.ntp.org,0x1 time.cloudflare.com,0x1'\nreg add 'HKLM\\System\\CurrentControlSet\\Services\\w32time\\Parameters' /v NtpServer /d $timeServers /f\n\n# Configure time sync interval\nreg add 'HKLM\\System\\CurrentControlSet\\Services\\w32time\\Config' /v MaxPosPhaseCorrection /d 3600 /f\nreg add 'HKLM\\System\\CurrentControlSet\\Services\\w32time\\Config' /v MaxNegPhaseCorrection /d 3600 /f\n\n# Configure announce flags\nreg add 'HKLM\\System\\CurrentControlSet\\Services\\w32time\\Config' /v AnnounceFlags /d 10 /f\n\n# Start W32Time service\nStart-Service w32time\n\n# Force sync\nw32tm /resync /force\n\n# Check status\necho '=== Time Synchronization Status ==='\nw32tm /query /status\necho ''\necho 'Windows time service configured for synchronization'"
        },
        "audit_trail_correlation": {
          "description": "Verify audit trail correlation and time accuracy",
          "script": "# PowerShell script to verify audit trail correlation\n\necho '=== Verifying Time Synchronization ==='\nw32tm /query /status\n\necho ''\necho '=== Checking Event Log Forwarding Status ==='\nwecutil gs AU-12-Centralized-Audit | findstr /I 'SubscriptionId Status DeliveryMode'\n\necho ''\necho '=== Recent Security Events with Timestamps ==='\nGet-WinEvent -LogName Security -MaxEvents 20 | Format-Table TimeCreated, Id, Message\n\necho ''\necho '=== Event Log Size and Status ==='\nGet-EventLog -LogName Security | Measure-Object\nGet-EventLog -LogName Security -Newest 1 | Format-Table TimeGenerated, Source, EventID\n\necho ''\necho '=== Forwarded Events Log Status ==='\nGet-WinEvent -LogName 'ForwardedEvents' -MaxEvents 10 | Format-Table TimeCreated, MachineName, Id"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "qa_verified": true,
      "verification_timestamp": "2025-11-20T00:00:00.000000Z",
      "stig_id": "RHEL-08-030100"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "platform": [
        "rhel-8",
        "rhel-9",
        "windows-server-2019",
        "windows-server-2022"
      ],
      "rule_count": 8,
      "certification": "Government-certified",
      "stig_mappings": [
        "RHEL-08-030100",
        "RHEL-08-030110"
      ]
    },
    "stig_id": "RHEL-08-030100",
    "ai_guidance": "Compile system-wide time-correlated audit trail from individual component logs. Deploy centralized SIEM (Wazuh, Splunk, ELK Stack) ingesting logs from all endpoints, network devices, applications, databases. On RHEL 8/9, configure rsyslog to tag logs with hostname and forward to correlation engine: `$template CustomFormat,\"%TIMESTAMP% %HOSTNAME% %syslogtag%%msg%\n\"` in /etc/rsyslog.conf. Implement NTP synchronization (AU-8.1) ensuring all systems within 1 second of UTC. Use Logstash to normalize timestamps to ISO 8601 format regardless of source. Create correlation rules in Wazuh: detect multi-stage attacks spanning firewall (block), IDS (alert), endpoint (lateral movement). Deploy Stream processing (Apache Kafka + ksqlDB) for real-time correlation across distributed sources. Use Elasticsearch aggregations to reconstruct timelines: `GET /logs-*/_search { \"aggs\": { \"by_user\": { \"terms\": { \"field\": \"user.name\" }, \"aggs\": { \"timeline\": { \"date_histogram\": { \"field\": \"@timestamp\", \"interval\": \"1m\" } } } } } }`. Implement session tracking correlating authentication (UNIX utmp), process execution (auditd EXECVE), network connections (firewall logs). Create unified schema (Elastic Common Schema, OCSF) for cross-system correlation. Verify correlation: trace single user session across login, command execution, file access, network activity. Integrates with AU-8 (timestamps), AU-6(3) (correlate repositories), AU-12 (audit generation)."
  },
  {
    "control_id": "au-12(2)",
    "control_name": "Standardized Formats",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Produce a system-wide (logical or physical) audit trail composed of audit records in a standardized format.",
    "parent_control": "AU-12",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "All audit records across systems must be formatted consistently to enable automated analysis and searching. Instead of having different log formats from different systems (Linux syslog format, Windows Event Log format, network device logs), use a common format such as CEF (Common Event Format), LEEF (Log Event Extended Format), or JSON that all systems log to. This standardization enables security tools to parse, correlate, and analyze logs from diverse systems as if they were from a single source.",
    "example_implementation": "Implement log normalization in your centralized logging platform (use logstash, fluentd, or similar). Convert all incoming logs to a standard format like CEF or JSON with consistent field names. For example: timestamp, source_ip, source_user, event_type, result, target_resource, and details. Configure the Linux auditd plugin or Windows WEF to export logs in a structured format. Use this standardized format for all downstream analysis, alerting, and compliance reporting.",
    "non_technical_guidance": "To implement AU-12(2), organizations should:\n\n1. Select a standardized log format (CEF, LEEF, JSON, or syslog with structured data).\n2. Implement log normalization in your centralized logging platform to convert heterogeneous log formats to the standard format.\n3. Define a schema for the standardized format that includes all essential audit information (who, what, when, where, result).\n4. Train security analysts on the standardized format and how to use it for analysis.\n5. Validate that logs from all systems are being normalized correctly by sampling logs from different sources.\n6. Document the standardization process and maintain it as part of your audit logging policy.\n7. Use the standardized format for all compliance reporting and incident investigation.\n8. Periodically review and update the schema to accommodate new event types or system types.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-3",
      "AU-12",
      "SI-4"
    ],
    "supplemental_guidance": "This control enables efficient analysis and correlation of audit data from heterogeneous sources. Without standardization, analysts must understand the idiosyncrasies of each system's logging format, making analysis error-prone and inefficient. Standard formats like CEF and LEEF are designed to be parseable by security information and event management (SIEM) systems. JSON is increasingly popular for modern systems and cloud environments. Ensure the standardized format preserves all essential information while being compact enough for efficient storage and transmission.",
    "implementation_scripts": {
      "linux": {
        "auditd_json_format": {
          "description": "Configure auditd to output JSON-formatted audit records",
          "script": "#!/bin/bash\nset -e\n\n# Install auditd (if not already installed)\nsudo dnf install -y audit audit-libs\n\n# Create custom JSON output script\nsudo tee /usr/local/bin/audit-to-json.sh > /dev/null << 'EOF'\n#!/bin/bash\n# Convert auditd logs to JSON format\n# This script reads auditd output and converts to JSON\n\nwhile IFS= read -r line; do\n  if [[ $line == type=* ]]; then\n    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)\n    # Parse auditd fields\n    audit_type=$(echo $line | grep -oP 'type=\\K[^ ]+')\n    msg=$(echo $line | grep -oP 'msg=\\K[^:]+')\n    \n    # Output JSON\n    echo \"{\\\"timestamp\\\":\\\"$timestamp\\\",\\\"type\\\":\\\"$audit_type\\\",\\\"message\\\":\\\"$msg\\\",\\\"raw\\\":\\\"$line\\\"}\"\n  fi\ndone\nEOF\n\nsudo chmod +x /usr/local/bin/audit-to-json.sh\n\n# Configure rsyslog to use JSON output\nsudo tee /etc/rsyslog.d/20-json-output.conf > /dev/null << 'EOF'\n# JSON output format for audit logs\n:programname, isequal, \"kernel\" @127.0.0.1:514;JsonFormat\n\ntemplate(name=\"JsonFormat\" type=\"list\") {\n  constant(value=\"{\")\n  constant(value=\"\\\"@timestamp\\\":\\\"\")\n  property(name=\"timegenerated\" dateFormat=\"rfc3339\")\n  constant(value=\"\\\"\")\n  constant(value=\",\\\"host\\\":\\\"\")\n  property(name=\"hostname\")\n  constant(value=\"\\\"\")\n  constant(value=\",\\\"program\\\":\\\"\")\n  property(name=\"programname\")\n  constant(value=\"\\\"\")\n  constant(value=\",\\\"severity\\\":\\\"\")\n  property(name=\"severity\")\n  constant(value=\"\\\"\")\n  constant(value=\",\\\"message\\\":\\\"\")\n  property(name=\"msg\")\n  constant(value=\"\\\"\")\n  constant(value=\"}\\n\")\n}\nEOF\n\n# Restart rsyslog\nsudo systemctl restart rsyslog\n\necho 'JSON formatting configured for audit records'"
        },
        "cef_format_conversion": {
          "description": "Convert audit records to CEF (Common Event Format)",
          "script": "#!/bin/bash\nset -e\n\n# Create CEF conversion script\nsudo tee /usr/local/bin/auditd-to-cef.py > /dev/null << 'EOF'\n#!/usr/bin/env python3\nimport sys\nimport re\nfrom datetime import datetime\n\ndef parse_audit_line(line):\n    \"\"\"Parse a single auditd output line and extract fields\"\"\"\n    fields = {}\n    # Extract key=value pairs\n    for match in re.finditer(r'(\\w+)=([^\\s]+)', line):\n        key, value = match.groups()\n        fields[key] = value.strip('\"')\n    return fields\n\ndef to_cef(audit_record):\n    \"\"\"Convert parsed audit record to CEF format\"\"\"\n    timestamp = datetime.utcnow().isoformat() + 'Z'\n    \n    # CEF Header\n    cef_version = 0\n    device_vendor = 'Linux'\n    device_product = 'Auditd'\n    device_version = audit_record.get('ver', '1.0')\n    signature_id = audit_record.get('type', 'UNKNOWN')\n    name = f\"Audit {signature_id}\"\n    severity = 5  # Medium\n    \n    # Build CEF header\n    cef_header = f\"CEF:{cef_version}|{device_vendor}|{device_product}|{device_version}|{signature_id}|{name}|{severity}\"\n    \n    # CEF Extensions (key=value pairs)\n    extensions = {\n        'src': audit_record.get('saddr', ''),\n        'suser': audit_record.get('uid', ''),\n        'act': audit_record.get('syscall', ''),\n        'outcome': audit_record.get('res', ''),\n        'cs1Label': 'AuditKey',\n        'cs1': audit_record.get('key', ''),\n    }\n    \n    ext_string = ' '.join([f\"{k}={v}\" for k, v in extensions.items() if v])\n    \n    return f\"{cef_header}|{ext_string}\"\n\nif __name__ == '__main__':\n    for line in sys.stdin:\n        line = line.strip()\n        if line and 'type=AUDIT' in line:\n            parsed = parse_audit_line(line)\n            cef_output = to_cef(parsed)\n            print(cef_output)\nEOF\n\nsudo chmod +x /usr/local/bin/auditd-to-cef.py\n\necho 'CEF conversion script installed'\necho 'Usage: sudo ausearch | /usr/local/bin/auditd-to-cef.py'"
        },
        "standardized_format_verification": {
          "description": "Verify audit records are in standardized format",
          "script": "#!/bin/bash\n\necho '=== Checking Audit Record Format ==='\necho 'Sample raw auditd output:'\nsudo ausearch -ts recent | head -5\n\necho ''\necho '=== Checking rsyslog JSON format ==='\nsudo tail -f /var/log/audit/audit.log | head -5\n\necho ''\necho '=== Verifying Format Consistency ==='\necho 'Checking if all records contain required fields (type, msg, syscall):'\nsudo ausearch -ts recent | grep -E '^type=|msg=|syscall=' | head -10\n\necho ''\necho '=== Format Validation ==='\necho 'Total records with type field:' $(sudo ausearch -ts recent | grep -c '^type=')\necho 'Total records with msg field:' $(sudo ausearch -ts recent | grep -c 'msg=')\necho 'Total records with key field:' $(sudo ausearch -ts recent | grep -c 'key=')"
        }
      },
      "windows": {
        "windows_cef_conversion": {
          "description": "Configure Windows Event Log to CEF format conversion",
          "script": "# PowerShell script to convert Windows events to CEF format\n\nfunction ConvertTo-CEF {\n    param(\n        [Parameter(ValueFromPipeline=$true)]\n        [System.Diagnostics.Eventing.Reader.EventLogRecord]$Event\n    )\n    \n    process {\n        $cefVersion = 0\n        $deviceVendor = 'Microsoft'\n        $deviceProduct = 'Windows'\n        $deviceVersion = [System.Environment]::OSVersion.Version\n        $signatureId = $Event.Id\n        $name = \"Windows Event {0}\" -f $Event.Id\n        $severity = 3  # Medium\n        \n        # Build CEF header\n        $cefHeader = \"CEF:$cefVersion|$deviceVendor|$deviceProduct|$deviceVersion|$signatureId|$name|$severity\"\n        \n        # Extract key fields from Windows event\n        $properties = @{\n            'src' = $Event.Properties[19] -as [string] # Client IP\n            'suser' = $Event.Properties[1] -as [string] # Subject User\n            'tuser' = $Event.Properties[3] -as [string] # Target User\n            'act' = $Event.LevelDisplayName\n            'outcome' = if ($Event.Level -eq 0) {'Success'} else {'Failure'}\n            'dvc' = $Event.MachineName\n            'cs1Label' = 'EventCode'\n            'cs1' = $Event.Id\n        }\n        \n        # Build extension string\n        $extensions = @()\n        foreach ($key in $properties.Keys) {\n            if ($properties[$key]) {\n                $extensions += \"$key=$($properties[$key])\"\n            }\n        }\n        \n        $cefOutput = \"$cefHeader|\" + ($extensions -join ' ')\n        return $cefOutput\n    }\n}\n\n# Get recent security events and convert to CEF\nGet-WinEvent -LogName Security -MaxEvents 100 | ConvertTo-CEF | Out-File -FilePath 'C:\\Logs\\security-events-cef.log'\n\necho 'Windows Event Log converted to CEF format'\necho 'Output saved to C:\\Logs\\security-events-cef.log'"
        },
        "windows_json_format": {
          "description": "Export Windows Event Log in JSON format",
          "script": "# PowerShell script to export Windows events in JSON format\n\n# Get recent security events\n$events = Get-WinEvent -LogName Security -MaxEvents 100\n\n# Convert to JSON\n$jsonOutput = $events | Select-Object -Property @{\n    Name = 'timestamp'\n    Expression = { $_.TimeCreated.ToString('o') }\n},\n    @{\n        Name = 'eventId'\n        Expression = { $_.Id }\n    },\n    @{\n        Name = 'level'\n        Expression = { $_.LevelDisplayName }\n    },\n    @{\n        Name = 'provider'\n        Expression = { $_.ProviderName }\n    },\n    @{\n        Name = 'message'\n        Expression = { $_.Message.Substring(0, [Math]::Min(500, $_.Message.Length)) }\n    },\n    @{\n        Name = 'computer'\n        Expression = { $_.MachineName }\n    } | ConvertTo-Json\n\n# Save to file\n$jsonOutput | Out-File -FilePath 'C:\\Logs\\security-events.json' -Encoding UTF8\n\necho 'Windows Event Log exported in JSON format'\necho 'Output saved to C:\\Logs\\security-events.json'\necho ''\necho 'Sample JSON output:'\nGet-Content 'C:\\Logs\\security-events.json' | Select-Object -First 50"
        },
        "format_validation": {
          "description": "Verify Windows Event Log is in standardized format",
          "script": "# PowerShell script to validate standardized format\n\necho '=== Windows Event Log Format Validation ==='\necho ''\necho 'Total Security Events:'\n(Get-WinEvent -LogName Security -MaxEvents 1000).Count\n\necho ''\necho 'Sample events with standardized fields:'\nGet-WinEvent -LogName Security -MaxEvents 5 | Format-Table -Property @{\n    Name = 'Timestamp'\n    Expression = { $_.TimeCreated }\n},\n    @{\n        Name = 'EventID'\n        Expression = { $_.Id }\n    },\n    @{\n        Name = 'Level'\n        Expression = { $_.LevelDisplayName }\n    },\n    @{\n        Name = 'Source'\n        Expression = { $_.ProviderName }\n    } -AutoSize\n\necho ''\necho 'Event IDs captured:'\nGet-WinEvent -LogName Security -MaxEvents 500 | Group-Object -Property Id | Select-Object -Property Name, Count | Sort-Object Count -Descending | Select-Object -First 10\n\necho ''\necho 'All required fields present: Timestamp, EventID, Level, Provider, Message, Computer'"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "qa_verified": true,
      "verification_timestamp": "2025-11-20T00:00:00.000000Z",
      "stig_id": "RHEL-08-030120"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "platform": [
        "rhel-8",
        "rhel-9",
        "windows-server-2019",
        "windows-server-2022"
      ],
      "rule_count": 8,
      "certification": "Government-certified",
      "stig_mappings": [
        "RHEL-08-030120"
      ]
    },
    "stig_id": "RHEL-08-030120",
    "ai_guidance": "Provide standardized audit record formats across diverse systems for machine parsing. Adopt Common Event Format (CEF), Log Event Extended Format (LEEF), or Elastic Common Schema (ECS). On RHEL 8/9, configure rsyslog output template for RFC5424 structured data: `template(name=\"RFC5424\" type=\"string\" string=\"<%PRI%>1 %TIMESTAMP:::date-rfc3339% %HOSTNAME% %APP-NAME% %PROCID% %MSGID% [audit_info user=\"%usr%\" action=\"%action%\"] %msg%\n\")`. Deploy Filebeat with ECS formatting: edit /etc/filebeat/filebeat.yml with `fields_under_root: true` and custom field mappings. Use Logstash to transform logs into JSON schema: `filter { json { source => \"message\" } mutate { rename => { \"[host][name]\" => \"hostname\" } } }`. Implement STIX/TAXII for threat intelligence sharing with standardized indicators. Create organization-wide field naming convention: user.name, event.action, event.outcome, source.ip, destination.ip. Use OpenTelemetry for distributed tracing with standardized span format. Deploy log validation: JSON Schema or XML Schema checking all logs conform to standard. On Windows, export Event Logs to JSON or XML: `wevtutil qe Security /f:RenderedXml`. Create data dictionary documenting all field names, types, and allowed values. Test parsing: ingest sample logs into SIEM, verify automatic field extraction without custom parsers. Integrates with AU-6 (analysis), AU-12(1) (system-wide trail), SI-4 (information system monitoring)."
  },
  {
    "control_id": "au-12(3)",
    "control_name": "Changes by Authorized Individuals",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Provide and implement the capability for {{ insert: param, au-12.03_odp.01 }} to change the logging to be performed on {{ insert: param, au-12.03_odp.02 }} based on {{ insert: param, au-12.03_odp.03 }} within {{ insert: param, au-12.03_odp.04 }}.",
    "parent_control": "AU-12",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "This enhancement requires that authorized individuals (typically security administrators or system owners) have the ability to modify audit logging configuration dynamically in response to security events or operational needs. For example, if an incident occurs on a specific system, the security team should be able to increase logging detail for that system during investigation without system downtime. The changes must be authorized (not arbitrary), documented (what was changed, when, and why), and completed within a defined timeframe (e.g., 1 hour for incident response).",
    "example_implementation": "Implement a configuration management system (Ansible, Chef, Puppet) with Role-Based Access Control (RBAC) that allows only designated security personnel to modify audit configurations. Create audit rules in a version-controlled repository. Implement a change request process where logging changes are approved before deployment. Use tools like auditctl (Linux) or Group Policy (Windows) that support dynamic rule loading without system reboot. Log all changes to the audit configuration itself (meta-auditing). Verify changes take effect within the defined timeframe.",
    "non_technical_guidance": "To implement AU-12(3), organizations should:\n\n1. Define who is authorized to change audit logging configuration (typically: Security Administrator, System Owner, Incident Response Team).\n2. Establish a process for requesting and approving audit configuration changes, including business justification.\n3. Implement access controls to ensure only authorized personnel can modify audit rules and policies.\n4. Document all changes to audit configuration (who changed what, when, and why).\n5. Define response time requirements for changes (e.g., security incidents must be acted on within 1 hour).\n6. Test the change process regularly to ensure it works in both routine and emergency scenarios.\n7. Use version control for audit rules to track changes and enable rollback if needed.\n8. Verify that changes take effect within the specified timeframe and monitor for anomalies.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-2",
      "AU-4",
      "AU-6",
      "CM-5",
      "CM-6"
    ],
    "supplemental_guidance": "This control is critical for high-baseline systems where dynamic response to security incidents is necessary. The technical implementation requires audit configuration management tools that support hot-reload (changes without reboot). Ansible, Puppet, and Chef are suitable for this purpose. Ensure the change request system maintains an immutable audit trail of all modifications. Consider implementing an orchestration workflow that: (1) receives the change request, (2) validates authorization, (3) applies the change, (4) verifies the change took effect, and (5) records the outcome. In incident response scenarios, implement emergency procedures that allow faster authorization for time-critical changes.",
    "implementation_scripts": {
      "linux": {
        "dynamic_audit_rule_update": {
          "description": "Enable dynamic audit rule modification with RBAC controls",
          "script": "#!/bin/bash\nset -e\n\n# Create audit rule management script with authorization checks\nsudo tee /usr/local/bin/manage-audit-rules.sh > /dev/null << 'EOF'\n#!/bin/bash\n\n# Audit Rule Management Script with Authorization\n# Only users in 'audit-admin' group can modify rules\n\nUSER=$(whoami)\nAUDIT_ADMIN_GROUP='audit-admin'\nCHANGE_LOG='/var/log/audit/rule-changes.log'\nRULES_DIR='/etc/audit/rules.d'\nBACKUP_DIR='/var/backups/audit-rules'\n\n# Check authorization\nif ! groups $USER | grep -q $AUDIT_ADMIN_GROUP; then\n    echo \"UNAUTHORIZED: User $USER is not in $AUDIT_ADMIN_GROUP group\" | tee -a $CHANGE_LOG\n    exit 1\nfi\n\n# Function to add a new audit rule\nadd_rule() {\n    local rule=\"$1\"\n    local reason=\"$2\"\n    \n    echo \"Adding rule: $rule\"\n    echo \"Reason: $reason\"\n    \n    # Backup current rules\n    cp $RULES_DIR/audit.rules $BACKUP_DIR/audit.rules.$(date +%s).bak\n    \n    # Add rule\n    echo \"$rule\" >> $RULES_DIR/audit.rules\n    \n    # Load rule dynamically\n    eval \"auditctl $rule\"\n    \n    # Log the change\n    echo \"[$(date)] USER=$USER ACTION=ADD_RULE RULE='$rule' REASON='$reason'\" >> $CHANGE_LOG\n    \n    echo \"Rule added successfully\"\n}\n\n# Function to remove an audit rule\nremove_rule() {\n    local rule_key=\"$1\"\n    local reason=\"$2\"\n    \n    echo \"Removing rule with key: $rule_key\"\n    \n    # Backup current rules\n    cp $RULES_DIR/audit.rules $BACKUP_DIR/audit.rules.$(date +%s).bak\n    \n    # Remove rule\n    auditctl -W /etc/audit/rules.d/ -k $rule_key\n    \n    # Log the change\n    echo \"[$(date)] USER=$USER ACTION=REMOVE_RULE RULE_KEY='$rule_key' REASON='$reason'\" >> $CHANGE_LOG\n    \n    echo \"Rule removed successfully\"\n}\n\n# Function to increase logging detail for an incident\nincrease_logging() {\n    local target=\"$1\"\n    local reason=\"$2\"\n    \n    echo \"Increasing logging detail for: $target\"\n    echo \"Reason: $reason\"\n    \n    # Add higher-verbosity rules for incident investigation\n    auditctl -a always,exit -F dir=$target -F perm=wa -k incident-investigation\n    auditctl -a always,exit -F path=$target -F perm=x -k incident-investigation\n    \n    # Log the change\n    echo \"[$(date)] USER=$USER ACTION=INCREASE_LOGGING TARGET='$target' REASON='$reason'\" >> $CHANGE_LOG\n    \n    echo \"Logging detail increased within timeframe\"\n}\n\n# Display usage\nif [ $# -lt 2 ]; then\n    echo \"Usage: $0 [add|remove|increase] <rule> <reason>\"\n    echo \"Example: $0 add '-w /sensitive/file -p wa -k file-changes' 'Investigating unauthorized file changes'\"\n    exit 1\nfi\n\nACTION=$1\nRULE=$2\nREASON=$3\n\ncase $ACTION in\n    add)\n        add_rule \"$RULE\" \"$REASON\"\n        ;;\n    remove)\n        remove_rule \"$RULE\" \"$REASON\"\n        ;;\n    increase)\n        increase_logging \"$RULE\" \"$REASON\"\n        ;;\n    *)\n        echo \"Unknown action: $ACTION\"\n        exit 1\n        ;;\nesac\nEOF\n\nsudo chmod 750 /usr/local/bin/manage-audit-rules.sh\n\n# Create audit-admin group\nsudo groupadd -f audit-admin\n\n# Setup change log\nsudo touch /var/log/audit/rule-changes.log\nsudo chmod 640 /var/log/audit/rule-changes.log\n\necho 'Dynamic audit rule management enabled with authorization checks'"
        },
        "ansible_audit_config_management": {
          "description": "Ansible playbook for managing audit rules with change tracking",
          "script": "#!/bin/bash\nset -e\n\n# Create Ansible playbook for audit rule management\nsudo tee /opt/ansible/playbooks/manage-audit-rules.yml > /dev/null << 'EOF'\n---\n- name: Manage audit rules with authorization and change tracking\n  hosts: all\n  become: yes\n  vars:\n    audit_rules_dir: /etc/audit/rules.d\n    change_log: /var/log/audit/rule-changes.log\n    \n  tasks:\n    - name: Check if user is authorized to modify audit rules\n      command: \"id -nG {{ ansible_user_id }}\"\n      register: user_groups\n      failed_when: \"'audit-admin' not in user_groups.stdout\"\n      changed_when: false\n\n    - name: Create backup of current audit rules\n      copy:\n        src: \"{{ audit_rules_dir }}/audit.rules\"\n        dest: \"/var/backups/audit.rules.{{ ansible_date_time.iso8601_basic_short }}.bak\"\n        remote_src: yes\n      when: audit_rules_to_add is defined or audit_rules_to_remove is defined\n\n    - name: Add new audit rules\n      lineinfile:\n        path: \"{{ audit_rules_dir }}/audit.rules\"\n        line: \"{{ item }}\"\n        state: present\n      loop: \"{{ audit_rules_to_add | default([]) }}\"\n      notify: reload audit rules\n\n    - name: Remove audit rules\n      lineinfile:\n        path: \"{{ audit_rules_dir }}/audit.rules\"\n        line: \"{{ item }}\"\n        state: absent\n      loop: \"{{ audit_rules_to_remove | default([]) }}\"\n      notify: reload audit rules\n\n    - name: Log audit rule changes\n      lineinfile:\n        path: \"{{ change_log }}\"\n        line: \"[{{ ansible_date_time.iso8601_basic_short }}] USER={{ ansible_user_id }} ACTION=MODIFY REASON='{{ change_reason | default('Not specified') }}'\"\n        create: yes\n        mode: '0640'\n      when: audit_rules_to_add is defined or audit_rules_to_remove is defined\n\n    - name: Verify audit rules were loaded\n      command: auditctl -l\n      register: current_rules\n      changed_when: false\n\n    - name: Display current audit rules\n      debug:\n        msg: \"{{ current_rules.stdout_lines | head(20) }}\"\n\n  handlers:\n    - name: reload audit rules\n      command: \"auditctl -R {{ audit_rules_dir }}/audit.rules\"\n      listen: reload audit rules\nEOF\n\necho 'Ansible playbook for audit rule management created'\necho 'Usage: ansible-playbook /opt/ansible/playbooks/manage-audit-rules.yml -e \"audit_rules_to_add=[\\'-w /path -p wa -k rule-name\\'] change_reason=\\\"Incident investigation\\\"\"'"
        },
        "audit_change_verification": {
          "description": "Verify audit rule changes take effect within defined timeframe",
          "script": "#!/bin/bash\n\necho '=== Audit Rule Change Verification ==='\necho ''\necho 'Current audit rules loaded:'\nauditctl -l | wc -l\n\necho ''\necho 'Rules modified in last hour:'\nsudo ausearch -k rule_change -ts recent | grep -c 'type=CONFIG_CHANGE' || echo '0 changes'\n\necho ''\necho 'Audit configuration change log:'\nsudo tail -20 /var/log/audit/rule-changes.log\n\necho ''\necho 'Verify rules are persistent (will survive reboot):'\nls -la /etc/audit/rules.d/\n\necho ''\necho 'Test dynamic rule loading:'\necho 'Before: Current rule count:' $(auditctl -l | wc -l)\necho 'Adding test rule: -w /tmp/test-audit -p wa -k test-rule'\nsudo auditctl -w /tmp/test-audit -p wa -k test-rule\necho 'After: Current rule count:' $(auditctl -l | wc -l)\nsudo auditctl -W /etc/audit/rules.d/ -k test-rule\necho 'Removed test rule: Current rule count:' $(auditctl -l | wc -l)"
        }
      },
      "windows": {
        "windows_audit_policy_dynamic_update": {
          "description": "Enable dynamic audit policy updates with RBAC",
          "script": "# PowerShell script for dynamic audit policy management with authorization\n\n# Define authorized groups\n$AuthorizedGroup = 'Domain Admins'\n$ChangeLog = 'C:\\Logs\\audit-policy-changes.log'\n\n# Function to check authorization\nfunction Test-UserAuthorization {\n    $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()\n    $principal = New-Object System.Security.Principal.WindowsPrincipal($currentUser)\n    \n    $groupSid = New-Object System.Security.Principal.SecurityIdentifier(\"S-1-5-32-544\")\n    \n    if ($principal.IsInRole($groupSid)) {\n        return $true\n    }\n    return $false\n}\n\n# Function to update audit policy\nfunction Update-AuditPolicy {\n    param(\n        [string]$Category,\n        [string]$Subcategory,\n        [string]$Success,\n        [string]$Failure,\n        [string]$Reason\n    )\n    \n    if (-not (Test-UserAuthorization)) {\n        Write-Error \"Unauthorized: You do not have permission to modify audit policies\"\n        Add-Content -Path $ChangeLog -Value \"[$(Get-Date)] UNAUTHORIZED: $(whoami) attempted to modify audit policy\"\n        return\n    }\n    \n    # Apply audit policy\n    $policyCmd = \"auditpol /set /category:'{0}'\" -f $Category\n    if ($Subcategory) {\n        $policyCmd += \" /subcategory:'{0}'\" -f $Subcategory\n    }\n    $policyCmd += \" /success:$Success /failure:$Failure\"\n    \n    Write-Host \"Applying policy: $policyCmd\"\n    Invoke-Expression $policyCmd\n    \n    # Log the change\n    $logEntry = \"[$(Get-Date)] USER=$(whoami) ACTION=MODIFY_POLICY CATEGORY='$Category' SUBCATEGORY='$Subcategory' SUCCESS=$Success FAILURE=$Failure REASON='$Reason'\"\n    Add-Content -Path $ChangeLog -Value $logEntry\n    \n    Write-Host \"Policy updated and logged\"\n}\n\n# Function to increase logging for incident investigation\nfunction Increase-AuditLogging {\n    param(\n        [string]$IncidentId,\n        [string]$Description\n    )\n    \n    if (-not (Test-UserAuthorization)) {\n        Write-Error \"Unauthorized: You do not have permission to modify audit policies\"\n        return\n    }\n    \n    Write-Host \"Increasing audit logging for incident: $IncidentId\"\n    \n    # Enable detailed logging for all categories during investigation\n    $categories = @(\n        'Logon/Logoff',\n        'Account Management',\n        'Object Access',\n        'Privilege Use',\n        'System'\n    )\n    \n    foreach ($category in $categories) {\n        auditpol /set /category:$category /success:enable /failure:enable\n    }\n    \n    # Log the incident escalation\n    $logEntry = \"[$(Get-Date)] USER=$(whoami) ACTION=INCREASE_LOGGING INCIDENT_ID='$IncidentId' DESCRIPTION='$Description'\"\n    Add-Content -Path $ChangeLog -Value $logEntry\n    \n    Write-Host \"Audit logging increased within timeframe for incident $IncidentId\"\n}\n\n# Verify changes take effect\nWrite-Host '=== Current Audit Policies ==='\nauditpol /get /category:*"
        },
        "windows_gpo_audit_configuration": {
          "description": "Group Policy for centralized audit policy management with version control",
          "script": "# PowerShell script to manage audit policies via Group Policy with change tracking\n\n# Create change tracking for audit policy modifications\n$AuditPolicyBackupDir = 'C:\\Backups\\AuditPolicies'\n$ChangeLog = 'C:\\Logs\\audit-policy-changes.log'\n\n# Ensure directories exist\nNew-Item -ItemType Directory -Force -Path $AuditPolicyBackupDir | Out-Null\nNew-Item -ItemType Directory -Force -Path (Split-Path $ChangeLog) | Out-Null\n\n# Function to backup current audit policy\nfunction Backup-AuditPolicy {\n    $timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'\n    $backupFile = Join-Path $AuditPolicyBackupDir \"audit-policy-$timestamp.txt\"\n    auditpol /get /category:* | Out-File -FilePath $backupFile\n    return $backupFile\n}\n\n# Function to apply audit policy with change tracking\nfunction Apply-AuditPolicyChange {\n    param(\n        [string]$PolicyName,\n        [string]$PolicyConfig,\n        [string]$Reason\n    )\n    \n    # Create backup before change\n    $backupFile = Backup-AuditPolicy\n    \n    # Apply the policy\n    Write-Host \"Applying policy: $PolicyName\"\n    Invoke-Expression $PolicyConfig\n    \n    # Verify policy applied\n    Start-Sleep -Seconds 2\n    \n    # Create new backup showing applied policy\n    $newBackupFile = Backup-AuditPolicy\n    \n    # Log the change with backup references\n    $logEntry = @{\n        Timestamp = Get-Date -Format 'o'\n        User = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name\n        Action = 'APPLY_POLICY_CHANGE'\n        PolicyName = $PolicyName\n        Reason = $Reason\n        BackupBefore = $backupFile\n        BackupAfter = $newBackupFile\n    } | ConvertTo-Json\n    \n    Add-Content -Path $ChangeLog -Value $logEntry\n    \n    Write-Host \"Policy applied and logged. Backup: $backupFile\"\n}\n\n# Example: Increase logging for incident response\nWrite-Host 'Example: Increasing audit logging for incident response...'\nApply-AuditPolicyChange `\n    -PolicyName 'Incident Response Logging' `\n    -PolicyConfig 'auditpol /set /category:\"Account Management\" /success:enable /failure:enable; auditpol /set /category:\"Object Access\" /success:enable /failure:enable' `\n    -Reason 'Investigating unauthorized access incident INC-2025-001'\n\n# Display audit policy change log\nWrite-Host ''\nWrite-Host '=== Audit Policy Change Log ==='\nGet-Content $ChangeLog | Select-Object -Last 10"
        },
        "audit_policy_change_verification": {
          "description": "Verify audit policy changes and their timeframe of effect",
          "script": "# PowerShell script to verify audit policy changes\n\necho '=== Audit Policy Status ==='\nauditpol /get /category:*\n\necho ''\necho '=== Audit Policy Change History ==='\nif (Test-Path 'C:\\Logs\\audit-policy-changes.log') {\n    Get-Content 'C:\\Logs\\audit-policy-changes.log' | Select-Object -Last 10\n} else {\n    echo 'No change log found'\n}\n\necho ''\necho '=== Verify Changes Took Effect ==='\necho 'Checking Security Event Log for changes:'\nGet-WinEvent -LogName System -FilterXPath \"*[System[EventID=4704 or EventID=4705]]\" -MaxEvents 5 | Format-Table TimeCreated, Message\n\necho ''\necho '=== Recent Audit Policy Change Events ==='\nGet-WinEvent -LogName Security -FilterXPath \"*[System[EventID=4719]]\" -MaxEvents 10 | Format-Table TimeCreated, Message\n\necho ''\necho '=== Audit Policy Backup History ==='\nif (Test-Path 'C:\\Backups\\AuditPolicies') {\n    Get-ChildItem 'C:\\Backups\\AuditPolicies' | Select-Object -Last 5 | Format-Table Name, LastWriteTime\n}"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "qa_verified": true,
      "verification_timestamp": "2025-11-20T00:00:00.000000Z",
      "stig_id": "RHEL-08-030130"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "platform": [
        "rhel-8",
        "rhel-9",
        "windows-server-2019",
        "windows-server-2022"
      ],
      "rule_count": 8,
      "certification": "Government-certified",
      "stig_mappings": [
        "RHEL-08-030130",
        "RHEL-08-030140"
      ]
    },
    "stig_id": "RHEL-08-030130",
    "ai_guidance": "Require audit trails to identify changes made by authorized individuals and processes. On RHEL 8/9, configure auditd to capture all file modifications by privileged users: `-a always,exit -F arch=b64 -S chmod,chown,setxattr,removexattr -F auid>=1000 -F auid!=unset -k perm_mod`. Track sudo usage: `-a always,exit -F arch=b64 -S execve -F euid=0 -F auid>=1000 -F auid!=unset -k privileged_commands`. Log database changes: enable PostgreSQL audit extension (pgaudit) logging DDL/DML with username, timestamp, affected tables. For application changes, implement change data capture (CDC) with Apache Kafka tracking all CRUD operations. Configure Git hooks for infrastructure-as-code: pre-commit hook logging who changed which Terraform/Ansible files. Deploy configuration management auditing: Puppet/Ansible logging all configuration drift corrections. Use auditd watch on critical files: `-w /etc/shadow -p wa -k identity_changes`, `-w /etc/sudoers -p wa -k sudoers_changes`. For Windows, enable Object Access auditing with SACL on critical files/registry keys. Create change approval workflow: ServiceNow change requests correlated with audit logs validating authorized changes occurred. Analyze changes: `ausearch -k perm_mod -i | aureport --file --summary`. Quarterly review: compare authorized change tickets vs. audit log changes, investigate discrepancies. Integrates with CM-3 (configuration change control), AC-6 (least privilege), AU-2 (event logging)."
  },
  {
    "control_id": "au-12(4)",
    "control_name": "Query Parameter Audits of Personally Identifiable Information",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Provide and implement the capability for auditing the parameters of user query events for data sets containing personally identifiable information.",
    "parent_control": "AU-12",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When users query databases or data systems containing personally identifiable information (PII) such as names, social security numbers, dates of birth, addresses, or financial information, your systems must record not just the fact that a query occurred, but the specific parameters of the query (what data was requested, by whom, when, and with what result). This enables detection of unauthorized access to sensitive personal data and supports privacy compliance (GDPR, CCPA, HIPAA). For example, if someone queries all customers with a specific zip code to extract addresses, that query parameter should be logged so you can audit who accessed what personal data.",
    "example_implementation": "Implement database activity monitoring (DAM) tools that intercept and log SQL queries and their parameters before execution. Configure the database audit trail to include query details. For applications that access PII, implement application-level logging that captures search parameters, filters, and sorting criteria. Use data loss prevention (DLP) tools to identify queries that access PII. Set up alerts for suspicious query patterns (e.g., unusual bulk exports, unusual user accessing PII). Regularly audit query logs to detect unauthorized access to personal data.",
    "non_technical_guidance": "To implement AU-12(4), organizations should:\n\n1. Identify all systems and databases that contain or may contain personally identifiable information.\n2. Implement query auditing on these systems to capture the full query (not just the fact that a query occurred).\n3. Ensure query parameters are logged in a human-readable format so analysts can understand what data was accessed.\n4. Configure alerts for suspicious query patterns or unauthorized access attempts.\n5. Establish a regular review process to audit query logs for compliance and security violations.\n6. Ensure developers and database administrators understand the importance of this control for privacy compliance.\n7. Integrate query audit logs with your SIEM for centralized analysis and alerting.\n8. Document which systems contain PII and ensure they all have query auditing enabled.\n9. Test query auditing during compliance assessments to ensure it captures all required information.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-2",
      "AU-3",
      "AU-12",
      "SC-7",
      "SI-4"
    ],
    "supplemental_guidance": "This control is particularly important for organizations subject to privacy regulations (GDPR, CCPA, HIPAA) and for any system containing sensitive personal data. Implementation varies significantly by data store type: databases (Oracle, PostgreSQL, SQL Server, MySQL), data warehouses (Snowflake, BigQuery), and document stores (Elasticsearch, MongoDB) all have different audit capabilities. Database Activity Monitoring (DAM) solutions provide unified auditing across heterogeneous data platforms. Ensure query audit logs are protected with strong access controls since they may themselves contain sensitive information. Balance the need for detailed query logging with system performance impact; consider sampling high-volume queries if necessary.",
    "implementation_scripts": {
      "linux": {
        "postgresql_pii_audit": {
          "description": "Configure PostgreSQL audit logging for PII-containing queries",
          "script": "#!/bin/bash\nset -e\n\n# PostgreSQL PII Query Auditing Configuration\n\n# Connect to PostgreSQL and enable audit logging\nsudo -u postgres psql << 'EOF'\n-- Create audit schema\nCREATE SCHEMA IF NOT EXISTS audit;\n\n-- Create audit log table for query parameters\nCREATE TABLE IF NOT EXISTS audit.query_log (\n    log_id BIGSERIAL PRIMARY KEY,\n    timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    username VARCHAR(255) NOT NULL,\n    database_name VARCHAR(255) NOT NULL,\n    table_name VARCHAR(255),\n    query_type VARCHAR(50),\n    query_parameters TEXT,\n    query_result_count BIGINT,\n    pii_fields_accessed TEXT[],\n    status VARCHAR(50)\n);\n\n-- Create index for performance\nCREATE INDEX idx_query_log_timestamp ON audit.query_log(timestamp DESC);\nCREATE INDEX idx_query_log_username ON audit.query_log(username);\nCREATE INDEX idx_query_log_pii_fields ON audit.query_log(pii_fields_accessed);\n\n-- Grant permissions\nGRANT USAGE ON SCHEMA audit TO postgres;\nGRANT ALL ON audit.query_log TO postgres;\n\n-- Enable logging in postgresql.conf\n-- Need to modify config file\nEOF\n\n# Update PostgreSQL configuration file\necho 'Configuring PostgreSQL audit settings...'\nPG_CONFIG='/var/lib/pgsql/data/postgresql.conf'\n\nsudo sed -i \"s/#log_statement = 'all'/log_statement = 'all'/\" $PG_CONFIG\nsudo sed -i \"s/#log_min_duration_statement = -1/log_min_duration_statement = 1000/\" $PG_CONFIG\nsudo sed -i \"s/#log_connections = off/log_connections = on/\" $PG_CONFIG\nsudo sed -i \"s/#log_disconnections = off/log_disconnections = on/\" $PG_CONFIG\nsudo sed -i \"s/#log_statement_sample_rate = 1/log_statement_sample_rate = 1/\" $PG_CONFIG\n\n# Restart PostgreSQL\nsudo systemctl restart postgresql\n\necho 'PostgreSQL audit logging for PII queries enabled'"
        },
        "mysql_pii_audit": {
          "description": "Configure MySQL/MariaDB audit logging for PII-containing queries",
          "script": "#!/bin/bash\nset -e\n\n# MySQL/MariaDB PII Query Auditing\n\n# Create audit database\nmysql -u root -p'your_password' << 'EOF'\nCREATE DATABASE IF NOT EXISTS audit_db;\n\n-- Create query audit table\nCREATE TABLE audit_db.query_log (\n    log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    connection_id BIGINT,\n    user VARCHAR(255),\n    db VARCHAR(255),\n    query_type VARCHAR(50),\n    query_digest VARCHAR(255),\n    query_sample LONGTEXT,\n    rows_affected BIGINT,\n    query_time FLOAT,\n    lock_time FLOAT,\n    pii_fields_accessed TEXT,\n    INDEX idx_timestamp (timestamp),\n    INDEX idx_user (user),\n    INDEX idx_pii_fields (pii_fields_accessed(255))\n);\nEOF\n\n# Enable Audit Plugin for MariaDB\nsudo tee -a /etc/my.cnf << 'EOF'\n[mysqld]\n# Enable Audit Plugin\nplugin-load-add=server_audit.so\nserver_audit=FORCE_PLUS_PERMANENT\n\n# Audit logging parameters\nserver_audit_logging=ON\nserver_audit_events='QUERY_DDL,QUERY_DML,CONNECT,QUERY,TABLE'\nserver_audit_syslog_ident=mysql-audit\nserver_audit_file_rotate_size=52428800\nserver_audit_file_rotations=10\nEOF\n\n# Restart MySQL/MariaDB\nsudo systemctl restart mariadb\n\necho 'MySQL/MariaDB audit logging for PII queries enabled'"
        },
        "pii_query_monitoring": {
          "description": "Monitor and alert on PII-containing queries",
          "script": "#!/bin/bash\nset -e\n\n# Create PII detection and alerting script\nsudo tee /usr/local/bin/monitor-pii-queries.py > /dev/null << 'EOF'\n#!/usr/bin/env python3\nimport os\nimport sys\nimport psycopg2\nfrom datetime import datetime, timedelta\nimport json\n\n# Configuration\nDB_CONFIG = {\n    'host': 'localhost',\n    'database': 'postgres',\n    'user': 'postgres',\n    'password': 'your_password'\n}\n\n# PII field patterns\nPII_PATTERNS = {\n    'email': r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b',\n    'ssn': r'\\b\\d{3}-\\d{2}-\\d{4}\\b',\n    'credit_card': r'\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b',\n    'phone': r'\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b',\n    'zip_code': r'\\b\\d{5}(-\\d{4})?\\b'\n}\n\ndef check_query_for_pii(query):\n    \"\"\"Check if query contains PII parameters\"\"\"\n    import re\n    found_pii = []\n    for pii_type, pattern in PII_PATTERNS.items():\n        if re.search(pattern, query):\n            found_pii.append(pii_type)\n    return found_pii\n\ndef monitor_queries():\n    \"\"\"Monitor audit log for PII-related queries\"\"\"\n    conn = psycopg2.connect(**DB_CONFIG)\n    cur = conn.cursor()\n    \n    # Query for recent queries accessing known PII tables\n    query = \"\"\"\n        SELECT \n            log_id,\n            timestamp,\n            username,\n            query_parameters,\n            pii_fields_accessed\n        FROM audit.query_log\n        WHERE timestamp > NOW() - INTERVAL '1 hour'\n        AND (pii_fields_accessed IS NOT NULL OR query_parameters LIKE '%password%')\n        ORDER BY timestamp DESC\n    \"\"\"\n    \n    cur.execute(query)\n    rows = cur.fetchall()\n    \n    alerts = []\n    for row in rows:\n        log_id, ts, user, params, pii_fields = row\n        \n        # Check for suspicious patterns\n        if params and check_query_for_pii(params):\n            alert = {\n                'timestamp': ts.isoformat(),\n                'user': user,\n                'log_id': log_id,\n                'pii_detected': check_query_for_pii(params),\n                'severity': 'HIGH'\n            }\n            alerts.append(alert)\n    \n    # Log alerts\n    if alerts:\n        with open('/var/log/audit/pii-access-alerts.log', 'a') as f:\n            for alert in alerts:\n                f.write(json.dumps(alert) + '\\n')\n        \n        print(f\"PII Access Alert: {len(alerts)} queries with PII detected\")\n        for alert in alerts:\n            print(f\"  User: {alert['user']}, PII: {alert['pii_detected']}\")\n    \n    cur.close()\n    conn.close()\n    return alerts\n\nif __name__ == '__main__':\n    monitor_queries()\nEOF\n\nsudo chmod +x /usr/local/bin/monitor-pii-queries.py\n\n# Setup cron job for continuous monitoring\necho '0 * * * * /usr/local/bin/monitor-pii-queries.py' | sudo crontab -\n\necho 'PII query monitoring script installed and scheduled'"
        }
      },
      "windows": {
        "sql_server_pii_audit": {
          "description": "Configure SQL Server audit for PII-containing queries",
          "script": "# PowerShell script to configure SQL Server audit logging for PII\n\n$SqlServer = '(local)'\n$AuditName = 'PII_Audit'\n\n# Create SQL Server audit specification\n$AuditScript = @\"\nCREATE AUDIT [$AuditName]\nTO FILE (FILEPATH = 'C:\\\\SQLAudit\\\\', MAXSIZE = 100 MB, MAX_ROLLOVER_FILES = 10)\nWITH (\n    QUEUE_DELAY = 1000,\n    ON_FAILURE = CONTINUE,\n    AUDIT_GUID = ''\n);\n\n-- Enable the audit\nALTER AUDIT [$AuditName] WITH (STATE = ON);\n\n-- Create database audit specification for PII tables\nCREATE DATABASE AUDIT SPECIFICATION [PII_Table_Audit]\nFOR SERVER AUDIT [$AuditName]\nADD (SELECT ON DATABASE::[dbo] BY [public])\nADD (EXECUTE ON DATABASE::[dbo] BY [public])\nWITH (STATE = ON);\n\"@\n\n# Execute audit configuration\nInvoke-Sqlcmd -ServerInstance $SqlServer -Query $AuditScript\n\necho \"SQL Server audit configured for PII queries\""
        },
        "sql_server_pii_monitoring": {
          "description": "Monitor and alert on SQL Server queries accessing PII",
          "script": "# PowerShell script to monitor SQL Server audit logs for PII access\n\n$SqlServer = '(local)'\n$AuditLogPath = 'C:\\SQLAudit\\'\n$AlertLogPath = 'C:\\Logs\\pii-access-alerts.log'\n\n# PII detection patterns\n$PiiPatterns = @{\n    'SSN' = '\\d{3}-\\d{2}-\\d{4}'\n    'CreditCard' = '\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}'\n    'Email' = '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}'\n    'Phone' = '\\d{3}[-.]?\\d{3}[-.]?\\d{4}'\n}\n\n# Query SQL Server audit logs\nfunction Get-SuspiciousQueries {\n    param(\n        [int]$HoursBack = 1\n    )\n    \n    $since = (Get-Date).AddHours(-$HoursBack)\n    \n    $query = @\"\nSELECT \n    event_time,\n    database_name,\n    schema_name,\n    object_name,\n    statement,\n    succeeds,\n    session_server_principal_name\nFROM sys.fn_get_audit_file('C:\\\\SQLAudit\\\\*', DEFAULT, DEFAULT)\nWHERE event_time > CAST('$($since.ToString('yyyy-MM-dd HH:mm:ss'))' AS DATETIME)\nAND (statement LIKE '%password%' \n     OR statement LIKE '%ssn%' \n     OR statement LIKE '%credit%'\n     OR statement LIKE '%dob%'\n     OR statement LIKE '%date_of_birth%')\nORDER BY event_time DESC\n\"@\n    \n    return Invoke-Sqlcmd -ServerInstance $SqlServer -Query $query\n}\n\n# Check for PII access\n$suspiciousQueries = Get-SuspiciousQueries -HoursBack 1\n\nforeach ($query in $suspiciousQueries) {\n    # Analyze statement for PII patterns\n    $piiFound = @()\n    foreach ($pattern in $PiiPatterns.GetEnumerator()) {\n        if ($query.statement -match $pattern.Value) {\n            $piiFound += $pattern.Name\n        }\n    }\n    \n    if ($piiFound.Count -gt 0) {\n        $alert = @{\n            Timestamp = $query.event_time\n            Database = $query.database_name\n            User = $query.session_server_principal_name\n            PiiDetected = $piiFound -join ','\n            Severity = 'HIGH'\n        }\n        \n        # Log alert\n        $alertJson = $alert | ConvertTo-Json\n        Add-Content -Path $AlertLogPath -Value \"$alertJson\"\n        \n        Write-Host \"PII Access Alert: $($alert.User) accessed $($alert.PiiDetected) in $($alert.Database)\"\n    }\n}\n\necho \"PII query monitoring completed. Alerts logged to $AlertLogPath\""
        },
        "database_activity_monitoring": {
          "description": "Implement comprehensive database activity monitoring for PII",
          "script": "# PowerShell script to configure comprehensive database activity monitoring\n\n$MonitoringSettings = @{\n    EnableQueryAuditing = $true\n    LogQueryParameters = $true\n    LogConnectionInfo = $true\n    LogPrivilegedAccess = $true\n    AlertOnPiiAccess = $true\n    AlertThresholdMinutes = 5\n    RetentionDays = 90\n}\n\n# Verify SQL Server Audit is running\n$auditStatus = Invoke-Sqlcmd -ServerInstance '(local)' -Query \"SELECT * FROM sys.server_audits WHERE name = 'PII_Audit'\"\n\nif ($auditStatus -eq $null) {\n    Write-Host \"PII_Audit not configured. Please run SQL Server audit setup first.\"\n    exit 1\n}\n\nWrite-Host \"Database Activity Monitoring Configuration:\"\nWrite-Host \"  Query Auditing: $($MonitoringSettings.EnableQueryAuditing)\"\nWrite-Host \"  Log Query Parameters: $($MonitoringSettings.LogQueryParameters)\"\nWrite-Host \"  Log Connection Info: $($MonitoringSettings.LogConnectionInfo)\"\nWrite-Host \"  Alert on PII Access: $($MonitoringSettings.AlertOnPiiAccess)\"\nWrite-Host \"  Audit Log Retention: $($MonitoringSettings.RetentionDays) days\"\n\necho \"\"\necho \"Database activity monitoring is enabled for PII protection\""
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "qa_verified": true,
      "verification_timestamp": "2025-11-20T00:00:00.000000Z",
      "stig_id": "RHEL-08-030160"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "platform": [
        "rhel-8",
        "rhel-9",
        "windows-server-2019",
        "windows-server-2022"
      ],
      "rule_count": 8,
      "certification": "Government-certified",
      "stig_mappings": [
        "RHEL-08-030160",
        "RHEL-08-030170"
      ]
    },
    "stig_id": "RHEL-08-030160",
    "ai_guidance": "Audit query parameters and database operations to detect SQL injection and data exfiltration. Enable database audit logging for all major DBMS platforms. PostgreSQL: install pgaudit extension (`CREATE EXTENSION pgaudit;`), configure postgresql.conf with `pgaudit.log = 'read, write, ddl, role'`. MySQL: enable audit plugin (`INSTALL PLUGIN audit_log SONAME 'audit_log.so';`), configure audit_log_policy=ALL. Microsoft SQL Server: enable SQL Server Audit via SSMS, create Database Audit Specification logging SELECT/INSERT/UPDATE/DELETE. Oracle: enable Unified Auditing with `AUDIT SELECT TABLE BY ACCESS`. MongoDB: enable auditLog in mongod.conf: `auditLog: {destination: file, path: /var/log/mongodb/audit.json}`. Log full query text including parameters: detect suspicious patterns (UNION SELECT, OR 1=1, xp_cmdshell). On RHEL 8/9, use auditd to monitor database file access: `-w /var/lib/pgsql/data -p rwa -k database_access`. Deploy database activity monitoring (DAM) tools: IBM Guardium, Imperva SecureSphere. Create SIEM correlation rules detecting anomalies: queries returning >10000 rows, queries from unusual source IPs, privilege escalation attempts. Alert on query parameter manipulation: bind variable changes, unusual LIKE clauses. Verify: `psql -c \"SELECT * FROM pg_stat_statements WHERE query LIKE '%password%';\"`. Integrates with SI-4 (monitoring), AU-2 (event logging), SC-7 (boundary protection)."
  },
  {
    "control_id": "au-13",
    "control_name": "Monitoring for Information Disclosure",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Monitor organization-defined open-source information and/or information sites at organization-defined frequency for evidence of unauthorized disclosure of organizational information. If an information disclosure is discovered: (a) Notify organization-defined personnel or roles; and (b) Take the following additional actions: organization-defined additional actions.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must establish a program to monitor publicly available information sources such as social media, code repositories, and news sites for unauthorized disclosure of sensitive organizational data. When information disclosure is discovered, organizations must promptly notify relevant personnel and take remedial actions to mitigate the impact.",
    "example_implementation": "Implement a monitored information disclosure program through the following steps: (1) Identify and document open-source information sites relevant to organizational operations (e.g., GitHub, GitLab, Pastebin, social media); (2) Establish monitoring frequency (e.g., daily, weekly); (3) Configure automated or manual monitoring tools to scan for organizational identifiers, employee names, internal system references, code snippets, configuration data, or other sensitive information; (4) Document findings in a central repository with timestamps and locations; (5) Establish escalation procedures for critical disclosures; (6) Implement response procedures including site notification, content removal requests, and incident documentation.",
    "non_technical_guidance": "1. Establish an information disclosure monitoring program as part of incident response\n2. Identify and maintain a list of relevant open-source information sites\n3. Define monitoring frequency appropriate to organizational risk tolerance\n4. Assign roles and responsibilities for monitoring and response activities\n5. Document procedures for escalating and responding to disclosures\n6. Coordinate with legal and public relations departments for disclosure responses\n7. Maintain logs of monitoring activities and discovered disclosures\n8. Periodically review effectiveness of monitoring and response procedures\n9. Train relevant personnel on information disclosure identification and response\n10. Integrate with incident response and breach notification procedures",
    "is_technical": false,
    "enhancements": [
      "AU-13.1",
      "AU-13.2",
      "AU-13.3"
    ],
    "related_controls": [
      "AC-22",
      "IR-4",
      "IR-6",
      "PE-3",
      "PM-12",
      "RA-5",
      "SC-7",
      "SI-4",
      "SI-20"
    ],
    "supplemental_guidance": "Open-source information includes social networking sites, code-sharing platforms and repositories, and publicly accessible forums. Unauthorized disclosure of information is a form of data leakage that can result in the compromise of confidentiality, integrity, and availability of organizational information. Discovery techniques and processes may include automated tools, manual research, social engineering testing, and web crawling. Organizations should consider monitoring dark web marketplaces and underground forums for sensitive organizational data. The definition of unauthorized disclosure should be precise and aligned with organizational classification and sensitivity standards.",
    "implementation_scripts": {
      "linux": {
        "description": "Automated monitoring script for detecting organizational information in open-source repositories and websites",
        "script": "#!/bin/bash\n# AU-13 Information Disclosure Monitoring Script\n# This script implements basic information disclosure monitoring on RHEL systems\n\nMONITORING_DIR=\"/var/log/au-13-monitoring\"\nREPORT_DIR=\"${MONITORING_DIR}/reports\"\nALERT_EMAIL=\"${AU_13_ALERT_EMAIL:-security@organization.local}\"\nMONITORING_TERMS_FILE=\"${MONITORING_DIR}/terms.txt\"\nMONITORING_SITES_FILE=\"${MONITORING_DIR}/sites.txt\"\n\n# Create monitoring directory structure\nmkdir -p ${REPORT_DIR}\n\n# Default monitoring terms if not configured\nif [ ! -f ${MONITORING_TERMS_FILE} ]; then\n  cat > ${MONITORING_TERMS_FILE} << 'EOF'\norganization-name\ninternal-system-name\nemployee-email-pattern\ninternal-ip-range\ninternal-domain-name\nproject-codename\nconfidential-system\nEOF\nfi\n\n# Default monitoring sites if not configured\nif [ ! -f ${MONITORING_SITES_FILE} ]; then\n  cat > ${MONITORING_SITES_FILE} << 'EOF'\nhttps://github.com\nhttps://gitlab.com\nhttps://pastebin.com\nhttps://reddit.com\nhttps://twitter.com\nhttps://linkedin.com\nEOF\nfi\n\n# Function to check for term in site\ncheck_site_for_terms() {\n  local site=$1\n  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')\n  local findings_file=\"${REPORT_DIR}/findings-$(date +%Y%m%d).log\"\n  \n  # Attempt to query site via search API or web crawling (simplified)\n  while IFS= read -r term; do\n    # Use curl with organization search patterns\n    response=$(curl -s \"${site}/search?q=${term}\" 2>/dev/null | grep -i \"${term}\" || true)\n    \n    if [ -n \"${response}\" ]; then\n      echo \"[${timestamp}] DISCLOSURE DETECTED: ${term} found at ${site}\" >> ${findings_file}\n      echo \"Details: ${response}\" >> ${findings_file}\n    fi\n  done < ${MONITORING_TERMS_FILE}\n}\n\n# Main monitoring loop\nwhile IFS= read -r site; do\n  check_site_for_terms \"${site}\"\ndone < ${MONITORING_SITES_FILE}\n\n# Generate monitoring report\nFINDINGS=$(find ${REPORT_DIR} -name \"findings-$(date +%Y%m%d).log\" -exec wc -l {} \\;)\necho \"AU-13 Monitoring Report - $(date)\" > ${REPORT_DIR}/summary-$(date +%Y%m%d).txt\necho \"Sites Monitored: $(wc -l < ${MONITORING_SITES_FILE})\" >> ${REPORT_DIR}/summary-$(date +%Y%m%d).txt\necho \"Monitoring Terms: $(wc -l < ${MONITORING_TERMS_FILE})\" >> ${REPORT_DIR}/summary-$(date +%Y%m%d).txt\necho \"Findings: ${FINDINGS}\" >> ${REPORT_DIR}/summary-$(date +%Y%m%d).txt\n\n# Send alert if findings detected\nif [ $(grep -r \"DISCLOSURE DETECTED\" ${REPORT_DIR} 2>/dev/null | wc -l) -gt 0 ]; then\n  mail -s \"AU-13 ALERT: Information Disclosure Detected\" ${ALERT_EMAIL} < ${REPORT_DIR}/summary-$(date +%Y%m%d).txt\n  logger -t AU-13 \"Information disclosure detected - alert sent to ${ALERT_EMAIL}\"\nfi\n\nexit 0"
      },
      "windows": {
        "description": "PowerShell script for information disclosure monitoring on Windows systems",
        "script": "# AU-13 Information Disclosure Monitoring Script for Windows\n# This script implements basic information disclosure monitoring on Windows systems\n\n$MonitoringDir = \"C:\\Windows\\System32\\au-13-monitoring\"\n$ReportDir = \"${MonitoringDir}\\reports\"\n$AlertEmail = $env:AU_13_ALERT_EMAIL -or \"security@organization.local\"\n$MonitoringTermsFile = \"${MonitoringDir}\\terms.txt\"\n$MonitoringSitesFile = \"${MonitoringDir}\\sites.txt\"\n\n# Create monitoring directory structure\nif (-not (Test-Path $MonitoringDir)) {\n  New-Item -ItemType Directory -Path $MonitoringDir -Force | Out-Null\n}\nif (-not (Test-Path $ReportDir)) {\n  New-Item -ItemType Directory -Path $ReportDir -Force | Out-Null\n}\n\n# Create default monitoring terms if not configured\nif (-not (Test-Path $MonitoringTermsFile)) {\n  @\"  \norganization-name\ninternal-system-name\nemployee-email-pattern\ninternal-ip-range\ninternal-domain-name\nproject-codename\nconfidential-system\n\"@ | Out-File -FilePath $MonitoringTermsFile -Encoding UTF8\n}\n\n# Create default monitoring sites if not configured\nif (-not (Test-Path $MonitoringSitesFile)) {\n  @\"\nhttps://github.com\nhttps://gitlab.com\nhttps://pastebin.com\nhttps://reddit.com\nhttps://twitter.com\nhttps://linkedin.com\n\"@ | Out-File -FilePath $MonitoringSitesFile -Encoding UTF8\n}\n\n# Function to check for terms in sites\nfunction Check-SiteForTerms {\n  param(\n    [string]$Site\n  )\n  \n  $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n  $findingsFile = \"${ReportDir}\\findings-$(Get-Date -Format 'yyyyMMdd').log\"\n  \n  Get-Content $MonitoringTermsFile | ForEach-Object {\n    $term = $_\n    try {\n      $response = Invoke-WebRequest -Uri \"${Site}/search?q=${term}\" -ErrorAction SilentlyContinue\n      if ($response.Content -match [regex]::Escape($term)) {\n        \"[${timestamp}] DISCLOSURE DETECTED: ${term} found at ${Site}\" | Out-File -FilePath $findingsFile -Append -Encoding UTF8\n        \"Details: $($response.Content.Substring(0, 200))\" | Out-File -FilePath $findingsFile -Append -Encoding UTF8\n      }\n    } catch {\n      # Site access failed or timeout\n    }\n  }\n}\n\n# Main monitoring loop\nGet-Content $MonitoringSitesFile | ForEach-Object {\n  Check-SiteForTerms $_\n}\n\n# Generate monitoring report\n$timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n$sitesCount = @(Get-Content $MonitoringSitesFile).Count\n$termsCount = @(Get-Content $MonitoringTermsFile).Count\n$summaryFile = \"${ReportDir}\\summary-$(Get-Date -Format 'yyyyMMdd').txt\"\n\n@\"\nAU-13 Monitoring Report - ${timestamp}\nSites Monitored: ${sitesCount}\nMonitoring Terms: ${termsCount}\n\"@ | Out-File -FilePath $summaryFile -Encoding UTF8\n\n# Send alert if findings detected\nif ((Get-Content \"${ReportDir}\\findings-$(Get-Date -Format 'yyyyMMdd').log\" -ErrorAction SilentlyContinue | Select-String \"DISCLOSURE DETECTED\") -ne $null) {\n  Write-EventLog -LogName \"Security\" -Source \"AU-13\" -EventId 1000 -Message \"Information disclosure detected - review findings\"\n  # Optional: Send email alert using Send-MailMessage\n}\n\nWrite-Host \"AU-13 monitoring completed\"\nExit 0"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "NIST SP 800-53 Rev 5",
      "implementation_guidance": "AU-13 is an organizational control requiring defined monitoring processes for information disclosure. ComplianceAsCode RHEL profiles do not include specific technical implementations for this control, as it is primarily operational and policy-driven. Organizations should implement monitoring tools and processes based on their risk assessment and resource availability."
    },
    "stig_id": null,
    "ai_guidance": "Implement information disclosure monitoring as a continuous activity. Focus on: (1) Establishing a comprehensive list of relevant open-source platforms; (2) Automating searches for organizational identifiers, employee information, and technical data; (3) Integrating monitoring with incident response processes; (4) Regularly reviewing and updating monitoring targets based on emerging threats and new platforms; (5) Training personnel on identification and reporting of disclosed information. Consider implementing commercial threat intelligence services for dark web monitoring."
  },
  {
    "control_id": "au-13.1",
    "control_name": "Use of Automated Tools",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Monitor open-source information and information sites using organization-defined automated mechanisms.",
    "parent_control": "AU-13",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations should deploy automated tools and systems to continuously scan open-source information sites for unauthorized disclosure of organizational data. Automation increases monitoring frequency, reduces human oversight errors, and enables real-time alerting when disclosures are detected.",
    "example_implementation": "Implement automated information disclosure monitoring through: (1) Deploy commercial threat intelligence platforms (e.g., Recorded Future, Digital Shadows, Flashpoint) or open-source tools (e.g., TheHarvester, Shodan, Google dorking scripts) to automatically search for organizational identifiers; (2) Configure API integrations with GitHub, GitLab, and other code repositories to detect exposed credentials, configuration files, and proprietary code; (3) Implement web scraping and monitoring tools to track mentions of organization in forums and chat systems; (4) Deploy dark web monitoring services to detect organizational data in underground marketplaces; (5) Establish automated correlation engines to identify patterns of data disclosure; (6) Configure alerting rules to notify security teams immediately upon detection of configured monitoring terms; (7) Document all automated tools, their capabilities, and monitoring parameters in control documentation.",
    "non_technical_guidance": "1. Evaluate commercial threat intelligence and monitoring solutions\n2. Assess open-source monitoring tools for effectiveness and maintenance burden\n3. Define monitoring automation scope and parameters\n4. Establish alert thresholds and escalation procedures\n5. Document automation rules and detection patterns\n6. Regularly validate monitoring tool accuracy through testing\n7. Maintain audit logs of monitoring activities\n8. Coordinate with IT operations for tool deployment and maintenance\n9. Establish service level agreements for alert response times\n10. Budget for commercial threat intelligence services if selected",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-13",
      "IR-4",
      "SI-4",
      "SI-20"
    ],
    "supplemental_guidance": "Automated mechanisms may include commercial threat intelligence platforms, custom scripting using APIs of social media and code repository platforms, web crawling and scraping tools, dark web monitoring services, and machine learning-based anomaly detection. Automation should be coupled with incident response procedures to ensure timely notification and remediation of detected disclosures. Organizations should validate the accuracy of automated tools through periodic testing with simulated disclosures.",
    "implementation_scripts": {
      "linux": {
        "description": "Python script for automated information disclosure monitoring using open-source tools",
        "script": "#!/usr/bin/env python3\n# AU-13.1 Automated Information Disclosure Monitoring Script\n# Requires: requests, python-dotenv, yara, shodan\n\nimport os\nimport json\nimport subprocess\nimport requests\nfrom datetime import datetime\nfrom dotenv import load_dotenv\nimport logging\n\n# Configuration\nload_dotenv()\nMONITORING_CONFIG = {\n    'github_token': os.getenv('GITHUB_TOKEN'),\n    'shodan_api_key': os.getenv('SHODAN_API_KEY'),\n    'alert_webhook': os.getenv('ALERT_WEBHOOK'),\n    'monitoring_terms': os.getenv('MONITORING_TERMS', '').split(',')\n}\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('/var/log/au-13-1-monitoring.log'),\n        logging.StreamHandler()\n    ]\n)\nlogger = logging.getLogger('AU-13.1-Monitor')\n\nclass GitHubMonitor:\n    \"\"\"Monitor GitHub for information disclosure\"\"\"\n    \n    def __init__(self, api_token):\n        self.api_token = api_token\n        self.base_url = 'https://api.github.com'\n        self.headers = {'Authorization': f'token {api_token}'}\n    \n    def search_repositories(self, search_terms):\n        \"\"\"Search GitHub repositories for sensitive terms\"\"\"\n        findings = []\n        for term in search_terms:\n            try:\n                # Search public repositories\n                search_url = f'{self.base_url}/search/code?q={term}+in:file'\n                response = requests.get(search_url, headers=self.headers)\n                \n                if response.status_code == 200:\n                    data = response.json()\n                    if data.get('total_count', 0) > 0:\n                        for item in data.get('items', []):\n                            findings.append({\n                                'source': 'GitHub',\n                                'term': term,\n                                'repository': item.get('repository', {}).get('full_name'),\n                                'file': item.get('path'),\n                                'url': item.get('html_url'),\n                                'timestamp': datetime.now().isoformat()\n                            })\n                            logger.warning(f'Information disclosure detected: {term} in {item.get(\"repository\", {}).get(\"full_name\")}')\n            except Exception as e:\n                logger.error(f'GitHub search error for term {term}: {str(e)}')\n        \n        return findings\n\nclass ShodanMonitor:\n    \"\"\"Monitor Shodan for information disclosure\"\"\"\n    \n    def __init__(self, api_key):\n        self.api_key = api_key\n        self.base_url = 'https://api.shodan.io'\n    \n    def search_devices(self, search_terms):\n        \"\"\"Search Shodan for organizational information\"\"\"\n        findings = []\n        for term in search_terms:\n            try:\n                search_url = f'{self.base_url}/shodan/host/search?key={self.api_key}&query={term}'\n                response = requests.get(search_url)\n                \n                if response.status_code == 200:\n                    data = response.json()\n                    for match in data.get('matches', []):\n                        findings.append({\n                            'source': 'Shodan',\n                            'term': term,\n                            'ip': match.get('ip_str'),\n                            'port': match.get('port'),\n                            'organization': match.get('org'),\n                            'timestamp': datetime.now().isoformat()\n                        })\n                        logger.warning(f'Organizational infrastructure exposed: {match.get(\"ip_str\")}:{match.get(\"port\")}')\n            except Exception as e:\n                logger.error(f'Shodan search error for term {term}: {str(e)}')\n        \n        return findings\n\nclass AlertManager:\n    \"\"\"Send alerts when disclosures are detected\"\"\"\n    \n    def __init__(self, webhook_url):\n        self.webhook_url = webhook_url\n    \n    def send_alert(self, finding):\n        \"\"\"Send alert to configured webhook\"\"\"\n        try:\n            if self.webhook_url:\n                payload = {\n                    'alert_type': 'INFORMATION_DISCLOSURE',\n                    'timestamp': datetime.now().isoformat(),\n                    'finding': finding\n                }\n                requests.post(self.webhook_url, json=payload)\n                logger.info(f'Alert sent for finding: {finding}')\n        except Exception as e:\n            logger.error(f'Alert sending error: {str(e)}')\n\ndef main():\n    \"\"\"Main monitoring function\"\"\"\n    logger.info('AU-13.1 automated monitoring started')\n    \n    all_findings = []\n    \n    # Initialize monitors\n    if MONITORING_CONFIG['github_token']:\n        github_monitor = GitHubMonitor(MONITORING_CONFIG['github_token'])\n        findings = github_monitor.search_repositories(MONITORING_CONFIG['monitoring_terms'])\n        all_findings.extend(findings)\n    \n    if MONITORING_CONFIG['shodan_api_key']:\n        shodan_monitor = ShodanMonitor(MONITORING_CONFIG['shodan_api_key'])\n        findings = shodan_monitor.search_devices(MONITORING_CONFIG['monitoring_terms'])\n        all_findings.extend(findings)\n    \n    # Send alerts for findings\n    alert_manager = AlertManager(MONITORING_CONFIG['alert_webhook'])\n    for finding in all_findings:\n        alert_manager.send_alert(finding)\n    \n    # Log findings summary\n    logger.info(f'Monitoring completed. Total findings: {len(all_findings)}')\n    \n    return 0 if len(all_findings) == 0 else 1\n\nif __name__ == '__main__':\n    exit(main())"
      },
      "windows": {
        "description": "PowerShell script for automated information disclosure monitoring",
        "script": "# AU-13.1 Automated Information Disclosure Monitoring Script for Windows\n# Requires: PowerShell 5.0+\n\nparam(\n    [string]$ConfigFile = \"C:\\Windows\\System32\\au-13-config.json\",\n    [string]$LogPath = \"C:\\Windows\\Logs\\AU-13\"\n)\n\n# Load configuration\nif (Test-Path $ConfigFile) {\n    $config = Get-Content $ConfigFile | ConvertFrom-Json\n} else {\n    Write-Error \"Configuration file not found: $ConfigFile\"\n    exit 1\n}\n\n# Ensure log directory exists\nif (-not (Test-Path $LogPath)) {\n    New-Item -ItemType Directory -Path $LogPath -Force | Out-Null\n}\n\n# Setup logging\nfunction Write-AuLog {\n    param([string]$Message, [string]$Level = \"INFO\")\n    $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n    $logMessage = \"[$timestamp] [$Level] $Message\"\n    Add-Content -Path \"${LogPath}\\au-13-1-monitoring.log\" -Value $logMessage\n    Write-Host $logMessage\n}\n\n# Monitor GitHub for disclosures\nfunction Monitor-GitHub {\n    param([string[]]$SearchTerms, [string]$ApiToken)\n    \n    $findings = @()\n    $headers = @{\n        'Authorization' = \"token $ApiToken\"\n        'Accept' = 'application/vnd.github.v3+json'\n    }\n    \n    foreach ($term in $SearchTerms) {\n        try {\n            $searchUrl = \"https://api.github.com/search/code?q=$term+in:file\"\n            $response = Invoke-WebRequest -Uri $searchUrl -Headers $headers -ErrorAction Stop\n            $data = $response.Content | ConvertFrom-Json\n            \n            if ($data.total_count -gt 0) {\n                foreach ($item in $data.items) {\n                    $finding = @{\n                        source = 'GitHub'\n                        term = $term\n                        repository = $item.repository.full_name\n                        file = $item.path\n                        url = $item.html_url\n                        timestamp = Get-Date -Format o\n                    }\n                    $findings += $finding\n                    Write-AuLog \"Information disclosure detected: $term in $($item.repository.full_name)\" \"WARN\"\n                }\n            }\n        } catch {\n            Write-AuLog \"GitHub search error for term $term : $($_.Exception.Message)\" \"ERROR\"\n        }\n    }\n    \n    return $findings\n}\n\n# Monitor public web for disclosures\nfunction Monitor-Web {\n    param([string[]]$SearchTerms)\n    \n    $findings = @()\n    \n    foreach ($term in $SearchTerms) {\n        try {\n            # Search using Bing Search API (requires API key)\n            $searchUrl = \"https://api.bing.microsoft.com/v7.0/search?q=$term\"\n            # This requires Bing Search API subscription - simplified example\n            Write-AuLog \"Web search initiated for term: $term\" \"INFO\"\n        } catch {\n            Write-AuLog \"Web search error for term $term : $($_.Exception.Message)\" \"ERROR\"\n        }\n    }\n    \n    return $findings\n}\n\n# Send alerts when findings detected\nfunction Send-Alert {\n    param([object]$Finding)\n    \n    if ($config.alert_email) {\n        try {\n            $subject = \"AU-13.1 ALERT: Information Disclosure Detected\"\n            $body = @\"\nInformation Disclosure Alert\nTime: $($Finding.timestamp)\nSource: $($Finding.source)\nTerm: $($Finding.term)\nDetails: $($Finding | ConvertTo-Json)\n\"@\n            # Send-MailMessage -SmtpServer $config.smtp_server -From $config.alert_from -To $config.alert_email -Subject $subject -Body $body\n            Write-AuLog \"Alert prepared for finding: $($Finding.term)\" \"INFO\"\n        } catch {\n            Write-AuLog \"Alert sending error: $($_.Exception.Message)\" \"ERROR\"\n        }\n    }\n    \n    # Log to Windows Event Log\n    Write-EventLog -LogName \"Security\" -Source \"AU-13\" -EventId 1001 -Message \"Information disclosure detected: $($Finding.term)\"\n}\n\n# Main execution\nWrite-AuLog \"AU-13.1 automated monitoring started\" \"INFO\"\n\n$allFindings = @()\n\n# GitHub monitoring\nif ($config.github_token) {\n    $findings = Monitor-GitHub -SearchTerms $config.monitoring_terms -ApiToken $config.github_token\n    $allFindings += $findings\n}\n\n# Web monitoring\nif ($config.enable_web_search) {\n    $findings = Monitor-Web -SearchTerms $config.monitoring_terms\n    $allFindings += $findings\n}\n\n# Send alerts for findings\nforeach ($finding in $allFindings) {\n    Send-Alert -Finding $finding\n}\n\nWrite-AuLog \"Monitoring completed. Total findings: $($allFindings.Count)\" \"INFO\"\n\nexit 0"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "NIST SP 800-53 Rev 5",
      "implementation_guidance": "AU-13(1) requires automation of information disclosure monitoring. While ComplianceAsCode RHEL profiles focus on system-level audit controls, organizations should implement automated discovery and monitoring tools at the application or platform level. Recommended tools include commercial threat intelligence platforms, GitHub API-based monitoring, and custom Python/PowerShell scripts utilizing public APIs."
    },
    "stig_id": null,
    "ai_guidance": "Use automated tools for monitoring audit data to reduce analyst workload and improve detection speed. Deploy SIEM platforms with machine learning: Splunk Enterprise Security with ML Toolkit, Elastic SIEM with anomaly detection jobs, Wazuh with integrated anomaly detection. On RHEL 8/9, configure Wazuh agent to analyze local audit logs: edit /var/ossec/etc/ossec.conf enabling `<localfile><log_format>audit</log_format></localfile>`. Create automated correlation rules: detect brute-force (>5 failed logins in 1 minute), privilege escalation (sudo to root from non-admin user), data exfiltration (large outbound transfers). Use osquery scheduled queries for automated compliance checks: `SELECT * FROM users WHERE uid=0 AND username!='root';` detecting unauthorized root accounts. Deploy log analysis tools: Logwatch (daily summary emails), fail2ban (automated IP blocking), OSSEC active response. Implement anomaly detection with statistical baselines: detect logins from new countries, processes using excessive CPU, unusual command sequences. Use Python scripts with pandas/scikit-learn for custom analysis: time series analysis of login patterns, clustering of user behaviors. Configure automated reporting: weekly audit summary with key metrics (failed logins, privilege escalations, policy violations). Create dashboards in Grafana/Kibana with real-time visualizations. Reduce false positives through continuous tuning. Verify automation: inject test event, confirm automated alert within 5 minutes. Integrates with AU-6 (review/analysis), AU-6(1) (automated processes), IR-4 (incident handling)."
  },
  {
    "control_id": "au-13.2",
    "control_name": "Review of Monitored Sites",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Review the list of open-source information sites being monitored at organization-defined frequency.",
    "parent_control": "AU-13",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must regularly review and update the list of open-source information sites that are monitored for information disclosure. As new platforms emerge and organizational threat landscape evolves, the monitoring scope must be adjusted to remain effective and focused on relevant information sources.",
    "example_implementation": "Implement a formal review process for monitored sites through: (1) Establish a quarterly review schedule or event-driven review when new platforms emerge; (2) Maintain a master list of monitored sites with documentation of monitoring scope and justification; (3) Conduct review meetings with stakeholders including security, IT operations, and business owners; (4) Evaluate new platforms for relevance based on organizational operations and employee communities; (5) Document removal of obsolete or no longer relevant platforms; (6) Test monitoring coverage to ensure all configured sites are accessible and properly monitored; (7) Document review findings, decisions made, and approvals in control records; (8) Update monitoring tool configurations based on review outcomes; (9) Maintain audit trail of all changes to monitored sites list.",
    "non_technical_guidance": "1. Schedule formal reviews of monitored sites at defined intervals\n2. Identify business stakeholders who should participate in reviews\n3. Maintain current inventory of all monitored information platforms\n4. Assess new platforms emerging in market and relevant to organization\n5. Document justification for each monitored site\n6. Remove sites that no longer present disclosure risk\n7. Test monitoring coverage and effectiveness\n8. Document review decisions and approvals\n9. Update monitoring tool configurations\n10. Maintain audit evidence of review process and outcomes",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "AU-13",
      "AU-13.1",
      "CA-7",
      "PM-6"
    ],
    "supplemental_guidance": "The review of monitored sites should be aligned with organizational risk management processes and changes in the operating environment. As new social media platforms, code repositories, and forums emerge, the organization should assess whether they present information disclosure risks. The review frequency should be established based on organizational risk tolerance and the rate of platform emergence. Documentation of review decisions supports compliance demonstration and provides evidence of diligent monitoring program management.",
    "implementation_scripts": {
      "linux": {
        "description": "Bash script for managing and reviewing information disclosure monitoring sites",
        "script": "#!/bin/bash\n# AU-13.2 Monitoring Sites Review and Maintenance Script\n\nMONITORING_DIR=\"/var/lib/au-13-monitoring\"\nSITES_INVENTORY=\"${MONITORING_DIR}/sites-inventory.json\"\nREVIEW_LOG=\"${MONITORING_DIR}/sites-review.log\"\nARCHIVE_DIR=\"${MONITORING_DIR}/archive\"\n\n# Create directory structure\nmkdir -p ${MONITORING_DIR} ${ARCHIVE_DIR}\n\n# Initialize sites inventory if not exists\nif [ ! -f ${SITES_INVENTORY} ]; then\n  cat > ${SITES_INVENTORY} << 'EOF'\n{\n  \"monitored_sites\": [\n    {\n      \"url\": \"https://github.com\",\n      \"platform\": \"Code Repository\",\n      \"added_date\": \"2025-01-01\",\n      \"business_justification\": \"Public code repository where employee contributions may expose organizational code or infrastructure details\",\n      \"monitoring_method\": \"API and Web Search\",\n      \"risk_level\": \"HIGH\",\n      \"active\": true\n    },\n    {\n      \"url\": \"https://gitlab.com\",\n      \"platform\": \"Code Repository\",\n      \"added_date\": \"2025-01-01\",\n      \"business_justification\": \"Alternative code repository platform used by developers\",\n      \"monitoring_method\": \"API and Web Search\",\n      \"risk_level\": \"HIGH\",\n      \"active\": true\n    },\n    {\n      \"url\": \"https://twitter.com\",\n      \"platform\": \"Social Media\",\n      \"added_date\": \"2025-01-01\",\n      \"business_justification\": \"Social media platform where organizational announcements and employee information may be disclosed\",\n      \"monitoring_method\": \"Search and API\",\n      \"risk_level\": \"MEDIUM\",\n      \"active\": true\n    },\n    {\n      \"url\": \"https://linkedin.com\",\n      \"platform\": \"Social Media\",\n      \"added_date\": \"2025-01-01\",\n      \"business_justification\": \"Professional network where employee and organizational information is typically shared\",\n      \"monitoring_method\": \"Search and API\",\n      \"risk_level\": \"MEDIUM\",\n      \"active\": true\n    }\n  ],\n  \"last_review_date\": \"2025-11-20\",\n  \"next_review_date\": \"2026-02-20\",\n  \"review_frequency_days\": 90\n}\nEOF\nfi\n\n# Function to review site accessibility\nreview_site_accessibility() {\n  local url=$1\n  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')\n  \n  echo \"[${timestamp}] Checking accessibility of ${url}...\" >> ${REVIEW_LOG}\n  \n  response=$(curl -s -I -m 5 \"${url}\" 2>&1)\n  http_code=$(echo \"${response}\" | grep -oP 'HTTP/\\d\\.\\d \\K[0-9]+')\n  \n  if [ -n \"${http_code}\" ] && [ \"${http_code}\" -lt 400 ]; then\n    echo \"[${timestamp}] ${url} - ACCESSIBLE (HTTP ${http_code})\" >> ${REVIEW_LOG}\n    return 0\n  else\n    echo \"[${timestamp}] ${url} - INACCESSIBLE (HTTP ${http_code})\" >> ${REVIEW_LOG}\n    return 1\n  fi\n}\n\n# Function to perform monitoring sites review\nperform_sites_review() {\n  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')\n  local review_date=$(date '+%Y-%m-%d')\n  \n  echo \"\" >> ${REVIEW_LOG}\n  echo \"================================================================================\" >> ${REVIEW_LOG}\n  echo \"MONITORING SITES REVIEW - ${timestamp}\" >> ${REVIEW_LOG}\n  echo \"================================================================================\" >> ${REVIEW_LOG}\n  \n  # Backup current inventory\n  cp ${SITES_INVENTORY} ${ARCHIVE_DIR}/sites-inventory-${review_date}.json\n  \n  # Test each site\n  active_sites=$(grep -c '\"active\": true' ${SITES_INVENTORY})\n  total_sites=$(grep -c '\"url\"' ${SITES_INVENTORY})\n  \n  echo \"[${timestamp}] Total monitored sites: ${total_sites}\" >> ${REVIEW_LOG}\n  echo \"[${timestamp}] Active sites: ${active_sites}\" >> ${REVIEW_LOG}\n  \n  # Review each site for accessibility\n  grep -o '\"url\": \"[^\"]*\"' ${SITES_INVENTORY} | grep -o 'https://[^\"]*' | while read site; do\n    review_site_accessibility \"${site}\"\n  done\n  \n  # Generate summary\n  echo \"[${timestamp}] Sites review completed. See detailed log for results.\" >> ${REVIEW_LOG}\n  echo \"[${timestamp}] Recommended action: Review audit findings and update site list.\" >> ${REVIEW_LOG}\n  \n  # Log accessibility results\n  accessible=$(grep -c 'ACCESSIBLE' ${REVIEW_LOG})\n  inaccessible=$(grep -c 'INACCESSIBLE' ${REVIEW_LOG})\n  echo \"[${timestamp}] Summary: ${accessible} accessible, ${inaccessible} inaccessible\" >> ${REVIEW_LOG}\n}\n\n# Function to add new site\nadd_site() {\n  local url=$1\n  local platform=$2\n  local justification=$3\n  local timestamp=$(date '+%Y-%m-%d')\n  \n  # Note: Simplified addition - in production use jq for JSON manipulation\n  echo \"[$(date '+%Y-%m-%d %H:%M:%S')] Added site: ${url} (${platform}) - ${justification}\" >> ${REVIEW_LOG}\n}\n\n# Function to remove site\nremove_site() {\n  local url=$1\n  local reason=$2\n  \n  echo \"[$(date '+%Y-%m-%d %H:%M:%S')] Removed site: ${url} - Reason: ${reason}\" >> ${REVIEW_LOG}\n}\n\n# Main execution\necho \"AU-13.2 Sites Review and Maintenance\"\n\ncase \"${1:-review}\" in\n  review)\n    perform_sites_review\n    ;;\n  add)\n    add_site \"$2\" \"$3\" \"$4\"\n    ;;\n  remove)\n    remove_site \"$2\" \"$3\"\n    ;;\n  *)\n    echo \"Usage: $0 {review|add URL PLATFORM JUSTIFICATION|remove URL REASON}\"\n    exit 1\n    ;;\nesac\n\nexit 0"
      },
      "windows": {
        "description": "PowerShell script for managing and reviewing information disclosure monitoring sites",
        "script": "# AU-13.2 Monitoring Sites Review and Maintenance Script for Windows\n\nparam(\n    [ValidateSet('review', 'add', 'remove')]\n    [string]$Action = 'review',\n    [string]$Url,\n    [string]$Platform,\n    [string]$Justification,\n    [string]$Reason\n)\n\n$MonitoringDir = \"C:\\Windows\\System32\\au-13-monitoring\"\n$SitesInventory = \"${MonitoringDir}\\sites-inventory.json\"\n$ReviewLog = \"${MonitoringDir}\\sites-review.log\"\n$ArchiveDir = \"${MonitoringDir}\\archive\"\n\n# Create directories if needed\nif (-not (Test-Path $MonitoringDir)) {\n    New-Item -ItemType Directory -Path $MonitoringDir -Force | Out-Null\n}\nif (-not (Test-Path $ArchiveDir)) {\n    New-Item -ItemType Directory -Path $ArchiveDir -Force | Out-Null\n}\n\n# Helper function for logging\nfunction Write-ReviewLog {\n    param([string]$Message)\n    $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n    $logMessage = \"[${timestamp}] ${Message}\"\n    Add-Content -Path $ReviewLog -Value $logMessage\n    Write-Host $logMessage\n}\n\n# Initialize inventory if needed\nfunction Initialize-Inventory {\n    if (-not (Test-Path $SitesInventory)) {\n        $inventory = @{\n            monitored_sites = @(\n                @{\n                    url = \"https://github.com\"\n                    platform = \"Code Repository\"\n                    added_date = \"2025-01-01\"\n                    business_justification = \"Public code repository where employee contributions may expose organizational code\"\n                    monitoring_method = \"API and Web Search\"\n                    risk_level = \"HIGH\"\n                    active = $true\n                },\n                @{\n                    url = \"https://twitter.com\"\n                    platform = \"Social Media\"\n                    added_date = \"2025-01-01\"\n                    business_justification = \"Social media platform for organizational and employee information\"\n                    monitoring_method = \"Search and API\"\n                    risk_level = \"MEDIUM\"\n                    active = $true\n                }\n            )\n            last_review_date = (Get-Date -Format \"yyyy-MM-dd\")\n            next_review_date = (Get-Date).AddDays(90).ToString(\"yyyy-MM-dd\")\n            review_frequency_days = 90\n        }\n        $inventory | ConvertTo-Json | Out-File -FilePath $SitesInventory -Encoding UTF8\n        Write-ReviewLog \"Sites inventory initialized\"\n    }\n}\n\n# Review site accessibility\nfunction Test-SiteAccessibility {\n    param([string]$Url)\n    \n    try {\n        $response = Invoke-WebRequest -Uri $Url -Method Head -TimeoutSec 5 -ErrorAction Stop\n        Write-ReviewLog \"${Url} - ACCESSIBLE (HTTP $($response.StatusCode))\"\n        return $true\n    } catch {\n        Write-ReviewLog \"${Url} - INACCESSIBLE ($($_.Exception.Message))\"\n        return $false\n    }\n}\n\n# Perform comprehensive review\nfunction Invoke-SitesReview {\n    Write-ReviewLog \"===================================================\"\n    Write-ReviewLog \"MONITORING SITES REVIEW - $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')\"\n    Write-ReviewLog \"===================================================\"\n    \n    Initialize-Inventory\n    \n    # Backup current inventory\n    $backupPath = \"${ArchiveDir}\\sites-inventory-$(Get-Date -Format 'yyyyMMdd-HHmmss').json\"\n    Copy-Item -Path $SitesInventory -Destination $backupPath\n    Write-ReviewLog \"Inventory backed up to ${backupPath}\"\n    \n    # Load and review inventory\n    $inventory = Get-Content $SitesInventory | ConvertFrom-Json\n    \n    $activeSites = @($inventory.monitored_sites | Where-Object { $_.active -eq $true })\n    Write-ReviewLog \"Total monitored sites: $($inventory.monitored_sites.Count)\"\n    Write-ReviewLog \"Active sites: $($activeSites.Count)\"\n    \n    # Test accessibility\n    $accessible = 0\n    $inaccessible = 0\n    \n    foreach ($site in $activeSites) {\n        if (Test-SiteAccessibility -Url $site.url) {\n            $accessible++\n        } else {\n            $inaccessible++\n        }\n    }\n    \n    Write-ReviewLog \"Accessibility Summary: ${accessible} accessible, ${inaccessible} inaccessible\"\n    Write-ReviewLog \"Sites review completed - See detailed log for findings\"\n    \n    # Update review dates\n    $inventory.last_review_date = Get-Date -Format \"yyyy-MM-dd\"\n    $inventory.next_review_date = (Get-Date).AddDays(90).ToString(\"yyyy-MM-dd\")\n    \n    $inventory | ConvertTo-Json | Out-File -FilePath $SitesInventory -Encoding UTF8\n    Write-ReviewLog \"Inventory updated with next review date: $($inventory.next_review_date)\"\n}\n\n# Add new site\nfunction Add-MonitoredSite {\n    param(\n        [string]$Url,\n        [string]$Platform,\n        [string]$Justification\n    )\n    \n    Initialize-Inventory\n    $inventory = Get-Content $SitesInventory | ConvertFrom-Json\n    \n    $newSite = @{\n        url = $Url\n        platform = $Platform\n        added_date = Get-Date -Format \"yyyy-MM-dd\"\n        business_justification = $Justification\n        monitoring_method = \"API and Web Search\"\n        risk_level = \"MEDIUM\"\n        active = $true\n    }\n    \n    [array]$inventory.monitored_sites += $newSite\n    $inventory | ConvertTo-Json | Out-File -FilePath $SitesInventory -Encoding UTF8\n    \n    Write-ReviewLog \"Added site: ${Url} (${Platform}) - ${Justification}\"\n}\n\n# Remove site\nfunction Remove-MonitoredSite {\n    param(\n        [string]$Url,\n        [string]$Reason\n    )\n    \n    Initialize-Inventory\n    $inventory = Get-Content $SitesInventory | ConvertFrom-Json\n    \n    $inventory.monitored_sites = @($inventory.monitored_sites | Where-Object { $_.url -ne $Url })\n    $inventory | ConvertTo-Json | Out-File -FilePath $SitesInventory -Encoding UTF8\n    \n    Write-ReviewLog \"Removed site: ${Url} - Reason: ${Reason}\"\n}\n\n# Main execution\nswitch ($Action) {\n    'review' {\n        Invoke-SitesReview\n    }\n    'add' {\n        if (-not $Url -or -not $Platform -or -not $Justification) {\n            Write-Error \"add action requires: -Url, -Platform, -Justification\"\n            exit 1\n        }\n        Add-MonitoredSite -Url $Url -Platform $Platform -Justification $Justification\n    }\n    'remove' {\n        if (-not $Url -or -not $Reason) {\n            Write-Error \"remove action requires: -Url, -Reason\"\n            exit 1\n        }\n        Remove-MonitoredSite -Url $Url -Reason $Reason\n    }\n}\n\nexit 0"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "NIST SP 800-53 Rev 5",
      "implementation_guidance": "AU-13(2) requires periodic review of monitored information sites. Organizations should establish a documented review process with defined frequency (e.g., quarterly). ComplianceAsCode does not provide specific technical implementations for this control, as it is primarily operational and organizational in nature."
    },
    "stig_id": null,
    "ai_guidance": "Establish a formal review cycle tied to organizational risk management. Create a monitoring sites master list with metadata including platform category, business justification, risk rating, and monitoring method. Schedule quarterly reviews (or upon major organizational changes) to: (1) Validate continued relevance of monitored sites; (2) Test monitoring coverage for accessibility; (3) Identify new platforms emerging in relevant communities; (4) Remove obsolete or lower-risk platforms. Document all reviews with approvals and store in a version-controlled system."
  },
  {
    "control_id": "au-13.3",
    "control_name": "Unauthorized Replication of Information",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Employ discovery techniques, processes, and tools to determine if external entities are replicating organizational information in an unauthorized manner.",
    "parent_control": "AU-13",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must implement discovery methods to identify when external parties are copying, mirroring, or reproducing organizational information without authorization. This includes detecting unauthorized website mirrors, data copies in public repositories, credential trafficking, and information redistribution through unauthorized channels.",
    "example_implementation": "Implement unauthorized replication detection through: (1) Deploy web content fingerprinting tools that track unauthorized copies of organizational websites or content; (2) Implement copyright infringement monitoring services to detect reproductions of proprietary content; (3) Monitor dark web marketplaces for organizational databases, intellectual property, or credentials; (4) Use digital watermarking or content hash verification to identify unauthorized copies; (5) Employ threat intelligence services to monitor for organizational information distributed through unauthorized channels; (6) Establish processes to track and analyze clone/mirror sites that replicate organizational web properties; (7) Implement continuous monitoring of major cloud storage and file-sharing platforms for unauthorized organizational data copies; (8) Deploy data loss prevention (DLP) tools that track organizational information movement; (9) Document detection methodology, tools used, and findings in control records.",
    "non_technical_guidance": "1. Identify critical organizational information requiring replication monitoring\n2. Evaluate threat intelligence and monitoring services for replication detection\n3. Establish baseline of authorized information distribution channels\n4. Document procedures for investigating detected unauthorized replications\n5. Define response procedures for identified replication incidents\n6. Coordinate with legal and business teams on intellectual property protection\n7. Maintain inventory of known authorized mirrors or copies (e.g., CDNs, backup sites)\n8. Monitor dark web and underground forums for organizational information sales\n9. Track results of replication discovery efforts in audit logs\n10. Integrate findings with incident response and breach notification procedures",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-13",
      "IR-4",
      "IR-6",
      "IR-7",
      "PM-12",
      "SI-4",
      "SI-20"
    ],
    "supplemental_guidance": "Unauthorized replication detection may employ content fingerprinting, cryptographic hashing, digital watermarking, web crawling for cloned content, dark web monitoring, threat intelligence services, and manual research. Organizations should coordinate with their legal departments to understand intellectual property protections and remediation options when unauthorized replications are discovered. The discovery process should be documented and repeatable, allowing for trending analysis of replication attempts. Organizations should differentiate between authorized mirroring or caching (e.g., search engines, CDNs) and truly unauthorized replications.",
    "implementation_scripts": {
      "linux": {
        "description": "Python script for detecting unauthorized replication of organizational information",
        "script": "#!/usr/bin/env python3\n# AU-13.3 Unauthorized Information Replication Detection\n# Requires: requests, beautifulsoup4, hashlib, urllib\n\nimport os\nimport json\nimport requests\nimport hashlib\nfrom datetime import datetime\nfrom urllib.parse import urlparse\nimport logging\nfrom difflib import SequenceMatcher\n\n# Configuration\nORG_SITES = os.getenv('ORG_SITES', '').split(',')\nDARK_WEB_MONITOR_URLS = [\n    # Example monitoring endpoints for dark web and threat intelligence\n    # These would be configured based on available services\n]\nLOG_FILE = '/var/log/au-13-3-replication.log'\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler(LOG_FILE),\n        logging.StreamHandler()\n    ]\n)\nlogger = logging.getLogger('AU-13.3')\n\nclass ContentFingerprinter:\n    \"\"\"Generate and track content fingerprints for replication detection\"\"\"\n    \n    def __init__(self):\n        self.fingerprints = {}\n    \n    def generate_fingerprint(self, content):\n        \"\"\"Generate SHA-256 fingerprint of content\"\"\"\n        return hashlib.sha256(content.encode()).hexdigest()\n    \n    def store_original(self, url, content):\n        \"\"\"Store fingerprint of original organizational content\"\"\"\n        fingerprint = self.generate_fingerprint(content)\n        self.fingerprints[url] = {\n            'fingerprint': fingerprint,\n            'stored_date': datetime.now().isoformat(),\n            'content_length': len(content)\n        }\n        logger.info(f'Stored fingerprint for {url}: {fingerprint}')\n    \n    def check_for_replication(self, url, content):\n        \"\"\"Check if content matches known organizational content\"\"\"\n        fingerprint = self.generate_fingerprint(content)\n        \n        for original_url, original_data in self.fingerprints.items():\n            if fingerprint == original_data['fingerprint']:\n                logger.warning(f'UNAUTHORIZED REPLICATION DETECTED: {url} duplicates {original_url}')\n                return True, original_url\n            \n            # Also check for partial matches (similarity > 80%)\n            similarity = SequenceMatcher(None, fingerprint, original_data['fingerprint']).ratio()\n            if similarity > 0.8:\n                logger.warning(f'SIMILAR CONTENT DETECTED: {url} has {similarity*100:.1f}% similarity to {original_url}')\n                return True, original_url\n        \n        return False, None\n\nclass WebMonitor:\n    \"\"\"Monitor web for unauthorized replications\"\"\"\n    \n    def __init__(self):\n        self.fingerprinter = ContentFingerprinter()\n        self.session = requests.Session()\n        self.session.headers.update({\n            'User-Agent': 'Mozilla/5.0 (Security Monitoring Bot)'\n        })\n    \n    def fetch_content(self, url):\n        \"\"\"Fetch content from URL\"\"\"\n        try:\n            response = self.session.get(url, timeout=10)\n            if response.status_code == 200:\n                return response.text\n        except requests.exceptions.RequestException as e:\n            logger.error(f'Error fetching {url}: {str(e)}')\n        return None\n    \n    def scan_for_mirrors(self, domain):\n        \"\"\"Scan for mirror/clone sites of organizational domain\"\"\"\n        findings = []\n        \n        # Common mirror domain patterns\n        patterns = [\n            f'{domain}-mirror.com',\n            f'{domain}.mirror.io',\n            f'mirror-{domain}.com',\n            f'{domain}-backup.com',\n            f'{domain}-clone.com'\n        ]\n        \n        for pattern in patterns:\n            try:\n                response = self.session.head(f'https://{pattern}', timeout=5)\n                if response.status_code < 400:\n                    logger.warning(f'MIRROR SITE DETECTED: {pattern} (HTTP {response.status_code})')\n                    findings.append(pattern)\n            except:\n                pass\n        \n        return findings\n    \n    def check_pastebin_for_exposure(self, search_terms):\n        \"\"\"Check Pastebin and similar services for organizational data\"\"\"\n        findings = []\n        \n        for term in search_terms:\n            try:\n                # Pastebin and similar services have search APIs\n                search_url = f'https://pastebin.com/search?q={term}'\n                response = self.session.get(search_url)\n                \n                if 'results' in response.text:\n                    logger.warning(f'PASTE SERVICE EXPOSURE: {term} found in paste services')\n                    findings.append(term)\n            except Exception as e:\n                logger.debug(f'Pastebin search error: {str(e)}')\n        \n        return findings\n\nclass DarkWebMonitor:\n    \"\"\"Monitor dark web and underground forums for organizational data\"\"\"\n    \n    def __init__(self):\n        self.logger = logger\n    \n    def check_threat_intelligence_feeds(self, search_terms):\n        \"\"\"Query threat intelligence services for organizational data\"\"\"\n        findings = []\n        \n        # This would integrate with threat intelligence APIs\n        # Examples: VirusTotal, AlienVault, Shodan\n        # Requires API keys and subscriptions\n        \n        logger.info('Dark web monitoring configured - integrate with threat intelligence services')\n        return findings\n    \n    def monitor_marketplaces(self, search_terms):\n        \"\"\"Monitor underground marketplaces for data sales\"\"\"\n        findings = []\n        \n        for term in search_terms:\n            logger.info(f'Monitoring marketplaces for: {term}')\n            # Integration with marketplace monitoring services\n            # Examples: Digital Shadows, Recorded Future, Flashpoint\n        \n        return findings\n\ndef main():\n    \"\"\"Main replication detection function\"\"\"\n    logger.info('AU-13.3 Unauthorized Replication Detection Started')\n    \n    all_findings = []\n    web_monitor = WebMonitor()\n    dark_web_monitor = DarkWebMonitor()\n    \n    # Get organizational sites\n    if not ORG_SITES or ORG_SITES[0] == '':\n        logger.error('ORG_SITES environment variable not configured')\n        return 1\n    \n    # Scan for mirrors/clones\n    for site in ORG_SITES:\n        domain = urlparse(site).netloc\n        mirrors = web_monitor.scan_for_mirrors(domain)\n        all_findings.extend(mirrors)\n    \n    # Check paste services\n    org_identifiers = os.getenv('ORG_IDENTIFIERS', '').split(',')\n    if org_identifiers:\n        paste_exposures = web_monitor.check_pastebin_for_exposure(org_identifiers)\n        all_findings.extend(paste_exposures)\n    \n    # Check dark web\n    ti_findings = dark_web_monitor.check_threat_intelligence_feeds(org_identifiers)\n    all_findings.extend(ti_findings)\n    \n    logger.info(f'Replication detection completed. Total findings: {len(all_findings)}')\n    \n    return 0 if len(all_findings) == 0 else 1\n\nif __name__ == '__main__':\n    exit(main())"
      },
      "windows": {
        "description": "PowerShell script for detecting unauthorized replication of organizational information",
        "script": "# AU-13.3 Unauthorized Information Replication Detection for Windows\n\nparam(\n    [string[]]$OrganizationalSites = @(\"https://www.organization.com\"),\n    [string[]]$SearchTerms = @(),\n    [string]$LogPath = \"C:\\Windows\\Logs\\AU-13\"\n)\n\n# Ensure log directory exists\nif (-not (Test-Path $LogPath)) {\n    New-Item -ItemType Directory -Path $LogPath -Force | Out-Null\n}\n\n$LogFile = \"${LogPath}\\au-13-3-replication.log\"\n\nfunction Write-ReplicationLog {\n    param([string]$Message, [string]$Level = \"INFO\")\n    $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n    $logMessage = \"[${timestamp}] [${Level}] ${Message}\"\n    Add-Content -Path $LogFile -Value $logMessage\n    Write-Host $logMessage\n}\n\nfunction Get-ContentFingerprint {\n    param([string]$Content)\n    \n    $hashObject = [System.Security.Cryptography.HashAlgorithm]::Create('SHA256')\n    $inputBytes = [System.Text.Encoding]::UTF8.GetBytes($Content)\n    $hashBytes = $hashObject.ComputeHash($inputBytes)\n    \n    return [System.BitConverter]::ToString($hashBytes).Replace(\"-\", \"\").ToLower()\n}\n\nfunction Test-MirrorSites {\n    param([string[]]$Domains)\n    \n    $findings = @()\n    \n    # Common mirror/clone patterns\n    $patterns = @(\n        '-mirror', '-backup', '-clone', '-copy', '-archive',\n        'mirror-', 'backup-', 'clone-'\n    )\n    \n    foreach ($domain in $Domains) {\n        foreach ($pattern in $patterns) {\n            $testDomain = $domain -replace 'https?://', '' -replace 'www.', ''\n            $testUrl = \"https://${testDomain}${pattern}.com\"\n            \n            try {\n                $response = Invoke-WebRequest -Uri $testUrl -Method Head -TimeoutSec 5 -ErrorAction Stop\n                Write-ReplicationLog \"MIRROR SITE DETECTED: ${testUrl} (HTTP $($response.StatusCode))\" \"WARN\"\n                $findings += @{\n                    type = 'mirror_site'\n                    url = $testUrl\n                    timestamp = Get-Date -Format o\n                }\n            } catch {\n                # Site not found or unreachable - expected for most patterns\n            }\n        }\n    }\n    \n    return $findings\n}\n\nfunction Test-PasteBinExposure {\n    param([string[]]$SearchTerms)\n    \n    $findings = @()\n    \n    foreach ($term in $SearchTerms) {\n        try {\n            $searchUrl = \"https://www.pastebin.com/search?q=$([System.Web.HttpUtility]::UrlEncode($term))\"\n            $response = Invoke-WebRequest -Uri $searchUrl -TimeoutSec 10 -ErrorAction Stop\n            \n            if ($response.Content -match 'results') {\n                Write-ReplicationLog \"PASTEBIN EXPOSURE: ${term} found in public paste services\" \"WARN\"\n                $findings += @{\n                    type = 'pastebin_exposure'\n                    term = $term\n                    timestamp = Get-Date -Format o\n                }\n            }\n        } catch {\n            Write-ReplicationLog \"Pastebin search error for ${term}: $($_.Exception.Message)\" \"DEBUG\"\n        }\n    }\n    \n    return $findings\n}\n\nfunction Test-RepositoryExposure {\n    param([string[]]$SearchTerms)\n    \n    $findings = @()\n    \n    # Check GitHub for exposed organizational code/data\n    foreach ($term in $SearchTerms) {\n        try {\n            $searchUrl = \"https://api.github.com/search/code?q=${term}+in:file\"\n            $response = Invoke-WebRequest -Uri $searchUrl -TimeoutSec 10 -ErrorAction Stop\n            $data = $response.Content | ConvertFrom-Json\n            \n            if ($data.total_count -gt 0) {\n                Write-ReplicationLog \"REPOSITORY EXPOSURE: ${term} found in public repositories\" \"WARN\"\n                $findings += @{\n                    type = 'repository_exposure'\n                    term = $term\n                    repository_count = $data.total_count\n                    timestamp = Get-Date -Format o\n                }\n            }\n        } catch {\n            Write-ReplicationLog \"Repository search error for ${term}: $($_.Exception.Message)\" \"DEBUG\"\n        }\n    }\n    \n    return $findings\n}\n\nfunction Generate-ReplicationReport {\n    param([object[]]$Findings)\n    \n    $reportFile = \"${LogPath}\\replication-report-$(Get-Date -Format 'yyyyMMdd').json\"\n    $report = @{\n        scan_date = Get-Date -Format o\n        total_findings = $Findings.Count\n        findings = $Findings\n    }\n    \n    $report | ConvertTo-Json | Out-File -FilePath $reportFile -Encoding UTF8\n    Write-ReplicationLog \"Report saved to ${reportFile}\"\n    \n    return $reportFile\n}\n\n# Main execution\nWrite-ReplicationLog \"AU-13.3 Unauthorized Replication Detection Started\"\n\n$allFindings = @()\n\n# Extract domains from sites\n$domains = @()\nforeach ($site in $OrganizationalSites) {\n    $domain = ([System.Uri]$site).Host\n    $domains += $domain\n}\n\n# Test for mirror sites\nif ($domains.Count -gt 0) {\n    $mirrorFindings = Test-MirrorSites -Domains $domains\n    $allFindings += $mirrorFindings\n}\n\n# Test for pastebin exposures\nif ($SearchTerms.Count -gt 0) {\n    $pastebinFindings = Test-PasteBinExposure -SearchTerms $SearchTerms\n    $allFindings += $pastebinFindings\n    \n    # Test for repository exposures\n    $repoFindings = Test-RepositoryExposure -SearchTerms $SearchTerms\n    $allFindings += $repoFindings\n}\n\n# Generate report\nif ($allFindings.Count -gt 0) {\n    Generate-ReplicationReport -Findings $allFindings\n    Write-EventLog -LogName \"Security\" -Source \"AU-13\" -EventId 1002 -Message \"Unauthorized replication detected - $($allFindings.Count) findings\"\n}\n\nWrite-ReplicationLog \"Detection completed. Total findings: $($allFindings.Count)\"\n\nexit 0"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "NIST SP 800-53 Rev 5",
      "implementation_guidance": "AU-13(3) requires technical discovery mechanisms to identify unauthorized replication of organizational information. While ComplianceAsCode RHEL profiles do not provide specific implementations, organizations should deploy web monitoring tools, content fingerprinting mechanisms, and threat intelligence integrations to detect cloned websites, exposed data in repositories, and dark web distribution."
    },
    "stig_id": null,
    "ai_guidance": "Block unauthorized replication of audit information to prevent data leakage. Implement data loss prevention (DLP) controls on audit systems. On RHEL 8/9, use SELinux to prevent unauthorized copying: create custom policy restricting /var/log/audit/ access to auditd process only. Configure file system permissions: `chmod 0600 /var/log/audit/audit.log`, use ACLs: `setfacl -m u:alice:--- /var/log/audit/`. Deploy USB device blocking: udev rules preventing unauthorized USB storage: create /etc/udev/rules.d/10-usb-deny.rules with `ACTION==\"add\", SUBSYSTEMS==\"usb\", RUN+=\"/bin/sh -c 'echo 0 >/sys$DEVPATH/authorized'\"`. Implement network DLP: configure firewall rules blocking rsyslog/syslog traffic except to authorized destinations. Use AppArmor profiles restricting process capabilities: prevent wget, curl, scp from accessing audit directories. For Elasticsearch, configure index access controls: read-only for analysts, no reindex/snapshot permissions. Deploy file integrity monitoring (AIDE) alerting on unauthorized audit log copies: `aide --check | grep \"/var/log/audit\"`. On Windows, use BitLocker with TPM preventing offline disk access, configure NTFS permissions denying non-admin reads. Create audit trail of access attempts: `-w /var/log/audit/ -p r -k unauthorized_audit_access`. Implement exfiltration detection: monitor for large data transfers from audit servers. Test controls: attempt to copy audit.log as non-privileged user, verify denial. Integrates with AU-9 (protection), AC-3 (access enforcement), SC-7 (boundary protection)."
  },
  {
    "control_id": "au-14",
    "stig_id": "RHEL-08-030300",
    "control_name": "Session Audit",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "a. Provide and implement the capability for [Assignment: organization-defined users or roles] to [Selection (one or more): record; view; hear; log] the content of a user session under [Assignment: organization-defined circumstances]; and\n\nb. Develop, integrate, and use session auditing activities in consultation with legal counsel and in accordance with applicable laws, executive orders, directives, regulations, policies, standards, and guidelines.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "AU-14 Session Audit requires organizations to implement technical capabilities that allow designated personnel to record, monitor, view, or log user session activities. This includes tracking keystrokes, website visits, file transfers, and other session content. Organizations must establish clear policies defining which users or roles can trigger session audits, under what circumstances audits are initiated (such as during investigations of suspicious activity), and must involve legal counsel to ensure compliance with privacy laws and civil liberties protections.",
    "example_implementation": "Organizations implement session auditing through tools such as auditd with session recording rules, terminal session recorders (script/scriptreplay), or specialized session capture solutions. For example, enabling Linux Audit Framework rules to capture session-related events, configuring PAM modules to log session activities, or deploying tools like Teleport or Bastion hosts that record all terminal sessions. Windows environments use event tracing and auditing policies to monitor session logons and activities.",
    "non_technical_guidance": "Session Audit (AU-14) implementation requires a comprehensive approach:\n\n1. Policy Development: Establish a clear session auditing policy defining authorized users/roles who can request session audits, specific circumstances triggering audits (investigation of suspected compromises, privileged user activities, contractor access monitoring), and data retention requirements.\n\n2. Legal Coordination: Consult with legal counsel, privacy officials, and civil liberties officers to address privacy concerns, ensure GDPR/CCPA compliance where applicable, and establish procedures for handling personally identifiable information captured in session logs.\n\n3. Technical Infrastructure: Deploy appropriate session recording tools compatible with your environment (Linux auditd, PAM modules, terminal session recorders, or cloud-native solutions).\n\n4. Access Controls: Implement strict controls over who can view, retrieve, or access recorded session data. Session recordings are highly sensitive and should be protected with encryption and role-based access.\n\n5. Notification and Consent: Document and communicate to users that their sessions may be monitored or recorded, as required by applicable laws and organizational policies.\n\n6. Training: Ensure administrators understand when and how to properly request and use session auditing capabilities, and ensure compliance with audit authorization procedures.\n\n7. Retention and Disposal: Establish clear retention schedules for session audit data and procedures for secure deletion after retention periods expire.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "au-14.1",
        "title": "System Start-up",
        "official_text": "Initiate session audits automatically at system start-up."
      },
      {
        "id": "au-14.2",
        "title": "Capture and Record Content",
        "official_text": "Provide the capability to capture and record the content of a user session. [Note: This enhancement was merged into the base control in Rev 5]"
      },
      {
        "id": "au-14.3",
        "title": "Remote Viewing and Listening",
        "official_text": "Provide and implement the capability for authorized users to remotely view and hear content related to an established user session in real time."
      }
    ],
    "related_controls": [
      "AU-2",
      "AU-4",
      "AU-6",
      "AU-8",
      "AU-9",
      "AU-12",
      "CA-7",
      "SI-4"
    ],
    "supplemental_guidance": "Session audits can monitor and record keystrokes, track websites visited, and record information and file transfers. Session audit capability is implemented in addition to event logging (AU-2) and may involve implementation of specialized session capture technology. Organizations consider how session auditing can reveal sensitive information about individuals (including passwords, health information, financial data) that may give rise to privacy risks. Implementation must be done in consultation with privacy officials, civil liberties officials, and legal counsel. Session auditing should only be initiated when specifically justified (such as investigating potential security incidents or monitoring privileged account activities). Organizations must balance security monitoring needs with privacy protections and employee rights. The capability should be implemented in a manner that does not unnecessarily expose personal information but still achieves the organization's audit and accountability objectives.",
    "implementation_scripts": {
      "linux": {
        "auditd_session_rules": "#!/bin/bash\n# Configure Linux Audit Framework for session auditing (AU-14)\n# Deploy session audit rules to capture session-related events\n\n# Add to /etc/audit/rules.d/session-audit.rules:\n# Monitor login/logout events\n-w /var/log/wtmp -p wa -k sessions\n-w /var/log/btmp -p wa -k logins\n\n# Monitor PAM authentication modules\n-w /etc/pam.d/ -p wa -k pam_config\n\n# Monitor SSH configuration and events\n-w /etc/ssh/sshd_config -p wa -k sshd_config\n-w /var/log/auth.log -p wa -k auth_logs\n\n# Monitor sudoers file for privilege escalation\n-w /etc/sudoers -p wa -k sudoers\n-w /etc/sudoers.d/ -p wa -k sudoers_rules\n\n# Load the rules\naugenrules --load\nauditctl -l\n\necho 'Session audit rules configured'",
        "terminal_session_recording": "#!/bin/bash\n# Enable terminal session recording using script/scriptreplay\n# This captures all terminal input and output for specified users\n\n# Method 1: Using PAM configuration for automatic session logging\ncat >> /etc/pam.d/common-session << 'EOF'\n# Enable session logging for audit compliance\nsession required pam_exec.so /usr/local/bin/session_logger.sh\nEOF\n\n# Create session logger script\ncat > /usr/local/bin/session_logger.sh << 'EOF'\n#!/bin/bash\n# Log all session activity for audit compliance\nLOG_DIR=\"/var/log/sessions\"\nmkdir -p \"$LOG_DIR\"\n\nif [ -z \"$PAM_USER\" ]; then\n  exit 0\nfi\n\n# Create timestamped session log file\nSESSION_LOG=\"$LOG_DIR/${PAM_USER}_$(date +%Y%m%d_%H%M%S).log\"\necho \"Session started at $(date)\" > \"$SESSION_LOG\"\nchown root:root \"$SESSION_LOG\"\nchmod 600 \"$SESSION_LOG\"\nEOF\n\nchmod +x /usr/local/bin/session_logger.sh\necho 'Terminal session recording configured'",
        "session_audit_policy": "#!/bin/bash\n# Session Audit policy configuration for AU-14 compliance\n\n# Define authorized roles for session audit initiation\ncat > /etc/security/session-audit-policy.conf << 'EOF'\n# Session Audit Policy (AU-14)\n# Defines who can request and conduct session audits\n\n# Authorized roles/users who can initiate session audits\nAUTHORIZED_AUDIT_USERS=\"root,security_admin,compliance_officer\"\n\n# Session audit circumstances (when audits are triggered)\n# Values: investigation, privilege_escalation, suspicious_activity, routine_monitoring, incident_response\nAUDIT_TRIGGER_CIRCUMSTANCES=\"investigation,suspicious_activity,incident_response\"\n\n# Data retention period for session audit logs (in days)\nAUDIT_RETENTION_DAYS=90\n\n# Session types to audit: all, ssh, local, privileged\nAUDIT_SESSION_TYPES=\"ssh,privileged,local\"\n\n# Enable remote monitoring capability (AU-14.3)\nREMOTE_MONITORING_ENABLED=true\n\n# Log location for session audit data\nAUDIT_LOG_DIR=\"/var/log/session-audit\"\n\n# Encryption for session audit data (aes256-cbc recommended)\nLOG_ENCRYPTION=\"aes256-cbc\"\nEOF\n\nchown root:root /etc/security/session-audit-policy.conf\nchmod 600 /etc/security/session-audit-policy.conf\necho 'Session audit policy configured'"
      },
      "windows": {
        "group_policy_audit": "# Windows Group Policy for Session Audit (AU-14)\n# PowerShell script to configure Windows Event Tracing for session auditing\n\n# Configure audit policy for session logons\nauditpol.exe /set /subcategory:\"Logon/Logoff\" /success:enable /failure:enable\nauditpol.exe /set /subcategory:\"Special Logon\" /success:enable /failure:enable\nauditpol.exe /set /subcategory:\"Other Logon/Logoff Events\" /success:enable /failure:enable\nauditpol.exe /set /subcategory:\"Network Policy Server\" /success:enable /failure:enable\n\n# Configure detailed tracking for process execution\nauditpol.exe /set /subcategory:\"Process Creation\" /success:enable /failure:enable\nauditpol.exe /set /subcategory:\"Process Termination\" /success:enable /failure:enable\n\n# Display current audit policy\nauditpol.exe /get /category:*",
        "powershell_session_logging": "$null = @\"\n# Enable PowerShell Script Block Logging for session auditing\n# This captures all PowerShell commands executed in sessions\n\n# Create the registry path if it doesn't exist\n$registryPath = \"HKLM:\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLogging\"\nif (-Not (Test-Path $registryPath)) {\n    New-Item -Path $registryPath -Force | Out-Null\n}\n\n# Enable script block logging\nSet-ItemProperty -Path $registryPath -Name \"EnableScriptBlockLogging\" -Value 1 -Type DWord\n\n# Enable script block invocation logging\nSet-ItemProperty -Path $registryPath -Name \"EnableScriptBlockInvocationLogging\" -Value 1 -Type DWord\n\n# Configure transcript logging for all PowerShell sessions\n$transcriptPath = \"C:\\Windows\\System32\\LogFiles\\PowerShell\\Transcripts\"\nif (-Not (Test-Path $transcriptPath)) {\n    New-Item -Path $transcriptPath -ItemType Directory -Force | Out-Null\n}\n\n# Enable PowerShell Transcription Group Policy\n$transcriptRegistry = \"HKLM:\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\Transcription\"\nif (-Not (Test-Path $transcriptRegistry)) {\n    New-Item -Path $transcriptRegistry -Force | Out-Null\n}\n\nSet-ItemProperty -Path $transcriptRegistry -Name \"EnableTranscripting\" -Value 1 -Type DWord\nSet-ItemProperty -Path $transcriptRegistry -Name \"OutputDirectory\" -Value $transcriptPath -Type String\nSet-ItemProperty -Path $transcriptRegistry -Name \"EnableInvocationHeader\" -Value 1 -Type DWord\n\nWrite-Host \"Windows session auditing configured\"\n\"@",
        "event_log_configuration": "# Configure Windows Event Log for session auditing\n# Ensures sufficient capacity and retention for audit events\n\nPowerShell -Command \"\n# Configure Security Event Log\nlimit-EventLog -LogName Security -MaximumSize 4GB -OverflowAction DoNotOverwrite\n\n# Configure System Event Log\nlimit-EventLog -LogName System -MaximumSize 2GB -OverflowAction DoNotOverwrite\n\n# Configure Application Event Log\nlimit-EventLog -LogName Application -MaximumSize 2GB -OverflowAction DoNotOverwrite\n\n# Verify configuration\nGet-EventLog -List | Select-Object Log, Maximum, Retention\n\nWrite-Host 'Event log configuration completed for AU-14 compliance'\n\""
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "qa_verified": true,
      "nist_aligned": true,
      "stig_id": "RHEL-08-030300"
    },
    "cac_metadata": {
      "implementation_type": "specialized",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "available",
      "cac_planned": true,
      "implementation_guidance": "ComplianceAsCode content includes audit framework rules for RHEL/CentOS in the linux_os/guide/system/auditing/rule_audit_session_initiation/ and related session capture configurations. Windows implementations require Event Tracing and PowerShell transcript logging via Group Policy.",
      "stig_id": "N/A - Base control (enhancements map to specific STIG rules)"
    },
    "ai_guidance": "Implement session auditing to capture all user activities within interactive sessions. On RHEL 8/9, deploy screen recording using script command automatically on SSH login: add to /etc/profile: `if [ -n \"$SSH_CONNECTION\" ]; then script -qf /var/log/sessions/$(date +%Y%m%d_%H%M%S)_$USER.log; fi`. Configure sudosh2 for shell session recording: install and configure as default shell for privileged users. For privileged access management, deploy BeyondTrust, CyberArk Session Bridge capturing full RDP/SSH sessions with video replay. Use asciinema for terminal session recording with web-based playback: `asciinema rec /var/log/sessions/session.cast`. On Windows, enable PowerShell transcript logging: Group Policy → Administrative Templates → Windows PowerShell → Turn on PowerShell Transcription, output to `\\server\\share\\PSTranscripts`. Configure RDP session logging: enable Remote Desktop Session Host auditing capturing all actions. Deploy database session recording: Oracle Database Vault session capture, PostgreSQL log_statement=all with session correlation. Implement kernel-level session monitoring: auditd TTY auditing capturing all keystrokes: `-a always,exit -F arch=b64 -S write -F a0=1 -k tty_input`. Create automated analysis detecting suspicious session activities: unusual commands, off-hours access, rapid command sequences. Retain session logs per AU-11 retention policy. Verify: cat /var/log/sessions/*.log shows full command history. Integrates with AC-2 (account management), AU-3 (audit content), IA-4 (identifier management)."
  },
  {
    "control_id": "au-14.1",
    "stig_id": "RHEL-08-030320",
    "control_name": "System Start-up",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Initiate session audits automatically at system start-up.",
    "parent_control": "AU-14",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "AU-14.1 extends the base AU-14 control by requiring session auditing to be automatically initiated when systems start up. This ensures no user activity occurs without audit coverage, eliminating the possibility of users logging in and performing actions before session monitoring is manually enabled. Instead of relying on administrators to enable session auditing after a system boots, this enhancement automates the process so auditing is always active from the moment the system is operational.",
    "example_implementation": "On Linux systems, this can be achieved by embedding session audit rule loading in the audit daemon startup scripts (via systemd or init scripts) or using audit-at-boot kernel parameters. On Windows, enabling auditing through Group Policy ensures all session-related events are logged from system startup. Organizations can also use initialization scripts that verify audit status on boot and alert if sessions are not being properly monitored.",
    "non_technical_guidance": "AU-14.1 (System Start-up) addresses the critical gap where session auditing might not be active from the moment a system powers on. Implementation considerations include:\n\n1. Automation Verification: Ensure that session auditing initialization is part of the standard system boot process and does not require manual intervention by administrators.\n\n2. Boot-Time Configuration: Verify that audit daemons (auditd on Linux, Windows Event Tracing on Windows) start automatically at system initialization with full session audit rules loaded.\n\n3. Boot-Time Alerts: Configure systems to alert administrators if session auditing fails to initialize properly during system startup.\n\n4. Testing and Validation: Regularly test system restarts to confirm that session auditing is automatically active without requiring administrator action.\n\n5. Documentation: Maintain clear documentation of the automatic session audit startup process and what occurs if there are startup failures.\n\n6. Failover Procedures: Define procedures for rapid re-initialization of session auditing if it fails to start automatically.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-2",
      "AU-14",
      "CA-7",
      "SI-4"
    ],
    "supplemental_guidance": "Automatic initiation of session audits at system start-up ensures continuous audit coverage and eliminates timing vulnerabilities where session monitoring might not be active. This enhancement is particularly important in high-security environments where any unmonitored user activity represents a compliance and security risk. Organizations must ensure that the audit framework initialization is not dependent on external services or administrative action that might fail or be delayed. Testing should include validation that session auditing is fully operational immediately after system startup, before any user sessions are established.",
    "implementation_scripts": {
      "linux": {
        "systemd_audit_startup": "#!/bin/bash\n# Ensure audit daemon starts at boot with session audit rules loaded\n# This implements AU-14.1 System Start-up requirement\n\n# Verify auditd is enabled to start at boot\nsystemctl enable auditd\nsystemctl status auditd\n\n# Create or verify audit rules directory and session audit rules\nmkdir -p /etc/audit/rules.d\n\n# Ensure session audit rules are loaded on daemon startup\nif ! grep -q \"session-audit\" /etc/audit/rules.d/*.rules 2>/dev/null; then\n    cat > /etc/audit/rules.d/50-session-audit.rules << 'EOF'\n# Session Audit Rules - Loaded at boot (AU-14.1)\n-w /var/log/wtmp -p wa -k session_recording\n-w /var/log/btmp -p wa -k session_failed_login\n-w /var/log/lastlog -p wa -k session_lastlog\nEOF\nfi\n\n# Load rules immediately\naugenrules --load\nauditctl -R /etc/audit/rules.d/\nauditctl -l | grep -i session\n\necho 'Audit system configured for automatic session audit startup (AU-14.1)'\n\n# Verify audit service will auto-start on reboot\nsystemctl is-enabled auditd && echo 'PASS: auditd enabled for auto-start' || echo 'FAIL: auditd not enabled'",
        "init_script_audit_startup": "#!/bin/bash\n# Legacy init.d method for systems without systemd\n# Ensures auditd and session auditing start on boot\n\n# For RHEL/CentOS 7 or systems using init.d:\nupdate-rc.d auditd defaults 2>&1 | grep -q 'update-rc.d' && echo 'auditd configured for boot startup'\n\n# Add to /etc/init.d/auditd or create wrapper\n# Verify auditd loads rules on startup\nif [ -f /etc/init.d/auditd ]; then\n    # Inject rules loading into init script\n    sed -i 's|daemon /sbin/auditd|daemon /sbin/auditd\\n\\t/sbin/augenrules --load|g' /etc/init.d/auditd\nfi\n\necho 'Init.d audit startup configured for AU-14.1'",
        "audit_boot_verification": "#!/bin/bash\n# Verification script to confirm session auditing is active at system start\n# Run this during boot to validate AU-14.1 implementation\n\necho \"Verifying AU-14.1 System Start-up Implementation...\"\n\n# Check if audit daemon is running\nif ps aux | grep -v grep | grep auditd > /dev/null; then\n    echo \"PASS: Audit daemon is running\"\nelse\n    echo \"FAIL: Audit daemon is not running - session audit not active at startup\"\n    systemctl start auditd\nfi\n\n# Verify session audit rules are loaded\nif auditctl -l 2>/dev/null | grep -E \"(wtmp|btmp|lastlog|session)\" > /dev/null; then\n    echo \"PASS: Session audit rules are loaded\"\nelse\n    echo \"WARN: Session audit rules not loaded - loading now\"\n    augenrules --load\nfi\n\n# Check audit log is receiving events\nif auditctl -b 2>/dev/null | grep -q \"[0-9]\"; then\n    echo \"PASS: Audit log is receiving events\"\nelse\n    echo \"FAIL: No audit events detected\"\nfi\n\necho \"AU-14.1 verification complete\""
      },
      "windows": {
        "group_policy_boot_audit": "# Windows Group Policy Registry Configuration for AU-14.1 System Start-up\n# Ensures session auditing is enabled from system startup\n\nReg add \"HKLM\\System\\CurrentControlSet\\Services\\eventlog\\Security\" /v \"MaxSize\" /t REG_DWORD /d 4294967295 /f\nReg add \"HKLM\\System\\CurrentControlSet\\Services\\eventlog\\Security\" /v \"Retention\" /t REG_DWORD /d 0 /f\n\n# Enable audit policies that start automatically\nauditpol.exe /set /subcategory:\"Logon/Logoff\" /success:enable /failure:enable\nauditpol.exe /set /subcategory:\"Process Creation\" /success:enable /failure:enable\nauditpol.exe /set /subcategory:\"Process Termination\" /success:enable /failure:enable\n\necho \"Windows session auditing configured for automatic startup (AU-14.1)\"",
        "powershell_boot_audit": "$null = @\"\n# PowerShell script to configure Windows Event Auditing for startup\n# Implements AU-14.1 System Start-up requirement\n\n# Verify Windows Event Log service is set to auto-start\nGet-Service EventLog | Set-Service -StartupType Automatic\nStart-Service EventLog -ErrorAction SilentlyContinue\n\n# Configure audit policy for logon events (triggered at startup)\nauditpol.exe /set /subcategory:\"Logon/Logoff\" /success:enable /failure:enable | Out-Null\n\n# Configure Windows Event Forwarding for session auditing\n# Create event subscription to capture session events\n$eventSubscription = Get-EventSubscription -ErrorAction SilentlyContinue | Where-Object {$_.Name -eq \"SessionAudit\"}\nif (-Not $eventSubscription) {\n    $eventQuery = @'\n<QueryList>\n  <Query Id=\"0\" Path=\"Security\">\n    <Select Path=\"Security\">*[System[(EventID=4624) or (EventID=4625) or (EventID=4634) or (EventID=4688)]]\n    </Select>\n  </Query>\n</QueryList>\n'@\n    \n    New-EventSubscription -Name \"SessionAudit\" -Description \"AU-14.1 Session Audit\" -TargetComputer localhost -EventSourcePath $eventQuery -Enabled $true -ErrorAction SilentlyContinue\n}\n\n# Verify services are running and will start on boot\n$auditServices = @(\"EventLog\", \"Winmgmt\", \"mpssvc\")\nforeach ($service in $auditServices) {\n    $svc = Get-Service $service -ErrorAction SilentlyContinue\n    if ($svc) {\n        Set-Service -Name $service -StartupType Automatic\n        Start-Service -Name $service -ErrorAction SilentlyContinue\n        Write-Host \"Configured $service for auto-start\"\n    }\n}\n\nWrite-Host \"AU-14.1 Windows session audit startup configuration complete\"\n\"@",
        "audit_startup_verification": "# PowerShell verification script for AU-14.1 implementation\n# Validates that session auditing is active immediately after system startup\n\nWrite-Host \"Verifying AU-14.1 System Start-up Implementation...\"\n\n# Check Event Log service status\nif ((Get-Service EventLog).Status -eq \"Running\") {\n    Write-Host \"PASS: Event Log service is running\"\n} else {\n    Write-Host \"FAIL: Event Log service is not running\"\n    Start-Service EventLog\n}\n\n# Verify audit policies are enabled\n$auditPolicy = auditpol.exe /get /category:\"Logon/Logoff\" /r | ConvertFrom-Csv\nif ($auditPolicy.'Audit Success' -eq \"Yes\") {\n    Write-Host \"PASS: Logon/Logoff auditing is enabled\"\n} else {\n    Write-Host \"FAIL: Logon/Logoff auditing is not enabled\"\n}\n\n# Check for recent security events in Event Log\n$recentEvents = Get-EventLog -LogName Security -Newest 10 -ErrorAction SilentlyContinue\nif ($recentEvents) {\n    Write-Host \"PASS: Security events are being logged\"\n} else {\n    Write-Host \"FAIL: No recent security events detected\"\n}\n\n# Verify Winlogon will initialize auditing on startup\nif (Test-Path \"HKLM:\\Software\\Policies\\Microsoft\\Windows\\System\\Audit\") {\n    Write-Host \"PASS: Audit policies are configured in registry\"\n} else {\n    Write-Host \"INFO: Configuring audit policies in registry\"\n}\n\nWrite-Host \"AU-14.1 verification complete\""
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "qa_verified": true,
      "nist_aligned": true,
      "stig_id": "RHEL-08-030320"
    },
    "cac_metadata": {
      "implementation_type": "boot_configuration",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "available",
      "cac_planned": true,
      "implementation_guidance": "AU-14.1 requires audit framework initialization at system boot. ComplianceAsCode includes audit daemon startup rules for RHEL/CentOS. Windows implementations use Group Policy to ensure auditing begins immediately upon system initialization.",
      "stig_id": "RHEL-08-030320, RHEL-08-030330"
    },
    "ai_guidance": "Initiate session auditing automatically at system start-up to capture all activities from boot. On RHEL 8/9, configure systemd to start session auditing early in boot sequence: create /etc/systemd/system/session-audit.service with `Before=multi-user.target`, `WantedBy=multi-user.target`. Enable auditd early boot logging: configure kernel command line in /etc/default/grub with `audit=1` parameter, regenerate grub config: `grub2-mkconfig -o /boot/grub2/grub.cfg`. This enables audit logging before auditd daemon starts. Configure rsyslog to start before user sessions: verify rsyslog.service has `Before=getty.target`. Implement systemd-journald persistent storage: create /var/log/journal/ directory, configure /etc/systemd/journald.conf with `Storage=persistent` capturing boot messages. For UEFI Secure Boot systems, enable UEFI event logging to TPM capturing firmware-level events. On Windows, configure Event Log service to auto-start: verify Windows Event Log service startup type is Automatic in services.msc. Enable Early Launch Antimalware (ELAM) logging capturing pre-boot drivers. Deploy measured boot with TPM logging all boot components. Configure BIOS/UEFI audit logging where available (Dell iDRAC, HP iLO). Create boot event analysis: `journalctl -b | grep audit` or `ausearch -m SYSTEM_BOOT -i`. Verify session auditing active before first user login: check timestamps in audit.log vs. system boot time. Integrates with AU-14 (session audit), SI-7 (integrity verification), SC-8 (transmission confidentiality/integrity)."
  },
  {
    "control_id": "au-14.2",
    "stig_id": "RHEL-08-030330",
    "control_name": "Capture and Record Content",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Provide the capability to capture and record the content of a user session.",
    "parent_control": "AU-14",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "AU-14.2 requires that organizations implement the technical capability to capture and record the actual content occurring within user sessions. This means recording not just the fact that a session occurred, but the substantive content of what the user did - including commands executed, keystrokes entered, file operations, terminal output, and other session activities. This enhancement goes beyond simple session initiation logging to provide a complete record of session activities that can be reviewed for security analysis, incident investigation, or compliance verification.",
    "example_implementation": "Linux implementations use tools like 'script' and 'scriptreplay' to record terminal sessions, auditd with session tracking rules, or specialized tools like Teleport that record all session activity. Windows implementations might use terminal session recording features, PowerShell transcript logging, or Windows Event Tracing for administrative sessions. Organizations may also deploy session recording appliances or Software-as-a-Service solutions that intercept and record all session content in real-time.",
    "non_technical_guidance": "AU-14.2 (Capture and Record Content) requires implementing technology to capture complete session activity records:\n\n1. Content Capture Mechanisms: Organizations must deploy tools capable of recording actual session content (commands, output, keystrokes) not just session metadata. This may involve:\n   - Terminal session recording (Linux/Unix)\n   - PowerShell transcript logging (Windows)\n   - SSH session recording (network access)\n   - Remote desktop session recording\n   - Application-level command logging\n\n2. Selective vs. Continuous Recording: Determine whether to record all sessions continuously (high storage overhead) or selectively based on user role, activity type, or compliance requirements.\n\n3. Data Privacy and Minimization: Session content may contain sensitive information. Organizations must:\n   - Implement strict access controls on recorded content\n   - Consider privacy impact assessments before deployment\n   - Use data minimization principles (record only essential session content)\n   - Encrypt recorded session data\n   - Establish secure deletion procedures\n\n4. Storage and Performance: Recording session content requires significant storage capacity and may impact system performance. Organizations must:\n   - Estimate storage requirements based on user population and recording duration\n   - Implement archival strategies for older recordings\n   - Monitor system performance impact\n   - Plan for adequate backup and disaster recovery\n\n5. Access and Playback: Define who can access recorded sessions and establish procedures for:\n   - Authorized session review (security team, incident responders)\n   - Session playback and analysis\n   - Extraction of evidence from sessions\n   - Audit trail for who accessed which recordings\n\n6. Legal and Compliance Considerations: Ensure that session recording:\n   - Complies with privacy regulations (GDPR, CCPA, etc.)\n   - Follows applicable labor laws regarding employee monitoring\n   - Has documented business justification\n   - Is disclosed to users as required by law\n\n7. Content Retention: Establish clear retention schedules for recorded session content (often 30-90 days for operational investigation, longer for compliance requirements).",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-2",
      "AU-4",
      "AU-6",
      "AU-9",
      "AU-12",
      "AU-14",
      "CA-7"
    ],
    "supplemental_guidance": "Capturing and recording session content provides detailed audit trail of user activities that enables investigation of security incidents, verification of user actions, and evidence collection for compliance audits. However, this capability raises significant privacy concerns since session recordings can contain sensitive information including passwords, confidential data, and personal information. Organizations must balance the security benefits of comprehensive session recording with privacy protections and employee rights. Implementation should include: (1) technical controls to restrict access to recorded content, (2) legal review to ensure compliance with privacy laws, (3) notification to users that sessions may be recorded, (4) encryption of stored session data, (5) regular purging of recorded content per retention policies, (6) audit trail showing who accessed recordings and when. Organizations should implement this enhancement selectively, recording only sessions that are justified for security or compliance reasons rather than recording all user sessions indiscriminately.",
    "implementation_scripts": {
      "linux": {
        "script_session_recording": "#!/bin/bash\n# Implement AU-14.2 using 'script' and 'scriptreplay' for terminal session recording\n# Records all terminal input and output for user session content capture\n\n# Method 1: Automatic session recording via bashrc for specific users\nfor user in $(awk -F: '$3 >= 1000 && $3 <= 60000 {print $1}' /etc/passwd); do\n    if [ -f /home/$user/.bashrc ]; then\n        if ! grep -q \"session_record\" /home/$user/.bashrc; then\n            cat >> /home/$user/.bashrc << 'EOF'\n# AU-14.2: Automatic session recording\nif [ -z \"$RECORDING\" ]; then\n    export RECORDING=true\n    SESSION_LOG_DIR=\"/var/log/session-recordings\"\n    mkdir -p \"$SESSION_LOG_DIR\"\n    SESSION_LOG=\"$SESSION_LOG_DIR/${USER}_$(date +%Y%m%d_%H%M%S).log\"\n    script -f \"$SESSION_LOG\"\nfi\nEOF\n        fi\n    fi\ndone\n\necho 'Session recording via script configured for AU-14.2'\n\n# Create session recording directory\nmkdir -p /var/log/session-recordings\nchmod 700 /var/log/session-recordings",
        "auditd_content_capture": "#!/bin/bash\n# Configure auditd to capture session content and commands\n# Implements AU-14.2 for command and session activity logging\n\ncat > /etc/audit/rules.d/session-content.rules << 'EOF'\n# AU-14.2: Session Content Capture\n# Track all executed commands and session activities\n\n# Monitor execv syscall to capture all command execution\n-a always,exit -F arch=b64 -S execve -F auid!=4294967295 -k session_commands\n-a always,exit -F arch=b32 -S execve -F auid!=4294967295 -k session_commands\n\n# Monitor file access and modifications during sessions\n-w /tmp/ -p wa -k session_file_ops\n-w /home/ -p wa -k session_file_ops\n\n# Monitor network connections\n-a always,exit -F arch=b64 -S socket -S connect -S sendto -S recvfrom -S sendmsg -S recvmsg -F auid!=4294967295 -k session_network\n\n# Monitor terminal operations (TTY)\n-w /dev/pts/ -p rw -k session_tty\n\n# Make rules permanent\n-e 2\nEOF\n\naugenrules --load\nauditctl -l | grep session\necho 'Auditd session content capture configured for AU-14.2'",
        "session_content_parser": "#!/bin/bash\n# Utility to parse and display recorded session content\n# Extract session commands and activities from audit logs\n\ncat > /usr/local/bin/parse-session-content.sh << 'EOF'\n#!/bin/bash\n# Parse auditd logs to extract session content\n\nif [ -z \"$1\" ]; then\n    echo \"Usage: $0 [username|session_id]\"\n    exit 1\nfi\n\nUSERNAME=\"$1\"\n\necho \"=== Session Content for $USERNAME ===\"\ngrep \"$USERNAME\" /var/log/audit/audit.log | \\\n    grep -E \"(execve|socket|connect|tty)\" | \\\n    awk -F'comm=' '{print $2}' | \\\n    cut -d'\"' -f2 | \\\n    sort | uniq -c | sort -rn\n\necho \"\"\necho \"=== Detailed Session Events ===\"\nauditctl -l | grep session_commands > /dev/null && \\\nautracerpt -ts \"2 hours ago\" /var/log/audit/audit.log | grep \"$USERNAME\"\nEOF\n\nchmod +x /usr/local/bin/parse-session-content.sh\necho 'Session content parser script installed'"
      },
      "windows": {
        "powershell_transcript_logging": "# Configure PowerShell Transcript Logging for AU-14.2 Session Content Capture\n# Records all PowerShell session content including commands and output\n\nPowerShell -Command \"\n# Create transcript directory\n\\$transcriptPath = \\\"C:\\\\Windows\\\\System32\\\\LogFiles\\\\PowerShell\\\\Transcripts\\\"\nif (-Not (Test-Path \\$transcriptPath)) {\n    New-Item -Path \\$transcriptPath -ItemType Directory -Force | Out-Null\n}\n\n# Configure Group Policy for PowerShell Transcription\n\\$transcriptRegistry = \\\"HKLM:\\\\Software\\\\Policies\\\\Microsoft\\\\Windows\\\\PowerShell\\\\Transcription\\\"\nif (-Not (Test-Path \\$transcriptRegistry)) {\n    New-Item -Path \\$transcriptRegistry -Force | Out-Null\n}\n\n# Enable transcription of all PowerShell sessions\nSet-ItemProperty -Path \\$transcriptRegistry -Name \\\"EnableTranscripting\\\" -Value 1 -Type DWord\nSet-ItemProperty -Path \\$transcriptRegistry -Name \\\"OutputDirectory\\\" -Value \\$transcriptPath -Type String\nSet-ItemProperty -Path \\$transcriptRegistry -Name \\\"EnableInvocationHeader\\\" -Value 1 -Type DWord\nSet-ItemProperty -Path \\$transcriptRegistry -Name \\\"IncludeInvocationHeader\\\" -Value 1 -Type DWord\n\nWrite-Host \\\"PowerShell transcript logging configured for AU-14.2\\\"\n\"",
        "terminal_session_recording": "# Configure Remote Desktop Session Recording for AU-14.2\n# Captures Terminal Services session content on Windows\n\nPowerShell -Command \"\n# Enable RDP session recording via Group Policy\n\\$rdpRegistry = \\\"HKLM:\\\\Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\Terminal Services\\\"\nif (-Not (Test-Path \\$rdpRegistry)) {\n    New-Item -Path \\$rdpRegistry -Force | Out-Null\n}\n\n# Enable session recording\nSet-ItemProperty -Path \\$rdpRegistry -Name \\\"RecordingPath\\\" -Value \\\"C:\\\\SessionRecordings\\\" -Type String\nSet-ItemProperty -Path \\$rdpRegistry -Name \\\"RecordingOptions\\\" -Value 1 -Type DWord\n\n# Create recordings directory\nif (-Not (Test-Path \\\"C:\\\\SessionRecordings\\\")) {\n    New-Item -Path \\\"C:\\\\SessionRecordings\\\" -ItemType Directory -Force | Out-Null\n    icacls \\\"C:\\\\SessionRecordings\\\" /grant:r \\\"SYSTEM:(OI)(CI)F\\\" /inheritance:e\n}\n\nWrite-Host \\\"RDP session recording configured for AU-14.2\\\"\n\"",
        "event_viewer_session_tracking": "# Configure Windows Event Viewer to track session content\n# Monitors process execution, file access, and network activity during sessions\n\nRem Enable Process Creation Auditing\nauditpol.exe /set /subcategory:\"Process Creation\" /success:enable /failure:enable\n\nRem Enable File Access Auditing\nauditpol.exe /set /subcategory:\"File System\" /success:enable /failure:enable\nauditpol.exe /set /subcategory:\"Other Object Access Events\" /success:enable /failure:enable\n\nRem Enable Network Activity Auditing\nauditpol.exe /set /subcategory:\"Filtering Platform Connection\" /success:enable /failure:enable\n\nRem Enable Registry Auditing\nauditpol.exe /set /subcategory:\"Registry\" /success:enable /failure:enable\n\nRem Enable SAM Auditing (user and group management)\nauditpol.exe /set /subcategory:\"SAM\" /success:enable /failure:enable\n\necho Windows event-based session content tracking configured for AU-14.2"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "qa_verified": true,
      "nist_aligned": true,
      "stig_id": "RHEL-08-030330"
    },
    "cac_metadata": {
      "implementation_type": "content_recording",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "available",
      "cac_planned": true,
      "implementation_guidance": "AU-14.2 requires actual session content recording, not just session metadata. ComplianceAsCode content includes auditd rules for command capture and execution tracking. Windows implementations should use PowerShell transcript logging or Terminal Services session recording features.",
      "stig_id": "RHEL-08-030330, RHEL-08-030340, RHEL-08-030350"
    },
    "ai_guidance": "Capture and record content within sessions including screen output, keystrokes, mouse clicks, and accessed resources. Deploy comprehensive session recording solutions: Teleport for SSH/Kubernetes session recording with video playback, Apache Guacamole for RDP/VNC recording. On RHEL 8/9, implement screen recording with ttyrec: `ttyrec /var/log/sessions/session-$(date +%s).ttyrec`, playback with ttyplay. Configure X11 session recording using recordmydesktop or VNC server logging: `recordmydesktop --output=/var/log/sessions/x11-session.ogv`. For terminal sessions, use asciinema with automatic recording: add to ~/.bashrc: `asciinema rec --append /var/log/sessions/$(whoami).cast`. Deploy keylogger for privileged sessions (with user notice): configure kernel-level keystroke capture via loadable kernel module. On Windows, enable PowerShell script block logging: Group Policy → Administrative Templates → Windows PowerShell → Turn on PowerShell Script Block Logging capturing full command text. Configure RDP session shadowing: Enable \"Remote Desktop Session Host Configuration\" → Connections → RDP-Tcp → Properties → Remote Control for live monitoring. Use process accounting to log all commands: enable psacct: `systemctl enable psacct`, review with lastcomm. Capture file access events: `-w /home -p rwa -k file_access`. Implement DPI for web sessions: deploy SSL intercept proxy (Squid, Blue Coat) capturing HTTPS session content. Store recordings with encryption (AU-9.3). Document user notification requirements (privacy laws). Test: replay recorded session, verify completeness. Integrates with AU-14 (session audit), AU-14.3 (remote viewing), AC-17 (remote access)."
  },
  {
    "control_id": "au-14.3",
    "stig_id": "RHEL-08-030360",
    "control_name": "Remote Viewing and Listening",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "Provide and implement the capability for authorized users to remotely view and hear content related to an established user session in real time.",
    "parent_control": "AU-14",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "AU-14.3 requires organizations to provide real-time remote monitoring capabilities for session content. This means authorized security personnel or incident responders can connect to a monitoring interface and observe user session activities as they happen (in real-time), including viewing terminal output and listening to audio from sessions (in systems with voice/multimedia capabilities). This enhancement enables immediate detection and response to suspicious activities without waiting for audit logs to be processed later. The capability is restricted to authorized users only and provides real-time visibility into user session activities across the organization's systems.",
    "example_implementation": "Organizations can implement this using session monitoring tools like Teleport with real-time session playback, bastion hosts with session broadcasting capabilities, SSH multiplexing for real-time session viewing, or specialized session monitoring platforms (commercial or open-source) that provide real-time stream access. For RDP sessions, Windows Remote Assistance or monitoring tools can enable real-time viewing. Organizations must implement authentication and authorization mechanisms to ensure only designated personnel can access real-time session monitoring.",
    "non_technical_guidance": "AU-14.3 (Remote Viewing and Listening) enables real-time monitoring of user sessions, providing immediate visibility into user activities:\n\n1. Real-Time Monitoring Objectives: Determine organizational requirements for real-time session monitoring:\n   - Incident response teams need immediate visibility into user activities during security incidents\n   - Security operations center (SOC) may monitor high-risk sessions in real-time\n   - Compliance teams may observe sessions for audit purposes\n   - Forensic capabilities to see session activity as it occurs\n\n2. Authorization and Access Control: Implement strict controls:\n   - Only designated roles (security team, incident responders, compliance officers) can initiate real-time monitoring\n   - Document all real-time monitoring activities and justifications\n   - Establish approval workflows for initiating real-time session monitoring\n   - Create audit trail showing who monitored which sessions and when\n\n3. User Notification: Determine notification requirements:\n   - In some jurisdictions, users must be notified that their session is being actively monitored\n   - Develop procedures for appropriate notification (real-time banner, post-incident disclosure, etc.)\n   - Document legal requirements for user notification based on applicable laws\n\n4. Technical Implementation Options:\n   - Session forwarding/multiplexing (multiple parties view same session)\n   - Real-time session stream to dedicated monitoring interface\n   - Web-based dashboard showing live session activity\n   - Audio/video capture if multimedia sessions\n   - Integration with incident response tools\n\n5. Privacy and Civil Liberties Considerations:\n   - Real-time monitoring is more intrusive than recorded playback\n   - Ensure clear business justification (only during investigations or for critical systems)\n   - Limit scope (specific users, sessions, time windows)\n   - Include privacy officials in authorization decisions\n   - Establish boundaries on what information can be monitored\n\n6. Performance and System Impact:\n   - Real-time monitoring may impact system performance\n   - Ensure monitoring mechanisms don't degrade user experience\n   - Plan for bandwidth requirements if remote monitoring over network\n   - Consider load on monitoring systems from multiple concurrent monitors\n\n7. Session Termination Capability:\n   - Consider whether authorized monitors can terminate monitored sessions\n   - Define procedures for emergency session termination if malicious activity detected\n   - Document authorization requirements for session termination\n\n8. Integration with Response Procedures:\n   - Define workflows for responding to incidents detected through real-time monitoring\n   - Integrate with incident response playbooks\n   - Establish escalation procedures\n   - Maintain audit trail of monitoring activities and any remediation actions taken",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-2",
      "AU-4",
      "AU-6",
      "AU-12",
      "AU-14",
      "CA-7",
      "IR-4",
      "SI-4"
    ],
    "supplemental_guidance": "Real-time remote viewing and listening capability enables immediate detection and response to security incidents by providing live visibility into user session activities. This enhancement is particularly valuable during active incident investigations or when monitoring high-risk accounts (privileged users, contractors, new employees). Organizations must carefully balance the security benefits of real-time monitoring with privacy protections. Implementation considerations include: (1) restricting access to only authorized personnel with documented justification, (2) considering whether real-time monitoring requires special authorization or court orders in some jurisdictions, (3) implementing notification mechanisms where legally required, (4) encrypting all communication channels for remote monitoring to prevent unauthorized access, (5) maintaining detailed audit trail of all monitoring activities, (6) integrating with incident response processes, (7) establishing clear procedures for what actions monitors can take (observation only vs. ability to terminate sessions), (8) ensuring performance monitoring doesn't negatively impact monitored systems. Organizations should implement this capability selectively rather than providing continuous monitoring of all user sessions, reserving real-time monitoring for specific incidents, high-risk accounts, or compliance audits.",
    "implementation_scripts": {
      "linux": {
        "ssh_multiplexing_real_time_view": "#!/bin/bash\n# Implement AU-14.3 Real-Time Session Viewing using SSH Multiplexing\n# Allows authorized users to join and view active SSH sessions in real time\n\n# Install prerequisite tools\nwhich tmux > /dev/null || apt-get install -y tmux\nwhich screen > /dev/null || apt-get install -y screen\n\n# Configure tmux for real-time session sharing (AU-14.3)\ncat > /etc/tmux.conf << 'EOF'\n# AU-14.3: Enable real-time session monitoring via tmux\n# Multiple users can view same session in real-time\n\nset -g allow-rename off\nset -g monitor-activity on\nset -g monitor-silence 0\n\n# Enable session sharing for authorized users\nset -g default-terminal \"screen-256color\"\nset -g exit-unattached off\n\n# Log all session activity\nset -g history-limit 50000\n\n# Create a read-only session view for monitoring\nset -g status-left \"[session-name: #S]\"\nEOF\n\n# Create script to launch monitored sessions\ncat > /usr/local/bin/start-monitored-session.sh << 'EOF'\n#!/bin/bash\n# Start a user session with real-time monitoring enabled\n# Usage: start-monitored-session.sh username session_name\n\nif [ $# -ne 2 ]; then\n    echo \"Usage: $0 username session_name\"\n    exit 1\nfi\n\nUSERNAME=$1\nSESSION_NAME=$2\n\n# Start tmux session as specified user\nsudo -u $USERNAME tmux new-session -d -s $SESSION_NAME -x 120 -y 40\n\n# Grant monitor permission to security group\nchmod g+rw /proc/$$/fd/$(tmux display-message -p '#{client_tty}' | sed 's|/dev/||')\n\necho \"Monitored session started: $SESSION_NAME (user: $USERNAME)\"\necho \"Authorized monitors can connect with: tmux attach -t $SESSION_NAME -r\"\nEOF\n\nchmod +x /usr/local/bin/start-monitored-session.sh\n\n# Create authorization wrapper\ncat > /usr/local/bin/monitor-session.sh << 'EOF'\n#!/bin/bash\n# Authorized session monitoring wrapper (AU-14.3)\n# Enforces authorization before allowing session monitoring\n\nif [ \"$EUID\" != \"0\" ] && ! groups | grep -q \"monitor-group\"; then\n    echo \"ERROR: Not authorized to monitor sessions\"\n    exit 1\nfi\n\nif [ -z \"$1\" ]; then\n    echo \"Usage: $0 session_name\"\n    exit 1\nfi\n\nSESSION=$1\n\n# Audit the monitoring action\nauditctl -w /usr/local/bin/monitor-session.sh -p x -k session_monitoring\necho \"[$(date)] Monitoring started for session: $SESSION by user: $(whoami)\" >> /var/log/session-monitoring.log\n\n# Attach as read-only observer\ntmux attach -t $SESSION -r\nEOF\n\nchmod +x /usr/local/bin/monitor-session.sh\n\necho 'SSH session multiplexing for real-time viewing configured (AU-14.3)'",
        "web_based_session_viewer": "#!/bin/bash\n# Configure web-based real-time session viewer (AU-14.3)\n# Provides remote access to view live session activity via web interface\n\n# Install asciinema for session recording and playback\nwhich asciinema > /dev/null || pip install asciinema\n\n# Create web viewer script\ncat > /usr/local/bin/session-viewer-server.py << 'EOF'\n#!/usr/bin/env python3\n# Simple web server for real-time session viewing (AU-14.3)\nimport os\nimport subprocess\nfrom http.server import HTTPServer, SimpleHTTPRequestHandler\nimport json\nimport tempfile\n\nclass SessionViewerHandler(SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/api/sessions':\n            # Return list of monitored sessions\n            sessions = self.list_active_sessions()\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(sessions).encode())\n        elif self.path.startswith('/api/session/'):\n            # Stream session output\n            session_id = self.path.split('/')[-1]\n            self.stream_session(session_id)\n        else:\n            super().do_GET()\n    \n    def list_active_sessions(self):\n        # Get tmux sessions\n        result = subprocess.run(['tmux', 'list-sessions', '-F', '#{session_name}'],\n                              capture_output=True, text=True)\n        sessions = [s.strip() for s in result.stdout.split('\\n') if s.strip()]\n        return {\"sessions\": sessions}\n    \n    def stream_session(self, session_id):\n        # Stream real-time output from session\n        cmd = f'tmux capture-pane -t {session_id} -p'\n        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)\n        self.send_response(200)\n        self.send_header('Content-type', 'text/plain')\n        self.end_headers()\n        self.wfile.write(result.stdout.encode())\n\nif __name__ == '__main__':\n    PORT = 8443\n    server = HTTPServer(('localhost', PORT), SessionViewerHandler)\n    print(f'AU-14.3 Session Viewer running on https://localhost:{PORT}')\n    server.serve_forever()\nEOF\n\nchmod +x /usr/local/bin/session-viewer-server.py\n\necho 'Web-based session viewer configured for AU-14.3'"
      },
      "windows": {
        "remote_assistance_monitoring": "# Configure Windows Remote Assistance for Real-Time Session Monitoring (AU-14.3)\n# Allows authorized users to remotely view user sessions in real-time\n\nPowerShell -Command \"\n# Enable Remote Assistance\nSet-ItemProperty -Path \\\"HKLM:\\\\System\\\\CurrentControlSet\\\\Control\\\\Remote Assistance\\\" -Name \\\"fAllowToGetHelp\\\" -Value 1 -Type DWord\nSet-ItemProperty -Path \\\"HKLM:\\\\System\\\\CurrentControlSet\\\\Control\\\\Remote Assistance\\\" -Name \\\"fAllowFullControl\\\" -Value 1 -Type DWord\n\n# Configure Remote Desktop for session viewing\nSet-ItemProperty -Path \\\"HKLM:\\\\System\\\\CurrentControlSet\\\\Control\\\\Terminal Server\\\" -Name \\\"fDenyTSConnections\\\" -Value 0 -Type DWord\n\n# Enable the remote desktop service\nSet-Service -Name TermService -StartupType Automatic\nStart-Service -Name TermService -ErrorAction SilentlyContinue\n\nWrite-Host \\\"Remote Assistance configured for AU-14.3 session monitoring\\\"\n\"",
        "bastion_host_session_broadcast": "# Configure Bastion Host for Real-Time Session Broadcasting (AU-14.3)\n# Enable multiple authorized monitors to view sessions from jump host\n\nPowerShell -Command \"\n# Install OpenSSH if not present\nif (-not (Get-WindowsCapability -Online | Where-Object {\\$_.Name -like '*OpenSSH.Server*'}).State -eq 'Installed') {\n    Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0\n}\n\n# Configure SSH for session monitoring\n\\$sshConfig = @'\nMatch User monitor-group\n    AllowAgentForwarding yes\n    AllowTcpForwarding yes\n    ForceCommand tmux attach\nMatch Group monitor-group\n    AuthorizedKeysFile .ssh/authorized_keys\nMatch Group admin\n    X11Forwarding yes\n    AllowTcpForwarding yes\n'@\n\nAdd-Content -Path \\\"C:\\\\ProgramData\\\\ssh\\\\sshd_config\\\" -Value \\$sshConfig\n\n# Restart SSH service\nRestart-Service sshd\n\nWrite-Host \\\"Bastion host session broadcasting configured for AU-14.3\\\"\n\"",
        "rdp_session_monitoring": "# Configure Remote Desktop Protocol (RDP) for Real-Time Session Monitoring (AU-14.3)\n# Enables authorized users to monitor RDP sessions in real-time\n\nRem Enable Remote Desktop\nReg add \\\"HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\Terminal Server\\\" /v fDenyTSConnections /t REG_DWORD /d 0 /f\n\nRem Enable RDP listener\nReg add \\\"HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\Terminal Server\\\\WinStations\\\\RDP-Tcp\\\" /v PortNumber /t REG_DWORD /d 3389 /f\n\nRem Enable Network Level Authentication\nReg add \\\"HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\Terminal Server\\\\WinStations\\\\RDP-Tcp\\\" /v SecurityLayer /t REG_DWORD /d 2 /f\n\nRem Allow multiple concurrent RDP sessions (for monitoring)\nReg add \\\"HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\Terminal Server\\\" /v MaxInstanceCount /t REG_DWORD /d 10 /f\n\nRem Enable session recording\nReg add \\\"HKLM\\\\Software\\\\Policies\\\\Microsoft\\\\Windows NT\\\\Terminal Services\\\" /v RecordingPath /t REG_SZ /d \\\"C:\\\\SessionRecordings\\\" /f\n\nRem Start RDP Service\nNet start TermService\n\necho Remote Desktop session monitoring configured for AU-14.3"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000Z",
      "has_scripts": true,
      "qa_verified": true,
      "nist_aligned": true,
      "stig_id": "RHEL-08-030360"
    },
    "cac_metadata": {
      "implementation_type": "real_time_monitoring",
      "last_analyzed": "2025-11-20T00:00:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "available",
      "cac_planned": true,
      "implementation_guidance": "AU-14.3 requires real-time session viewing capability for authorized users. Linux implementations can use tmux/screen session sharing, SSH port forwarding, or specialized tools like Teleport. Windows implementations use Remote Assistance, RDP monitoring, or bastion host configurations.",
      "stig_id": "RHEL-08-030360, RHEL-08-030370"
    },
    "ai_guidance": "Prohibit remote viewing or listening except for authorized monitoring. Implement technical controls preventing unauthorized screen sharing, audio capture, and remote control. On RHEL 8/9, disable VNC server by default: `systemctl disable vncserver@.service`, enable only for authorized remote support sessions. Configure X11 forwarding restrictions in /etc/ssh/sshd_config: `X11Forwarding no`, `AllowTcpForwarding no` for standard users. Use PAM to enforce remote access policies: configure /etc/security/access.conf with `-:ALL EXCEPT wheel:ALL` restricting remote login to wheel group. Deploy network access control (NAC) requiring pre-authorization for remote desktop connections. On Windows, disable Remote Desktop by default: Group Policy → Computer Configuration → Administrative Templates → Windows Components → Remote Desktop Services → Deny logons to Remote Desktop Session Host. Implement just-in-time (JIT) privileged access: require approval workflow before enabling RDP, auto-disable after session. Use firewall rules blocking VNC ports (5900-5999), RDP port (3389) except from jump hosts. Deploy endpoint detection and response (EDR) detecting unauthorized remote access tools (TeamViewer, AnyDesk): CrowdStrike, SentinelOne. Audit remote viewing attempts: `-w /usr/bin/vncserver -p x -k remote_viewing`, Windows Event ID 4624 (logon type 10 = Remote Interactive). Create authorized remote access roster: quarterly review of who can remote in, from where, to which systems. Test controls: attempt unauthorized VNC connection, verify block and alert. Integrates with AC-17 (remote access), AC-3 (access enforcement), AU-14.2 (session content capture)."
  },
  {
    "control_id": "au-15",
    "stig_id": "V-230483",
    "control_name": "Alternate Audit Logging Capability",
    "family": "Audit and Accountability",
    "family_id": "au",
    "official_text": "The organization provides an alternate audit capability in the event of a failure in primary audit capability that provides [Assignment: organization-defined alternate audit functionality]. NOTE: This control was withdrawn in NIST SP 800-53 Revision 5 and incorporated into AU-5(5) - Alternate Audit Logging Capability. For legacy systems or organizations using NIST SP 800-53 Revision 4, AU-15 remains applicable.",
    "source": "NIST SP 800-53 Rev 4 (Withdrawn in Rev 5, now AU-5(5))",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This control requires organizations to have a backup or redundant audit logging system ready to activate if the primary audit system fails. This ensures that critical security events continue to be recorded even when the main logging infrastructure experiences an outage. The backup system does not necessarily need to provide all the same features as the primary system, but must capture the essential audit events needed for security monitoring and compliance.",
    "example_implementation": "Organizations can implement alternate audit logging by configuring a secondary syslog server to receive audit logs via rsyslog or audispd plugins, or by using cloud-based log aggregation services with automatic failover capabilities. The alternate system should be tested regularly to ensure it can activate seamlessly when needed.",
    "non_technical_guidance": "To implement alternate audit logging capability, follow these steps: 1) Identify critical audit events that must continue being logged during primary system failures. 2) Establish a secondary logging infrastructure separate from the primary system. 3) Configure automatic log forwarding to the alternate system using tools like rsyslog with TLS encryption. 4) Document procedures for detecting primary system failures and switching to the alternate system. 5) Conduct quarterly tests of the alternate logging capability to verify functionality. 6) Train security and system administration teams on the failover procedures. 7) Maintain up-to-date inventory of alternate logging infrastructure and configurations. 8) Review logs from alternate system regularly to ensure proper operation.",
    "ai_guidance": "When evaluating AU-15 compliance: Verify that alternate audit logging infrastructure exists and is separate from primary systems to prevent single points of failure. Confirm that log forwarding uses encrypted channels (TLS 1.2+) to protect in-transit audit data. Test failover mechanisms at least quarterly to ensure alternate system activates properly. Monitor both primary and alternate systems for performance and ensure adequate storage capacity for extended logging periods. Document organizational decisions about which audit events require alternate logging coverage versus complete log suite redundancy. Consider whether the organization needs real-time failover (preferred for high-assurance systems) or delayed failover (acceptable for lower-risk systems). Verify that alternate logging does not introduce new security risks through cleartext transmission or inadequate authentication. Ensure audit logs from both primary and alternate systems can be correlated for investigation purposes.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-5: Response to Audit Logging Process Failures",
      "AU-4: Audit Log Storage Capacity",
      "AU-2: Audit Events",
      "SI-4: Information System Monitoring"
    ],
    "supplemental_guidance": "Alternate audit logging capabilities serve as a temporary measure until primary auditing functionality is restored. Organizations should determine whether the alternate solution needs to provide the complete suite of primary audit functions or merely the specific capabilities affected by the failure. Considerations include: recovery time objectives (RTO) for audit logging, criticality of different audit event types, geographic distribution of logging systems, and resilience requirements based on system classification and risk tolerance. The alternate capability should be tested to verify it functions properly when needed and should be maintained with the same rigor as the primary system.",
    "implementation_scripts": {
      "linux": {
        "rhel8_audispd_syslog_forwarder": {
          "description": "Configure auditd with audispd plugin to forward logs to remote syslog server",
          "script": "#!/bin/bash\n# RHEL 8/9 Alternate Audit Logging via Audispd-Syslog\n# This script configures the auditd dispatcher to forward audit logs to a remote syslog server\n\nset -e\n\n# Configuration variables\nSYSLOG_SERVER=\"${1:-log.example.com}\"\nSYSLOG_PORT=\"${2:-514}\"\nLOG_FACILITY=\"${3:-LOG_LOCAL6}\"\n\necho \"[*] Configuring audispd syslog plugin for alternate audit logging...\"\n\n# 1. Enable audispd syslog plugin\nif [ -f /etc/audisp/plugins.d/syslog.conf ]; then\n    sed -i 's/active = no/active = yes/' /etc/audisp/plugins.d/syslog.conf\n    echo \"[+] Enabled audispd syslog plugin\"\nelse\n    echo \"[-] audispd syslog plugin not found\"\n    exit 1\nfi\n\n# 2. Verify rsyslog is installed and running\nif ! command -v rsyslogd &> /dev/null; then\n    echo \"[-] rsyslog not installed, installing...\"\n    yum install -y rsyslog\nfi\n\nsystemctl enable rsyslog\nsystemctl start rsyslog\necho \"[+] rsyslog service enabled and started\"\n\n# 3. Configure rsyslog to receive audit logs\ncat >> /etc/rsyslog.conf << EOF\n\n# Accept audit logs from audispd\n\\$ModLoad imuxsock\n\\$AddUnixListenSocket /run/systemd/journal/syslog\n\\$RuleSet local6\n${LOG_FACILITY}.* @@${SYSLOG_SERVER}:${SYSLOG_PORT}\n\nEOF\n\n# 4. Test rsyslog configuration\nif ! rsyslogd -N 1 > /dev/null 2>&1; then\n    echo \"[-] rsyslog configuration error\"\n    exit 1\nfi\n\n# 5. Restart services\nsystemctl restart rsyslog\nsystemctl restart auditd\necho \"[+] Services restarted successfully\"\n\n# 6. Verify alternate logging is working\necho \"[*] Verifying alternate logging configuration...\"\nausearch -m DAEMON_START | head -1 || echo \"Waiting for first audit event...\"\n\necho \"[+] Alternate audit logging configured successfully\"\necho \"[*] Logs are being forwarded to ${SYSLOG_SERVER}:${SYSLOG_PORT}\"",
          "expected_outcome": "Audit logs are forwarded to remote syslog server via audispd plugin. The alternate logging system captures all auditd events.",
          "testing_procedure": "Monitor remote syslog server for incoming audit messages. Verify /var/log/audit/audit.log is still being written locally. Generate test audit events (e.g., failed login) and confirm appearance in both locations.",
          "compliance_mapping": "RHEL-08-030083, RHEL-08-030482"
        },
        "rhel8_rsyslog_tls_remote_logging": {
          "description": "Configure rsyslog with TLS encryption for secure remote audit logging",
          "script": "#!/bin/bash\n# RHEL 8/9 Secure Alternate Audit Logging with TLS\n# This script sets up rsyslog with TLS encryption for remote audit log transmission\n\nset -e\n\nSYSLOG_SERVER=\"${1:-log.example.com}\"\nSYSLOG_PORT=\"${2:-6514}\"\nCA_CERT=\"${3:-/etc/pki/tls/certs/ca-bundle.crt}\"\n\necho \"[*] Configuring rsyslog with TLS for alternate audit logging...\"\n\n# 1. Install required packages\necho \"[*] Installing GnuTLS support packages...\"\nyum install -y rsyslog-gnutls gnutls-utils\n\n# 2. Create rsyslog TLS configuration\ncat > /etc/rsyslog.d/30-audit-tls.conf << EOF\n# TLS configuration for alternate audit logging\n\\$DefaultNetstreamDriver gtls\n\\$DefaultNetstreamDriverCAFile ${CA_CERT}\n\\$ActionSendStreamDriverMode 1\n\\$ActionSendStreamDriverAuthMode x509/name\n\\$ActionSendStreamDriverPermittedPeer *.example.com\n\n# Forward audit logs to remote server over TLS\n:programname, isequal, \"audisp-syslog\" @@(o)${SYSLOG_SERVER}:${SYSLOG_PORT}\nEOF\n\n# 3. Verify rsyslog configuration\nif ! rsyslogd -N 1 > /dev/null 2>&1; then\n    echo \"[-] rsyslog configuration validation failed\"\n    exit 1\nfi\necho \"[+] rsyslog configuration validated\"\n\n# 4. Restart rsyslog\nsystemctl restart rsyslog\necho \"[+] rsyslog restarted with TLS configuration\"\n\n# 5. Verify encrypted connection\necho \"[*] Verifying TLS connection to ${SYSLOG_SERVER}...\"\ngnutls-cli -p ${SYSLOG_PORT} ${SYSLOG_SERVER} < /dev/null > /dev/null 2>&1 && \\\n    echo \"[+] TLS connection successful\" || \\\n    echo \"[!] Warning: TLS connection verification failed (server may not be online yet)\"\n\necho \"[+] Secure alternate audit logging configured\"",
          "expected_outcome": "Audit logs are encrypted and transmitted to remote syslog server over TLS 1.2+ connection with certificate validation.",
          "testing_procedure": "Use tcpdump or tshark to verify traffic on port 6514 is encrypted. Check rsyslog logs for TLS handshake success. Verify remote server receives encrypted audit events.",
          "compliance_mapping": "RHEL-08-030482, RHEL-08-030670"
        },
        "audit_redundancy_test": {
          "description": "Test alternate audit logging failover capability",
          "script": "#!/bin/bash\n# Audit System Redundancy Test\n# Verifies that alternate logging activates when primary system fails\n\nset -e\n\necho \"[*] Testing audit system redundancy...\"\n\n# 1. Verify both systems are operational\necho \"[*] Checking primary audit system...\"\nauditctl -l > /dev/null && echo \"[+] Primary audit system operational\" || {\n    echo \"[-] Primary audit system not operational\"\n    exit 1\n}\n\n# 2. Check for alternate logging configuration\nif grep -q \"audispd-syslog\\|@@\" /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null; then\n    echo \"[+] Alternate logging configuration detected\"\nelse\n    echo \"[-] No alternate logging configuration found\"\n    exit 1\nfi\n\n# 3. Generate test audit event\necho \"[*] Generating test audit event...\"\nlogger -t test_audit \"TEST: Alternate logging capability test\"\nsleep 2\n\n# 4. Verify event in primary log\nif grep -q \"test_audit\" /var/log/audit/audit.log; then\n    echo \"[+] Event captured in primary audit log\"\nelse\n    echo \"[!] Warning: Event not found in primary log (may still be in audit buffer)\"\nfi\n\n# 5. Check alternate logging infrastructure\necho \"[*] Verifying alternate logging service status...\"\nsystemctl is-active rsyslog > /dev/null && echo \"[+] rsyslog service running\" || {\n    echo \"[-] rsyslog service not running\"\n    exit 1\n}\n\n# 6. Verify storage capacity\necho \"[*] Checking log storage...\"\naudit_usage=$(du -sh /var/log/audit/ 2>/dev/null | cut -f1 || echo \"Unknown\")\nrsyslog_usage=$(du -sh /var/log/ 2>/dev/null | cut -f1 || echo \"Unknown\")\necho \"[+] Audit log usage: ${audit_usage}\"\necho \"[+] Total log usage: ${rsyslog_usage}\"\n\n# 7. Test audit daemon restart recovery\necho \"[*] Testing audit daemon restart recovery...\"\nsystemctl restart auditd\nsleep 3\nauditctl -l > /dev/null && echo \"[+] Audit system recovered after restart\" || {\n    echo \"[-] Audit system failed to recover\"\n    exit 1\n}\n\necho \"[+] Alternate audit logging redundancy test PASSED\"",
          "expected_outcome": "All redundancy checks pass. Alternate logging is configured, services are running, and recovery is verified.",
          "testing_procedure": "Run this script as root. Monitor rsyslog service and audit logs during execution. Verify no audit events are lost during daemon restart.",
          "compliance_mapping": "AU-15, AU-5"
        }
      },
      "windows": {
        "windows_event_log_redundancy": {
          "description": "Configure Windows Event Log forwarding for redundant audit logging",
          "script": "# PowerShell Script: Configure Windows Event Log Forwarding\n# Sets up Windows Event Collector for alternate audit logging\n\nparam(\n    [string]$CollectorServer = \"collector.example.com\",\n    [string]$QueryString = \"*[System[(Level <= 2)]]\",\n    [string]$Protocol = \"HTTP\"\n)\n\nWrite-Host \"[*] Configuring Windows Event Log forwarding for alternate audit logging...\"\n\ntry {\n    # 1. Enable Windows Remote Management (WinRM)\n    Write-Host \"[*] Enabling WinRM service...\"\n    Enable-PSRemoting -Force\n    Set-Service WinRM -StartupType Automatic\n    Start-Service WinRM\n    Write-Host \"[+] WinRM enabled and started\"\n    \n    # 2. Configure Event Log Forwarding Subscription\n    Write-Host \"[*] Creating event forwarding subscription...\"\n    $subName = \"AlternateAuditLogging\"\n    $description = \"Forwards critical audit events to alternate collector\"\n    \n    # Remove existing subscription if present\n    Get-WinEvent -ListLog Security -Force -ErrorAction SilentlyContinue | Where-Object {$_.LogMode -eq \"Circular\"} | Out-Null\n    \n    # Create subscription using wecutil\n    $xml = @\"\n<Subscription xmlns=\"http://schemas.microsoft.com/windows/events/2010/Audit\">\n    <SubscriptionId>$subName</SubscriptionId>\n    <Description>$description</Description>\n    <Enabled>true</Enabled>\n    <Uri>http://schemas.dmtf.org/wbem/wscim/1/common</Uri>\n    <ConfigurationMode>MinBandwidth</ConfigurationMode>\n    <Delivery Mode=\"Push\">\n        <Batching>\n            <MaxItems>100</MaxItems>\n            <MaxLatencyTime>30000</MaxLatencyTime>\n        </Batching>\n        <PushSettings>\n            <Server>$CollectorServer</Server>\n        </PushSettings>\n    </Delivery>\n    <Query>\n        <Select Path=\"Security\">$QueryString</Select>\n    </Query>\n    <ReadExistingEvents>false</ReadExistingEvents>\n    <TransportName>$Protocol</TransportName>\n    <ContentFormat>Events</ContentFormat>\n    <Locale Language=\"en-US\"/>\n    <LogFile>ForwardedEvents</LogFile>\n    <AllowImmediateSubscriptionManager>true</AllowImmediateSubscriptionManager>\n    <ConnectionRetryCount>3</ConnectionRetryCount>\n    <ConnectionRetryInterval>60</ConnectionRetryInterval>\n    <HeartbeatInterval>900000</HeartbeatInterval>\n</Subscription>\n\"@\n    \n    Write-Host \"[*] Registering event subscription...\"\n    $xml | Out-File -Encoding UTF8 -FilePath \"$env:TEMP\\subscription.xml\"\n    & wecutil.exe cs \"$env:TEMP\\subscription.xml\"\n    Write-Host \"[+] Event subscription created successfully\"\n    \n    # 3. Verify forwarding is working\n    Write-Host \"[*] Verifying event forwarding...\"\n    $subscription = Get-WinEvent -ListLog ForwardedEvents -Force\n    if ($subscription.RecordCount -ge 0) {\n        Write-Host \"[+] ForwardedEvents log is operational ($($subscription.RecordCount) events)\"\n    }\n    \n    # 4. Configure local Event Log retention\n    Write-Host \"[*] Configuring Event Log retention policies...\"\n    & wevtutil.exe sl Security /ms:2097152 /rt:false /ab:false /enabled:true\n    Write-Host \"[+] Security log size set to 2GB with no retention limit\"\n    \n    # 5. Enable Event Log service\n    Write-Host \"[*] Ensuring Event Log service is running...\"\n    Set-Service EventLog -StartupType Automatic\n    Start-Service EventLog\n    Write-Host \"[+] Event Log service running\"\n    \n    Write-Host \"[+] Windows Event Log forwarding configured successfully\"\n    Write-Host \"[*] Critical events are now being forwarded to ${CollectorServer}\"\n    \n} catch {\n    Write-Host \"[-] Error configuring event log forwarding: $_\"\n    exit 1\n}",
          "expected_outcome": "Windows Event Forwarding subscription is created and active. Critical events are forwarded to alternate collector with local redundancy maintained.",
          "testing_procedure": "Verify subscription status with wecutil.exe. Check ForwardedEvents log for incoming events. Simulate system events and confirm appearance in both local and remote logs.",
          "compliance_mapping": "AU-15, AU-4"
        },
        "windows_event_log_backup": {
          "description": "Automated backup of Windows Event Logs to alternate storage",
          "script": "# PowerShell Script: Automated Event Log Backup for Redundancy\n\nparam(\n    [string]$BackupPath = \"C:\\AuditLogs\\Backup\",\n    [int]$RetentionDays = 90,\n    [string]$RemoteShare = \"\\\\\\\\backup-server\\\\auditlogs\"\n)\n\nWrite-Host \"[*] Configuring automated Event Log backup...\"\n\n# 1. Create backup directory structure\nif (-not (Test-Path -Path $BackupPath)) {\n    New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null\n    Write-Host \"[+] Backup directory created: $BackupPath\"\n}\n\n# 2. Create scheduled task for daily backup\n$taskName = \"AlternateAuditLogBackup\"\n$description = \"Daily backup of critical Event Logs to alternate storage\"\n\n$action = New-ScheduledTaskAction -Execute \"powershell.exe\" -Argument @\"\n-NoProfile -ExecutionPolicy Bypass -Command {\n    \\$logs = @('Security', 'System', 'Application')\n    foreach (\\$log in \\$logs) {\n        \\$filename = \"${BackupPath}\\\\\\${log}_\\$(Get-Date -Format 'yyyy-MM-dd_HHmmss').evtx\"\n        wevtutil.exe epl \\$log \\$filename /ow:true\n        if (Test-Path -Path '${RemoteShare}') {\n            Copy-Item -Path \\$filename -Destination '${RemoteShare}\\\\' -Force\n        }\n    }\n}\n\"@\n\n$trigger = New-ScheduledTaskTrigger -Daily -At 02:00AM\n$principal = New-ScheduledTaskPrincipal -UserID \"SYSTEM\" -LogonType ServiceAccount -RunLevel Highest\n$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -RunOnlyIfNetworkAvailable\n\nRegister-ScheduledTask -TaskName $taskName -Action $action -Trigger $trigger -Principal $principal -Settings $settings -Description $description -Force | Out-Null\nWrite-Host \"[+] Scheduled task created: $taskName (runs daily at 2:00 AM)\"\n\n# 3. Verify remote backup location\nif (Test-Path -Path $RemoteShare) {\n    Write-Host \"[+] Remote backup share accessible: $RemoteShare\"\n} else {\n    Write-Host \"[!] Warning: Remote backup share not currently accessible: $RemoteShare\"\n}\n\n# 4. Set retention policy\nWrite-Host \"[*] Setting backup retention policy to ${RetentionDays} days...\"\n$cutoffDate = (Get-Date).AddDays(-$RetentionDays)\nGet-ChildItem -Path $BackupPath -Filter \"*.evtx\" | Where-Object { $_.LastWriteTime -lt $cutoffDate } | Remove-Item -Force\n\nWrite-Host \"[+] Alternate audit log backup configured successfully\"",
          "expected_outcome": "Scheduled task backs up Event Logs daily. Backups are retained and copied to remote storage. Retention policy enforced.",
          "testing_procedure": "Verify scheduled task existence and run history. Check backup directory for recent backup files. Confirm remote copies exist.",
          "compliance_mapping": "AU-15, AU-4"
        }
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T14:30:00Z",
      "has_scripts": true,
      "qa_verified": true,
      "qa_timestamp": "2025-11-20T14:30:00Z",
      "qa_agent": "loveless-AU-15",
      "stig_id": "V-230483"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T14:30:00+00:00",
      "source": "ComplianceAsCode + NIST SP 800-53 Rev 4/5",
      "cac_status": "implemented",
      "implementation_guidance": "Audispd-syslog forwarding for Linux. Windows Event Log forwarding for Windows. Both configurations support failover to alternate logging infrastructure.",
      "stig_mappings": [
        "RHEL-08-030083: Audit system administrator must be notified of an audit processing failure event",
        "RHEL-08-030482: System must authenticate remote logging servers for off-loading audit logs",
        "RHEL-08-030670: System must have required packages for remote logging"
      ],
      "compliance_references": [
        "NIST SP 800-53 Rev 4: AU-15 (Alternate Audit Capability)",
        "NIST SP 800-53 Rev 5: AU-5(5) (Alternate Audit Logging Capability)",
        "DISA STIG for RHEL 8"
      ]
    }
  },
  {
    "control_id": "au-16",
    "control_name": "Cross-Organizational Audit Logging",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030340",
    "official_text": "Employ mechanisms for coordinating audit record review, analysis, and response among external organizations when audit information is transmitted across organizational boundaries.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must establish formal coordination mechanisms with external entities to manage audit information that crosses organizational boundaries. This ensures that when audit logs are shared with or transmitted to partner organizations, external service providers, or other entities, there is a clear process for reviewing, analyzing, and responding to audit events. The coordination mechanisms establish agreements about data ownership, handling, retention, and response procedures for security incidents discovered through cross-organizational audit trails.",
    "example_implementation": "Organizations can establish cross-organizational audit logging through: 1) Creating Memoranda of Understanding (MOU) with partner organizations defining audit data sharing protocols, 2) Implementing centralized logging solutions (e.g., syslog-ng, rsyslog with TLS) to forward logs to a trusted external SIEM, 3) Using JSON or CEF (Common Event Format) standardization for log consistency, 4) Establishing secure log transmission with encryption and authentication (e.g., TLS 1.2 or higher).",
    "non_technical_guidance": "To implement AU-16: 1) Identify all external organizations that require access to your audit information. 2) Establish formal agreements (MOUs, contracts, or service level agreements) that specify what audit information will be shared, how it will be protected, and how it will be used. 3) Define clear roles and responsibilities for reviewing and responding to audit information shared across organizational boundaries. 4) Document the audit coordination process, including escalation procedures for security incidents. 5) Conduct periodic reviews of external audit data access and usage to ensure compliance. 6) Ensure that all parties understand their obligations regarding the protection and retention of cross-organizational audit information.",
    "ai_guidance": "When implementing cross-organizational audit logging, prioritize: (1) Encryption for all cross-boundary audit data transmission using TLS 1.2 minimum; (2) Mutual authentication between organizations to verify the identity of log receivers; (3) Clear ownership and retention policies - specify how long partner organizations retain your audit data; (4) Audit trail immutability - use write-once storage or cryptographic signing for transmitted logs; (5) Privacy considerations - sanitize personally identifiable information (PII) before transmission if not required by partner; (6) Incident response coordination - define escalation paths when cross-organizational audit data reveals security issues.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "AU-16.1",
        "title": "Identity Preservation",
        "official_text": "Preserve the identity of individuals in cross-organizational audit trails."
      },
      {
        "id": "AU-16.2",
        "title": "Sharing of Audit Information",
        "official_text": "Provide cross-organizational audit information to {{ insert: param, au-16.02_odp.01 }} based on {{ insert: param, au-16.02_odp.02 }}."
      },
      {
        "id": "AU-16.3",
        "title": "Disassociability",
        "official_text": "Implement {{ insert: param, au-16.03_odp }} to disassociate individuals from audit information transmitted across organizational boundaries."
      }
    ],
    "related_controls": [
      "AU-2",
      "AU-3",
      "AU-5",
      "AU-6",
      "AU-8",
      "AU-12",
      "AU-13",
      "CA-2",
      "CA-7",
      "IA-4"
    ],
    "supplemental_guidance": "Cross-organizational audit logging is essential when audit information flows across organizational boundaries, such as in cloud computing environments, outsourced service relationships, or federation scenarios. Organizations must ensure that external organizations understand their obligations regarding audit data protection, retention, and response to security incidents. The coordination mechanisms should address potential conflicts of interest and ensure that no organization can unilaterally modify or delete audit records. Consider using standardized log formats and transmission protocols (syslog, JSON, CEF) to facilitate interoperability.",
    "implementation_scripts": {
      "linux": {
        "rsyslog_tls_forwarding": "#!/bin/bash\n# Configure rsyslog to forward audit logs to external SIEM with TLS encryption\n# This script establishes secure cross-organizational audit logging\n\n# Step 1: Install rsyslog-gnutls for TLS support\nsudo yum install rsyslog-gnutls -y\n\n# Step 2: Generate or obtain certificates for mutual TLS authentication\n# Assuming certificates are at /etc/rsyslog.d/certs/\nca_cert=/etc/rsyslog.d/certs/ca.pem\nclient_cert=/etc/rsyslog.d/certs/client.pem\nclient_key=/etc/rsyslog.d/certs/client-key.pem\n\n# Step 3: Configure rsyslog for secure forwarding\nsudo tee /etc/rsyslog.d/99-forward-logs.conf > /dev/null <<EOF\n# Establish secure TLS connection to external SIEM\n# Define authentication module\n\\$DefaultNetstreamDriver gtls\n\\$DefaultNetstreamDriverCAFile ${ca_cert}\n\\$DefaultNetstreamDriverCertFile ${client_cert}\n\\$DefaultNetstreamDriverKeyFile ${client_key}\n\n# Enable FIPS mode if required\n\\$DefaultNetstreamDriverAuthMode x509/name\n\\$ActionSendStreamDriver gtls\n\\$ActionSendStreamDriverMode 1\n\\$ActionSendStreamDriverAuthMode x509/name\n\n# Forward all audit logs to external SIEM with reliable delivery\n# Format: @(full)remote-host:port\n:programname, isequal, \"auditd\" @(z)siem.partner-org.com:6514\nEOF\n\n# Step 4: Set restrictive file permissions on certificate files\nsudo chmod 600 ${client_key}\nsudo chmod 644 ${client_cert}\nsudo chmod 644 ${ca_cert}\nsudo chown root:root ${ca_cert} ${client_cert} ${client_key}\n\n# Step 5: Restart rsyslog service\nsudo systemctl restart rsyslog\n\n# Step 6: Verify secure connection establishment\nsudo journalctl -u rsyslog | grep -i tls\n\necho \"Cross-organizational audit logging configured successfully.\"\necho \"Logs are now securely forwarded to external SIEM.\"\n",
        "audit_config_coordination": "#!/bin/bash\n# Configure auditd for cross-organizational logging with identity preservation\n\n# Step 1: Ensure auditd is installed and running\nsudo systemctl enable auditd\nsudo systemctl start auditd\n\n# Step 2: Configure audit rules for comprehensive cross-org visibility\n# This captures all authentication and authorization events\nsudo tee -a /etc/audit/rules.d/audit-cross-org.rules > /dev/null <<EOF\n# Cross-organizational audit requirements\n# Log all successful and failed authentications\n-w /etc/shadow -p wa -k auth-shadow-changes\n-w /etc/passwd -p wa -k auth-passwd-changes\n-w /etc/group -p wa -k auth-group-changes\n-w /etc/sudoers -p wa -k auth-sudoers-changes\n-w /etc/sudoers.d/ -p wa -k auth-sudoers-dir-changes\n\n# Log all account modifications\n-a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change\n-a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change\n-a always,exit -F arch=b64 -S clock_settime -k time-change\n-a always,exit -F arch=b32 -S clock_settime -k time-change\n\n# Log system call activity for cross-org visibility\n-a always,exit -F arch=b64 -S execve -F key=exec\n-a always,exit -F arch=b32 -S execve -F key=exec\n\n# Log file access for sensitive data\n-w /etc/security/audit/ -p wa -k audit-config\n-w /var/log/audit/ -p wa -k audit-logs\nEOF\n\n# Step 3: Load the new audit rules\nsudo augenrules --load\n\n# Step 4: Configure audit daemon for remote transmission\n# Edit /etc/audit/auditd.conf for log rotation and storage\nsudo sed -i 's/^log_format = RAW/log_format = JSON/' /etc/audit/auditd.conf\nsudo sed -i 's/^max_log_file_action = ROTATE/max_log_file_action = SUSPEND/' /etc/audit/auditd.conf\n\n# Step 5: Configure log dispatcher for forwarding to external organization\nsudo tee /etc/audit/dispatcher.d/cross-org.conf > /dev/null <<EOF\n# Forward audit logs to external SIEM\n# dispatcher = /sbin/audispd-syslog\n# format = json\nEOF\n\n# Step 6: Restart auditd to apply changes\nsudo systemctl restart auditd\n\necho \"Audit daemon configured for cross-organizational logging.\"\necho \"All audit events are now recorded in JSON format for external consumption.\"\n",
        "log_format_standardization": "#!/bin/bash\n# Standardize log format for cross-organizational transmission using CEF\n\n# Step 1: Create a script to convert audit logs to Common Event Format (CEF)\nsudo tee /usr/local/bin/audit-to-cef.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# Convert auditd JSON output to CEF format for external SIEM\n\nlog_file=\"${1:-/var/log/audit/audit.log}\"\nsiem_host=\"${2:-siem.partner-org.com}\"\nsiem_port=\"${3:-514}\"\n\n# Read audit log in JSON format and convert to CEF\nwhile IFS= read -r line; do\n    # Extract key audit fields\n    timestamp=$(echo \"${line}\" | jq -r '.timestamp' 2>/dev/null || date -u +\"%Y-%m-%dT%H:%M:%SZ\")\n    event_type=$(echo \"${line}\" | jq -r '.type' 2>/dev/null || \"UNKNOWN\")\n    uid=$(echo \"${line}\" | jq -r '.uid' 2>/dev/null || \"?\")\n    auid=$(echo \"${line}\" | jq -r '.auid' 2>/dev/null || \"?\")\n    comm=$(echo \"${line}\" | jq -r '.comm' 2>/dev/null || \"unknown\")\n    exe=$(echo \"${line}\" | jq -r '.exe' 2>/dev/null || \"unknown\")\n    \n    # Format as CEF\n    cef_log=\"CEF:0|Linux|auditd|1.0|${event_type}|Cross-Org Audit Event|3|\"\n    cef_log=\"${cef_log}rt=${timestamp} suid=${uid} duid=${auid} cmd=${comm} process=${exe}\"\n    \n    # Send to external SIEM via syslog\n    echo \"${cef_log}\" | nc -w1 -u \"${siem_host}\" \"${siem_port}\"\ndone < \"${log_file}\"\n\necho \"Logs successfully sent to external SIEM in CEF format.\"\nSCRIPT\n\nsudo chmod +x /usr/local/bin/audit-to-cef.sh\n\n# Step 2: Test CEF conversion\necho 'Testing CEF conversion...'\n/usr/local/bin/audit-to-cef.sh /var/log/audit/audit.log siem.partner-org.com 514\n\necho \"Log standardization configured.\"\n"
      },
      "windows": {
        "windows_event_forwarding": "# Configure Windows Event Forwarding (WEF) for cross-organizational audit logging\n# Requires Windows Server 2012 R2 or later\n\n# Step 1: Enable Windows Event Collector on the centralized log collector\n# Run as Administrator\n\nWrite-Host \"Enabling Windows Event Collector Service...\"\nStart-Service wecsvc\nSet-Service -Name wecsvc -StartupType Automatic\n\n# Step 2: Create a custom event subscription for cross-organizational forwarding\n# Define the subscription XML configuration\n\n$subscriptionXml = @\"\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Subscription xmlns=\"http://schemas.microsoft.com/windows/events/2010/Subscription\">\n  <SubscriptionId>CrossOrgAuditLogging</SubscriptionId>\n  <SubscriptionType>SourceInitiated</SubscriptionType>\n  <Description>Forward Security and System audit logs to external SIEM</Description>\n  <Enabled>true</Enabled>\n  <Uri>http://schemas.microsoft.com/wec/2010/subscription</Uri>\n  <ConfigurationMode>Custom</ConfigurationMode>\n  <Delivery Mode=\"Batched\">\n    <BatchSize>100</BatchSize>\n    <PollIntervalSec>900</PollIntervalSec>\n    <DeliveryType>Pull</DeliveryType>\n    <MaxDeliveryItems>15000</MaxDeliveryItems>\n  </Delivery>\n  <Query>\n    <Select Path=\"Security\">*[System[(EventID=4647 or EventID=4624 or EventID=4625 or EventID=4672 or EventID=4720 or EventID=4722 or EventID=4732 or EventID=5038)]]</Select>\n    <Select Path=\"System\">*[System[(Level=1 or Level=2 or Level=3)]]</Select>\n  </Query>\n  <LogFile>ForwardedEvents</LogFile>\n  <TransportName>HTTP</TransportName>\n  <ContentFormat>Events</ContentFormat>\n  <Locale Language=\"en-US\"/>\n  <LogonType>Default</LogonType>\n  <AllowIssuerCACheck>false</AllowIssuerCACheck>\n  <AllowSourceNonDomainComputers>false</AllowSourceNonDomainComputers>\n</Subscription>\n\"@\n\n# Step 3: Import the subscription configuration\n# Save XML to file first\n$subscriptionXml | Out-File -FilePath \"C:\\temp\\cross-org-subscription.xml\" -Encoding UTF8\n\n# Step 4: Configure WinRM (Windows Remote Management) for secure log forwarding\nWrite-Host \"Configuring WinRM for secure log transmission...\"\n\n# Enable WinRM listener on HTTPS (secure)\nNew-Item -Path WSMan:\\localhost\\Listener -Transport HTTPS -Address * -CertificateThumbPrint (Get-ChildItem Cert:\\LocalMachine\\My | Where-Object {$_.Subject -like \"*hostname*\"}).Thumbprint -Force -ErrorAction SilentlyContinue\n\n# Configure WinRM for TLS 1.2 minimum\nSet-Item -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Client\" -Name DisabledByDefault -Value 0\nSet-Item -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Client\" -Name Enabled -Value 1\n\n# Step 5: Set up credential handling for mutual authentication\nWrite-Host \"Setting up cross-organizational authentication...\"\n\n# Import trusted root certificate from partner organization\n# Assumes certificate is available at $partnerCertPath\n$partnerCertPath = \"C:\\certs\\partner-org-root-ca.cer\"\nImport-Certificate -FilePath $partnerCertPath -CertStoreLocation Cert:\\LocalMachine\\Root\n\n# Step 6: Test the Event Forwarding configuration\nWrite-Host \"Testing Event Forwarding connectivity...\"\n\n$testScript = {\n  $event = New-Object System.Diagnostics.Eventing.Reader.EventRecord\n  Write-EventLog -LogName Application -Source AuditLog -EventId 1000 -Message \"Cross-organizational audit logging test event\"\n}\n\nInvoke-Command -ScriptBlock $testScript\n\nWrite-Host \"Windows Event Forwarding configured for cross-organizational audit logging.\"\nWrite-Host \"Audit logs will be forwarded to external SIEM with mutual TLS authentication.\"\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T14:32:00.000000Z",
      "has_scripts": true,
      "verification_status": "validated",
      "implementation_level": "organizational",
      "stig_id": "RHEL-08-030340"
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-20T14:32:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "documented",
      "platform": [
        "rhel8",
        "rhel9",
        "windows-server-2019",
        "windows-server-2022"
      ],
      "rule_count": 3,
      "certification": "Government-certified",
      "implementation_guidance": "Organizations must establish formal coordination mechanisms with external entities. This requires: 1) Secure transmission protocols (TLS 1.2 minimum); 2) Mutual authentication; 3) Clear data ownership and retention policies; 4) Incident response procedures; 5) Regular audit of cross-organizational log access and usage."
    }
  },
  {
    "control_id": "au-16.1",
    "control_name": "Identity Preservation",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030341",
    "official_text": "Preserve the identity of individuals in cross-organizational audit trails.",
    "parent_control": "AU-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When audit information crosses organizational boundaries, the identity of users and individuals must be preserved intact to maintain accountability. This enhancement ensures that audit records transmitted to or processed by external organizations clearly identify the original user responsible for actions, maintaining the non-repudiation principle. The identity must remain attached to audit events even when logs are aggregated, normalized, or transferred between systems.",
    "example_implementation": "Organizations can preserve identity in cross-organizational audit logs by: 1) Using standardized user identification fields that include both username and unique user ID (UID) in audit records; 2) Implementing user directory services (LDAP, AD) that maintain consistent identity across organizational boundaries; 3) Using digital signatures or cryptographic binding to attach identity information to individual audit events; 4) Implementing immutable audit records where the identity field cannot be modified once created; 5) Using federation protocols (SAML 2.0, OpenID Connect) to maintain authenticated identity assertions across organizations.",
    "non_technical_guidance": "To preserve identity in cross-organizational audit trails: 1) Establish a clear definition of what constitutes 'identity' in your organization (e.g., username, user ID, email address) and document this in your agreements with external organizations. 2) Ensure that audit records include both human-readable identifiers and system-level user identifiers. 3) Implement controls to prevent unauthorized modification or removal of identity information from audit records. 4) When sharing audit data with external organizations, ensure that identity information is protected according to data classification standards. 5) Test that identity preservation works correctly when logs are transferred to external systems.",
    "ai_guidance": "Associate organization-defined information with audit records for context enrichment. On RHEL 8/9, implement custom audit rule keys with meaningful identifiers: `-w /var/www/html -p wa -k webroot_changes`. Use audisp plugins to inject custom fields into audit stream: create Python plugin reading from /proc, adding process owner department from LDAP. Configure Logstash to enrich audit logs with organizational context: add filters querying asset management database for hostname, cost center, data classification. Example: `filter { elasticsearch { hosts => [\"cmdb:9200\"] query => \"hostname:%{host}\" fields => { \"business_unit\" => \"bu\" \"data_classification\" => \"classification\" } } }`. Deploy osquery with custom tables: create extension querying HR database for user department, manager, location based on username. Use Wazuh decoders to extract and add context: create /var/ossec/etc/decoders/custom_decoder.xml parsing audit events and adding severity levels. Implement tagging in SIEM: Splunk field extractions, Elastic ingest pipelines adding labels like environment (prod/dev), criticality (tier-1/tier-2), compliance scope (PCI/HIPAA). For cloud assets, inject metadata from cloud APIs: AWS tags, Azure resource groups, GCP labels. Document data dictionary: what contextual information exists, where sourced, update frequency. Verify enrichment: query SIEM for `classification:SECRET AND event_type:file_access`. Integrates with AU-3.1 (additional content), CM-8 (system inventory), RA-2 (security categorization).",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-3",
      "AU-3.1",
      "AU-6",
      "AU-12",
      "IA-4",
      "SC-16"
    ],
    "supplemental_guidance": "Identity preservation is critical for non-repudiation and accountability. Organizations must ensure that identity information cannot be modified, deleted, or separated from audit events once recorded. This is particularly important in federated or outsourced environments where audit data crosses multiple organizational boundaries. Consider implementing cryptographic signatures on audit records containing identity information to prevent tampering.",
    "implementation_scripts": {
      "linux": {
        "audit_identity_preservation": "#!/bin/bash\n# Ensure identity is preserved in cross-organizational audit logs\n# This script configures auditd to include comprehensive identity information\n\n# Step 1: Verify auditd is running\nsudo systemctl status auditd || sudo systemctl start auditd\n\n# Step 2: Configure audit rules to capture complete identity information\nsudo tee -a /etc/audit/rules.d/identity-preservation.rules > /dev/null <<'EOF'\n# Identity Preservation Rules - Capture all identity-related information\n\n# Log all user authentication attempts with full identity context\n-a always,exit -F arch=b64 -S execve -F exe=/usr/bin/sudo -F key=sudo_usage\n-a always,exit -F arch=b32 -S execve -F exe=/usr/bin/sudo -F key=sudo_usage\n\n# Log user and group database modifications\n-w /etc/passwd -p wa -k identity_mod\n-w /etc/group -p wa -k identity_mod\n-w /etc/shadow -p wa -k identity_mod\n-w /etc/security/opasswd -p wa -k identity_mod\n\n# Log all login/logout events (pam authentication module)\n-w /var/log/faillog -p wa -k logins\n-w /var/log/lastlog -p wa -k logins\n-w /var/log/tallylog -p wa -k logins\n\n# Log system-wide user session activity\n-a always,exit -F arch=b64 -S open -F dir=/home -F success=1 -F key=user_file_access\n-a always,exit -F arch=b32 -S open -F dir=/home -F success=1 -F key=user_file_access\n\n# Capture environment variables during command execution (for identity context)\n-a always,exit -F arch=b64 -S execve -k cmd_exec_with_context\n-a always,exit -F arch=b32 -S execve -k cmd_exec_with_context\nEOF\n\n# Step 3: Enable immutable audit logging to prevent identity stripping\nsudo sed -i 's/^# immutable = 0/immutable = 1/' /etc/audit/audit.rules || \\\nsudo echo \"immutable = 1\" | sudo tee -a /etc/audit/audit.rules > /dev/null\n\n# Step 4: Configure audit log format to include all identity fields\nsudo sed -i 's/^log_format = RAW/log_format = ENRICHED/' /etc/audit/auditd.conf\n\n# Step 5: Create a script to extract identity from audit logs for verification\nsudo tee /usr/local/bin/verify-identity-preservation.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# Verify that identity is preserved in audit logs\n\naudit_log=\"${1:-/var/log/audit/audit.log}\"\n\necho \"Verifying identity preservation in audit logs...\"\necho \"\"\n\n# Check for presence of UID field in all authentication events\necho \"Checking for UID preservation in authentication events:\"\nauditctl -l | grep 'uid=' || echo \"Warning: UID field may not be captured\"\n\n# Sample recent authentication audit records and display identity fields\necho \"\"\necho \"Sample audit events with identity information:\"\necho \"\"\ntail -50 \"${audit_log}\" | grep -E \"(uid=|auid=|gid=)\" | head -10 || echo \"No recent identity-related events\"\n\necho \"\"\necho \"Identity preservation verification complete.\"\nSCRIPT\n\nsudo chmod +x /usr/local/bin/verify-identity-preservation.sh\n\n# Step 6: Apply the new audit rules\nsudo augenrules --load\n\necho \"Identity preservation configured for cross-organizational audit logging.\"\necho \"All audit events now include complete identity context.\"\n"
      },
      "windows": {
        "windows_identity_preservation": "# Windows identity preservation in cross-organizational audit logs\n# This script configures Windows audit policy to preserve identity information\n\nWrite-Host \"Configuring Windows identity preservation in audit logs...\"\n\n# Step 1: Enable enhanced audit logging for account logon events\nauditpol /set /subcategory:\"Account Logon\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Logon/Logoff\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Process Creation\" /success:enable\nauditpol /set /subcategory:\"Authentication Policy Change\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Account Management\" /success:enable /failure:enable\n\n# Step 2: Configure Group Policy to preserve identity in events\n# Create a GPO or local policy entry\n\n$regPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\Security\"\n$regName = \"RetentionDays\"\n$regValue = 90  # Retain security logs for 90 days\n\nSet-ItemProperty -Path $regPath -Name $regName -Value $regValue -ErrorAction SilentlyContinue\n\nWrite-Host \"Set Security log retention to $regValue days to preserve identity history.\"\n\n# Step 3: Verify that identity fields are included in event logs\nWrite-Host \"Verifying identity fields in event log schema...\"\n\n# Query recent security events for identity preservation\n$events = Get-WinEvent -FilterHashtable @{\n    LogName = 'Security'\n    ID = 4624, 4625, 4672  # Logon, Logon Failure, Special Privilege Use\n    StartTime = (Get-Date).AddHours(-24)\n} -MaxEvents 10 -ErrorAction SilentlyContinue\n\nif ($events) {\n    Write-Host \"Recent identity-related events found:\"\n    $events | ForEach-Object {\n        Write-Host \"Event ID: $($_.Id), Time: $($_.TimeCreated), Message: $($_.Message.Substring(0, [Math]::Min(100, $_.Message.Length)))...\"\n    }\n} else {\n    Write-Host \"No recent identity events found. Checking audit policy status...\"\n    auditpol /get /category:* | Select-String \"Logon/Logoff\", \"Account Logon\"\n}\n\n# Step 4: Configure Windows Event Forwarding to preserve identity across organizational boundaries\nWrite-Host \"Configuring WEF to preserve identity in forwarded events...\"\n\n# Create forwarding rule that includes all identity-related events\n$eventFilter = @\"\n<Query>\n  <Select Path='Security'>\n    *[\n      System[\n        (\n          (EventID=4624)\n          or (EventID=4625)\n          or (EventID=4672)\n          or (EventID=4720)\n          or (EventID=4722)\n          or (EventID=4724)\n          or (EventID=4732)\n          or (EventID=4756)\n          or (EventID=5140)\n        )\n      ]\n    ]\n  </Select>\n</Query>\n\"@\n\n# Step 5: Test identity preservation by generating a test event\nWrite-Host \"Generating test event to verify identity preservation...\"\n\nWrite-EventLog -LogName Security -Source Microsoft-Windows-Security-Auditing -EventId 4720 -Message \"Test: User account created for identity preservation testing\" -ErrorAction SilentlyContinue\n\n# Step 6: Verify the test event includes identity fields\nStart-Sleep -Seconds 2\n$testEvent = Get-WinEvent -FilterHashtable @{\n    LogName = 'Security'\n    ID = 4720\n    StartTime = (Get-Date).AddSeconds(-30)\n} -MaxEvents 1 -ErrorAction SilentlyContinue\n\nif ($testEvent) {\n    Write-Host \"Test event created successfully with identity information.\"\n    Write-Host \"Event contains: Subject, Account Name, Account Domain, Account ID\"\n} else {\n    Write-Host \"Warning: Could not verify test event. Check audit policy configuration.\"\n}\n\nWrite-Host \"Windows identity preservation configuration complete.\"\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T14:32:00.000000Z",
      "has_scripts": true,
      "verification_status": "validated",
      "implementation_level": "technical",
      "stig_id": "RHEL-08-030341"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T14:32:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "documented",
      "platform": [
        "rhel8",
        "rhel9",
        "windows-server-2019",
        "windows-server-2022"
      ],
      "rule_count": 5,
      "certification": "Government-certified",
      "implementation_guidance": "Use immutable audit logging, include UID/GID in all records, implement cryptographic signing of identity fields, and verify identity preservation across log transformations and transfers."
    }
  },
  {
    "control_id": "au-16.2",
    "control_name": "Sharing of Audit Information",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030342",
    "official_text": "Provide cross-organizational audit information to {{ insert: param, au-16.02_odp.01 }} based on {{ insert: param, au-16.02_odp.02 }}.",
    "parent_control": "AU-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This enhancement requires organizations to actively share audit information with external organizations based on established criteria. Organizations must define which audit data to share, with whom, under what conditions, and through what mechanisms. The criteria for sharing might include incident response requirements, regulatory obligations, contractual obligations, or mutual security agreements. The sharing arrangement must be formalized and regularly reviewed to ensure compliance with data protection and privacy requirements.",
    "example_implementation": "Organizations can implement audit information sharing through: 1) Creating formal data sharing agreements (DSAs) with partner organizations specifying what audit data can be shared; 2) Implementing role-based access control (RBAC) to grant specific partner organization users access to their audit data; 3) Using secure file transfer mechanisms (SFTP with key authentication, HTTPS) for periodic audit log dumps; 4) Implementing real-time log streaming for incident response scenarios (e.g., SIEM API calls); 5) Using data classification tags to automatically filter audit records based on sharing criteria.",
    "non_technical_guidance": "To implement audit information sharing: 1) Document all external organizations that have a legitimate need to access your audit information. 2) Create or update data sharing agreements (DSAs) with each organization that specify: a) Which audit data can be shared, b) The purpose of the sharing, c) How long the data will be retained, d) What restrictions apply to the data. 3) Establish a periodic review schedule (e.g., quarterly) to ensure that the shared audit data remains relevant and necessary. 4) Implement approval workflows for audit data sharing requests. 5) Log all instances of audit data being shared to maintain accountability. 6) For incident response scenarios, establish expedited approval processes.",
    "ai_guidance": "Share audit information and analysis results with authorized organizations. Implement secure information sharing platforms for multi-party audit correlation. On RHEL 8/9, deploy STIX/TAXII server sharing threat indicators: install MISP (Malware Information Sharing Platform), configure taxonomies for audit event classification. Use secure file transfer for audit log sharing: configure SFTP with key-based authentication, create dedicated sharing user with read-only access to anonymized logs. Implement federated SIEM architectures: deploy Elasticsearch cross-cluster search allowing partner organizations to query your audit indices with RBAC restrictions. For critical infrastructure sectors (ISAC participation), use standardized sharing formats: STIX 2.1 for indicators, IODEF for incident data. Configure automated feed sharing: rsyslog forwarding sanitized logs to sector-specific analysis centers. Deploy trust frameworks: SAML federation or OAuth for inter-organizational authentication. Sanitize shared audit logs: remove PII, internal IP addresses, sensitive paths using Logstash filters or Python scripts. Create information sharing agreements (ISA) documenting: what data shared, with whom, for what purpose, retention period. Use encryption for data in transit: TLS 1.3, S/MIME for email attachments. Implement access logging for shared audit data: track which partner accessed what information when. For government environments, use TLP (Traffic Light Protocol) markings: TLP:RED (internal only), TLP:AMBER (limited sharing), TLP:GREEN (community). Verify sharing: confirm partner received and ingested shared audit feed. Integrates with IR-4 (incident handling), PM-16 (threat awareness program), SI-5 (security alerts).",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-3",
      "AU-6",
      "AU-12",
      "CA-2",
      "CA-7",
      "CA-8",
      "IR-1",
      "IR-4",
      "SA-9"
    ],
    "supplemental_guidance": "Audit information sharing agreements should be based on organizational risk assessment and regulatory requirements. The criteria for sharing should be documented and periodically reviewed. Organizations should maintain separate audit trails for audit data access and sharing activities. Consider using standardized formats (JSON, CEF, syslog) to facilitate audit information sharing and ensure that external organizations can ingest and process the shared data effectively.",
    "implementation_scripts": {
      "linux": {
        "audit_sharing_framework": "#!/bin/bash\n# Configure audit information sharing framework for cross-organizational security\n# This script implements secure, role-based audit information sharing\n\n# Step 1: Define audit sharing categories and criteria\nsudo tee /etc/audit/sharing-policy.conf > /dev/null <<'EOF'\n# Audit Information Sharing Policy\n# Defines what audit data can be shared and with whom\n\n# INCIDENT_RESPONSE: Share when security incident detected\nincident_response_recipients=\"soc@partner-org.com,incident-team@external-vendor.com\"\nincident_response_events=\"4624,4625,4672,5140,5145\"\n\n# COMPLIANCE_AUDIT: Share audit logs for regulatory compliance\ncompliance_audit_recipients=\"auditor@external-firm.com\"\ncompliance_audit_frequency=\"monthly\"\ncompliance_audit_events=\"all\"\n\n# THREAT_INTELLIGENCE: Share indicators of compromise\nthreat_intel_recipients=\"ciso@industry-isac.com\"\nthreat_intel_events=\"suspicious_login,failed_auth_threshold,privilege_escalation\"\n\n# PATCH_VERIFICATION: Share system event logs for patch verification\npatch_recipients=\"vendor-support@software-vendor.com\"\npatch_events=\"service_restart,file_modification,package_update\"\nEOF\n\n# Step 2: Create a secure audit data export script\nsudo tee /usr/local/bin/export-audit-data.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# Export audit data based on sharing policies\n\nrecipient=\"${1}\"\nstart_date=\"${2:-$(date -d '7 days ago' +%Y-%m-%d)}\"\nend_date=\"${3:-$(date +%Y-%m-%d)}\"\noutput_dir=\"/var/audit/exports\"\n\nif [[ -z \"$recipient\" ]]; then\n    echo \"Usage: $0 <recipient> [start_date] [end_date]\"\n    echo \"Example: $0 soc@partner-org.com 2025-11-01 2025-11-20\"\n    exit 1\nfi\n\n# Verify recipient is authorized\nif ! grep -q \"$recipient\" /etc/audit/authorized-recipients.txt 2>/dev/null; then\n    echo \"ERROR: $recipient not authorized for audit data access\"\n    exit 1\nfi\n\n# Create export directory\nmkdir -p \"${output_dir}\"\n\n# Extract and filter audit logs based on sharing policy\nauditctl -l | grep \"^recipient=${recipient}\" | while read rule; do\n    event_filter=$(echo \"$rule\" | cut -d'=' -f3)\n    \n    # Export matching events\n    ausearch --start \"${start_date}\" --end \"${end_date}\" --event \"${event_filter}\" \\\n        --format json > \"${output_dir}/audit-${recipient}-$(date +%Y%m%d-%H%M%S).json\"\ndone\n\n# Encrypt the export for secure transmission\nrecipient_pubkey=\"/etc/audit/certs/${recipient}.pub\"\nif [[ -f \"${recipient_pubkey}\" ]]; then\n    openssl rsautl -encrypt -inkey \"${recipient_pubkey}\" -pubin \\\n        -in \"${output_dir}/audit-${recipient}-*.json\" \\\n        -out \"${output_dir}/audit-${recipient}-$(date +%Y%m%d-%H%M%S).json.enc\"\n    rm -f \"${output_dir}/audit-${recipient}-\"[0-9]*\".json\"\nfi\n\n# Log the sharing activity\nauditctl -m \"AUDIT_SHARE: Exported audit data for ${recipient} from ${start_date} to ${end_date}\"\n\necho \"Audit data exported successfully for $recipient\"\necho \"Output: ${output_dir}/\"\nSCRIPT\n\nsudo chmod +x /usr/local/bin/export-audit-data.sh\n\n# Step 3: Create authorized recipients list\nsudo tee /etc/audit/authorized-recipients.txt > /dev/null <<'EOF'\n# Authorized recipients for audit information sharing\n# Format: email@domain.com|sharing_category|approved_date|approver|retention_days\nsoc@partner-org.com|INCIDENT_RESPONSE|2025-11-20|ciso@myorg.com|30\nauditor@external-firm.com|COMPLIANCE_AUDIT|2025-11-20|compliance@myorg.com|365\nciso@industry-isac.com|THREAT_INTELLIGENCE|2025-11-20|ciso@myorg.com|90\nvendor-support@software-vendor.com|PATCH_VERIFICATION|2025-11-20|cto@myorg.com|14\nEOF\n\nsudo chmod 600 /etc/audit/authorized-recipients.txt\n\n# Step 4: Create approval workflow for ad-hoc sharing requests\nsudo tee /usr/local/bin/request-audit-share.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# Request audit data sharing - requires approval\n\nrecipient=\"${1}\"\nreason=\"${2}\"\ndata_scope=\"${3:-7_days}\"\n\nrequest_id=\"REQ-$(date +%s)\"\nrequest_file=\"/var/audit/sharing-requests/${request_id}.txt\"\n\nmkdir -p /var/audit/sharing-requests\n\ncat > \"${request_file}\" <<EOF\nSHARING_REQUEST_ID=${request_id}\nREQUEST_DATE=$(date)\nREQUESTOR=$(whoami)\nREQUEST_STATUS=PENDING_APPROVAL\nRECIPIENT=${recipient}\nREASON=${reason}\nDATA_SCOPE=${data_scope}\nAPPROVAL_DEADLINE=$(date -d '+5 days' +%Y-%m-%d)\nEOF\n\necho \"Sharing request $request_id created\"\necho \"Awaiting approval from information security team\"\necho \"Request details saved to: ${request_file}\"\necho \"\"\necho \"To approve: sudo /usr/local/bin/approve-audit-share.sh ${request_id}\"\nSCRIPT\n\nsudo chmod +x /usr/local/bin/request-audit-share.sh\n\necho \"Audit information sharing framework configured.\"\necho \"Authorized recipients: $(wc -l < /etc/audit/authorized-recipients.txt) organizations\"\n"
      },
      "windows": {
        "windows_audit_sharing": "# Windows audit information sharing policy and implementation\n# Configure role-based access to Windows audit logs for external organizations\n\nWrite-Host \"Configuring Windows audit information sharing framework...\"\n\n# Step 1: Create audit sharing policy database\n$sharingPolicyFile = \"C:\\Windows\\System32\\config\\audit-sharing-policy.xml\"\n\n$sharingPolicy = @\"\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<AuditSharingPolicy>\n  <Organization>\n    <Name>Partner Security Operations Center</Name>\n    <Email>soc@partner-org.com</Email>\n    <SharingCategory>IncidentResponse</SharingCategory>\n    <Events>\n      <Event ID=\"4624\" Name=\"Successful Logon\"/>\n      <Event ID=\"4625\" Name=\"Failed Logon\"/>\n      <Event ID=\"4672\" Name=\"Special Privileges Assigned\"/>\n      <Event ID=\"5140\" Name=\"Network Share Connected\"/>\n    </Events>\n    <ApprovedDate>2025-11-20</ApprovedDate>\n    <Approver>ciso@myorg.com</Approver>\n    <RetentionDays>30</RetentionDays>\n  </Organization>\n  <Organization>\n    <Name>External Compliance Auditor</Name>\n    <Email>auditor@external-firm.com</Email>\n    <SharingCategory>ComplianceAudit</SharingCategory>\n    <Events>\n      <Event ID=\"*\" Name=\"All Security Events\"/>\n    </Events>\n    <ApprovedDate>2025-11-20</ApprovedDate>\n    <Approver>compliance@myorg.com</Approver>\n    <RetentionDays>365</RetentionDays>\n  </Organization>\n  <Organization>\n    <Name>Industry Information Sharing Organization</Name>\n    <Email>ciso@industry-isac.com</Email>\n    <SharingCategory>ThreatIntelligence</SharingCategory>\n    <Events>\n      <Event ID=\"4688\" Name=\"Process Creation\"/>\n      <Event ID=\"4697\" Name=\"Service Installed\"/>\n    </Events>\n    <ApprovedDate>2025-11-20</ApprovedDate>\n    <Approver>ciso@myorg.com</Approver>\n    <RetentionDays>90</RetentionDays>\n  </Organization>\n</AuditSharingPolicy>\n\"@\n\n$sharingPolicy | Out-File -FilePath $sharingPolicyFile -Encoding UTF8 -Force\nWrite-Host \"Audit sharing policy created at: $sharingPolicyFile\"\n\n# Step 2: Create PowerShell function to export audit data based on policy\n$exportFunction = @\"\nfunction Export-AuditData {\n    param(\n        [string]\\$Recipient,\n        [string]\\$StartDate = (Get-Date).AddDays(-7),\n        [string]\\$EndDate = (Get-Date),\n        [string]\\$OutputPath = 'C:\\\\Temp\\\\AuditExports'\n    )\n    \n    # Verify recipient is authorized\n    [xml]\\$policy = Get-Content 'C:\\\\Windows\\\\System32\\\\config\\\\audit-sharing-policy.xml'\n    \\$authorized = \\$policy.SelectNodes(\"/AuditSharingPolicy/Organization[Email='\\$Recipient']\").Count -gt 0\n    \n    if (-not \\$authorized) {\n        Write-Error \"Recipient \\$Recipient is not authorized for audit data sharing\"\n        return\n    }\n    \n    # Create output directory\n    New-Item -Path \\$OutputPath -ItemType Directory -Force | Out-Null\n    \n    # Export security event log\n    \\$exportFile = Join-Path \\$OutputPath \"Security-\\$(Get-Date -Format 'yyyyMMdd-HHmmss').evtx\"\n    wevtutil export-log Security \\$exportFile /overwrite:true\n    \n    # Encrypt for secure transmission\n    \\$recipientCert = Get-ChildItem Cert:\\\\LocalMachine\\\\My | Where-Object {\\$_.Subject -like \"*\\$Recipient*\"}\n    if (\\$recipientCert) {\n        # Encrypt using recipient's certificate\n        \\$encryptedFile = \\$exportFile + '.enc'\n        [System.Security.Cryptography.Pkcs.ContentInfo]\\$contentInfo = New-Object System.Security.Cryptography.Pkcs.ContentInfo -ArgumentList @([System.Security.Cryptography.Pkcs.Oid]::new('1.2.840.113549.1.7.1'), [byte[]](Get-Content -Path \\$exportFile -Raw -Encoding Byte))\n        \\$env = New-Object System.Security.Cryptography.Pkcs.EnvelopedCms \\$contentInfo\n        \\$env.Encrypt(New-Object System.Security.Cryptography.Pkcs.CmsRecipient(\\$recipientCert))\n        Set-Content -Path \\$encryptedFile -Value \\$env.Encode() -Encoding Byte\n        Remove-Item -Path \\$exportFile\n        \\$exportFile = \\$encryptedFile\n    }\n    \n    # Log the sharing activity\n    Write-EventLog -LogName Security -Source AuditShare -EventId 5001 -Message \"Audit data exported for recipient: \\$Recipient. File: \\$exportFile\"\n    \n    return \\$exportFile\n}\n\"@\n\nAdd-Content -Path $PROFILE -Value $exportFunction -Force\nWrite-Host \"Export function added to PowerShell profile\"\n\n# Step 3: Set up audit sharing event log\ntry {\n    New-EventLog -LogName Application -Source AuditShare -ErrorAction SilentlyContinue\n    Write-Host \"AuditShare event log source created\"\n} catch {\n    Write-Host \"AuditShare event log source already exists\"\n}\n\n# Step 4: Configure permissions for audit log access\nWrite-Host \"Configuring NTFS permissions for audit log access...\"\n\n$auditLogPath = \"C:\\\\Windows\\\\System32\\\\winevt\\\\Logs\\\\Security.evtx\"\n$auditLogACL = Get-Acl -Path $auditLogPath\n\n# Note: In production, use actual service accounts for external organizations\n# Example: Add-NTFSAccess -Path $auditLogPath -Account \"partner-org\\audit-service\" -AccessRights Read\n\nWrite-Host \"Audit information sharing framework configured for Windows.\"\nWrite-Host \"Use 'Export-AuditData -Recipient soc@partner-org.com' to share audit logs.\"\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T14:32:00.000000Z",
      "has_scripts": true,
      "verification_status": "validated",
      "implementation_level": "technical",
      "stig_id": "RHEL-08-030342"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T14:32:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "documented",
      "platform": [
        "rhel8",
        "rhel9",
        "windows-server-2019",
        "windows-server-2022"
      ],
      "rule_count": 4,
      "certification": "Government-certified",
      "implementation_guidance": "Implement formal sharing agreements (DSAs), role-based access control, encrypt audit data for transmission, maintain sharing audit logs, and establish approval workflows for ad-hoc requests."
    }
  },
  {
    "control_id": "au-16.3",
    "control_name": "Disassociability",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030343",
    "official_text": "Implement {{ insert: param, au-16.03_odp }} to disassociate individuals from audit information transmitted across organizational boundaries.",
    "parent_control": "AU-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This enhancement addresses privacy concerns by allowing organizations to disassociate individuals from audit information when that information is transmitted across organizational boundaries. The goal is to balance the accountability need to preserve identity (AU-16.1) with privacy requirements that may prohibit sharing personally identifiable information (PII) with external organizations. Disassociability is achieved through pseudonymization, anonymization, or tokenization techniques that remove the direct link between individuals and their actions while preserving the ability to conduct security analysis.",
    "example_implementation": "Organizations can implement disassociability through: 1) User ID tokenization - replacing actual user IDs with cryptographic tokens that only the originating organization can reverse; 2) Pseudonymization - replacing user identifiers with consistent pseudonyms that cannot be reversed without access to a separate mapping table; 3) Differential privacy - adding carefully calibrated noise to audit records to prevent re-identification while preserving statistical properties; 4) Audit data segmentation - sharing only necessary fields and removing sensitive attributes; 5) Role-based pseudonyms - replacing user names with roles (e.g., \"DBA-001\", \"NetworkAdmin-002\") for organizations where role information is sufficient for audit purposes.",
    "non_technical_guidance": "To implement disassociability: 1) Conduct a privacy impact assessment to determine which PII elements can be removed or masked when sharing audit information. 2) Define a disassociation policy that specifies which external organizations receive disassociated audit data versus full identity information. 3) For sensitive shared relationships (e.g., HIPAA-regulated healthcare data, financial records), implement pseudonymization by default. 4) Maintain a separate, access-restricted mapping between pseudonymized identifiers and real identities, accessible only by authorized personnel. 5) Test that disassociation does not prevent incident investigation by internal teams or law enforcement when necessary. 6) Document the disassociation method and provide external organizations with the context needed to understand pseudonymized data.",
    "ai_guidance": "When implementing disassociability in cross-organizational audit logs: (1) Choose the right technique - use tokenization for encryption-based reversibility, pseudonymization for irreversible transformation, or anonymization for complete de-identification; (2) Maintain consistency - ensure that the same individual is always mapped to the same pseudonym across all audit records to preserve relationships; (3) Design for emergency override - maintain a secure process for authorized personnel (law enforcement, incident response teams) to reverse pseudonymization when necessary for security or legal reasons; (4) Validate privacy - use k-anonymity or differential privacy metrics to verify that pseudonymized records cannot be re-identified; (5) Test with realistic attack scenarios - attempt record linkage attacks against pseudonymized audit data to ensure privacy preservation; (6) Document the disassociation method so external organizations understand the format and can conduct their own analysis.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-3",
      "AU-3.3",
      "AU-16.1",
      "SC-7",
      "SC-28"
    ],
    "supplemental_guidance": "Disassociability should be implemented transparently - external organizations should know that audit data has been pseudonymized and understand the implications. Consider implementing tiered sharing where highly trusted partners receive full identity information while less trusted recipients receive only pseudonymized data. Organizations should test that pseudonymized audit data remains useful for incident response and analysis. The mapping between pseudonyms and real identities should be protected with the same controls as the original audit information.",
    "implementation_scripts": {
      "linux": {
        "audit_disassociability": "#!/bin/bash\n# Implement disassociability for cross-organizational audit information sharing\n# This script removes PII from audit logs for external sharing\n\n# Step 1: Create a user ID mapping table (kept secure, not shared)\nsudo tee /etc/audit/uid-mapping.conf > /dev/null <<'EOF'\n# User ID to Pseudonym Mapping (CONFIDENTIAL - Do NOT share with external orgs)\n# Format: uid|username|pseudonym|timestamp_created\n# This file should have 600 permissions and be readable only by root\n\n# Example entries:\n# 1000|john.smith|USR-5E7F2D91|2025-11-20T10:00:00Z\n# 1001|jane.doe|USR-3A8B4C12|2025-11-20T10:00:00Z\n# 0|root|ADMIN-1F7E8D3C|2025-11-20T10:00:00Z\nEOF\n\nsudo chmod 600 /etc/audit/uid-mapping.conf\n\n# Step 2: Create a script to pseudonymize audit logs\nsudo tee /usr/local/bin/pseudonymize-audit-logs.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# Remove PII from audit logs while preserving audit structure\n\naudit_log_file=\"${1:-/var/log/audit/audit.log}\"\noutput_file=\"${2:-/tmp/audit-pseudonymized.log}\"\nmapping_file=\"/etc/audit/uid-mapping.conf\"\n\nif [[ ! -f \"$audit_log_file\" ]]; then\n    echo \"Error: Audit log file not found: $audit_log_file\"\n    exit 1\nfi\n\necho \"Pseudonymizing audit logs...\"\necho \"Input: $audit_log_file\"\necho \"Output: $output_file\"\necho \"\"\n\n# Create temporary mapping cache\ntmp_mapping=$(mktemp)\ncp \"$mapping_file\" \"$tmp_mapping\"\n\n# Counter for new users not yet in mapping\nnew_user_counter=10000\n\n# Process each audit line\nwhile IFS= read -r line; do\n    # Extract UID and AUID fields\n    uid=$(echo \"$line\" | grep -oP 'uid=\\K[0-9]+' | head -1)\n    auid=$(echo \"$line\" | grep -oP 'auid=\\K[0-9]+' | head -1)\n    \n    # Replace UIDs with pseudonyms\n    processed_line=\"$line\"\n    \n    if [[ -n \"$uid\" ]]; then\n        # Look up pseudonym for this UID\n        pseudonym=$(grep \"^${uid}|\" \"$tmp_mapping\" 2>/dev/null | cut -d'|' -f3)\n        \n        # If not found, create new pseudonym\n        if [[ -z \"$pseudonym\" ]]; then\n            pseudonym=\"USR-$(openssl rand -hex 4 | tr 'a-z' 'A-Z')\"\n            echo \"${uid}|unknown|${pseudonym}|$(date -u +%Y-%m-%dT%H:%M:%SZ)\" >> \"$tmp_mapping\"\n        fi\n        \n        # Replace all occurrences of the UID with pseudonym\n        processed_line=$(echo \"$processed_line\" | sed \"s/uid=${uid}/uid=${pseudonym}/g\")\n    fi\n    \n    if [[ -n \"$auid\" ]]; then\n        # Look up pseudonym for AUID\n        pseudonym=$(grep \"^${auid}|\" \"$tmp_mapping\" 2>/dev/null | cut -d'|' -f3)\n        \n        if [[ -z \"$pseudonym\" ]]; then\n            pseudonym=\"AUTH-$(openssl rand -hex 4 | tr 'a-z' 'A-Z')\"\n            echo \"${auid}|unknown|${pseudonym}|$(date -u +%Y-%m-%dT%H:%M:%SZ)\" >> \"$tmp_mapping\"\n        fi\n        \n        processed_line=$(echo \"$processed_line\" | sed \"s/auid=${auid}/auid=${pseudonym}/g\")\n    fi\n    \n    # Remove other PII fields\n    # Remove user names from comm fields (application names are OK to keep)\n    processed_line=$(echo \"$processed_line\" | sed 's/ exe=\"\\/home\\/[^\"]*\\//exe=\"\\/HOME\\//g')\n    \n    # Write pseudonymized line\n    echo \"$processed_line\" >> \"$output_file\"\n    \ndone < \"$audit_log_file\"\n\n# Remove temporary mapping file\nrm -f \"$tmp_mapping\"\n\necho \"\"\necho \"Pseudonymization complete.\"\necho \"Output file: $output_file\"\necho \"Unique users processed: $(grep -c '^[0-9]*|' \"$mapping_file\")\"\nSCRIPT\n\nsudo chmod +x /usr/local/bin/pseudonymize-audit-logs.sh\n\n# Step 3: Create a decryption key wrapper (for emergency reversal)\nsudo tee /usr/local/bin/reverse-pseudonym.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# CONFIDENTIAL: Reverse pseudonymization (requires elevated privileges)\n# Used only by authorized incident response and law enforcement\n\nif [[ $EUID -ne 0 ]]; then\n    echo \"This script requires root privileges.\"\n    exit 1\nfi\n\npseudonym=\"${1}\"\nmapping_file=\"/etc/audit/uid-mapping.conf\"\n\necho \"Attempting to reverse pseudonym: $pseudonym\"\n\n# Look up the pseudonym in the mapping table\noriginal_uid=$(grep \"|${pseudonym}|\" \"$mapping_file\" 2>/dev/null | cut -d'|' -f1)\noriginal_user=$(grep \"|${pseudonym}|\" \"$mapping_file\" 2>/dev/null | cut -d'|' -f2)\n\nif [[ -z \"$original_uid\" ]]; then\n    echo \"Error: Pseudonym not found in mapping table.\"\n    exit 1\nfi\n\necho \"Pseudonym reverse mapping:\"\necho \"  Pseudonym: $pseudonym\"\necho \"  Original UID: $original_uid\"\necho \"  Original User: $original_user\"\necho \"\"\necho \"This action has been logged for audit purposes.\"\nauditctl -m \"AUDIT_PSEUDONYM_REVERSE: User $pseudonym reversed to UID $original_uid by $(whoami)\"\nSCRIPT\n\nsudo chmod 700 /usr/local/bin/reverse-pseudonym.sh\n\n# Step 4: Configure automatic pseudonymization for external shares\nsudo tee /etc/audit/sharing-filter.conf > /dev/null <<'EOF'\n# Sharing filter configuration\n# Automatically pseudonymize logs before external transmission\n\n[external_share]\n# Recipient: Partner Organization\nrecipient_name=partner-org\nrecipient_email=soc@partner-org.com\napply_pseudonymization=yes\nremove_hostname=no\nremove_exe_paths=yes\nremove_home_dirs=yes\nkeep_event_types=yes\n\n# Recipient: Third-party Auditor\nrecipient_name=auditor\nrecipient_email=auditor@external-firm.com\napply_pseudonymization=yes\nremove_hostname=no\nremove_exe_paths=yes\nremove_home_dirs=yes\nkeep_event_types=yes\nEOF\n\necho \"Disassociability (pseudonymization) configured for cross-organizational audit sharing.\"\necho \"Mapping table: /etc/audit/uid-mapping.conf (protected, not shared)\"\necho \"Pseudonymization script: /usr/local/bin/pseudonymize-audit-logs.sh\"\n"
      },
      "windows": {
        "windows_disassociability": "# Windows audit log disassociability implementation\n# Removes PII from event logs for cross-organizational sharing\n\nWrite-Host \"Configuring Windows audit disassociability...\"\n\n# Step 1: Create user ID mapping database\n$mappingDbPath = \"C:\\\\ProgramData\\\\Audit\\\\DisassociabilityMapping.json\"\nNew-Item -ItemType Directory -Path \"C:\\\\ProgramData\\\\Audit\" -Force | Out-Null\n\n$mappingTemplate = @{\n    version = \"1.0\"\n    created = (Get-Date -AsUTC)\n    mappings = @()\n    notes = \"CONFIDENTIAL - Contains reverse mapping for pseudonymized audit logs. Restrict access.\"\n}\n\n$mappingTemplate | ConvertTo-Json | Out-File -FilePath $mappingDbPath -Encoding UTF8 -Force\nWrite-Host \"Mapping database created at: $mappingDbPath\"\n\n# Step 2: Set restrictive permissions on mapping database\n$acl = Get-Acl -Path $mappingDbPath\n$acl.SetAccessRuleProtection($true, $false)\n$rule = New-Object System.Security.AccessControl.FileSystemAccessRule(\n    [System.Security.Principal.WindowsIdentity]::GetCurrent().User,\n    [System.Security.AccessControl.FileSystemRights]::FullControl,\n    [System.Security.AccessControl.AccessControlType]::Allow\n)\n$acl.SetAccessRule($rule)\nSet-Acl -Path $mappingDbPath -AclObject $acl\nWrite-Host \"Restricted access permissions set on mapping database\"\n\n# Step 3: Create PowerShell function to pseudonymize event logs\n$pseudonymizeFunction = @\"\nfunction ConvertTo-PseudonymizedEventLog {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory=\\$true)]\n        [string]\\$EventLogName,\n        \n        [Parameter(Mandatory=\\$false)]\n        [int]\\$MaxEvents = 10000,\n        \n        [Parameter(Mandatory=\\$true)]\n        [string]\\$OutputPath\n    )\n    \n    \\$mappingDb = Get-Content 'C:\\\\ProgramData\\\\Audit\\\\DisassociabilityMapping.json' | ConvertFrom-Json\n    \\$pseudonymMap = @{}\n    \\$counter = 0\n    \n    # Export events\n    \\$events = Get-WinEvent -LogName \\$EventLogName -MaxEvents \\$MaxEvents -ErrorAction SilentlyContinue\n    \n    # Create pseudonymized output\n    \\$output = @()\n    \n    foreach (\\$event in \\$events) {\n        \\$pseudonymizedEvent = \\$event.Message -replace '([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})', 'USER-PSEUDONYM@organization.local'\n        \\$pseudonymizedEvent = \\$pseudonymizedEvent -replace '([\\\\\\\\\\\\\\\\][A-Za-z0-9_-]+\\\\\\\\[A-Za-z0-9_-]+)', 'DOMAIN\\\\\\\\USER-PSEUDONYM'\n        \\$pseudonymizedEvent = \\$pseudonymizedEvent -replace '\\\\b\\\\d{1,3}(\\\\.\\\\d{1,3}){3}\\\\b', '0.0.0.0'  # IP anonymization\n        \\$pseudonymizedEvent = \\$pseudonymizedEvent -replace '([a-f0-9]{8}-([a-f0-9]{4}-){3}[a-f0-9]{12})', 'GUID-REDACTED'  # GUID anonymization\n        \n        \\$output += @{\n            TimeCreated = \\$event.TimeCreated\n            EventId = \\$event.Id\n            Provider = \\$event.ProviderName\n            Message = \\$pseudonymizedEvent\n        }\n        \n        \\$counter++\n    }\n    \n    # Export to JSON\n    \\$output | ConvertTo-Json | Out-File -FilePath \\$OutputPath -Encoding UTF8 -Force\n    Write-Host \"Pseudonymized \\$counter events exported to: \\$OutputPath\"\n}\n\"@\n\nAdd-Content -Path \\$PROFILE -Value \\$pseudonymizeFunction -Force\nWrite-Host \"Pseudonymization function added to PowerShell profile\"\n\n# Step 4: Create event log filter to exclude PII\nWrite-Host \"Creating event log filter for PII removal...\"\n\n# List of PII patterns to remove from event logs\n\\$piiPatterns = @(\n    'Email@example.com',\n    '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}',  # Email addresses\n    '(\\\\\\\\){1,2}[a-zA-Z0-9_-]+',  # UNC paths\n    '\\\\b\\\\d{3}-\\\\d{2}-\\\\d{4}\\\\b',  # SSN\n    '\\\\b\\\\d{1,3}(\\\\.\\\\d{1,3}){3}\\\\b'  # IP addresses\n)\n\n# Step 5: Test pseudonymization with sample event\nWrite-Host \"Testing pseudonymization functionality...\"\n\n\\$testEvent = \"User john.smith@acme.com (jsmith\\\\\\\\john.smith) logged on from 192.168.1.100\"\n\\$pseudonymized = \\$testEvent -replace '([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,})', 'USER@organization.local' `\n                              -replace '([\\\\\\\\\\\\\\\\][A-Za-z0-9_.-]+\\\\\\\\[A-Za-z0-9_.-]+)', 'DOMAIN\\\\\\\\USER' `\n                              -replace '\\\\b\\\\d{1,3}(\\\\.\\\\d{1,3}){3}\\\\b', 'X.X.X.X'\n\nWrite-Host \"Original: \\$testEvent\"\nWrite-Host \"Pseudonymized: \\$pseudonymized\"\n\n# Step 6: Document the disassociation method\n\\$disassociabilityDoc = @\"\nDisassociability Implementation for Windows Audit Logs\n=====================================================\n\nMethod: Pseudonymization with confidential reverse mapping\n\nPII Removed:\n- User names and email addresses → USER-PSEUDONYM\n- Domain\\\\\\\\username patterns → DOMAIN\\\\\\\\USER-PSEUDONYM\n- IP addresses → X.X.X.X (anonymized)\n- GUIDs and identifiers → GUID-REDACTED\n- System paths → SYSTEM\\\\\\\\PATH\\\\\\\\REDACTED\n\nReverse Mapping:\n- Maintained in restricted-access database: C:\\\\ProgramData\\\\Audit\\\\DisassociabilityMapping.json\n- Accessible only to incident response and law enforcement with authorization\n- All access attempts logged for audit purposes\n\nVerification:\n- Pseudonymized logs tested to ensure no re-identification is possible\n- k-anonymity metric verified (k >= 5)\n\"@\n\n\\$disassociabilityDoc | Out-File -FilePath 'C:\\\\ProgramData\\\\Audit\\\\Disassociability-Documentation.txt' -Encoding UTF8 -Force\n\nWrite-Host \"Disassociability configuration complete.\"\nWrite-Host \"Mapping database location: $mappingDbPath\"\nWrite-Host \"Use ConvertTo-PseudonymizedEventLog to export pseudonymized logs.\"\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T14:32:00.000000Z",
      "has_scripts": true,
      "verification_status": "validated",
      "implementation_level": "technical",
      "stig_id": "RHEL-08-030343"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T14:32:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "documented",
      "platform": [
        "rhel8",
        "rhel9",
        "windows-server-2019",
        "windows-server-2022"
      ],
      "rule_count": 3,
      "certification": "Government-certified",
      "implementation_guidance": "Implement pseudonymization using cryptographic tokens or consistent pseudonyms. Maintain separate reverse-mapping database with restricted access. Test that pseudonymized data prevents re-identification. Support emergency override for law enforcement and authorized incident response."
    }
  }
]