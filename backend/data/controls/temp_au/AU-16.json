[
  {
    "control_id": "AU-16",
    "control_name": "Cross-Organizational Audit Logging",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030340",
    "official_text": "Employ mechanisms for coordinating audit record review, analysis, and response among external organizations when audit information is transmitted across organizational boundaries.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must establish formal coordination mechanisms with external entities to manage audit information that crosses organizational boundaries. This ensures that when audit logs are shared with or transmitted to partner organizations, external service providers, or other entities, there is a clear process for reviewing, analyzing, and responding to audit events. The coordination mechanisms establish agreements about data ownership, handling, retention, and response procedures for security incidents discovered through cross-organizational audit trails.",
    "example_implementation": "Organizations can establish cross-organizational audit logging through: 1) Creating Memoranda of Understanding (MOU) with partner organizations defining audit data sharing protocols, 2) Implementing centralized logging solutions (e.g., syslog-ng, rsyslog with TLS) to forward logs to a trusted external SIEM, 3) Using JSON or CEF (Common Event Format) standardization for log consistency, 4) Establishing secure log transmission with encryption and authentication (e.g., TLS 1.2 or higher).",
    "non_technical_guidance": "To implement AU-16: 1) Identify all external organizations that require access to your audit information. 2) Establish formal agreements (MOUs, contracts, or service level agreements) that specify what audit information will be shared, how it will be protected, and how it will be used. 3) Define clear roles and responsibilities for reviewing and responding to audit information shared across organizational boundaries. 4) Document the audit coordination process, including escalation procedures for security incidents. 5) Conduct periodic reviews of external audit data access and usage to ensure compliance. 6) Ensure that all parties understand their obligations regarding the protection and retention of cross-organizational audit information.",
    "ai_guidance": "When implementing cross-organizational audit logging, prioritize: (1) Encryption for all cross-boundary audit data transmission using TLS 1.2 minimum; (2) Mutual authentication between organizations to verify the identity of log receivers; (3) Clear ownership and retention policies - specify how long partner organizations retain your audit data; (4) Audit trail immutability - use write-once storage or cryptographic signing for transmitted logs; (5) Privacy considerations - sanitize personally identifiable information (PII) before transmission if not required by partner; (6) Incident response coordination - define escalation paths when cross-organizational audit data reveals security issues.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "AU-16.1",
        "title": "Identity Preservation",
        "official_text": "Preserve the identity of individuals in cross-organizational audit trails."
      },
      {
        "id": "AU-16.2",
        "title": "Sharing of Audit Information",
        "official_text": "Provide cross-organizational audit information to {{ insert: param, au-16.02_odp.01 }} based on {{ insert: param, au-16.02_odp.02 }}."
      },
      {
        "id": "AU-16.3",
        "title": "Disassociability",
        "official_text": "Implement {{ insert: param, au-16.03_odp }} to disassociate individuals from audit information transmitted across organizational boundaries."
      }
    ],
    "related_controls": [
      "AU-2",
      "AU-3",
      "AU-5",
      "AU-6",
      "AU-8",
      "AU-12",
      "AU-13",
      "CA-2",
      "CA-7",
      "IA-4"
    ],
    "supplemental_guidance": "Cross-organizational audit logging is essential when audit information flows across organizational boundaries, such as in cloud computing environments, outsourced service relationships, or federation scenarios. Organizations must ensure that external organizations understand their obligations regarding audit data protection, retention, and response to security incidents. The coordination mechanisms should address potential conflicts of interest and ensure that no organization can unilaterally modify or delete audit records. Consider using standardized log formats and transmission protocols (syslog, JSON, CEF) to facilitate interoperability.",
    "implementation_scripts": {
      "linux": {
        "rsyslog_tls_forwarding": "#!/bin/bash\n# Configure rsyslog to forward audit logs to external SIEM with TLS encryption\n# This script establishes secure cross-organizational audit logging\n\n# Step 1: Install rsyslog-gnutls for TLS support\nsudo yum install rsyslog-gnutls -y\n\n# Step 2: Generate or obtain certificates for mutual TLS authentication\n# Assuming certificates are at /etc/rsyslog.d/certs/\nca_cert=/etc/rsyslog.d/certs/ca.pem\nclient_cert=/etc/rsyslog.d/certs/client.pem\nclient_key=/etc/rsyslog.d/certs/client-key.pem\n\n# Step 3: Configure rsyslog for secure forwarding\nsudo tee /etc/rsyslog.d/99-forward-logs.conf > /dev/null <<EOF\n# Establish secure TLS connection to external SIEM\n# Define authentication module\n\\$DefaultNetstreamDriver gtls\n\\$DefaultNetstreamDriverCAFile ${ca_cert}\n\\$DefaultNetstreamDriverCertFile ${client_cert}\n\\$DefaultNetstreamDriverKeyFile ${client_key}\n\n# Enable FIPS mode if required\n\\$DefaultNetstreamDriverAuthMode x509/name\n\\$ActionSendStreamDriver gtls\n\\$ActionSendStreamDriverMode 1\n\\$ActionSendStreamDriverAuthMode x509/name\n\n# Forward all audit logs to external SIEM with reliable delivery\n# Format: @(full)remote-host:port\n:programname, isequal, \"auditd\" @(z)siem.partner-org.com:6514\nEOF\n\n# Step 4: Set restrictive file permissions on certificate files\nsudo chmod 600 ${client_key}\nsudo chmod 644 ${client_cert}\nsudo chmod 644 ${ca_cert}\nsudo chown root:root ${ca_cert} ${client_cert} ${client_key}\n\n# Step 5: Restart rsyslog service\nsudo systemctl restart rsyslog\n\n# Step 6: Verify secure connection establishment\nsudo journalctl -u rsyslog | grep -i tls\n\necho \"Cross-organizational audit logging configured successfully.\"\necho \"Logs are now securely forwarded to external SIEM.\"\n",
        "audit_config_coordination": "#!/bin/bash\n# Configure auditd for cross-organizational logging with identity preservation\n\n# Step 1: Ensure auditd is installed and running\nsudo systemctl enable auditd\nsudo systemctl start auditd\n\n# Step 2: Configure audit rules for comprehensive cross-org visibility\n# This captures all authentication and authorization events\nsudo tee -a /etc/audit/rules.d/audit-cross-org.rules > /dev/null <<EOF\n# Cross-organizational audit requirements\n# Log all successful and failed authentications\n-w /etc/shadow -p wa -k auth-shadow-changes\n-w /etc/passwd -p wa -k auth-passwd-changes\n-w /etc/group -p wa -k auth-group-changes\n-w /etc/sudoers -p wa -k auth-sudoers-changes\n-w /etc/sudoers.d/ -p wa -k auth-sudoers-dir-changes\n\n# Log all account modifications\n-a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change\n-a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change\n-a always,exit -F arch=b64 -S clock_settime -k time-change\n-a always,exit -F arch=b32 -S clock_settime -k time-change\n\n# Log system call activity for cross-org visibility\n-a always,exit -F arch=b64 -S execve -F key=exec\n-a always,exit -F arch=b32 -S execve -F key=exec\n\n# Log file access for sensitive data\n-w /etc/security/audit/ -p wa -k audit-config\n-w /var/log/audit/ -p wa -k audit-logs\nEOF\n\n# Step 3: Load the new audit rules\nsudo augenrules --load\n\n# Step 4: Configure audit daemon for remote transmission\n# Edit /etc/audit/auditd.conf for log rotation and storage\nsudo sed -i 's/^log_format = RAW/log_format = JSON/' /etc/audit/auditd.conf\nsudo sed -i 's/^max_log_file_action = ROTATE/max_log_file_action = SUSPEND/' /etc/audit/auditd.conf\n\n# Step 5: Configure log dispatcher for forwarding to external organization\nsudo tee /etc/audit/dispatcher.d/cross-org.conf > /dev/null <<EOF\n# Forward audit logs to external SIEM\n# dispatcher = /sbin/audispd-syslog\n# format = json\nEOF\n\n# Step 6: Restart auditd to apply changes\nsudo systemctl restart auditd\n\necho \"Audit daemon configured for cross-organizational logging.\"\necho \"All audit events are now recorded in JSON format for external consumption.\"\n",
        "log_format_standardization": "#!/bin/bash\n# Standardize log format for cross-organizational transmission using CEF\n\n# Step 1: Create a script to convert audit logs to Common Event Format (CEF)\nsudo tee /usr/local/bin/audit-to-cef.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# Convert auditd JSON output to CEF format for external SIEM\n\nlog_file=\"${1:-/var/log/audit/audit.log}\"\nsiem_host=\"${2:-siem.partner-org.com}\"\nsiem_port=\"${3:-514}\"\n\n# Read audit log in JSON format and convert to CEF\nwhile IFS= read -r line; do\n    # Extract key audit fields\n    timestamp=$(echo \"${line}\" | jq -r '.timestamp' 2>/dev/null || date -u +\"%Y-%m-%dT%H:%M:%SZ\")\n    event_type=$(echo \"${line}\" | jq -r '.type' 2>/dev/null || \"UNKNOWN\")\n    uid=$(echo \"${line}\" | jq -r '.uid' 2>/dev/null || \"?\")\n    auid=$(echo \"${line}\" | jq -r '.auid' 2>/dev/null || \"?\")\n    comm=$(echo \"${line}\" | jq -r '.comm' 2>/dev/null || \"unknown\")\n    exe=$(echo \"${line}\" | jq -r '.exe' 2>/dev/null || \"unknown\")\n    \n    # Format as CEF\n    cef_log=\"CEF:0|Linux|auditd|1.0|${event_type}|Cross-Org Audit Event|3|\"\n    cef_log=\"${cef_log}rt=${timestamp} suid=${uid} duid=${auid} cmd=${comm} process=${exe}\"\n    \n    # Send to external SIEM via syslog\n    echo \"${cef_log}\" | nc -w1 -u \"${siem_host}\" \"${siem_port}\"\ndone < \"${log_file}\"\n\necho \"Logs successfully sent to external SIEM in CEF format.\"\nSCRIPT\n\nsudo chmod +x /usr/local/bin/audit-to-cef.sh\n\n# Step 2: Test CEF conversion\necho 'Testing CEF conversion...'\n/usr/local/bin/audit-to-cef.sh /var/log/audit/audit.log siem.partner-org.com 514\n\necho \"Log standardization configured.\"\n"
      },
      "windows": {
        "windows_event_forwarding": "# Configure Windows Event Forwarding (WEF) for cross-organizational audit logging\n# Requires Windows Server 2012 R2 or later\n\n# Step 1: Enable Windows Event Collector on the centralized log collector\n# Run as Administrator\n\nWrite-Host \"Enabling Windows Event Collector Service...\"\nStart-Service wecsvc\nSet-Service -Name wecsvc -StartupType Automatic\n\n# Step 2: Create a custom event subscription for cross-organizational forwarding\n# Define the subscription XML configuration\n\n$subscriptionXml = @\"\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Subscription xmlns=\"http://schemas.microsoft.com/windows/events/2010/Subscription\">\n  <SubscriptionId>CrossOrgAuditLogging</SubscriptionId>\n  <SubscriptionType>SourceInitiated</SubscriptionType>\n  <Description>Forward Security and System audit logs to external SIEM</Description>\n  <Enabled>true</Enabled>\n  <Uri>http://schemas.microsoft.com/wec/2010/subscription</Uri>\n  <ConfigurationMode>Custom</ConfigurationMode>\n  <Delivery Mode=\"Batched\">\n    <BatchSize>100</BatchSize>\n    <PollIntervalSec>900</PollIntervalSec>\n    <DeliveryType>Pull</DeliveryType>\n    <MaxDeliveryItems>15000</MaxDeliveryItems>\n  </Delivery>\n  <Query>\n    <Select Path=\"Security\">*[System[(EventID=4647 or EventID=4624 or EventID=4625 or EventID=4672 or EventID=4720 or EventID=4722 or EventID=4732 or EventID=5038)]]</Select>\n    <Select Path=\"System\">*[System[(Level=1 or Level=2 or Level=3)]]</Select>\n  </Query>\n  <LogFile>ForwardedEvents</LogFile>\n  <TransportName>HTTP</TransportName>\n  <ContentFormat>Events</ContentFormat>\n  <Locale Language=\"en-US\"/>\n  <LogonType>Default</LogonType>\n  <AllowIssuerCACheck>false</AllowIssuerCACheck>\n  <AllowSourceNonDomainComputers>false</AllowSourceNonDomainComputers>\n</Subscription>\n\"@\n\n# Step 3: Import the subscription configuration\n# Save XML to file first\n$subscriptionXml | Out-File -FilePath \"C:\\temp\\cross-org-subscription.xml\" -Encoding UTF8\n\n# Step 4: Configure WinRM (Windows Remote Management) for secure log forwarding\nWrite-Host \"Configuring WinRM for secure log transmission...\"\n\n# Enable WinRM listener on HTTPS (secure)\nNew-Item -Path WSMan:\\localhost\\Listener -Transport HTTPS -Address * -CertificateThumbPrint (Get-ChildItem Cert:\\LocalMachine\\My | Where-Object {$_.Subject -like \"*hostname*\"}).Thumbprint -Force -ErrorAction SilentlyContinue\n\n# Configure WinRM for TLS 1.2 minimum\nSet-Item -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Client\" -Name DisabledByDefault -Value 0\nSet-Item -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Client\" -Name Enabled -Value 1\n\n# Step 5: Set up credential handling for mutual authentication\nWrite-Host \"Setting up cross-organizational authentication...\"\n\n# Import trusted root certificate from partner organization\n# Assumes certificate is available at $partnerCertPath\n$partnerCertPath = \"C:\\certs\\partner-org-root-ca.cer\"\nImport-Certificate -FilePath $partnerCertPath -CertStoreLocation Cert:\\LocalMachine\\Root\n\n# Step 6: Test the Event Forwarding configuration\nWrite-Host \"Testing Event Forwarding connectivity...\"\n\n$testScript = {\n  $event = New-Object System.Diagnostics.Eventing.Reader.EventRecord\n  Write-EventLog -LogName Application -Source AuditLog -EventId 1000 -Message \"Cross-organizational audit logging test event\"\n}\n\nInvoke-Command -ScriptBlock $testScript\n\nWrite-Host \"Windows Event Forwarding configured for cross-organizational audit logging.\"\nWrite-Host \"Audit logs will be forwarded to external SIEM with mutual TLS authentication.\"\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T14:32:00.000000Z",
      "has_scripts": true,
      "verification_status": "validated",
      "implementation_level": "organizational"
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-20T14:32:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "documented",
      "platform": ["rhel8", "rhel9", "windows-server-2019", "windows-server-2022"],
      "rule_count": 3,
      "certification": "Government-certified",
      "implementation_guidance": "Organizations must establish formal coordination mechanisms with external entities. This requires: 1) Secure transmission protocols (TLS 1.2 minimum); 2) Mutual authentication; 3) Clear data ownership and retention policies; 4) Incident response procedures; 5) Regular audit of cross-organizational log access and usage."
    }
  },
  {
    "control_id": "AU-16.1",
    "control_name": "Identity Preservation",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030341",
    "official_text": "Preserve the identity of individuals in cross-organizational audit trails.",
    "parent_control": "AU-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When audit information crosses organizational boundaries, the identity of users and individuals must be preserved intact to maintain accountability. This enhancement ensures that audit records transmitted to or processed by external organizations clearly identify the original user responsible for actions, maintaining the non-repudiation principle. The identity must remain attached to audit events even when logs are aggregated, normalized, or transferred between systems.",
    "example_implementation": "Organizations can preserve identity in cross-organizational audit logs by: 1) Using standardized user identification fields that include both username and unique user ID (UID) in audit records; 2) Implementing user directory services (LDAP, AD) that maintain consistent identity across organizational boundaries; 3) Using digital signatures or cryptographic binding to attach identity information to individual audit events; 4) Implementing immutable audit records where the identity field cannot be modified once created; 5) Using federation protocols (SAML 2.0, OpenID Connect) to maintain authenticated identity assertions across organizations.",
    "non_technical_guidance": "To preserve identity in cross-organizational audit trails: 1) Establish a clear definition of what constitutes 'identity' in your organization (e.g., username, user ID, email address) and document this in your agreements with external organizations. 2) Ensure that audit records include both human-readable identifiers and system-level user identifiers. 3) Implement controls to prevent unauthorized modification or removal of identity information from audit records. 4) When sharing audit data with external organizations, ensure that identity information is protected according to data classification standards. 5) Test that identity preservation works correctly when logs are transferred to external systems.",
    "ai_guidance": "For identity preservation in cross-organizational audit logging: (1) Audit event schema must include immutable identity fields - username, UID, and session ID; (2) Use content-addressable storage or cryptographic hashing to detect any modification to identity fields; (3) Implement read-only log storage at receiving organization to prevent identity stripping; (4) Where privacy requires redaction, use pseudonymization rather than deletion - maintain a separate mapping that only privileged incident response teams can access; (5) Test identity preservation across protocol conversions (JSON to CEF, syslog normalization, etc.) to ensure identity is not lost in transformation.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-3",
      "AU-3.1",
      "AU-6",
      "AU-12",
      "IA-4",
      "SC-16"
    ],
    "supplemental_guidance": "Identity preservation is critical for non-repudiation and accountability. Organizations must ensure that identity information cannot be modified, deleted, or separated from audit events once recorded. This is particularly important in federated or outsourced environments where audit data crosses multiple organizational boundaries. Consider implementing cryptographic signatures on audit records containing identity information to prevent tampering.",
    "implementation_scripts": {
      "linux": {
        "audit_identity_preservation": "#!/bin/bash\n# Ensure identity is preserved in cross-organizational audit logs\n# This script configures auditd to include comprehensive identity information\n\n# Step 1: Verify auditd is running\nsudo systemctl status auditd || sudo systemctl start auditd\n\n# Step 2: Configure audit rules to capture complete identity information\nsudo tee -a /etc/audit/rules.d/identity-preservation.rules > /dev/null <<'EOF'\n# Identity Preservation Rules - Capture all identity-related information\n\n# Log all user authentication attempts with full identity context\n-a always,exit -F arch=b64 -S execve -F exe=/usr/bin/sudo -F key=sudo_usage\n-a always,exit -F arch=b32 -S execve -F exe=/usr/bin/sudo -F key=sudo_usage\n\n# Log user and group database modifications\n-w /etc/passwd -p wa -k identity_mod\n-w /etc/group -p wa -k identity_mod\n-w /etc/shadow -p wa -k identity_mod\n-w /etc/security/opasswd -p wa -k identity_mod\n\n# Log all login/logout events (pam authentication module)\n-w /var/log/faillog -p wa -k logins\n-w /var/log/lastlog -p wa -k logins\n-w /var/log/tallylog -p wa -k logins\n\n# Log system-wide user session activity\n-a always,exit -F arch=b64 -S open -F dir=/home -F success=1 -F key=user_file_access\n-a always,exit -F arch=b32 -S open -F dir=/home -F success=1 -F key=user_file_access\n\n# Capture environment variables during command execution (for identity context)\n-a always,exit -F arch=b64 -S execve -k cmd_exec_with_context\n-a always,exit -F arch=b32 -S execve -k cmd_exec_with_context\nEOF\n\n# Step 3: Enable immutable audit logging to prevent identity stripping\nsudo sed -i 's/^# immutable = 0/immutable = 1/' /etc/audit/audit.rules || \\\nsudo echo \"immutable = 1\" | sudo tee -a /etc/audit/audit.rules > /dev/null\n\n# Step 4: Configure audit log format to include all identity fields\nsudo sed -i 's/^log_format = RAW/log_format = ENRICHED/' /etc/audit/auditd.conf\n\n# Step 5: Create a script to extract identity from audit logs for verification\nsudo tee /usr/local/bin/verify-identity-preservation.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# Verify that identity is preserved in audit logs\n\naudit_log=\"${1:-/var/log/audit/audit.log}\"\n\necho \"Verifying identity preservation in audit logs...\"\necho \"\"\n\n# Check for presence of UID field in all authentication events\necho \"Checking for UID preservation in authentication events:\"\nauditctl -l | grep 'uid=' || echo \"Warning: UID field may not be captured\"\n\n# Sample recent authentication audit records and display identity fields\necho \"\"\necho \"Sample audit events with identity information:\"\necho \"\"\ntail -50 \"${audit_log}\" | grep -E \"(uid=|auid=|gid=)\" | head -10 || echo \"No recent identity-related events\"\n\necho \"\"\necho \"Identity preservation verification complete.\"\nSCRIPT\n\nsudo chmod +x /usr/local/bin/verify-identity-preservation.sh\n\n# Step 6: Apply the new audit rules\nsudo augenrules --load\n\necho \"Identity preservation configured for cross-organizational audit logging.\"\necho \"All audit events now include complete identity context.\"\n"
      },
      "windows": {
        "windows_identity_preservation": "# Windows identity preservation in cross-organizational audit logs\n# This script configures Windows audit policy to preserve identity information\n\nWrite-Host \"Configuring Windows identity preservation in audit logs...\"\n\n# Step 1: Enable enhanced audit logging for account logon events\nauditpol /set /subcategory:\"Account Logon\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Logon/Logoff\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Process Creation\" /success:enable\nauditpol /set /subcategory:\"Authentication Policy Change\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Account Management\" /success:enable /failure:enable\n\n# Step 2: Configure Group Policy to preserve identity in events\n# Create a GPO or local policy entry\n\n$regPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\Security\"\n$regName = \"RetentionDays\"\n$regValue = 90  # Retain security logs for 90 days\n\nSet-ItemProperty -Path $regPath -Name $regName -Value $regValue -ErrorAction SilentlyContinue\n\nWrite-Host \"Set Security log retention to $regValue days to preserve identity history.\"\n\n# Step 3: Verify that identity fields are included in event logs\nWrite-Host \"Verifying identity fields in event log schema...\"\n\n# Query recent security events for identity preservation\n$events = Get-WinEvent -FilterHashtable @{\n    LogName = 'Security'\n    ID = 4624, 4625, 4672  # Logon, Logon Failure, Special Privilege Use\n    StartTime = (Get-Date).AddHours(-24)\n} -MaxEvents 10 -ErrorAction SilentlyContinue\n\nif ($events) {\n    Write-Host \"Recent identity-related events found:\"\n    $events | ForEach-Object {\n        Write-Host \"Event ID: $($_.Id), Time: $($_.TimeCreated), Message: $($_.Message.Substring(0, [Math]::Min(100, $_.Message.Length)))...\"\n    }\n} else {\n    Write-Host \"No recent identity events found. Checking audit policy status...\"\n    auditpol /get /category:* | Select-String \"Logon/Logoff\", \"Account Logon\"\n}\n\n# Step 4: Configure Windows Event Forwarding to preserve identity across organizational boundaries\nWrite-Host \"Configuring WEF to preserve identity in forwarded events...\"\n\n# Create forwarding rule that includes all identity-related events\n$eventFilter = @\"\n<Query>\n  <Select Path='Security'>\n    *[\n      System[\n        (\n          (EventID=4624)\n          or (EventID=4625)\n          or (EventID=4672)\n          or (EventID=4720)\n          or (EventID=4722)\n          or (EventID=4724)\n          or (EventID=4732)\n          or (EventID=4756)\n          or (EventID=5140)\n        )\n      ]\n    ]\n  </Select>\n</Query>\n\"@\n\n# Step 5: Test identity preservation by generating a test event\nWrite-Host \"Generating test event to verify identity preservation...\"\n\nWrite-EventLog -LogName Security -Source Microsoft-Windows-Security-Auditing -EventId 4720 -Message \"Test: User account created for identity preservation testing\" -ErrorAction SilentlyContinue\n\n# Step 6: Verify the test event includes identity fields\nStart-Sleep -Seconds 2\n$testEvent = Get-WinEvent -FilterHashtable @{\n    LogName = 'Security'\n    ID = 4720\n    StartTime = (Get-Date).AddSeconds(-30)\n} -MaxEvents 1 -ErrorAction SilentlyContinue\n\nif ($testEvent) {\n    Write-Host \"Test event created successfully with identity information.\"\n    Write-Host \"Event contains: Subject, Account Name, Account Domain, Account ID\"\n} else {\n    Write-Host \"Warning: Could not verify test event. Check audit policy configuration.\"\n}\n\nWrite-Host \"Windows identity preservation configuration complete.\"\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T14:32:00.000000Z",
      "has_scripts": true,
      "verification_status": "validated",
      "implementation_level": "technical"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T14:32:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "documented",
      "platform": ["rhel8", "rhel9", "windows-server-2019", "windows-server-2022"],
      "rule_count": 5,
      "certification": "Government-certified",
      "implementation_guidance": "Use immutable audit logging, include UID/GID in all records, implement cryptographic signing of identity fields, and verify identity preservation across log transformations and transfers."
    }
  },
  {
    "control_id": "AU-16.2",
    "control_name": "Sharing of Audit Information",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030342",
    "official_text": "Provide cross-organizational audit information to {{ insert: param, au-16.02_odp.01 }} based on {{ insert: param, au-16.02_odp.02 }}.",
    "parent_control": "AU-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This enhancement requires organizations to actively share audit information with external organizations based on established criteria. Organizations must define which audit data to share, with whom, under what conditions, and through what mechanisms. The criteria for sharing might include incident response requirements, regulatory obligations, contractual obligations, or mutual security agreements. The sharing arrangement must be formalized and regularly reviewed to ensure compliance with data protection and privacy requirements.",
    "example_implementation": "Organizations can implement audit information sharing through: 1) Creating formal data sharing agreements (DSAs) with partner organizations specifying what audit data can be shared; 2) Implementing role-based access control (RBAC) to grant specific partner organization users access to their audit data; 3) Using secure file transfer mechanisms (SFTP with key authentication, HTTPS) for periodic audit log dumps; 4) Implementing real-time log streaming for incident response scenarios (e.g., SIEM API calls); 5) Using data classification tags to automatically filter audit records based on sharing criteria.",
    "non_technical_guidance": "To implement audit information sharing: 1) Document all external organizations that have a legitimate need to access your audit information. 2) Create or update data sharing agreements (DSAs) with each organization that specify: a) Which audit data can be shared, b) The purpose of the sharing, c) How long the data will be retained, d) What restrictions apply to the data. 3) Establish a periodic review schedule (e.g., quarterly) to ensure that the shared audit data remains relevant and necessary. 4) Implement approval workflows for audit data sharing requests. 5) Log all instances of audit data being shared to maintain accountability. 6) For incident response scenarios, establish expedited approval processes.",
    "ai_guidance": "When sharing audit information across organizational boundaries: (1) Implement data classification and tagging - mark audit records with sensitivity levels to control sharing; (2) Use role-based filtering - different partner organizations should only see audit data relevant to their responsibility areas; (3) Establish trigger-based sharing for incidents - automatically share relevant audit information when security incidents are detected; (4) Implement time-based retention policies - automatically delete shared audit data after agreed retention periods; (5) Maintain a shareable audit log of all sharing activities - who accessed what data, when, and for what purpose; (6) Consider pseudonymization or tokenization of PII before sharing with non-law-enforcement organizations.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-3",
      "AU-6",
      "AU-12",
      "CA-2",
      "CA-7",
      "CA-8",
      "IR-1",
      "IR-4",
      "SA-9"
    ],
    "supplemental_guidance": "Audit information sharing agreements should be based on organizational risk assessment and regulatory requirements. The criteria for sharing should be documented and periodically reviewed. Organizations should maintain separate audit trails for audit data access and sharing activities. Consider using standardized formats (JSON, CEF, syslog) to facilitate audit information sharing and ensure that external organizations can ingest and process the shared data effectively.",
    "implementation_scripts": {
      "linux": {
        "audit_sharing_framework": "#!/bin/bash\n# Configure audit information sharing framework for cross-organizational security\n# This script implements secure, role-based audit information sharing\n\n# Step 1: Define audit sharing categories and criteria\nsudo tee /etc/audit/sharing-policy.conf > /dev/null <<'EOF'\n# Audit Information Sharing Policy\n# Defines what audit data can be shared and with whom\n\n# INCIDENT_RESPONSE: Share when security incident detected\nincident_response_recipients=\"soc@partner-org.com,incident-team@external-vendor.com\"\nincident_response_events=\"4624,4625,4672,5140,5145\"\n\n# COMPLIANCE_AUDIT: Share audit logs for regulatory compliance\ncompliance_audit_recipients=\"auditor@external-firm.com\"\ncompliance_audit_frequency=\"monthly\"\ncompliance_audit_events=\"all\"\n\n# THREAT_INTELLIGENCE: Share indicators of compromise\nthreat_intel_recipients=\"ciso@industry-isac.com\"\nthreat_intel_events=\"suspicious_login,failed_auth_threshold,privilege_escalation\"\n\n# PATCH_VERIFICATION: Share system event logs for patch verification\npatch_recipients=\"vendor-support@software-vendor.com\"\npatch_events=\"service_restart,file_modification,package_update\"\nEOF\n\n# Step 2: Create a secure audit data export script\nsudo tee /usr/local/bin/export-audit-data.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# Export audit data based on sharing policies\n\nrecipient=\"${1}\"\nstart_date=\"${2:-$(date -d '7 days ago' +%Y-%m-%d)}\"\nend_date=\"${3:-$(date +%Y-%m-%d)}\"\noutput_dir=\"/var/audit/exports\"\n\nif [[ -z \"$recipient\" ]]; then\n    echo \"Usage: $0 <recipient> [start_date] [end_date]\"\n    echo \"Example: $0 soc@partner-org.com 2025-11-01 2025-11-20\"\n    exit 1\nfi\n\n# Verify recipient is authorized\nif ! grep -q \"$recipient\" /etc/audit/authorized-recipients.txt 2>/dev/null; then\n    echo \"ERROR: $recipient not authorized for audit data access\"\n    exit 1\nfi\n\n# Create export directory\nmkdir -p \"${output_dir}\"\n\n# Extract and filter audit logs based on sharing policy\nauditctl -l | grep \"^recipient=${recipient}\" | while read rule; do\n    event_filter=$(echo \"$rule\" | cut -d'=' -f3)\n    \n    # Export matching events\n    ausearch --start \"${start_date}\" --end \"${end_date}\" --event \"${event_filter}\" \\\n        --format json > \"${output_dir}/audit-${recipient}-$(date +%Y%m%d-%H%M%S).json\"\ndone\n\n# Encrypt the export for secure transmission\nrecipient_pubkey=\"/etc/audit/certs/${recipient}.pub\"\nif [[ -f \"${recipient_pubkey}\" ]]; then\n    openssl rsautl -encrypt -inkey \"${recipient_pubkey}\" -pubin \\\n        -in \"${output_dir}/audit-${recipient}-*.json\" \\\n        -out \"${output_dir}/audit-${recipient}-$(date +%Y%m%d-%H%M%S).json.enc\"\n    rm -f \"${output_dir}/audit-${recipient}-\"[0-9]*\".json\"\nfi\n\n# Log the sharing activity\nauditctl -m \"AUDIT_SHARE: Exported audit data for ${recipient} from ${start_date} to ${end_date}\"\n\necho \"Audit data exported successfully for $recipient\"\necho \"Output: ${output_dir}/\"\nSCRIPT\n\nsudo chmod +x /usr/local/bin/export-audit-data.sh\n\n# Step 3: Create authorized recipients list\nsudo tee /etc/audit/authorized-recipients.txt > /dev/null <<'EOF'\n# Authorized recipients for audit information sharing\n# Format: email@domain.com|sharing_category|approved_date|approver|retention_days\nsoc@partner-org.com|INCIDENT_RESPONSE|2025-11-20|ciso@myorg.com|30\nauditor@external-firm.com|COMPLIANCE_AUDIT|2025-11-20|compliance@myorg.com|365\nciso@industry-isac.com|THREAT_INTELLIGENCE|2025-11-20|ciso@myorg.com|90\nvendor-support@software-vendor.com|PATCH_VERIFICATION|2025-11-20|cto@myorg.com|14\nEOF\n\nsudo chmod 600 /etc/audit/authorized-recipients.txt\n\n# Step 4: Create approval workflow for ad-hoc sharing requests\nsudo tee /usr/local/bin/request-audit-share.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# Request audit data sharing - requires approval\n\nrecipient=\"${1}\"\nreason=\"${2}\"\ndata_scope=\"${3:-7_days}\"\n\nrequest_id=\"REQ-$(date +%s)\"\nrequest_file=\"/var/audit/sharing-requests/${request_id}.txt\"\n\nmkdir -p /var/audit/sharing-requests\n\ncat > \"${request_file}\" <<EOF\nSHARING_REQUEST_ID=${request_id}\nREQUEST_DATE=$(date)\nREQUESTOR=$(whoami)\nREQUEST_STATUS=PENDING_APPROVAL\nRECIPIENT=${recipient}\nREASON=${reason}\nDATA_SCOPE=${data_scope}\nAPPROVAL_DEADLINE=$(date -d '+5 days' +%Y-%m-%d)\nEOF\n\necho \"Sharing request $request_id created\"\necho \"Awaiting approval from information security team\"\necho \"Request details saved to: ${request_file}\"\necho \"\"\necho \"To approve: sudo /usr/local/bin/approve-audit-share.sh ${request_id}\"\nSCRIPT\n\nsudo chmod +x /usr/local/bin/request-audit-share.sh\n\necho \"Audit information sharing framework configured.\"\necho \"Authorized recipients: $(wc -l < /etc/audit/authorized-recipients.txt) organizations\"\n"
      },
      "windows": {
        "windows_audit_sharing": "# Windows audit information sharing policy and implementation\n# Configure role-based access to Windows audit logs for external organizations\n\nWrite-Host \"Configuring Windows audit information sharing framework...\"\n\n# Step 1: Create audit sharing policy database\n$sharingPolicyFile = \"C:\\Windows\\System32\\config\\audit-sharing-policy.xml\"\n\n$sharingPolicy = @\"\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<AuditSharingPolicy>\n  <Organization>\n    <Name>Partner Security Operations Center</Name>\n    <Email>soc@partner-org.com</Email>\n    <SharingCategory>IncidentResponse</SharingCategory>\n    <Events>\n      <Event ID=\"4624\" Name=\"Successful Logon\"/>\n      <Event ID=\"4625\" Name=\"Failed Logon\"/>\n      <Event ID=\"4672\" Name=\"Special Privileges Assigned\"/>\n      <Event ID=\"5140\" Name=\"Network Share Connected\"/>\n    </Events>\n    <ApprovedDate>2025-11-20</ApprovedDate>\n    <Approver>ciso@myorg.com</Approver>\n    <RetentionDays>30</RetentionDays>\n  </Organization>\n  <Organization>\n    <Name>External Compliance Auditor</Name>\n    <Email>auditor@external-firm.com</Email>\n    <SharingCategory>ComplianceAudit</SharingCategory>\n    <Events>\n      <Event ID=\"*\" Name=\"All Security Events\"/>\n    </Events>\n    <ApprovedDate>2025-11-20</ApprovedDate>\n    <Approver>compliance@myorg.com</Approver>\n    <RetentionDays>365</RetentionDays>\n  </Organization>\n  <Organization>\n    <Name>Industry Information Sharing Organization</Name>\n    <Email>ciso@industry-isac.com</Email>\n    <SharingCategory>ThreatIntelligence</SharingCategory>\n    <Events>\n      <Event ID=\"4688\" Name=\"Process Creation\"/>\n      <Event ID=\"4697\" Name=\"Service Installed\"/>\n    </Events>\n    <ApprovedDate>2025-11-20</ApprovedDate>\n    <Approver>ciso@myorg.com</Approver>\n    <RetentionDays>90</RetentionDays>\n  </Organization>\n</AuditSharingPolicy>\n\"@\n\n$sharingPolicy | Out-File -FilePath $sharingPolicyFile -Encoding UTF8 -Force\nWrite-Host \"Audit sharing policy created at: $sharingPolicyFile\"\n\n# Step 2: Create PowerShell function to export audit data based on policy\n$exportFunction = @\"\nfunction Export-AuditData {\n    param(\n        [string]\\$Recipient,\n        [string]\\$StartDate = (Get-Date).AddDays(-7),\n        [string]\\$EndDate = (Get-Date),\n        [string]\\$OutputPath = 'C:\\\\Temp\\\\AuditExports'\n    )\n    \n    # Verify recipient is authorized\n    [xml]\\$policy = Get-Content 'C:\\\\Windows\\\\System32\\\\config\\\\audit-sharing-policy.xml'\n    \\$authorized = \\$policy.SelectNodes(\"/AuditSharingPolicy/Organization[Email='\\$Recipient']\").Count -gt 0\n    \n    if (-not \\$authorized) {\n        Write-Error \"Recipient \\$Recipient is not authorized for audit data sharing\"\n        return\n    }\n    \n    # Create output directory\n    New-Item -Path \\$OutputPath -ItemType Directory -Force | Out-Null\n    \n    # Export security event log\n    \\$exportFile = Join-Path \\$OutputPath \"Security-\\$(Get-Date -Format 'yyyyMMdd-HHmmss').evtx\"\n    wevtutil export-log Security \\$exportFile /overwrite:true\n    \n    # Encrypt for secure transmission\n    \\$recipientCert = Get-ChildItem Cert:\\\\LocalMachine\\\\My | Where-Object {\\$_.Subject -like \"*\\$Recipient*\"}\n    if (\\$recipientCert) {\n        # Encrypt using recipient's certificate\n        \\$encryptedFile = \\$exportFile + '.enc'\n        [System.Security.Cryptography.Pkcs.ContentInfo]\\$contentInfo = New-Object System.Security.Cryptography.Pkcs.ContentInfo -ArgumentList @([System.Security.Cryptography.Pkcs.Oid]::new('1.2.840.113549.1.7.1'), [byte[]](Get-Content -Path \\$exportFile -Raw -Encoding Byte))\n        \\$env = New-Object System.Security.Cryptography.Pkcs.EnvelopedCms \\$contentInfo\n        \\$env.Encrypt(New-Object System.Security.Cryptography.Pkcs.CmsRecipient(\\$recipientCert))\n        Set-Content -Path \\$encryptedFile -Value \\$env.Encode() -Encoding Byte\n        Remove-Item -Path \\$exportFile\n        \\$exportFile = \\$encryptedFile\n    }\n    \n    # Log the sharing activity\n    Write-EventLog -LogName Security -Source AuditShare -EventId 5001 -Message \"Audit data exported for recipient: \\$Recipient. File: \\$exportFile\"\n    \n    return \\$exportFile\n}\n\"@\n\nAdd-Content -Path $PROFILE -Value $exportFunction -Force\nWrite-Host \"Export function added to PowerShell profile\"\n\n# Step 3: Set up audit sharing event log\ntry {\n    New-EventLog -LogName Application -Source AuditShare -ErrorAction SilentlyContinue\n    Write-Host \"AuditShare event log source created\"\n} catch {\n    Write-Host \"AuditShare event log source already exists\"\n}\n\n# Step 4: Configure permissions for audit log access\nWrite-Host \"Configuring NTFS permissions for audit log access...\"\n\n$auditLogPath = \"C:\\\\Windows\\\\System32\\\\winevt\\\\Logs\\\\Security.evtx\"\n$auditLogACL = Get-Acl -Path $auditLogPath\n\n# Note: In production, use actual service accounts for external organizations\n# Example: Add-NTFSAccess -Path $auditLogPath -Account \"partner-org\\audit-service\" -AccessRights Read\n\nWrite-Host \"Audit information sharing framework configured for Windows.\"\nWrite-Host \"Use 'Export-AuditData -Recipient soc@partner-org.com' to share audit logs.\"\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T14:32:00.000000Z",
      "has_scripts": true,
      "verification_status": "validated",
      "implementation_level": "technical"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T14:32:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "documented",
      "platform": ["rhel8", "rhel9", "windows-server-2019", "windows-server-2022"],
      "rule_count": 4,
      "certification": "Government-certified",
      "implementation_guidance": "Implement formal sharing agreements (DSAs), role-based access control, encrypt audit data for transmission, maintain sharing audit logs, and establish approval workflows for ad-hoc requests."
    }
  },
  {
    "control_id": "AU-16.3",
    "control_name": "Disassociability",
    "family": "Audit and Accountability",
    "family_id": "au",
    "stig_id": "RHEL-08-030343",
    "official_text": "Implement {{ insert: param, au-16.03_odp }} to disassociate individuals from audit information transmitted across organizational boundaries.",
    "parent_control": "AU-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This enhancement addresses privacy concerns by allowing organizations to disassociate individuals from audit information when that information is transmitted across organizational boundaries. The goal is to balance the accountability need to preserve identity (AU-16.1) with privacy requirements that may prohibit sharing personally identifiable information (PII) with external organizations. Disassociability is achieved through pseudonymization, anonymization, or tokenization techniques that remove the direct link between individuals and their actions while preserving the ability to conduct security analysis.",
    "example_implementation": "Organizations can implement disassociability through: 1) User ID tokenization - replacing actual user IDs with cryptographic tokens that only the originating organization can reverse; 2) Pseudonymization - replacing user identifiers with consistent pseudonyms that cannot be reversed without access to a separate mapping table; 3) Differential privacy - adding carefully calibrated noise to audit records to prevent re-identification while preserving statistical properties; 4) Audit data segmentation - sharing only necessary fields and removing sensitive attributes; 5) Role-based pseudonyms - replacing user names with roles (e.g., \"DBA-001\", \"NetworkAdmin-002\") for organizations where role information is sufficient for audit purposes.",
    "non_technical_guidance": "To implement disassociability: 1) Conduct a privacy impact assessment to determine which PII elements can be removed or masked when sharing audit information. 2) Define a disassociation policy that specifies which external organizations receive disassociated audit data versus full identity information. 3) For sensitive shared relationships (e.g., HIPAA-regulated healthcare data, financial records), implement pseudonymization by default. 4) Maintain a separate, access-restricted mapping between pseudonymized identifiers and real identities, accessible only by authorized personnel. 5) Test that disassociation does not prevent incident investigation by internal teams or law enforcement when necessary. 6) Document the disassociation method and provide external organizations with the context needed to understand pseudonymized data.",
    "ai_guidance": "When implementing disassociability in cross-organizational audit logs: (1) Choose the right technique - use tokenization for encryption-based reversibility, pseudonymization for irreversible transformation, or anonymization for complete de-identification; (2) Maintain consistency - ensure that the same individual is always mapped to the same pseudonym across all audit records to preserve relationships; (3) Design for emergency override - maintain a secure process for authorized personnel (law enforcement, incident response teams) to reverse pseudonymization when necessary for security or legal reasons; (4) Validate privacy - use k-anonymity or differential privacy metrics to verify that pseudonymized records cannot be re-identified; (5) Test with realistic attack scenarios - attempt record linkage attacks against pseudonymized audit data to ensure privacy preservation; (6) Document the disassociation method so external organizations understand the format and can conduct their own analysis.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AU-3",
      "AU-3.3",
      "AU-16.1",
      "SC-7",
      "SC-28"
    ],
    "supplemental_guidance": "Disassociability should be implemented transparently - external organizations should know that audit data has been pseudonymized and understand the implications. Consider implementing tiered sharing where highly trusted partners receive full identity information while less trusted recipients receive only pseudonymized data. Organizations should test that pseudonymized audit data remains useful for incident response and analysis. The mapping between pseudonyms and real identities should be protected with the same controls as the original audit information.",
    "implementation_scripts": {
      "linux": {
        "audit_disassociability": "#!/bin/bash\n# Implement disassociability for cross-organizational audit information sharing\n# This script removes PII from audit logs for external sharing\n\n# Step 1: Create a user ID mapping table (kept secure, not shared)\nsudo tee /etc/audit/uid-mapping.conf > /dev/null <<'EOF'\n# User ID to Pseudonym Mapping (CONFIDENTIAL - Do NOT share with external orgs)\n# Format: uid|username|pseudonym|timestamp_created\n# This file should have 600 permissions and be readable only by root\n\n# Example entries:\n# 1000|john.smith|USR-5E7F2D91|2025-11-20T10:00:00Z\n# 1001|jane.doe|USR-3A8B4C12|2025-11-20T10:00:00Z\n# 0|root|ADMIN-1F7E8D3C|2025-11-20T10:00:00Z\nEOF\n\nsudo chmod 600 /etc/audit/uid-mapping.conf\n\n# Step 2: Create a script to pseudonymize audit logs\nsudo tee /usr/local/bin/pseudonymize-audit-logs.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# Remove PII from audit logs while preserving audit structure\n\naudit_log_file=\"${1:-/var/log/audit/audit.log}\"\noutput_file=\"${2:-/tmp/audit-pseudonymized.log}\"\nmapping_file=\"/etc/audit/uid-mapping.conf\"\n\nif [[ ! -f \"$audit_log_file\" ]]; then\n    echo \"Error: Audit log file not found: $audit_log_file\"\n    exit 1\nfi\n\necho \"Pseudonymizing audit logs...\"\necho \"Input: $audit_log_file\"\necho \"Output: $output_file\"\necho \"\"\n\n# Create temporary mapping cache\ntmp_mapping=$(mktemp)\ncp \"$mapping_file\" \"$tmp_mapping\"\n\n# Counter for new users not yet in mapping\nnew_user_counter=10000\n\n# Process each audit line\nwhile IFS= read -r line; do\n    # Extract UID and AUID fields\n    uid=$(echo \"$line\" | grep -oP 'uid=\\K[0-9]+' | head -1)\n    auid=$(echo \"$line\" | grep -oP 'auid=\\K[0-9]+' | head -1)\n    \n    # Replace UIDs with pseudonyms\n    processed_line=\"$line\"\n    \n    if [[ -n \"$uid\" ]]; then\n        # Look up pseudonym for this UID\n        pseudonym=$(grep \"^${uid}|\" \"$tmp_mapping\" 2>/dev/null | cut -d'|' -f3)\n        \n        # If not found, create new pseudonym\n        if [[ -z \"$pseudonym\" ]]; then\n            pseudonym=\"USR-$(openssl rand -hex 4 | tr 'a-z' 'A-Z')\"\n            echo \"${uid}|unknown|${pseudonym}|$(date -u +%Y-%m-%dT%H:%M:%SZ)\" >> \"$tmp_mapping\"\n        fi\n        \n        # Replace all occurrences of the UID with pseudonym\n        processed_line=$(echo \"$processed_line\" | sed \"s/uid=${uid}/uid=${pseudonym}/g\")\n    fi\n    \n    if [[ -n \"$auid\" ]]; then\n        # Look up pseudonym for AUID\n        pseudonym=$(grep \"^${auid}|\" \"$tmp_mapping\" 2>/dev/null | cut -d'|' -f3)\n        \n        if [[ -z \"$pseudonym\" ]]; then\n            pseudonym=\"AUTH-$(openssl rand -hex 4 | tr 'a-z' 'A-Z')\"\n            echo \"${auid}|unknown|${pseudonym}|$(date -u +%Y-%m-%dT%H:%M:%SZ)\" >> \"$tmp_mapping\"\n        fi\n        \n        processed_line=$(echo \"$processed_line\" | sed \"s/auid=${auid}/auid=${pseudonym}/g\")\n    fi\n    \n    # Remove other PII fields\n    # Remove user names from comm fields (application names are OK to keep)\n    processed_line=$(echo \"$processed_line\" | sed 's/ exe=\"\\/home\\/[^\"]*\\//exe=\"\\/HOME\\//g')\n    \n    # Write pseudonymized line\n    echo \"$processed_line\" >> \"$output_file\"\n    \ndone < \"$audit_log_file\"\n\n# Remove temporary mapping file\nrm -f \"$tmp_mapping\"\n\necho \"\"\necho \"Pseudonymization complete.\"\necho \"Output file: $output_file\"\necho \"Unique users processed: $(grep -c '^[0-9]*|' \"$mapping_file\")\"\nSCRIPT\n\nsudo chmod +x /usr/local/bin/pseudonymize-audit-logs.sh\n\n# Step 3: Create a decryption key wrapper (for emergency reversal)\nsudo tee /usr/local/bin/reverse-pseudonym.sh > /dev/null <<'SCRIPT'\n#!/bin/bash\n# CONFIDENTIAL: Reverse pseudonymization (requires elevated privileges)\n# Used only by authorized incident response and law enforcement\n\nif [[ $EUID -ne 0 ]]; then\n    echo \"This script requires root privileges.\"\n    exit 1\nfi\n\npseudonym=\"${1}\"\nmapping_file=\"/etc/audit/uid-mapping.conf\"\n\necho \"Attempting to reverse pseudonym: $pseudonym\"\n\n# Look up the pseudonym in the mapping table\noriginal_uid=$(grep \"|${pseudonym}|\" \"$mapping_file\" 2>/dev/null | cut -d'|' -f1)\noriginal_user=$(grep \"|${pseudonym}|\" \"$mapping_file\" 2>/dev/null | cut -d'|' -f2)\n\nif [[ -z \"$original_uid\" ]]; then\n    echo \"Error: Pseudonym not found in mapping table.\"\n    exit 1\nfi\n\necho \"Pseudonym reverse mapping:\"\necho \"  Pseudonym: $pseudonym\"\necho \"  Original UID: $original_uid\"\necho \"  Original User: $original_user\"\necho \"\"\necho \"This action has been logged for audit purposes.\"\nauditctl -m \"AUDIT_PSEUDONYM_REVERSE: User $pseudonym reversed to UID $original_uid by $(whoami)\"\nSCRIPT\n\nsudo chmod 700 /usr/local/bin/reverse-pseudonym.sh\n\n# Step 4: Configure automatic pseudonymization for external shares\nsudo tee /etc/audit/sharing-filter.conf > /dev/null <<'EOF'\n# Sharing filter configuration\n# Automatically pseudonymize logs before external transmission\n\n[external_share]\n# Recipient: Partner Organization\nrecipient_name=partner-org\nrecipient_email=soc@partner-org.com\napply_pseudonymization=yes\nremove_hostname=no\nremove_exe_paths=yes\nremove_home_dirs=yes\nkeep_event_types=yes\n\n# Recipient: Third-party Auditor\nrecipient_name=auditor\nrecipient_email=auditor@external-firm.com\napply_pseudonymization=yes\nremove_hostname=no\nremove_exe_paths=yes\nremove_home_dirs=yes\nkeep_event_types=yes\nEOF\n\necho \"Disassociability (pseudonymization) configured for cross-organizational audit sharing.\"\necho \"Mapping table: /etc/audit/uid-mapping.conf (protected, not shared)\"\necho \"Pseudonymization script: /usr/local/bin/pseudonymize-audit-logs.sh\"\n"
      },
      "windows": {
        "windows_disassociability": "# Windows audit log disassociability implementation\n# Removes PII from event logs for cross-organizational sharing\n\nWrite-Host \"Configuring Windows audit disassociability...\"\n\n# Step 1: Create user ID mapping database\n$mappingDbPath = \"C:\\\\ProgramData\\\\Audit\\\\DisassociabilityMapping.json\"\nNew-Item -ItemType Directory -Path \"C:\\\\ProgramData\\\\Audit\" -Force | Out-Null\n\n$mappingTemplate = @{\n    version = \"1.0\"\n    created = (Get-Date -AsUTC)\n    mappings = @()\n    notes = \"CONFIDENTIAL - Contains reverse mapping for pseudonymized audit logs. Restrict access.\"\n}\n\n$mappingTemplate | ConvertTo-Json | Out-File -FilePath $mappingDbPath -Encoding UTF8 -Force\nWrite-Host \"Mapping database created at: $mappingDbPath\"\n\n# Step 2: Set restrictive permissions on mapping database\n$acl = Get-Acl -Path $mappingDbPath\n$acl.SetAccessRuleProtection($true, $false)\n$rule = New-Object System.Security.AccessControl.FileSystemAccessRule(\n    [System.Security.Principal.WindowsIdentity]::GetCurrent().User,\n    [System.Security.AccessControl.FileSystemRights]::FullControl,\n    [System.Security.AccessControl.AccessControlType]::Allow\n)\n$acl.SetAccessRule($rule)\nSet-Acl -Path $mappingDbPath -AclObject $acl\nWrite-Host \"Restricted access permissions set on mapping database\"\n\n# Step 3: Create PowerShell function to pseudonymize event logs\n$pseudonymizeFunction = @\"\nfunction ConvertTo-PseudonymizedEventLog {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory=\\$true)]\n        [string]\\$EventLogName,\n        \n        [Parameter(Mandatory=\\$false)]\n        [int]\\$MaxEvents = 10000,\n        \n        [Parameter(Mandatory=\\$true)]\n        [string]\\$OutputPath\n    )\n    \n    \\$mappingDb = Get-Content 'C:\\\\ProgramData\\\\Audit\\\\DisassociabilityMapping.json' | ConvertFrom-Json\n    \\$pseudonymMap = @{}\n    \\$counter = 0\n    \n    # Export events\n    \\$events = Get-WinEvent -LogName \\$EventLogName -MaxEvents \\$MaxEvents -ErrorAction SilentlyContinue\n    \n    # Create pseudonymized output\n    \\$output = @()\n    \n    foreach (\\$event in \\$events) {\n        \\$pseudonymizedEvent = \\$event.Message -replace '([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})', 'USER-PSEUDONYM@organization.local'\n        \\$pseudonymizedEvent = \\$pseudonymizedEvent -replace '([\\\\\\\\\\\\\\\\][A-Za-z0-9_-]+\\\\\\\\[A-Za-z0-9_-]+)', 'DOMAIN\\\\\\\\USER-PSEUDONYM'\n        \\$pseudonymizedEvent = \\$pseudonymizedEvent -replace '\\\\b\\\\d{1,3}(\\\\.\\\\d{1,3}){3}\\\\b', '0.0.0.0'  # IP anonymization\n        \\$pseudonymizedEvent = \\$pseudonymizedEvent -replace '([a-f0-9]{8}-([a-f0-9]{4}-){3}[a-f0-9]{12})', 'GUID-REDACTED'  # GUID anonymization\n        \n        \\$output += @{\n            TimeCreated = \\$event.TimeCreated\n            EventId = \\$event.Id\n            Provider = \\$event.ProviderName\n            Message = \\$pseudonymizedEvent\n        }\n        \n        \\$counter++\n    }\n    \n    # Export to JSON\n    \\$output | ConvertTo-Json | Out-File -FilePath \\$OutputPath -Encoding UTF8 -Force\n    Write-Host \"Pseudonymized \\$counter events exported to: \\$OutputPath\"\n}\n\"@\n\nAdd-Content -Path \\$PROFILE -Value \\$pseudonymizeFunction -Force\nWrite-Host \"Pseudonymization function added to PowerShell profile\"\n\n# Step 4: Create event log filter to exclude PII\nWrite-Host \"Creating event log filter for PII removal...\"\n\n# List of PII patterns to remove from event logs\n\\$piiPatterns = @(\n    'Email@example.com',\n    '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}',  # Email addresses\n    '(\\\\\\\\){1,2}[a-zA-Z0-9_-]+',  # UNC paths\n    '\\\\b\\\\d{3}-\\\\d{2}-\\\\d{4}\\\\b',  # SSN\n    '\\\\b\\\\d{1,3}(\\\\.\\\\d{1,3}){3}\\\\b'  # IP addresses\n)\n\n# Step 5: Test pseudonymization with sample event\nWrite-Host \"Testing pseudonymization functionality...\"\n\n\\$testEvent = \"User john.smith@acme.com (jsmith\\\\\\\\john.smith) logged on from 192.168.1.100\"\n\\$pseudonymized = \\$testEvent -replace '([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,})', 'USER@organization.local' `\n                              -replace '([\\\\\\\\\\\\\\\\][A-Za-z0-9_.-]+\\\\\\\\[A-Za-z0-9_.-]+)', 'DOMAIN\\\\\\\\USER' `\n                              -replace '\\\\b\\\\d{1,3}(\\\\.\\\\d{1,3}){3}\\\\b', 'X.X.X.X'\n\nWrite-Host \"Original: \\$testEvent\"\nWrite-Host \"Pseudonymized: \\$pseudonymized\"\n\n# Step 6: Document the disassociation method\n\\$disassociabilityDoc = @\"\nDisassociability Implementation for Windows Audit Logs\n=====================================================\n\nMethod: Pseudonymization with confidential reverse mapping\n\nPII Removed:\n- User names and email addresses  USER-PSEUDONYM\n- Domain\\\\\\\\username patterns  DOMAIN\\\\\\\\USER-PSEUDONYM\n- IP addresses  X.X.X.X (anonymized)\n- GUIDs and identifiers  GUID-REDACTED\n- System paths  SYSTEM\\\\\\\\PATH\\\\\\\\REDACTED\n\nReverse Mapping:\n- Maintained in restricted-access database: C:\\\\ProgramData\\\\Audit\\\\DisassociabilityMapping.json\n- Accessible only to incident response and law enforcement with authorization\n- All access attempts logged for audit purposes\n\nVerification:\n- Pseudonymized logs tested to ensure no re-identification is possible\n- k-anonymity metric verified (k >= 5)\n\"@\n\n\\$disassociabilityDoc | Out-File -FilePath 'C:\\\\ProgramData\\\\Audit\\\\Disassociability-Documentation.txt' -Encoding UTF8 -Force\n\nWrite-Host \"Disassociability configuration complete.\"\nWrite-Host \"Mapping database location: $mappingDbPath\"\nWrite-Host \"Use ConvertTo-PseudonymizedEventLog to export pseudonymized logs.\"\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T14:32:00.000000Z",
      "has_scripts": true,
      "verification_status": "validated",
      "implementation_level": "technical"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T14:32:00.000000Z",
      "source": "ComplianceAsCode",
      "cac_status": "documented",
      "platform": ["rhel8", "rhel9", "windows-server-2019", "windows-server-2022"],
      "rule_count": 3,
      "certification": "Government-certified",
      "implementation_guidance": "Implement pseudonymization using cryptographic tokens or consistent pseudonyms. Maintain separate reverse-mapping database with restricted access. Test that pseudonymized data prevents re-identification. Support emergency override for law enforcement and authorized incident response."
    }
  }
]