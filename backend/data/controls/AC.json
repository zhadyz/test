[
  {
    "control_id": "AC-1",
    "control_name": "Policy and Procedures",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This control requires organizations to establish and maintain policies and procedures to manage their information security program.",
    "example_implementation": "This script develop a comprehensive set of policies and procedures that outline roles, responsibilities, and processes for managing information security within your organization. Regularly review and update these documents to ensure they remain current and effective.",
    "non_technical_guidance": "This plan to ensure compliance with Control ID ac-1 (Policy and Procedures), follow these steps:\n1. Develop and document policies and procedures that address the security requirements outlined in NIST 800-53.\n2. Ensure that the policies and procedures are reviewed and approved by appropriate stakeholders, including management and legal teams.\n3. Distribute the policies and procedures to all relevant personnel and ensure they are trained on their contents.\n4. Regularly review and update the policies and procedures to reflect changes in the organization's security posture or regulatory requirements.\n5. Implement a process for monitoring and enforcing compliance with the policies and procedures, including conducting periodic audits.\n6. Document any deviations from the policies and procedures and implement corrective actions as needed.\n7. Continuously improve the policies and procedures based on feedback and lessons learned from security incidents or audits.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "IA-1",
      "PM-9",
      "PM-24",
      "PS-8",
      "SI-12"
    ],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-09T21:34:53.460026+00:00",
      "has_scripts": true,
      "stig_id": "GEN000001"
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-10T09:36:39.818624+00:00",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires organizational policy documentation and procedures. No technical automation available."
    },
    "rationale": "Access control policy and procedures address the controls in the AC family that are implemented within systems and organizations. The risk management strategy is an important factor in establishing such policies and procedures. Policies and procedures contribute to security and privacy assurance. Therefore, it is important that security and privacy programs collaborate on the development of access control policy and procedures. Security and privacy program policies and procedures at the organization level are preferable, in general, and may obviate the need for mission- or system-specific policies and procedures. The policy can be included as part of the general security and privacy policy or be represented by multiple policies reflecting the complex nature of organizations.\n\nProcedures can be established for security and privacy programs, for mission or business processes, and for systems, if needed. Procedures describe how the policies or controls are implemented and can be directed at the individual or role that is the object of the procedure. Procedures can be documented in system security and privacy plans or in one or more separate documents. Events that may precipitate an update to access control policy and procedures include assessment or audit findings, security incidents or breaches, or changes in laws, executive orders, directives, regulations, policies, standards, and guidelines. Simply restating controls does not constitute an organizational policy or procedure.",
    "ai_guidance": "Create a policy document that says who can access what, and update it whenever rules change.",
    "stig_id": "GEN000001"
  },
  {
    "control_id": "AC-2",
    "control_name": "Account Management",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "a. Define and document the types of accounts allowed and specifically prohibited for use within the system;\nb. Assign account managers;\nc. Require organization-defined prerequisites and criteria for group and role membership;\nd. Specify:\n  1. Authorized users of the system;\n  2. Group and role membership; and\n  3. Access authorizations (i.e., privileges) and organization-defined attributes (as required) for each account;\ne. Require approvals by organization-defined personnel or roles for requests to create accounts;\nf. Create, enable, modify, disable, and remove accounts in accordance with organization-defined policy, procedures, prerequisites, and criteria;\ng. Monitor the use of accounts;\nh. Notify account managers and organization-defined personnel or roles within:\n  1. organization-defined time period when accounts are no longer required;\n  2. organization-defined time period when users are terminated or transferred; and\n  3. organization-defined time period when system usage or need-to-know changes for an individual;\ni. Authorize access to the system based on:\n  1. A valid access authorization;\n  2. Intended system usage; and\n  3. organization-defined attributes (as required);\nj. Review accounts for compliance with account management requirements organization-defined frequency;\nk. Establish and implement a process for changing shared or group account authenticators (if deployed) when individuals are removed from the group; and\nl. Align account management processes with personnel termination and transfer processes.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Account Management ensures that organizations carefully control who has access to their systems. This includes defining what types of accounts are allowed, assigning people to manage accounts, monitoring account usage, and promptly removing access when someone leaves or no longer needs it. The control covers the entire lifecycle of user accounts from creation through termination.",
    "example_implementation": "Implement an automated account management system that: (1) Requires manager approval before creating new accounts, (2) Automatically disables accounts after 90 days of inactivity, (3) Sends notifications to account managers when users are terminated, (4) Reviews all accounts quarterly, (5) Enforces separation between regular and privileged accounts, (6) Logs all account creation/modification/deletion events.",
    "non_technical_guidance": "To ensure compliance with account management control (AC-2), follow these steps:\n1. Create a formal policy documenting allowed and prohibited account types (individual, shared, emergency, temporary, service).\n2. Designate specific individuals as account managers with documented responsibilities.\n3. Establish an approval workflow for all new account requests with proper justification.\n4. Implement regular account reviews (at least quarterly) to verify all accounts are still needed and appropriate.\n5. Coordinate with HR to ensure accounts are disabled immediately upon termination or transfer.\n6. Prohibit or strictly limit shared accounts; require individual accountability.\n7. Implement automated monitoring to detect dormant accounts, unusual access patterns, or policy violations.\n8. Document all account management procedures and train staff accordingly.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "ac-2.1",
        "title": "Automated System Account Management",
        "official_text": "Support the management of system accounts using [Assignment: organization-defined automated mechanisms].",
        "rationale": "Automated account management reduces human error, ensures consistency, and provides scalability. Automated mechanisms can create, enable, modify, disable, and remove accounts; notify account managers of status changes; monitor account usage; and report atypical activity. Examples include Active Directory, LDAP, Okta, Azure AD, AWS IAM, and other identity management platforms."
      },
      {
        "id": "ac-2.2",
        "title": "Automated Temporary and Emergency Account Management",
        "official_text": "Automatically [Assignment: remove; disable] temporary and emergency accounts after [Assignment: organization-defined time period].",
        "rationale": "Temporary and emergency accounts present significant security risks if left active beyond their intended lifespan. Automated removal or disabling ensures these accounts cannot be exploited after the need has passed. U.S. Government systems typically require 72-hour automatic expiration."
      },
      {
        "id": "ac-2.3",
        "title": "Disable Accounts",
        "official_text": "Disable accounts within [Assignment: organization-defined time period] when the accounts: (a) Have expired; (b) Are no longer associated with a user or individual; (c) Are in violation of organizational policy; or (d) Have been inactive for [Assignment: organization-defined time period].",
        "rationale": "Dormant and unmanaged accounts expand the attack surface and provide opportunities for unauthorized access. Timely disabling of accounts based on multiple triggers (expiration, disassociation, policy violation, inactivity) implements the principle of least functionality. Typical inactivity periods range from 35-90 days."
      },
      {
        "id": "ac-2.4",
        "title": "Automated Audit Actions",
        "official_text": "Automatically audit account creation, modification, enabling, disabling, and removal actions.",
        "rationale": "Comprehensive auditing of all account lifecycle events provides accountability and enables forensic analysis. Automated logging eliminates manual oversight burden and creates tamper-resistant audit trails. Account audit records are defined in AU-2 and analyzed per AU-6 and AU-7 requirements."
      },
      {
        "id": "ac-2.5",
        "title": "Inactivity Logout",
        "official_text": "Require that users log out when [Assignment: organization-defined time period of expected inactivity or description of when to log out].",
        "rationale": "Automatic session termination after a period of inactivity prevents unauthorized access through unattended workstations or sessions. Typical inactivity periods range from 10-15 minutes depending on the sensitivity of the system. This control works with AC-11 (Device Lock) and AC-12 (Session Termination)."
      },
      {
        "id": "ac-2.6",
        "title": "Dynamic Privilege Management",
        "official_text": "Implement [Assignment: organization-defined dynamic privilege management capabilities].",
        "rationale": "Dynamic privilege management enables just-in-time (JIT) and just-enough-administration (JEA) approaches where privileges are granted only when needed and automatically revoked afterward. This reduces standing privilege exposure and adapts to changing mission requirements without requiring session restarts. Examples include attribute-based access control (ABAC) and privileged access management (PAM) solutions."
      },
      {
        "id": "ac-2.7",
        "title": "Privileged User Accounts",
        "official_text": "(a) Establish and administer privileged user accounts in accordance with [Assignment: organization-defined role-based access scheme; organization-defined attribute-based access scheme];\n(b) Monitor privileged role or attribute assignments;\n(c) Monitor changes to roles or attributes; and\n(d) Revoke access when privileged role or attribute assignments are no longer appropriate.",
        "rationale": "Privileged accounts (e.g., system administrators, database administrators, security administrators) have elevated access that enables security-relevant functions. These high-value accounts require enhanced oversight through role-based or attribute-based schemes, continuous monitoring of privilege assignments, and immediate revocation when roles change. Privileged roles should be organizationally defined and separated from regular user accounts."
      },
      {
        "id": "ac-2.8",
        "title": "Dynamic Account Management",
        "official_text": "Create, activate, manage, and deactivate [Assignment: organization-defined system accounts] dynamically.",
        "rationale": "Dynamic account management supports cloud environments and microservices architectures where accounts must be provisioned and deprovisioned rapidly in response to operational demands. This enhancement enables automated account lifecycle management tied to business processes, temporary projects, or ephemeral workloads, reducing the window of exposure for dormant accounts."
      },
      {
        "id": "ac-2.9",
        "title": "Restrictions on Use of Shared and Group Accounts",
        "official_text": "Only permit the use of shared and group accounts that meet [Assignment: organization-defined conditions].",
        "rationale": "Shared and group accounts eliminate individual accountability and make it difficult to attribute actions to specific users. Organizations should prohibit shared accounts except under documented conditions (e.g., break-glass emergency access, certain legacy applications). When necessary, shared accounts require enhanced logging, credential rotation, and approval processes to mitigate risks."
      },
      {
        "id": "ac-2.10",
        "title": "Shared and Group Account Credential Change",
        "official_text": "Terminate or change shared or group account credentials when members leave the group.",
        "rationale": "When individuals with knowledge of shared credentials leave a group, those credentials must be immediately changed to prevent unauthorized access by former group members. This enhancement is now incorporated into the base AC-2 control in NIST SP 800-53 Rev 5 (requirement k). Organizations must establish processes that trigger credential changes synchronized with group membership changes."
      },
      {
        "id": "ac-2.11",
        "title": "Usage Conditions",
        "official_text": "Enforce [Assignment: organization-defined circumstances and/or usage conditions] for [Assignment: organization-defined system accounts].",
        "rationale": "Usage conditions provide context-aware access control beyond traditional authentication. Organizations can restrict accounts based on time-of-day (e.g., business hours only), location (e.g., on-premises or specific countries), device type (e.g., managed workstations only), network (e.g., corporate network required), or other environmental factors. These conditions add defense-in-depth and help detect compromised credentials used from anomalous contexts."
      },
      {
        "id": "ac-2.12",
        "title": "Account Monitoring for Atypical Usage",
        "official_text": "(a) Monitor system accounts for [Assignment: organization-defined atypical usage]; and\n(b) Report atypical usage of system accounts to [Assignment: organization-defined personnel or roles].",
        "rationale": "Atypical usage patterns often indicate compromised accounts, insider threats, or unauthorized access. Organizations should baseline normal account behavior and implement anomaly detection for indicators such as: access at unusual times, access from unusual locations, privilege escalation attempts, unusual data access patterns, failed authentication attempts, or concurrent sessions from multiple locations. Automated user and entity behavior analytics (UEBA) solutions can enhance detection capabilities."
      },
      {
        "id": "ac-2.13",
        "title": "Disable Accounts for High-risk Individuals",
        "official_text": "Disable accounts of individuals within [Assignment: organization-defined time period] of discovery of [Assignment: organization-defined significant risks].",
        "rationale": "High-risk individuals (e.g., employees being terminated for cause, individuals under security investigation, compromised accounts) require immediate account suspension to prevent malicious activity during the window between risk discovery and full termination processing. Organizations should define significant risks and establish rapid response procedures. Typical timeframes range from immediate to within 1 hour of risk discovery. This enhancement complements personnel security controls (PS-4, PS-5)."
      }
    ],
    "related_controls": [
      "AC-3 (Access Enforcement)",
      "AC-5 (Separation of Duties)",
      "AC-6 (Least Privilege)",
      "AC-11 (Device Lock)",
      "AC-12 (Session Termination)",
      "AC-16 (Security and Privacy Attributes)",
      "AC-17 (Remote Access)",
      "AC-18 (Wireless Access)",
      "AC-20 (Use of External Systems)",
      "AC-24 (Access Control Decisions)",
      "AU-2 (Event Logging)",
      "AU-6 (Audit Record Review)",
      "AU-7 (Audit Record Generation)",
      "AU-12 (Audit Record Generation)",
      "CA-7 (Continuous Monitoring)",
      "CM-5 (Access Restrictions for Change)",
      "IA-2 (Identification and Authentication - Organizational Users)",
      "IA-4 (Identifier Management)",
      "IA-5 (Authenticator Management)",
      "IA-8 (Identification and Authentication - Non-organizational Users)",
      "IR-8 (Incident Response Plan)",
      "PE-2 (Physical Access Authorizations)",
      "PL-4 (Rules of Behavior)",
      "PS-2 (Position Risk Designation)",
      "PS-4 (Personnel Termination)",
      "PS-5 (Personnel Transfer)",
      "PS-7 (External Personnel Security)",
      "SC-7 (Boundary Protection)",
      "SI-4 (System Monitoring)"
    ],
    "supplemental_guidance": "Account types include individual, shared, group, system, guest, anonymous, emergency, developer/manufacturer/vendor, temporary, and service accounts. Organizations identify authorized system users and specify access privileges/restrictions for each account.\n\nAdministrative/privileged accounts require additional scrutiny and approval by system owners, mission/business owners, senior agency information security officers, or senior agency officials for privacy. Organizations may prohibit high-risk account types (shared, group, emergency, anonymous, temporary, guest) or implement additional controls when such accounts are necessary.\n\nTemporary accounts are established for short-term needs without immediacy requirements. Emergency accounts are created in response to crisis situations requiring rapid activation. Both account types should include automatic expiration.\n\nAccount management includes: establishing account management personnel, defining account types, establishing conditions for group/role membership, identifying authorized users, specifying privileges/attributes for each account, requiring appropriate approvals, creating/enabling/modifying/disabling/removing accounts per policy, monitoring usage, notifying managers of account status, authorizing access based on valid need, reviewing accounts periodically, managing shared authenticators, and aligning with personnel processes (PS-4, PS-5).\n\nAccount monitoring (AC-2(12)) and usage restrictions (AC-2(11)) provide enhanced security for sensitive accounts. Dynamic privilege management (AC-2(6)) and just-in-time access reduce standing privilege exposure.",
    "implementation_scripts": {
      "linux": {
        "ansible": "---\n# AC-2 Account Management - Linux Implementation\n# Source: ComplianceAsCode/content (Government-certified)\n# Comprehensive account management automation\n\n- name: \"AC-2 - Enable auditd Service for Account Auditing\"\n  block:\n  - name: Gather the package facts\n    ansible.builtin.package_facts:\n      manager: auto\n\n  - name: \"Enable auditd Service\"\n    ansible.builtin.systemd:\n      name: \"auditd\"\n      enabled: true\n      state: \"started\"\n      masked: false\n    when:\n    - '\"audit\" in ansible_facts.packages'\n  tags:\n  - ac-2\n  - ac-2.4\n  - audit\n\n- name: \"AC-2 - Configure Account Audit Rules\"\n  block:\n  - name: \"Audit Account Modifications (useradd)\"\n    ansible.builtin.lineinfile:\n      path: /etc/audit/rules.d/account_management.rules\n      line: \"-w /usr/sbin/useradd -p x -k account_modification\"\n      create: yes\n\n  - name: \"Audit Account Modifications (userdel)\"\n    ansible.builtin.lineinfile:\n      path: /etc/audit/rules.d/account_management.rules\n      line: \"-w /usr/sbin/userdel -p x -k account_modification\"\n\n  - name: \"Audit Account Modifications (usermod)\"\n    ansible.builtin.lineinfile:\n      path: /etc/audit/rules.d/account_management.rules\n      line: \"-w /usr/sbin/usermod -p x -k account_modification\"\n\n  - name: \"Audit Account Modifications (groupadd)\"\n    ansible.builtin.lineinfile:\n      path: /etc/audit/rules.d/account_management.rules\n      line: \"-w /usr/sbin/groupadd -p x -k group_modification\"\n\n  - name: \"Audit Account Modifications (groupdel)\"\n    ansible.builtin.lineinfile:\n      path: /etc/audit/rules.d/account_management.rules\n      line: \"-w /usr/sbin/groupdel -p x -k group_modification\"\n\n  - name: \"Audit Account Modifications (groupmod)\"\n    ansible.builtin.lineinfile:\n      path: /etc/audit/rules.d/account_management.rules\n      line: \"-w /usr/sbin/groupmod -p x -k group_modification\"\n\n  - name: \"Reload audit rules\"\n    ansible.builtin.command: augenrules --load\n    changed_when: true\n  tags:\n  - ac-2.4\n\n- name: \"AC-2 - Disable Guest Account\"\n  ansible.builtin.user:\n    name: guest\n    state: absent\n  ignore_errors: yes\n  tags:\n  - ac-2\n\n- name: \"AC-2.3 - Disable Inactive Accounts (35 days default)\"\n  ansible.builtin.lineinfile:\n    path: /etc/default/useradd\n    regexp: '^INACTIVE='\n    line: 'INACTIVE=35'\n    create: yes\n  tags:\n  - ac-2.3\n\n- name: \"AC-2 - Ensure UID uniqueness\"\n  block:\n  - name: \"Check for duplicate UIDs\"\n    ansible.builtin.shell: |\n      cut -d: -f3 /etc/passwd | sort | uniq -d\n    register: duplicate_uids\n    changed_when: false\n\n  - name: \"Fail if duplicate UIDs found\"\n    ansible.builtin.fail:\n      msg: \"Duplicate UIDs detected: {{ duplicate_uids.stdout_lines }}\"\n    when: duplicate_uids.stdout | length > 0\n  tags:\n  - ac-2\n",
        "bash": "#!/bin/bash\n# AC-2 Account Management - Linux Implementation\n# Source: ComplianceAsCode/content (Government-certified)\n\nset -e\n\necho \"[AC-2] Enabling auditd service for account auditing...\"\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'auditd.service'\nif [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then\n  \"$SYSTEMCTL_EXEC\" start 'auditd.service'\nfi\n\"$SYSTEMCTL_EXEC\" enable 'auditd.service'\n\necho \"[AC-2.4] Configuring account audit rules...\"\nmkdir -p /etc/audit/rules.d\ncat > /etc/audit/rules.d/account_management.rules << 'EOF'\n# AC-2.4 - Account Management Audit Rules\n-w /usr/sbin/useradd -p x -k account_modification\n-w /usr/sbin/userdel -p x -k account_modification\n-w /usr/sbin/usermod -p x -k account_modification\n-w /usr/sbin/groupadd -p x -k group_modification\n-w /usr/sbin/groupdel -p x -k group_modification\n-w /usr/sbin/groupmod -p x -k group_modification\n-w /etc/group -p wa -k group_modification\n-w /etc/passwd -p wa -k passwd_modification\n-w /etc/shadow -p wa -k shadow_modification\n-w /etc/gshadow -p wa -k gshadow_modification\nEOF\n\naugenrules --load 2>/dev/null || service auditd restart\n\necho \"[AC-2.3] Configuring account inactivity timeout (35 days)...\"\nsed -i 's/^INACTIVE=.*/INACTIVE=35/' /etc/default/useradd || echo 'INACTIVE=35' >> /etc/default/useradd\n\necho \"[AC-2] Checking for duplicate UIDs...\"\nDUPLICATE_UIDS=$(cut -d: -f3 /etc/passwd | sort | uniq -d)\nif [ -n \"$DUPLICATE_UIDS\" ]; then\n  echo \"WARNING: Duplicate UIDs found: $DUPLICATE_UIDS\"\n  echo \"Manual remediation required\"\nfi\n\necho \"[AC-2] Checking for duplicate usernames...\"\nDUPLICATE_USERS=$(cut -d: -f1 /etc/passwd | sort | uniq -d)\nif [ -n \"$DUPLICATE_USERS\" ]; then\n  echo \"WARNING: Duplicate usernames found: $DUPLICATE_USERS\"\n  echo \"Manual remediation required\"\nfi\n\necho \"[AC-2] Account management baseline applied successfully.\"\n"
      },
      "windows": {
        "powershell": "# AC-2 Account Management - Windows Implementation\n# Comprehensive account management for Windows systems\n# Covers AC-2 base + AC-2.3, AC-2.4\n\n# Enable auditing for account management (AC-2.4)\nWrite-Host \"[AC-2.4] Configuring account management audit policies...\"\nauditpol /set /subcategory:\"User Account Management\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Security Group Management\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Computer Account Management\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Distribution Group Management\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Other Account Management Events\" /success:enable /failure:enable\n\n# Disable Guest account (AC-2)\nWrite-Host \"[AC-2] Disabling Guest account...\"\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# Check for inactive accounts (AC-2.3)\nWrite-Host \"[AC-2.3] Checking for inactive accounts (90+ days)...\"\n$threshold = (Get-Date).AddDays(-90)\n$inactiveAccounts = Get-LocalUser | Where-Object { \n    $_.LastLogon -lt $threshold -and $_.Enabled -and $_.Name -ne 'Administrator' \n}\n\nif ($inactiveAccounts) {\n    Write-Host \"WARNING: Found $($inactiveAccounts.Count) inactive accounts:\"\n    $inactiveAccounts | Select-Object Name, LastLogon, Enabled | Format-Table\n    \n    # Optionally disable them (uncomment to enable)\n    # $inactiveAccounts | ForEach-Object { Disable-LocalUser -Name $_.Name }\n} else {\n    Write-Host \"No inactive accounts found.\"\n}\n\n# Check for accounts without password expiration (AC-2)\nWrite-Host \"[AC-2] Checking for accounts with non-expiring passwords...\"\n$nonExpiringAccounts = Get-LocalUser | Where-Object { \n    $_.PasswordNeverExpires -eq $true -and $_.Enabled -and $_.Name -ne 'Administrator' \n}\n\nif ($nonExpiringAccounts) {\n    Write-Host \"WARNING: Found $($nonExpiringAccounts.Count) accounts with non-expiring passwords:\"\n    $nonExpiringAccounts | Select-Object Name, PasswordNeverExpires | Format-Table\n}\n\n# List all enabled accounts for review\nWrite-Host \"[AC-2] Current enabled accounts:\"\nGet-LocalUser | Where-Object { $_.Enabled } | \n    Select-Object Name, Description, LastLogon, PasswordLastSet, PasswordNeverExpires | \n    Format-Table -AutoSize\n\n# Check for duplicate UIDs (SIDs)\nWrite-Host \"[AC-2] Verifying account uniqueness...\"\n$accounts = Get-LocalUser\n$sids = $accounts | Select-Object -ExpandProperty SID\n$duplicateSids = $sids | Group-Object | Where-Object { $_.Count -gt 1 }\n\nif ($duplicateSids) {\n    Write-Host \"ERROR: Duplicate SIDs detected!\"\n    $duplicateSids | Format-Table\n} else {\n    Write-Host \"All accounts have unique identifiers.\"\n}\n\nWrite-Host \"`n[AC-2] Account management baseline applied successfully.\"\nWrite-Host \"Review the warnings above and take appropriate action.\"\n",
        "ansible": "---\n# AC-2 Account Management - Windows Implementation\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: \"AC-2.4 - Enable User Account Management Auditing\"\n      win_audit_policy_system:\n        subcategory: User Account Management\n        audit_type: success, failure\n\n    - name: \"AC-2.4 - Enable Security Group Management Auditing\"\n      win_audit_policy_system:\n        subcategory: Security Group Management\n        audit_type: success, failure\n\n    - name: \"AC-2 - Disable Guest account\"\n      win_user:\n        name: Guest\n        account_disabled: yes\n\n    - name: \"AC-2.3 - Find inactive accounts\"\n      win_shell: |\n        $threshold = (Get-Date).AddDays(-90)\n        Get-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | \n          Select-Object Name, LastLogon | ConvertTo-Json\n      register: inactive_accounts\n\n    - name: \"AC-2 - Display account status\"\n      debug:\n        msg: \"Review inactive accounts: {{ inactive_accounts.stdout }}\"\n"
      }
    },
    "metadata": {
      "status": "production_ready",
      "last_updated": "2025-11-20T00:00:00.000000",
      "has_scripts": true,
      "script_count": 6,
      "migration_source": "NIST_SP_800-53_Rev5_Official + CAC",
      "migration_date": "2025-11-20",
      "cac_status": "government_certified",
      "cac_rules": [
        "service_auditd_enabled",
        "account_temp_expire_date",
        "account_emergency_expire_date",
        "account_disable_inactivity_system_auth",
        "audit_rules_usergroup_modification"
      ],
      "stig_id": "RHEL-08-020010",
      "cci": [
        "CCI-000015",
        "CCI-000016",
        "CCI-000017",
        "CCI-000018",
        "CCI-001403",
        "CCI-001404",
        "CCI-001405",
        "CCI-002130",
        "CCI-002145"
      ],
      "qa_verified": true,
      "qa_date": "2025-11-20",
      "qa_agent": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000",
      "source": "ComplianceAsCode",
      "last_updated": "2025-11-20T00:00:00.000000",
      "platform": "multi_platform_all",
      "rule_count": 28,
      "certification": "Government-certified"
    },
    "rationale": "Account management is foundational to access control. Examples of system account types include individual, shared, group, system, guest, anonymous, emergency, developer, temporary, and service accounts.\n\nOrganizations identify authorized system users and the types of accounts allowed and prohibited. Access privileges and account attributes reflect requirements from other security and privacy controls. Administrative accounts require heightened scrutiny during approval due to their elevated privileges.\n\nAccount types prohibited due to increased risk include: shared, group, emergency, anonymous, temporary, and guest accounts. Where access involves personally identifiable information (PII), security programs collaborate with privacy officials to establish appropriate controls.\n\nTemporary and emergency accounts are short-term by design. Temporary accounts support planned short-term needs without immediacy demands. Emergency accounts respond to crisis situations requiring rapid activation, potentially bypassing normal authorization processes. Both account types must include automatic expiration to prevent persistent unauthorized access.\n\nAccount management processes align with personnel security controls (PS-4 Personnel Termination, PS-5 Personnel Transfer) to ensure timely account status updates when employment relationships change.",
    "ai_guidance": "Account Management is about controlling who can access your systems. Think of it like managing keys to a building:\n\n1. Keep a master list of everyone with an account\n2. Different types of accounts for different purposes (employee, contractor, emergency, temporary)\n3. Require approval before creating new accounts\n4. Remove access immediately when someone leaves\n5. Regularly check that all accounts are still needed\n6. Avoid shared accounts - everyone should have their own login\n7. Monitor for suspicious account activity\n8. Automatically disable accounts that haven't been used in 90 days\n9. Log every time an account is created, modified, or deleted\n10. Force logout after 15 minutes of inactivity\n\nThe goal: ensure only authorized people have access, and only for as long as they need it.",
    "stig_id": "RHEL-08-020010"
  },
  {
    "control_id": "AC-2.1",
    "control_name": "Automated System Account Management",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Support the management of system accounts using [automated mechanisms (e.g., Active Directory, Okta)].",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Support the management of system accounts using [automated mechanisms (e.g., Active Directory, Okta)].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      },
      "linux": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141031+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-020011"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:49.315796+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Automated mechanisms help ensure consistency and reduce administrative burden. This enhancement supports the management of system accounts using organization-defined automated mechanisms.",
    "ai_guidance": "Use software (like Active Directory) to automatically create and delete user accounts so you don't make mistakes.",
    "stig_id": "RHEL-08-020011"
  },
  {
    "control_id": "AC-2.2",
    "control_name": "Automated Temporary and Emergency Account Management",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Automatically [automatically remove or disable] temporary and emergency accounts after [a defined time period (e.g., 72 hours)].",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Automatically [automatically remove or disable] temporary and emergency accounts after [a defined time period (e.g., 72 hours)].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      },
      "linux": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141104+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-020012"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:56.950741+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Ensures temporary access does not become permanent vulnerabilities. Automatically remove or disable temporary and emergency accounts after a defined time period.",
    "ai_guidance": "Make sure temporary accounts (for interns or contractors) automatically expire so they aren't forgotten.",
    "stig_id": "RHEL-08-020012"
  },
  {
    "control_id": "AC-2.3",
    "control_name": "Disable Accounts",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Disable accounts within [a defined time period (e.g., 90 days)] when the accounts:",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Disable accounts within [a defined time period (e.g., 90 days)] when the accounts:",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      },
      "linux": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141119+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-020013"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:58.496348+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Reduces the attack surface by removing dormant accounts. Disable accounts within a defined time period when they expire, are no longer associated with a user, or have been inactive.",
    "ai_guidance": "If an account hasn't been used in 90 days, disable it. It might have been abandoned and is a security risk.",
    "stig_id": "RHEL-08-020013"
  },
  {
    "control_id": "AC-2.4",
    "control_name": "Automated Audit Actions",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Automatically audit account creation, modification, enabling, disabling, and removal actions.",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Automatically audit account creation, modification, enabling, disabling, and removal actions.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-2(4) Automated Audit Actions\n# Description: Configure auditd to watch user/group modification files\n\nAUDIT_RULE_FILE=\"/etc/audit/rules.d/30-ac-2-4-account-actions.rules\"\n\necho \"Configuring audit rules for account actions...\"\n\n# Watch identity files for write/attribute changes\n{\n  echo \"-w /etc/group -p wa -k identity\"\n  echo \"-w /etc/passwd -p wa -k identity\"\n  echo \"-w /etc/gshadow -p wa -k identity\"\n  echo \"-w /etc/shadow -p wa -k identity\"\n  echo \"-w /etc/security/opasswd -p wa -k identity\"\n} > \"$AUDIT_RULE_FILE\"\n\nchmod 0600 \"$AUDIT_RULE_FILE\"\n\n# Reload audit rules\necho \"Reloading audit rules...\"\naugenrules --load\n\necho \"AC-2(4) Implementation Complete.\"\n",
        "ansible": "---\n# AC-2(4) Automated Audit Actions\n# Description: Automatically audit account creation, modification, enabling, disabling, and removal actions.\n# Strategy: Monitor changes to user/group databases and authentication logs.\n\n- name: Configure Account Modification Auditing\n  hosts: all\n  become: yes\n  tasks:\n    - name: Ensure audit rules for user/group modification exist\n      ansible.builtin.lineinfile:\n        path: /etc/audit/rules.d/30-ospp-v42-1-create-modify-user-group-information.rules\n        line: \"{{ item }}\"\n        create: yes\n        mode: '0600'\n      loop:\n        - \"-w /etc/group -p wa -k identity\"\n        - \"-w /etc/passwd -p wa -k identity\"\n        - \"-w /etc/gshadow -p wa -k identity\"\n        - \"-w /etc/shadow -p wa -k identity\"\n        - \"-w /etc/security/opasswd -p wa -k identity\"\n      notify: Reload Auditd\n\n    - name: Ensure audit rules for user/group modification are loaded\n      command: augenrules --load\n      changed_when: false\n\n  handlers:\n    - name: Reload Auditd\n      service:\n        name: auditd\n        state: restarted\n",
        "_note": "Cleaned up migration artifacts. Focused on identity file auditing."
      },
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      }
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-10T23:31:18.586798",
      "has_scripts": true,
      "migration_source": "CAC_AC2_enhancements_migration",
      "stig_id": "RHEL-08-030360"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:00.075524+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Provides accountability for account changes. Automatically audit account creation, modification, enabling, disabling, and removal actions.",
    "ai_guidance": "Configure the system to automatically log whenever an account is created, changed, or deleted.",
    "stig_id": "RHEL-08-030360"
  },
  {
    "control_id": "AC-2.5",
    "control_name": "Inactivity Logout",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Require that users log out when [a defined inactivity period (e.g., 15 minutes)].",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Require that users log out when [a defined inactivity period (e.g., 15 minutes)].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {
        "bash": "# platform = multi_platform_all\n# reboot = false\n# strategy = restrict\n# complexity = low\n# disruption = low\n\n# Combined remediation script for multiple rules\n# Generated by NIST Compliance Migration System\n\n# Rule 1\nsshd_idle_timeout_value='(bash-populate sshd_idle_timeout_value)'\n\n# For Oracle Linux, remove conflicting settings from included files\nincluded_files=$(grep -oP \"^\\s*(?i)include.*\" /etc/ssh/sshd_config 2>/dev/null | sed -e 's/\\s*include\\s*//I' | sed -e 's|^[^/]|/etc/ssh/sshd_config.d/&|' || true)\nfor included_file in $included_files ; do\n    if [ -f \"$included_file\" ]; then\n        # Comment out any existing ClientAliveInterval settings in included files\n        sed -i 's/^\\s*ClientAliveInterval.*$/# &/' \"$included_file\"\n    fi\ndone\n\n# Use monolithic configuration in /etc/ssh/sshd_config\n# Set ClientAliveInterval to $sshd_idle_timeout_value\nif grep -q \"^\\s*ClientAliveInterval\\s\" /etc/ssh/sshd_config; then\n    # Parameter exists, update it\n    sed -i \"s/^\\s*ClientAliveInterval\\s.*$/ClientAliveInterval $sshd_idle_timeout_value/\" /etc/ssh/sshd_config\nelse\n    # Parameter doesn't exist, add it at beginning of file\n    sed -i \"1iClientAliveInterval $sshd_idle_timeout_value\" /etc/ssh/sshd_config\nfi\n\n# Rule 2\nvar_sshd_set_keepalive='(bash-populate var_sshd_set_keepalive)'\n\n# For Oracle Linux, remove conflicting settings from included files\nincluded_files=$(grep -oP \"^\\s*(?i)include.*\" /etc/ssh/sshd_config 2>/dev/null | sed -e 's/\\s*include\\s*//I' | sed -e 's|^[^/]|/etc/ssh/sshd_config.d/&|' || true)\nfor included_file in $included_files ; do\n    if [ -f \"$included_file\" ]; then\n        # Comment out any existing ClientAliveCountMax settings in included files\n        sed -i 's/^\\s*ClientAliveCountMax.*$/# &/' \"$included_file\"\n    fi\ndone\n\n# Use monolithic configuration in /etc/ssh/sshd_config\n# Set ClientAliveCountMax to $var_sshd_set_keepalive\nif grep -q \"^\\s*ClientAliveCountMax\\s\" /etc/ssh/sshd_config; then\n    # Parameter exists, update it\n    sed -i \"s/^\\s*ClientAliveCountMax\\s.*$/ClientAliveCountMax $var_sshd_set_keepalive/\" /etc/ssh/sshd_config\nelse\n    # Parameter doesn't exist, add it at beginning of file\n    sed -i \"1iClientAliveCountMax $var_sshd_set_keepalive\" /etc/ssh/sshd_config\nfi\n\n# End of combined remediation\n",
        "ansible": "---\n# Source: ComplianceAsCode/content\n# Combined remediation playbook for multiple rules\n# Generated by NIST Compliance Migration System\n\n# Tasks from Rule 1\n- name: \"Set SSH Client Alive Interval - Find sshd_config included files\"\n  ansible.builtin.shell: |-\n    included_files=$(grep -oP \"^\\s*(?i)include.*\" /etc/ssh/sshd_config | sed -e 's/\\s*Include\\s*//i' | sed -e 's|^[^/]|/etc/ssh/&|')\n    [[ -n $included_files ]] && ls $included_files || true\n  register: sshd_config_included_files\n  changed_when: false\n\n- name: \"Set SSH Client Alive Interval - Comment out ClientAliveInterval from included files\"\n  ansible.builtin.replace:\n    path: '{{ item }}'\n    regexp: '^(\\s*ClientAliveInterval.*)$'\n    replace: '# \\1'\n  loop: \"{{ sshd_config_included_files.stdout_lines }}\"\n  when: sshd_config_included_files.stdout_lines | length > 0\n\n- name: \"Set SSH Client Alive Interval - Set ClientAliveInterval in /etc/ssh/sshd_config\"\n  ansible.builtin.lineinfile:\n    path: /etc/ssh/sshd_config\n    regexp: '(?i)^\\s*ClientAliveInterval\\s'\n    line: 'ClientAliveInterval {{ sshd_idle_timeout_value }}'\n    state: present\n    create: yes\n    insertbefore: BOF\n    validate: '/usr/sbin/sshd -t -f %s'\n  notify: restart sshd\n\n# Tasks from Rule 2\n- name: \"Set SSH Client Alive Count Max - Find sshd_config included files\"\n  ansible.builtin.shell: |-\n    included_files=$(grep -oP \"^\\s*(?i)include.*\" /etc/ssh/sshd_config | sed -e 's/\\s*Include\\s*//i' | sed -e 's|^[^/]|/etc/ssh/&|')\n    [[ -n $included_files ]] && ls $included_files || true\n  register: sshd_config_included_files\n  changed_when: false\n\n- name: \"Set SSH Client Alive Count Max - Comment out ClientAliveCountMax from included files\"\n  ansible.builtin.replace:\n    path: '{{ item }}'\n    regexp: '^(\\s*ClientAliveCountMax.*)$'\n    replace: '# \\1'\n  loop: \"{{ sshd_config_included_files.stdout_lines }}\"\n  when: sshd_config_included_files.stdout_lines | length > 0\n\n- name: \"Set SSH Client Alive Count Max - Set ClientAliveCountMax in /etc/ssh/sshd_config\"\n  ansible.builtin.lineinfile:\n    path: /etc/ssh/sshd_config\n    regexp: '(?i)^\\s*ClientAliveCountMax\\s'\n    line: 'ClientAliveCountMax {{ var_sshd_set_keepalive }}'\n    state: present\n    create: yes\n    insertbefore: BOF\n    validate: '/usr/sbin/sshd -t -f %s'\n  notify: restart sshd\n"
      },
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      }
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-10T23:31:18.586814",
      "has_scripts": true,
      "migration_source": "CAC_AC2_enhancements_migration",
      "stig_id": "RHEL-08-020014"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:01.658304+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Prevents unauthorized access to unattended sessions. Require that users log out when a defined time period of expected inactivity is reached.",
    "ai_guidance": "Force users to log out if they walk away from their computer for 15 minutes.",
    "stig_id": "RHEL-08-020014"
  },
  {
    "control_id": "AC-2.6",
    "control_name": "Dynamic Privilege Management",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Implement [dynamic privilege management (e.g., JIT access)].",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Implement [dynamic privilege management (e.g., JIT access)].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      },
      "linux": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141163+00:00",
      "has_scripts": true,
      "stig_id": "GEN000000-GEN00"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:03.200255+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Privilege management must be dynamic to adapt to changing roles and environments.",
    "ai_guidance": "Give users permissions only when they need them, and take them away when they're done.",
    "stig_id": "GEN000000-GEN00"
  },
  {
    "control_id": "AC-2.7",
    "control_name": "Privileged User Accounts",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      },
      "linux": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141178+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010370"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:04.738021+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Privileged accounts are high-value targets and require strict role-based or attribute-based controls.",
    "ai_guidance": "Watch 'superuser' (admin) accounts closely. They have the keys to the kingdom.",
    "stig_id": "RHEL-08-010370"
  },
  {
    "control_id": "AC-2.8",
    "control_name": "Dynamic Account Management",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Create, activate, manage, and deactivate [specific system accounts] dynamically.",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Create, activate, manage, and deactivate [specific system accounts] dynamically.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      },
      "linux": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141193+00:00",
      "has_scripts": true,
      "stig_id": "GEN000000-GEN00"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:06.244624+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Dynamic account management allows for just-in-time access, reducing the window of exposure.",
    "ai_guidance": "Turn on accounts only when needed, then turn them off. Don't leave them 'always on'.",
    "stig_id": "GEN000000-GEN00"
  },
  {
    "control_id": "AC-2.9",
    "control_name": "Restrictions on Use of Shared and Group Accounts",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Only permit the use of shared and group accounts that meet [specific operational conditions].",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Only permit the use of shared and group accounts that meet [specific operational conditions].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      },
      "linux": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141208+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-020015"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:07.781739+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Shared accounts eliminate individual accountability and should be strictly limited.",
    "ai_guidance": "Avoid sharing accounts (like 'admin' or 'root'). Everyone should have their own login.",
    "stig_id": "RHEL-08-020015"
  },
  {
    "control_id": "AC-2.10",
    "control_name": "Shared and Group Account Credential Change",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      },
      "linux": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141046+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-020016"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:50.852155+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Shared account credentials must be changed frequently to prevent former members from retaining access.",
    "ai_guidance": "If you MUST share an account, change the password frequently, especially when someone leaves the team.",
    "stig_id": "RHEL-08-020016"
  },
  {
    "control_id": "AC-2.11",
    "control_name": "Usage Conditions",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Enforce [usage conditions (e.g., time-of-day, location)] for [specific system accounts].",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Enforce [usage conditions (e.g., time-of-day, location)] for [specific system accounts].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      },
      "linux": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141060+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-020017"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:52.374996+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Usage conditions (e.g., time of day, location) add a layer of defense beyond simple authentication.",
    "ai_guidance": "Restrict logins to specific times (9-5) or locations (office only) if possible.",
    "stig_id": "RHEL-08-020017"
  },
  {
    "control_id": "AC-2.12",
    "control_name": "Account Monitoring for Atypical Usage",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      },
      "linux": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141075+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-020018"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:53.887442+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Atypical usage patterns often indicate compromise. Monitoring provides early detection.",
    "ai_guidance": "Set up alerts for weird behavior, like a user logging in at 3 AM from another country.",
    "stig_id": "RHEL-08-020018"
  },
  {
    "control_id": "AC-2.13",
    "control_name": "Disable Accounts for High-risk Individuals",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Disable accounts of individuals within [a defined time period (e.g., 1 hour)] of discovery of [significant risk (e.g., termination)].",
    "parent_control": "ac-2",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Disable accounts of individuals within [a defined time period (e.g., 1 hour)] of discovery of [significant risk (e.g., termination)].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "windows": {
        "powershell": "# Windows Account Management (AC-2)\n# Covers AC-2(3) Disable Inactive Accounts, AC-2(4) Audit Actions\n\n# 1. List all local users\nGet-LocalUser\n\n# 2. Disable Guest account if active\nDisable-LocalUser -Name 'Guest' -ErrorAction SilentlyContinue\n\n# 3. Check for inactive accounts (e.g., 90 days) - Maps to AC-2(3)\n$threshold = (Get-Date).AddDays(-90)\nGet-LocalUser | Where-Object { $_.LastLogon -lt $threshold -and $_.Enabled } | Select-Object Name, LastLogon\n\n# 4. Create a new user (example)\n# New-LocalUser -Name 'NewUser' -Description 'Description' -NoPassword\n",
        "ansible": "---\n- name: Windows Account Management\n  hosts: windows\n  tasks:\n    - name: Disable Guest account\n      win_user:\n        name: Guest\n        account_disabled: yes\n"
      },
      "linux": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141090+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-020019"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:55.389747+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "High-risk individuals (e.g., terminated hostile employees) must have access revoked immediately.",
    "ai_guidance": "If you fire an employee who might be angry, disable their access *while* they are being fired, not after.",
    "stig_id": "RHEL-08-020019"
  },
  {
    "control_id": "AC-3",
    "control_name": "Access Enforcement",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Enforce approved authorizations for logical access to information and system resources in accordance with applicable access control policies.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Make sure only authorized users have access to information and system resources.",
    "example_implementation": "This script regularly review and update access control policies to ensure that only approved users can access sensitive information and resources.",
    "non_technical_guidance": "This plan to enforce approved authorizations for logical access, follow these steps:\n1. Regularly review and update access control policies to ensure they align with the organization's security requirements.\n2. Implement role-based access control (RBAC) to assign permissions based on job roles and responsibilities.\n3. Use multi-factor authentication to enhance access security.\n4. Conduct regular access reviews to ensure that access rights are appropriate and up to date.\n5. Implement monitoring and auditing mechanisms to detect unauthorized access attempts.\n6. Provide security awareness training to employees on the importance of following access control policies.\n7. Document and communicate access control procedures to all personnel.\n8. Periodically test access controls to identify and address any vulnerabilities or gaps.\n```",
    "is_technical": true,
    "enhancements": [
      {
        "id": "ac-3.1",
        "title": "Restricted Access to Privileged Functions",
        "official_text": "",
        "rationale": "Access enforcement mechanisms must be able to restrict access based on attributes (e.g., time of day, location, project assignment) rather than just identity.",
        "metadata": {
          "stig_id": "RHEL-08-010301"
        },
        "ai_guidance": "Control access based on things like 'is the user on the VPN?' not just 'who is the user?'."
      },
      {
        "id": "ac-3.2",
        "title": "Dual Authorization",
        "official_text": "Enforce dual authorization for [dual authorization procedures].",
        "metadata": {
          "stig_id": "RHEL-08-010302"
        },
        "ai_guidance": "Enhance security by applying specific controls for Dual Authorization."
      },
      {
        "id": "ac-3.3",
        "title": "Mandatory Access Control",
        "official_text": "Enforce [mandatory access control policy] over the set of covered subjects and objects specified in the policy, and where the policy:",
        "metadata": {
          "stig_id": "RHEL-08-010303"
        },
        "ai_guidance": "Enhance security by applying specific controls for Mandatory Access Control."
      },
      {
        "id": "ac-3.4",
        "title": "Discretionary Access Control",
        "official_text": "Enforce [discretionary access control policy] over the set of covered subjects and objects specified in the policy, and where the policy specifies that a subject that has been granted access to information can do one or more of the following:",
        "metadata": {
          "stig_id": "RHEL-08-010304"
        },
        "ai_guidance": "Enhance security by applying specific controls for Discretionary Access Control."
      },
      {
        "id": "ac-3.5",
        "title": "Security-relevant Information",
        "official_text": "Prevent access to [security attributes (e.g., classification)] except during secure, non-operable system states.",
        "metadata": {
          "stig_id": "RHEL-08-010305"
        },
        "ai_guidance": "Enhance security by applying specific controls for Security-relevant Information."
      },
      {
        "id": "ac-3.6",
        "title": "Protection of User and System Information",
        "official_text": "",
        "rationale": "Encrypting data at rest and in transit adds a layer of defense, ensuring that even if access controls are bypassed, the data remains unintelligible.",
        "metadata": {
          "stig_id": "RHEL-08-010306"
        },
        "ai_guidance": "Encrypt your data. If someone steals the hard drive, they still can't read the files."
      },
      {
        "id": "ac-3.7",
        "title": "Role-based Access Control",
        "official_text": "Enforce a role-based access control policy over defined subjects and objects and control access based upon [role-based access control policy].",
        "metadata": {
          "stig_id": "RHEL-08-010307"
        },
        "ai_guidance": "Enhance security by applying specific controls for Role-based Access Control."
      },
      {
        "id": "ac-3.8",
        "title": "Revocation of Access Authorizations",
        "official_text": "Enforce the revocation of access authorizations resulting from changes to the security attributes of subjects and objects based on [revocation time period (e.g., immediate)].",
        "metadata": {
          "stig_id": "RHEL-08-010308"
        },
        "ai_guidance": "Enhance security by applying specific controls for Revocation of Access Authorizations."
      },
      {
        "id": "ac-3.9",
        "title": "Controlled Release",
        "official_text": "Release information outside of the system only if:",
        "rationale": "Controlled release ensures that information sharing with external systems only occurs when the receiving system has adequate security controls.",
        "metadata": {
          "stig_id": "RHEL-08-010309"
        },
        "ai_guidance": "Don't send sensitive data to a system that isn't secure. Check before you send."
      },
      {
        "id": "ac-3.10",
        "title": "Audited Override of Access Control Mechanisms",
        "official_text": "Employ an audited override of automated access control mechanisms under [audit logs] by [prohibited activities].",
        "metadata": {
          "stig_id": "RHEL-08-010310"
        },
        "ai_guidance": "Enhance security by applying specific controls for Audited Override of Access Control Mechanisms."
      },
      {
        "id": "ac-3.11",
        "title": "Restrict Access to Specific Information Types",
        "official_text": "Restrict access to data repositories containing [restricted interface (e.g., read-only)].",
        "metadata": {
          "stig_id": "RHEL-08-010311"
        },
        "ai_guidance": "Enhance security by applying specific controls for Restrict Access to Specific Information Types."
      },
      {
        "id": "ac-3.12",
        "title": "Assert and Enforce Application Access",
        "official_text": "",
        "rationale": "Applications must explicitly state their access requirements during installation to prevent 'scope creep' and unauthorized access escalation.",
        "metadata": {
          "stig_id": "RHEL-08-010312"
        },
        "ai_guidance": "When installing new software, make it say exactly what permissions it needs upfront."
      },
      {
        "id": "ac-3.13",
        "title": "Attribute-based Access Control",
        "official_text": "Enforce attribute-based access control policy over defined subjects and objects and control access based upon [sensitive data types].",
        "metadata": {
          "stig_id": "RHEL-08-010313"
        },
        "ai_guidance": "Enhance security by applying specific controls for Attribute-based Access Control."
      },
      {
        "id": "ac-3.14",
        "title": "Individual Access",
        "official_text": "Provide [specific individuals] to enable individuals to have access to the following elements of their personally identifiable information: [specific data types].",
        "metadata": {
          "stig_id": "RHEL-08-010314"
        },
        "ai_guidance": "Enhance security by applying specific controls for Individual Access."
      },
      {
        "id": "ac-3.15",
        "title": "Discretionary and Mandatory Access Control",
        "official_text": "",
        "rationale": "Implementing both Discretionary Access Control (DAC) and Mandatory Access Control (MAC) provides robust defense-in-depth for high-security environments.",
        "metadata": {
          "stig_id": "RHEL-08-010315"
        },
        "ai_guidance": "Use both 'user-decided' permissions (DAC) and 'system-mandated' permissions (MAC) for double protection."
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-3 Access Enforcement (Linux)\n# Description: Verify permissions on critical system files and ensure discretionary access control is enforced.\n\necho \"Verifying permissions on /etc/shadow...\"\nif [ \"$(stat -c %a /etc/shadow)\" -ne \"000\" ]; then\n    echo \"Fixing /etc/shadow permissions...\"\n    chmod 000 /etc/shadow\nfi\n\necho \"Verifying permissions on /etc/gshadow...\"\nif [ \"$(stat -c %a /etc/gshadow)\" -ne \"000\" ]; then\n    echo \"Fixing /etc/gshadow permissions...\"\n    chmod 000 /etc/gshadow\nfi\n\necho \"Verifying permissions on /etc/passwd...\"\nif [ \"$(stat -c %a /etc/passwd)\" -ne \"644\" ]; then\n    echo \"Fixing /etc/passwd permissions...\"\n    chmod 644 /etc/passwd\nfi\n\necho \"Access enforcement verification complete.\"\n",
        "ansible": "---\n- name: AC-3 Access Enforcement\n  hosts: all\n  tasks:\n    - name: Ensure permissions on /etc/shadow are configured\n      file:\n        path: /etc/shadow\n        mode: '0000'\n        owner: root\n        group: root\n\n    - name: Ensure permissions on /etc/gshadow are configured\n      file:\n        path: /etc/gshadow\n        mode: '0000'\n        owner: root\n        group: root\n\n    - name: Ensure permissions on /etc/passwd are configured\n      file:\n        path: /etc/passwd\n        mode: '0644'\n        owner: root\n        group: root\n"
      },
      "windows": {},
      "_note": "Added file permission checks."
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-10T22:36:36.343614",
      "has_scripts": true,
      "migration_source": "CAC_AC3_family_migration",
      "stig_id": "RHEL-08-010300"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-10T09:38:32.639071+00:00",
      "source": "ComplianceAsCode",
      "last_updated": "2025-11-10T09:38:32.710637+00:00",
      "platform": "rhcos4",
      "rule_count": 2,
      "certification": "Government-certified"
    },
    "ai_guidance": "Ensure the computer actually stops people from accessing files they shouldn't see.",
    "stig_id": "RHEL-08-010300"
  },
  {
    "control_id": "AC-3.1",
    "status": "FIX_REQUIRED",
    "changes": [
      "Added complete official_text from NIST SP 800-53 Rev 5",
      "Enhanced plain_english_explanation to clarify attribute-based restrictions",
      "Added example_implementation guidance for time/location/VPN-based access controls",
      "Noted CAC has no direct automation but provided implementation path"
    ],
    "fixed_content": {
      "official_text": "Restrict access to privileged functions or security-relevant information to explicitly authorized personnel, users, or processes.",
      "plain_english_explanation": "Restrict access to privileged functions based on attributes (such as time of day, location, network source) rather than just user identity. This means implementing rules like 'admin functions only accessible from corporate VPN' or 'financial system access only during business hours'.",
      "example_implementation": "Implement attribute-based access controls using PAM modules (pam_time, pam_access) to restrict privileged access based on time of day, terminal location, or network source. Configure sudo with time-based restrictions and require VPN connection for administrative access.",
      "non_technical_guidance": "To enforce attribute-based privileged access restrictions:\n1. Identify all privileged functions and define access attributes (time, location, role, clearance)\n2. Implement technical controls using PAM, sudo policies, or network segmentation\n3. Configure systems to enforce attribute checks before granting privileged access\n4. Document attribute requirements for each privileged function\n5. Regularly audit privileged access logs to verify attribute enforcement\n6. Update attribute policies when roles or security requirements change",
      "metadata": {
        "status": "documented",
        "implementation_guidance": "Manual implementation using PAM and sudo configuration"
      }
    }
  },
  {
    "control_id": "AC-3.2",
    "status": "FIX_REQUIRED",
    "changes": [
      "Enhanced official_text to specify dual authorization requirements",
      "Added plain_english_explanation with banking analogy",
      "Provided concrete implementation examples for sudo and GPG dual signing"
    ],
    "fixed_content": {
      "official_text": "Enforce dual authorization for organization-defined privileged commands and/or organization-defined actions.",
      "plain_english_explanation": "Require two authorized people to approve critical actions (like two keys to launch nuclear missiles). For example, deploying to production or deleting critical data requires approval from two different administrators.",
      "example_implementation": "Configure sudo to require dual authorization for critical commands using sudoredit with approval workflow. Implement GPG dual-signing for sensitive configuration changes. Use approval gates in CI/CD pipelines requiring two reviewers for production deployments.",
      "non_technical_guidance": "To implement dual authorization:\n1. Identify privileged commands requiring dual authorization (system shutdown, data deletion, financial transactions)\n2. Implement technical approval workflows (sudo with approval plugins, GPG multi-signature)\n3. Document dual authorization procedures and train personnel\n4. Configure audit logging to capture both authorizers' identities\n5. Establish exception processes for emergencies with compensating controls\n6. Regularly review dual authorization logs and refine policies"
    }
  },
  {
    "control_id": "AC-3.3",
    "control_name": "Mandatory Access Control",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Enforce [mandatory access control policy] over the set of covered subjects and objects specified in the policy, and where the policy:",
    "parent_control": "ac-3",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Enforce [mandatory access control policy] over the set of covered subjects and objects specified in the policy, and where the policy:",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# Source: ComplianceAsCode/content\n# Generated from CAC template\n\n# platform = multi_platform_all\n# reboot = false\n# strategy = configure\n# complexity = low\n# disruption = low\n\nvar_selinux_policy_name='(bash-populate var_selinux_policy_name)'\nif [ -e \"/etc/selinux/config\" ] ; then\n    LC_ALL=C sed -i \"/^SELINUXTYPE=/Id\" \"/etc/selinux/config\"\nelse\n    touch \"/etc/selinux/config\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/selinux/config\"\n\ncp \"/etc/selinux/config\" \"/etc/selinux/config.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"SELINUXTYPE=$var_selinux_policy_name\" >> \"/etc/selinux/config\"\n# Clean up after ourselves.\nrm \"/etc/selinux/config.bak\"\n",
        "ansible": "---\n# Source: ComplianceAsCode/content\n# Generated from CAC template\n\n# platform = multi_platform_all\n# reboot = false\n# strategy = configure\n# complexity = low\n# disruption = low\n\n- (xccdf-var var_selinux_policy_name)\n- name: \"Configure SELinux Policy\"\n  block:\n    - name: \"Check for duplicate values\"\n      ansible.builtin.lineinfile:\n        path: '/etc/selinux/config'\n        create: True\n        regexp: '^SELINUXTYPE='\n        state: 'absent'\n      check_mode: yes\n      changed_when: no\n      register: 'dupes'\n    - name: \"Deduplicate values from /etc/selinux/config\"\n      ansible.builtin.lineinfile:\n        path: '/etc/selinux/config'\n        create: True\n        regexp: '^SELINUXTYPE='\n        state: 'absent'\n      when: 'dupes.found is defined and dupes.found > 1'\n    - name: \"Insert correct line to /etc/selinux/config\"\n      ansible.builtin.lineinfile:\n        path: '/etc/selinux/config'\n        create: True\n        regexp: '^SELINUXTYPE='\n        line: 'SELINUXTYPE={{ var_selinux_policy_name }}'\n        state: present\n"
      },
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-10T22:36:36.343629",
      "has_scripts": true,
      "migration_source": "CAC_AC3_family_migration",
      "stig_id": "RHEL-08-010303"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:46.978305+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Mandatory Access Control according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010303"
  },
  {
    "control_id": "AC-3.4",
    "status": "FIX_REQUIRED",
    "changes": [
      "Added complete official_text for DAC requirements",
      "Enhanced plain_english_explanation with Unix permission examples",
      "Documented available CAC automation for file permissions",
      "Added implementation scripts from CAC file_permissions templates"
    ],
    "fixed_content": {
      "official_text": "Enforce organization-defined discretionary access control policy over the set of covered subjects and objects specified in the policy, and where the policy specifies that a subject that has been granted access to information can do one or more of the following:\n(a) Pass the information to other subjects or objects;\n(b) Grant its privileges to other subjects;\n(c) Change security attributes on subjects, objects, the system, or the system components;\n(d) Choose the security attributes to be associated with newly created or revised objects; or\n(e) Change the rules governing access control.",
      "plain_english_explanation": "Implement Discretionary Access Control (DAC) where file owners can decide who can access their files (like Unix permissions: rwxr-xr--). This is the traditional 'owner sets permissions' model using chmod, chown, and ACLs.",
      "example_implementation": "Configure proper default umask (0027 or 0077) to restrict new file permissions. Use Access Control Lists (ACLs) for fine-grained permissions beyond standard Unix rwx. Implement file permission monitoring to detect unauthorized changes. Set proper permissions on critical system files (/etc/shadow: 000, /etc/passwd: 644).",
      "non_technical_guidance": "To enforce Discretionary Access Control:\n1. Set restrictive default umask (0027) in /etc/profile and shell configs\n2. Audit critical system file permissions regularly\n3. Use setfacl for fine-grained ACLs where needed\n4. Train users on proper permission management\n5. Implement automated permission remediation for critical files\n6. Monitor for unauthorized permission changes via auditd\n7. Document permission standards for different file types\n8. Regularly review and correct overly permissive files",
      "implementation_scripts": {
        "linux": {
          "bash": "#!/bin/bash\n# AC-3.4 Discretionary Access Control\n# Enforce proper file permissions on critical system files\n\necho 'Setting critical file permissions...'\n\n# Password files\nchmod 000 /etc/shadow /etc/gshadow\nchmod 644 /etc/passwd /etc/group\nchown root:root /etc/shadow /etc/gshadow /etc/passwd /etc/group\n\n# Shell configuration\nchmod 644 /etc/shells /etc/profile\nchown root:root /etc/shells /etc/profile\n\n# Set secure umask\nif ! grep -q 'umask 0027' /etc/profile; then\n  echo 'umask 0027' >> /etc/profile\nfi\n\necho 'DAC permissions configured.'",
          "ansible": "---\n- name: AC-3.4 Discretionary Access Control\n  hosts: all\n  tasks:\n    - name: Set permissions on password files\n      file:\n        path: '{{ item.path }}'\n        mode: '{{ item.mode }}'\n        owner: root\n        group: root\n      loop:\n        - { path: '/etc/shadow', mode: '0000' }\n        - { path: '/etc/gshadow', mode: '0000' }\n        - { path: '/etc/passwd', mode: '0644' }\n        - { path: '/etc/group', mode: '0644' }\n        - { path: '/etc/shells', mode: '0644' }\n\n    - name: Configure secure umask\n      lineinfile:\n        path: /etc/profile\n        line: 'umask 0027'\n        state: present"
        }
      },
      "metadata": {
        "status": "implemented",
        "has_scripts": true
      },
      "cac_metadata": {
        "implementation_type": "automated",
        "cac_status": "available",
        "implementation_guidance": "CAC provides file_permissions template for automated DAC enforcement. Found 15+ file permission rules with AC-3 references."
      }
    }
  },
  {
    "control_id": "AC-3.5",
    "status": "FIX_REQUIRED",
    "changes": [
      "Enhanced official_text with complete security attributes protection requirements",
      "Added plain_english_explanation clarifying secure system states",
      "Provided implementation guidance for immutable flags and single-user mode"
    ],
    "fixed_content": {
      "official_text": "Prevent access to organization-defined security attributes associated with information except during secure, non-operable system states.",
      "plain_english_explanation": "Protect security labels and classifications from modification except when the system is in a secure maintenance mode (like single-user mode). Prevent users from changing SELinux labels or file classifications during normal operation.",
      "example_implementation": "Use immutable flags (chattr +i) on security attribute files. Restrict SELinux context changes to authorized administrators. Require single-user mode for modifying security label databases. Implement file integrity monitoring to detect unauthorized attribute changes.",
      "non_technical_guidance": "To protect security-relevant attributes:\n1. Identify files containing security attributes (SELinux contexts, classification labels)\n2. Set immutable flags to prevent modification during normal operation\n3. Require system downtime (single-user mode) for authorized attribute changes\n4. Implement integrity monitoring for attribute files\n5. Audit all attempts to modify security attributes\n6. Document procedures for authorized attribute modification\n7. Train administrators on secure attribute management"
    }
  },
  {
    "control_id": "AC-3.6",
    "status": "PASS",
    "changes": [
      "Enhanced plain_english_explanation (already had good rationale)",
      "Added implementation guidance for encryption at rest and in transit",
      "Control already has appropriate content, minimal fixes needed"
    ],
    "fixed_content": {
      "official_text": "Protect user and system information from unauthorized modification, disclosure, or deletion.",
      "plain_english_explanation": "Encrypt data at rest (disk encryption with LUKS) and in transit (TLS/SSH). This adds defense-in-depth so even if access controls fail, stolen data remains unreadable.",
      "example_implementation": "Enable LUKS full-disk encryption at installation. Configure mandatory TLS for web services. Use SSH key-based authentication with encrypted home directories. Implement SELinux or AppArmor for process isolation.",
      "non_technical_guidance": "To protect user and system information:\n1. Enable full-disk encryption using LUKS during OS installation\n2. Configure encrypted home directories for user data\n3. Mandate TLS 1.2+ for all network services\n4. Use SSH with key-based authentication, disable passwords\n5. Implement file integrity monitoring for critical system files\n6. Configure automated encrypted backups\n7. Deploy process isolation using MAC (SELinux/AppArmor)\n8. Regularly test encryption key recovery procedures"
    }
  },
  {
    "control_id": "AC-3.7",
    "status": "FIX_REQUIRED",
    "changes": [
      "Added complete official_text for RBAC requirements",
      "Enhanced plain_english_explanation with concrete role examples",
      "Documented SELinux user-to-role mapping as RBAC implementation",
      "Added implementation scripts using semanage"
    ],
    "fixed_content": {
      "official_text": "Enforce a role-based access control policy over defined subjects and objects and control access based upon organization-defined roles and users authorized to assume such roles.",
      "plain_english_explanation": "Implement Role-Based Access Control (RBAC) where permissions are assigned to roles (like 'Database Administrator', 'Developer', 'Auditor') rather than individual users. Users are then assigned to roles, inheriting the role's permissions.",
      "example_implementation": "Use SELinux user-to-role mappings with semanage to assign users to roles (user_r, staff_r, sysadm_r). Configure sudo policies based on Unix groups representing roles. Implement LDAP/Active Directory with role-based group membership for centralized RBAC.",
      "non_technical_guidance": "To implement Role-Based Access Control:\n1. Define organizational roles (admin, developer, auditor, user)\n2. Map each role to specific permissions and access levels\n3. Assign users to roles based on job functions\n4. Implement technical RBAC using SELinux roles, sudo groups, or IdM\n5. Configure automated role assignment based on HR data\n6. Regularly review role assignments and permissions\n7. Implement separation of duties by restricting role combinations\n8. Audit role-based access patterns to detect anomalies",
      "implementation_scripts": {
        "linux": {
          "bash": "#!/bin/bash\n# AC-3.7 Role-Based Access Control using SELinux\n# Configure SELinux user-to-role mappings\n\necho 'Configuring SELinux RBAC...'\n\n# Map staff users to staff_r and sysadm_r roles\nsemanage user -m staff_u -R staff_r -R sysadm_r\n\n# Map regular users to user_r role only\nsemanage user -m user_u -R user_r\n\n# Map guest users to guest_r role (most restrictive)\nsemanage user -m guest_u -R guest_r\n\n# Verify configuration\necho 'SELinux user-to-role mappings:'\nsemanage user -l\n\necho 'RBAC configuration complete.'",
          "ansible": "---\n- name: AC-3.7 Role-Based Access Control\n  hosts: all\n  tasks:\n    - name: Configure SELinux user-to-role mappings\n      selinux_permissive:\n        name: '{{ item.user }}'\n        state: '{{ item.state }}'\n      loop:\n        - { user: 'staff_u', state: 'enforcing' }\n        - { user: 'user_u', state: 'enforcing' }\n        - { user: 'guest_u', state: 'enforcing' }\n\n    - name: Verify RBAC configuration\n      command: semanage user -l\n      register: selinux_users\n\n    - name: Display user-to-role mappings\n      debug:\n        var: selinux_users.stdout_lines"
        }
      },
      "metadata": {
        "status": "documented",
        "has_scripts": true
      },
      "cac_metadata": {
        "implementation_type": "hybrid",
        "cac_status": "available",
        "implementation_guidance": "SELinux provides RBAC via user-to-role mappings. CAC has selinux_confine_to_least_privilege rule with AC-3(4) and AC-6(10) references."
      }
    }
  },
  {
    "control_id": "AC-3.8",
    "status": "FIX_REQUIRED",
    "changes": [
      "Enhanced official_text with complete revocation timing requirements",
      "Added plain_english_explanation with immediate revocation example",
      "Provided implementation guidance for automated session termination"
    ],
    "fixed_content": {
      "official_text": "Enforce the revocation of access authorizations resulting from changes to the security attributes of subjects and objects based on organization-defined rules governing the timing of revocations of access authorizations.",
      "plain_english_explanation": "Immediately revoke access when security attributes change. For example, if an employee moves from 'Finance' to 'Marketing' role, their access to financial systems must be revoked immediately (or within defined timeframe like 1 hour), not wait until next account review.",
      "example_implementation": "Implement automated access revocation using PAM session limits and sudo timestamp invalidation. Configure LDAP/IdM to push immediate role changes. Use kill-user-processes scripts to terminate active sessions when roles change. Deploy real-time access control list updates.",
      "non_technical_guidance": "To enforce timely access revocation:\n1. Define revocation timeframes for different security attribute changes (role change: immediate, clearance downgrade: 15 minutes)\n2. Implement automated revocation workflows triggered by HR system changes\n3. Configure session timeout policies aligned with revocation requirements\n4. Deploy tools to terminate active sessions when authorization changes\n5. Audit revocation timing to ensure compliance with policies\n6. Document exceptions requiring manual intervention\n7. Test revocation automation regularly with simulated role changes"
    }
  },
  {
    "control_id": "AC-3.9",
    "status": "PASS",
    "changes": [
      "Enhanced official_text with complete controlled release requirements",
      "Plain_english_explanation and rationale already adequate",
      "Added implementation guidance for secure data transmission validation"
    ],
    "fixed_content": {
      "official_text": "Release information outside of the system only if:\n(a) The receiving system provides controls that are at least equivalent to those of the originating system; and\n(b) The security and privacy attributes of the information being released remain applicable after the information is released.",
      "plain_english_explanation": "Before sending sensitive data to another system, verify that system has adequate security controls. Don't send classified data to an unclassified system. Ensure data labels and protections travel with the data.",
      "example_implementation": "Implement pre-transmission security validation checks. Use secure file transfer protocols (SFTP, SCP) with certificate validation. Embed security labels in transmitted data (XML security tokens, HTTP headers). Maintain cross-domain solution (CDS) gateways for classified-to-unclassified transfers.",
      "non_technical_guidance": "To implement controlled release:\n1. Classify information assets by sensitivity level\n2. Document security requirements for each sensitivity level\n3. Maintain registry of external systems with their security capabilities\n4. Implement automated validation before external data transmission\n5. Embed security labels that persist with transmitted data\n6. Log all external data releases with justification\n7. Regularly audit external system security postures\n8. Establish data sharing agreements with security requirements"
    }
  },
  {
    "control_id": "AC-3.10",
    "status": "FIX_REQUIRED",
    "changes": [
      "Added complete official_text for audited override requirements",
      "Enhanced plain_english_explanation with emergency access example",
      "Provided implementation guidance for break-glass procedures"
    ],
    "fixed_content": {
      "official_text": "Employ an audited override of automated access control mechanisms under organization-defined conditions by organization-defined roles.",
      "plain_english_explanation": "Provide 'break glass' emergency access that logs everything. For example, if the DBA is on vacation and a critical database issue occurs, an on-call engineer can override access controls but every action is heavily audited and reviewed.",
      "example_implementation": "Implement sudo break-glass accounts with comprehensive session recording using script or screen. Configure auditd to log all commands executed by emergency accounts. Deploy automated alerting when break-glass access is used. Require post-incident review of all override actions.",
      "non_technical_guidance": "To implement audited override:\n1. Identify scenarios requiring emergency access override\n2. Create break-glass accounts with elevated but audited privileges\n3. Configure comprehensive logging of all override actions\n4. Implement real-time alerting when override is invoked\n5. Require mandatory post-incident review of override usage\n6. Document override procedures and authorized personnel\n7. Test override mechanisms regularly\n8. Investigate any unexpected override invocations"
    }
  },
  {
    "control_id": "AC-3.11",
    "status": "FIX_REQUIRED",
    "changes": [
      "Enhanced official_text with complete information type restriction requirements",
      "Added plain_english_explanation with database read-only example",
      "Provided implementation guidance for read-only access enforcement"
    ],
    "fixed_content": {
      "official_text": "Restrict access to data repositories containing organization-defined information types to only organization-defined users or processes using organization-defined access control mechanisms.",
      "plain_english_explanation": "Restrict access to repositories containing sensitive data types (like PII databases) to specific users/processes with defined access modes (e.g., read-only for analysts, read-write for DBAs). Most users get no access at all.",
      "example_implementation": "Use database role-based permissions to grant read-only access to sensitive tables. Mount filesystems containing PII as read-only for non-privileged processes. Implement SELinux type enforcement to restrict process access to sensitive directories. Deploy data classification tools to auto-restrict based on content.",
      "non_technical_guidance": "To restrict access to specific information types:\n1. Classify data repositories by information type (PII, financial, classified)\n2. Define access requirements for each information type\n3. Implement technical restrictions (database roles, file permissions, SELinux types)\n4. Grant minimum necessary access (read-only where possible)\n5. Regularly audit access to sensitive repositories\n6. Implement data discovery tools to identify uncontrolled sensitive data\n7. Document information type access matrix\n8. Review and update access lists quarterly"
    }
  },
  {
    "control_id": "AC-3.12",
    "status": "PASS",
    "changes": [
      "Enhanced official_text with application access assertion requirements",
      "Plain_english_explanation and rationale already strong",
      "Added implementation guidance for application permission manifests"
    ],
    "fixed_content": {
      "official_text": "Require applications to assert, as part of the installation process, the access needed to the following system applications and functions: organization-defined system applications and functions.",
      "plain_english_explanation": "Applications must declare upfront what permissions they need during installation (like Android app permissions). This prevents 'permission creep' where apps gradually gain more access over time without review.",
      "example_implementation": "Use AppArmor or SELinux profiles that applications must declare during installation. Implement package metadata requiring permission declarations (RPM capabilities, Debian dependencies). Deploy application control solutions that enforce declared permission boundaries.",
      "non_technical_guidance": "To enforce application access assertion:\n1. Require all applications to declare needed permissions before installation\n2. Review permission requests against application function\n3. Deny installation if permissions are excessive or unexplained\n4. Implement mandatory access control (MAC) to enforce declared permissions\n5. Audit applications for unauthorized permission escalation\n6. Document approved permission sets for application types\n7. Regularly review installed application permissions\n8. Investigate applications attempting undeclared access"
    }
  },
  {
    "control_id": "AC-3.13",
    "status": "FIX_REQUIRED",
    "changes": [
      "Enhanced official_text with complete ABAC requirements",
      "Added comprehensive plain_english_explanation with concrete examples",
      "Referenced NIST SP 800-162 for detailed ABAC guidance",
      "Provided implementation architecture with PEP/PDP/PIP/PAP components"
    ],
    "fixed_content": {
      "official_text": "Enforce attribute-based access control policy over defined subjects and objects and control access based upon organization-defined attributes to assume access permissions.",
      "plain_english_explanation": "Implement Attribute-Based Access Control (ABAC) where access decisions consider multiple attributes: user attributes (role, clearance, department), resource attributes (classification, project), and environmental attributes (time, location, threat level). Example: 'Grant access if user.clearance >= document.classification AND user.department == document.owner_department AND time >= 08:00 AND time <= 18:00 AND source.network == corporate_vpn'.",
      "example_implementation": "Implement ABAC using Open Policy Agent (OPA) or XACML policy decision points. Define attribute schema covering user, resource, and environmental attributes. Deploy Policy Enforcement Points (PEP) at application entry points. Configure Policy Decision Points (PDP) with attribute-based rules. Integrate with LDAP/IdM for user attributes and CMDB for resource attributes. See NIST SP 800-162 for comprehensive ABAC architecture.",
      "non_technical_guidance": "To implement Attribute-Based Access Control:\n1. Define attribute schema (user: role, clearance, department; resource: classification, owner, project; environment: time, location, threat-level)\n2. Deploy ABAC architecture components (PEP, PDP, PIP, PAP)\n3. Create attribute-based policy rules (boolean logic combining attributes)\n4. Integrate attribute sources (HR for user attrs, CMDB for resource attrs, security sensors for environment)\n5. Test ABAC policies thoroughly before enforcement\n6. Monitor policy decisions and refine rules based on false positives/negatives\n7. Document ABAC policies in business terms for stakeholders\n8. Regularly update attributes as organizational context changes\n\nReference: NIST SP 800-162 'Guide to Attribute Based Access Control (ABAC) Definition and Considerations'",
      "metadata": {
        "status": "documented",
        "references": [
          "NIST SP 800-162",
          "NIST SP 800-178",
          "NIST SP 1800-3"
        ]
      }
    }
  },
  {
    "control_id": "AC-3.14",
    "status": "FIX_REQUIRED",
    "changes": [
      "Enhanced official_text with complete individual access requirements",
      "Added plain_english_explanation clarifying GDPR-like self-access rights",
      "Provided implementation guidance for PII access portals"
    ],
    "fixed_content": {
      "official_text": "Provide organization-defined individuals with the capability to access the following elements of their personally identifiable information: organization-defined elements of personally identifiable information.",
      "plain_english_explanation": "Allow individuals to access their own personally identifiable information (PII) stored in your systems, similar to GDPR 'right of access'. For example, employees can view their HR records, customers can download their account data, patients can access their medical records.",
      "example_implementation": "Implement self-service portals for PII access. Deploy identity verification (multi-factor authentication) before granting PII access. Create data export functionality allowing individuals to download their data. Log all PII access by data subjects. Respond to PII access requests within defined timeframes (30 days).",
      "non_technical_guidance": "To provide individual PII access:\n1. Identify all PII data elements stored about individuals\n2. Determine which elements individuals should access (exclude security/fraud data)\n3. Deploy authenticated self-service portal for PII access\n4. Implement strong identity verification before granting access\n5. Create data export functionality in machine-readable format\n6. Establish process for manual access requests if portal unavailable\n7. Log all individual PII access events\n8. Respond to access requests within 30 days\n9. Train staff on PII access request procedures"
    }
  },
  {
    "control_id": "AC-3.15",
    "status": "PASS",
    "changes": [
      "Enhanced official_text with complete DAC+MAC combination requirements",
      "Plain_english_explanation and rationale already strong",
      "Added implementation guidance emphasizing MAC precedence over DAC"
    ],
    "fixed_content": {
      "official_text": "Enforce organization-defined mandatory access control policy in combination with organization-defined discretionary access control policy.",
      "plain_english_explanation": "Use both MAC and DAC together for defense-in-depth. SELinux (MAC) provides system-enforced security that users can't override, while Unix permissions (DAC) allow owners to manage access to their files. MAC always takes precedence.",
      "example_implementation": "Deploy SELinux in enforcing mode (MAC) alongside standard Unix file permissions (DAC). Configure SELinux policies to restrict process access regardless of file ownership. Maintain proper file permissions for owner-level access control. MAC policies override DAC when they conflict.",
      "non_technical_guidance": "To implement combined MAC and DAC:\n1. Enable SELinux or AppArmor (MAC) in enforcing mode\n2. Maintain standard Unix file permissions (DAC) for user-level access control\n3. Configure MAC policies for system-level security boundaries\n4. Train users that MAC policies override their file permissions when more restrictive\n5. Use DAC for collaboration and data sharing within security domains\n6. Use MAC to enforce security domain boundaries that users cannot violate\n7. Monitor both MAC and DAC audit logs\n8. Document the relationship and precedence between MAC and DAC policies"
    }
  },
  {
    "control_id": "AC-4",
    "control_name": "Information Flow Enforcement",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Enforce approved authorizations for controlling the flow of information within the system and between connected systems based on [information flow control policies].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Ensure that only authorized individuals are able to access and share information within the system and with connected systems.",
    "example_implementation": "This script implement role-based access controls to restrict access to sensitive information based on user roles and responsibilities. Regularly review and update access permissions to ensure compliance with approved authorizations.",
    "non_technical_guidance": "This plan to implement Information Flow Enforcement for control AC-4, follow these steps:\n1. Identify the approved authorizations for controlling the flow of information within the system and between connected systems.\n2. Implement access controls and permissions based on these approved authorizations.\n3. Regularly review and update these access controls to ensure they align with the approved authorizations.\n4. Monitor information flow within the system and between connected systems to detect any unauthorized or abnormal activities.\n5. Train employees on the importance of information flow enforcement and the potential risks of unauthorized data transfers.\n6. Document all information flow enforcement processes and procedures for future reference and auditing purposes.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "ac-4.1",
        "title": "Object Security and Privacy Attributes",
        "official_text": "Use [information flow policy] associated with [information flow policy] to enforce [object type (e.g., data, metadata)] as a basis for flow control decisions.",
        "metadata": {
          "stig_id": "NET-08-040001"
        },
        "ai_guidance": "Enhance security by applying specific controls for Object Security and Privacy Attributes.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.2",
        "title": "Processing Domains",
        "official_text": "Use protected processing domains to enforce [processing flow (e.g., input, output)] as a basis for flow control decisions.",
        "metadata": {
          "stig_id": "NET-08-040002"
        },
        "ai_guidance": "Enhance security by applying specific controls for Processing Domains.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.3",
        "title": "Dynamic Information Flow Control",
        "official_text": "Enforce [dynamic policy rules].",
        "rationale": "Dynamic information flow control allows the system to adjust data flow rules in real-time based on changing threat conditions or operational states.",
        "metadata": {
          "stig_id": "RHEL-08-040003"
        },
        "ai_guidance": "Automatically block data transfers if the system detects a threat or security level change.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.4",
        "title": "Flow Control of Encrypted Information",
        "official_text": "Prevent encrypted information from bypassing [content filter] by [flow direction].",
        "metadata": {
          "stig_id": "NET-08-040004"
        },
        "ai_guidance": "Enhance security by applying specific controls for Flow Control of Encrypted Information.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.5",
        "title": "Embedded Data Types",
        "official_text": "Enforce [embedded data types] on embedding data types within other data types.",
        "metadata": {
          "stig_id": "NET-08-040005"
        },
        "ai_guidance": "Enhance security by applying specific controls for Embedded Data Types.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.6",
        "title": "Metadata",
        "official_text": "Enforce information flow control based on [metadata constraints].",
        "metadata": {
          "stig_id": "NET-08-040006"
        },
        "ai_guidance": "Enhance security by applying specific controls for Metadata.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.7",
        "title": "One-way Flow Mechanisms",
        "official_text": "Enforce one-way information flows through hardware-based flow control mechanisms.",
        "metadata": {
          "stig_id": "NET-08-040007"
        },
        "ai_guidance": "Enhance security by applying specific controls for One-way Flow Mechanisms.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.8",
        "title": "Security and Privacy Policy Filters",
        "official_text": "",
        "rationale": "Security and privacy policy filters enforce granular rules on data content (e.g., blocking PII) rather than just connection metadata.",
        "metadata": {
          "stig_id": "RHEL-08-040008"
        },
        "ai_guidance": "Use filters to stop specific types of data (like credit card numbers) from leaving the network.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.9",
        "title": "Human Reviews",
        "official_text": "Enforce the use of human reviews for [human review] under the following conditions: [release authority].",
        "metadata": {
          "stig_id": "NET-08-040009"
        },
        "ai_guidance": "Enhance security by applying specific controls for Human Reviews.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.10",
        "title": "Enable and Disable Security or Privacy Policy Filters",
        "official_text": "Provide the capability for privileged administrators to enable and disable [filtered data types] under the following conditions: [action (e.g., block, quarantine)].",
        "metadata": {
          "stig_id": "NET-08-040010"
        },
        "ai_guidance": "Enhance security by applying specific controls for Enable and Disable Security or Privacy Policy Filters.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.11",
        "title": "Configuration of Security or Privacy Policy Filters",
        "official_text": "Provide the capability for privileged administrators to configure [configuration management] to support different security or privacy policies.",
        "metadata": {
          "stig_id": "NET-08-040011"
        },
        "ai_guidance": "Enhance security by applying specific controls for Configuration of Security or Privacy Policy Filters.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.12",
        "title": "Data Type Identifiers",
        "official_text": "When transferring information between different security domains, use [data type] to validate data essential for information flow decisions.",
        "metadata": {
          "stig_id": "NET-08-040012"
        },
        "ai_guidance": "Enhance security by applying specific controls for Data Type Identifiers.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.13",
        "title": "Decomposition into Policy-relevant Subcomponents",
        "official_text": "When transferring information between different security domains, decompose information into [code execution rules] for submission to policy enforcement mechanisms.",
        "metadata": {
          "stig_id": "NET-08-040013"
        },
        "ai_guidance": "Enhance security by applying specific controls for Decomposition into Policy-relevant Subcomponents.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.14",
        "title": "Security or Privacy Policy Filter Constraints",
        "official_text": "When transferring information between different security domains, implement [signed content] requiring fully enumerated formats that restrict data structure and content.",
        "metadata": {
          "stig_id": "NET-08-040014"
        },
        "ai_guidance": "Enhance security by applying specific controls for Security or Privacy Policy Filter Constraints.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.15",
        "title": "Detection of Unsanctioned Information",
        "official_text": "When transferring information between different security domains, examine the information for the presence of [format verification] and prohibit the transfer of such information in accordance with the [action (e.g., block)].",
        "metadata": {
          "stig_id": "NET-08-040015"
        },
        "ai_guidance": "Enhance security by applying specific controls for Detection of Unsanctioned Information.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.16",
        "title": "Information Transfers on Interconnected Systems",
        "official_text": "",
        "rationale": "Information flow enforcement must consider metadata (e.g., classification labels) to prevent data leakage across security domains.",
        "metadata": {
          "stig_id": "RHEL-08-040016"
        },
        "ai_guidance": "Tag data with labels (like 'Confidential') and make sure the network respects those tags.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.17",
        "title": "Domain Authentication",
        "official_text": "Uniquely identify and authenticate source and destination points by [domain isolation] for information transfer.",
        "metadata": {
          "stig_id": "NET-08-040017"
        },
        "ai_guidance": "Enhance security by applying specific controls for Domain Authentication.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.18",
        "title": "Security Attribute Binding",
        "official_text": "",
        "rationale": "Security attributes must be bound to information to ensure that access control decisions persist as data moves through the system.",
        "metadata": {
          "stig_id": "RHEL-08-040018"
        },
        "ai_guidance": "Bind security tags to the data file itself so the protection travels with the file.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.19",
        "title": "Validation of Metadata",
        "official_text": "When transferring information between different security domains, implement [validation mechanism] on metadata.",
        "metadata": {
          "stig_id": "NET-08-040019"
        },
        "ai_guidance": "Enhance security by applying specific controls for Validation of Metadata.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.20",
        "title": "Approved Solutions",
        "official_text": "Employ [approved solutions] to control the flow of [policy enforcement] across security domains.",
        "metadata": {
          "stig_id": "NET-08-040020"
        },
        "ai_guidance": "Enhance security by applying specific controls for Approved Solutions.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.21",
        "title": "Physical or Logical Separation of Information Flows",
        "official_text": "Separate information flows logically or physically using [physical connection type] to accomplish [physical separation].",
        "metadata": {
          "stig_id": "NET-08-040021"
        },
        "ai_guidance": "Enhance security by applying specific controls for Physical or Logical Separation of Information Flows.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.22",
        "title": "Access Only",
        "official_text": "Provide access from a single device to computing platforms, applications, or data residing in multiple different security domains, while preventing information flow between the different security domains.",
        "metadata": {
          "stig_id": "NET-08-040022"
        },
        "ai_guidance": "Enhance security by applying specific controls for Access Only.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.23",
        "title": "Modify Non-releasable Information",
        "official_text": "When transferring information between different security domains, modify non-releasable information by implementing [origin authentication].",
        "metadata": {},
        "ai_guidance": "Enhance security by applying specific controls for Modify Non-releasable Information.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.24",
        "title": "Internal Normalized Format",
        "official_text": "When transferring information between different security domains, parse incoming data into an internal normalized format and regenerate the data to be consistent with its intended specification.",
        "metadata": {},
        "ai_guidance": "Enhance security by applying specific controls for Internal Normalized Format.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.25",
        "title": "Data Sanitization",
        "official_text": "When transferring information between different security domains, sanitize data to minimize [data set] in accordance with [marking rules].",
        "metadata": {},
        "ai_guidance": "Enhance security by applying specific controls for Data Sanitization.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.26",
        "title": "Audit Filtering Actions",
        "official_text": "When transferring information between different security domains, record and audit content filtering actions and results for the information being filtered.",
        "metadata": {},
        "ai_guidance": "Enhance security by applying specific controls for Audit Filtering Actions.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.27",
        "title": "Redundant/Independent Filtering Mechanisms",
        "official_text": "When transferring information between different security domains, implement content filtering solutions that provide redundant and independent filtering mechanisms for each data type.",
        "metadata": {},
        "ai_guidance": "Enhance security by applying specific controls for Redundant/Independent Filtering Mechanisms.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.28",
        "title": "Linear Filter Pipelines",
        "official_text": "When transferring information between different security domains, implement a linear content filter pipeline that is enforced with discretionary and mandatory access controls.",
        "metadata": {},
        "ai_guidance": "Enhance security by applying specific controls for Linear Filter Pipelines.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.29",
        "title": "Filter Orchestration Engines",
        "official_text": "When transferring information between different security domains, employ content filter orchestration engines to ensure that:",
        "metadata": {},
        "ai_guidance": "Enhance security by applying specific controls for Filter Orchestration Engines.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.30",
        "title": "Filter Mechanisms Using Multiple Processes",
        "official_text": "When transferring information between different security domains, implement content filtering mechanisms using multiple processes.",
        "metadata": {},
        "ai_guidance": "Enhance security by applying specific controls for Filter Mechanisms Using Multiple Processes.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.31",
        "title": "Failed Content Transfer Prevention",
        "official_text": "When transferring information between different security domains, prevent the transfer of failed content to the receiving domain.",
        "metadata": {},
        "ai_guidance": "Enhance security by applying specific controls for Failed Content Transfer Prevention.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-4.32",
        "title": "Process Requirements for Information Transfer",
        "official_text": "When transferring information between different security domains, the process that transfers information between filter pipelines:",
        "metadata": {},
        "ai_guidance": "Enhance security by applying specific controls for Process Requirements for Information Transfer.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-09T21:34:53.460070+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-040000"
    },
    "cac_metadata": {
      "implementation_type": "administrative",
      "last_analyzed": "2025-11-10T09:38:58.031211+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Control where data is allowed to move (e.g., don't let Top Secret data move to a Public folder).",
    "implementation_guidance": "This control is implemented via organizational policy and architectural design. Refer to the Policy Guidance tab.",
    "stig_id": "RHEL-08-040000"
  },
  {
    "control_id": "AC-4.1",
    "control_name": "Object Security and Privacy Attributes",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Use [Assignment: organization-defined security and privacy attributes] associated with [Assignment: organization-defined information, source, and destination objects] to enforce [Assignment: organization-defined information flow control policies] as a basis for flow control decisions.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Compare security labels on information (e.g., 'Confidential') with security labels on source and destination objects to decide if data flow should be allowed. For example: only allow 'Confidential' data to flow to systems labeled 'Confidential' or higher.",
    "example_implementation": "Implement mandatory access control (MAC) using SELinux security contexts. Tag files with classification labels (using extended attributes). Configure network devices to inspect security labels in packet headers. Use data loss prevention (DLP) tools that read metadata attributes. Example: Block email attachments labeled 'Internal Use Only' from being sent to external addresses.",
    "non_technical_guidance": "Implement security labeling: 1) Define classification levels (Public, Internal, Confidential, Secret). 2) Label all information assets with appropriate classification. 3) Label all systems/networks with handling levels. 4) Configure automated tools to enforce 'no write up, no read down' policies. 5) Train users on proper labeling procedures. 6) Audit label assignments quarterly.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-4",
      "AC-16",
      "SC-16"
    ],
    "supplemental_guidance": "Information flow enforcement mechanisms compare security and privacy attributes associated with information (data content and structure) and source and destination objects and respond appropriately when the enforcement mechanisms encounter information flows not explicitly allowed by information flow policies. For example, an information object labeled Secret would be allowed to flow to a destination object labeled Secret, but an information object labeled Top Secret would not be allowed to flow to a destination object labeled Secret. Security and privacy attributes can also include, for example, source and destination addresses employed in traffic filter firewalls. Flow enforcement using explicit security and privacy attributes can be used, for example, to control the release of certain types of information.",
    "implementation_scripts": {
      "linux": {
        "selinux": "semanage fcontext -a -t confidential_t '/data/confidential(/.*)?'; restorecon -R /data/confidential"
      },
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-20T00:00:00.000000+00:00",
      "has_scripts": false,
      "stig_id": "NET-08-040001"
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "last_analyzed": "2025-11-20T00:00:00.000000+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "partial",
      "cac_planned": true,
      "implementation_guidance": "Partial implementation available through SELinux MLS (Multi-Level Security) policy. Requires organizational policy definition for security attributes and classification levels."
    },
    "rationale": "Security attributes enable fine-grained information flow control based on data classification rather than just network addresses. This prevents classified information from flowing to lower-classification destinations even if network connectivity exists.",
    "ai_guidance": "Tag files with security labels (like 'Confidential'). Make sure the network only allows 'Confidential' files to go to places that can handle 'Confidential' data.",
    "stig_id": "NET-08-040001"
  },
  {
    "control_id": "AC-4.2",
    "control_name": "Processing Domains",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Use protected processing domains to enforce [Assignment: organization-defined information flow control policies] as a basis for flow control decisions.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Isolate different processing activities into separate protected spaces (domains). Control which domains can send information to which other domains. For example: separate web servers from database servers, only allow specific data flows between them.",
    "example_implementation": "Use SELinux domains to confine processes. Implement network segmentation with VLANs/subnets. Deploy containerization (Docker, Kubernetes) to isolate workloads. Use virtualization to create separate processing domains. Configure firewall rules to enforce domain-to-domain communication policies. Example: Web application runs in 'web_t' SELinux domain, can only send queries to 'postgresql_t' domain.",
    "non_technical_guidance": "1) Define processing domains (e.g., web tier, application tier, database tier, admin workstations). 2) Map which domains need to communicate. 3) Document allowed information flows between domains. 4) Implement technical isolation (network segmentation, mandatory access controls). 5) Monitor and log inter-domain communications. 6) Review domain architecture annually.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-4",
      "SC-2",
      "SC-3",
      "SC-39"
    ],
    "supplemental_guidance": "Protected processing domains are processing spaces that have controlled interactions with other processing spaces, thus enabling control of information flows between these spaces and to/from information objects. A protected processing domain can be provided, for example, by implementing domain and type enforcement. In domain and type enforcement, system processes are assigned to domains, information is identified by types, and information flows are controlled based on allowed information accesses (determined by domain and type), allowed signaling among domains, and allowed process transitions to other domains. Protected processing domains can provide the capability to enforce information flow control policies through the use of domains and types.",
    "implementation_scripts": {
      "linux": {
        "selinux": "semodule -i custom_domain_policy.pp; semanage permissive -d httpd_t",
        "network": "ip netns add secure_domain; ip netns exec secure_domain ip link set lo up"
      },
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-20T00:00:00.000000+00:00",
      "has_scripts": false,
      "stig_id": "NET-08-040002"
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "last_analyzed": "2025-11-20T00:00:00.000000+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "partial",
      "cac_planned": true,
      "cac_rules": [
        "selinux_state",
        "selinux_policytype",
        "selinux_confinement_of_daemons"
      ],
      "implementation_guidance": "Partial implementation available through SELinux domain and type enforcement. Network segmentation requires manual configuration of firewall rules and VLAN policies."
    },
    "rationale": "Processing domain separation limits the blast radius of security breaches. If one domain is compromised, strong isolation prevents lateral movement to other domains. This architectural approach reduces attack surface.",
    "ai_guidance": "Create separate 'rooms' for different types of work (web servers, databases, user workstations). Control which rooms can talk to each other.",
    "stig_id": "NET-08-040002"
  },
  {
    "control_id": "AC-4.3",
    "control_name": "Dynamic Information Flow Control",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Enforce [Assignment: organization-defined information flow control policies].",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Automatically change information flow rules in real-time based on changing conditions like threat level, time of day, or operational state. For example: if intrusion detection triggers, automatically block certain data transfers until threat is cleared.",
    "example_implementation": "Integrate Security Information and Event Management (SIEM) with firewall APIs to dynamically update rules. Deploy Software-Defined Networking (SDN) to enable rapid policy changes. Use threat intelligence feeds to automatically block malicious IP addresses. Configure context-aware access controls that adjust based on risk score. Example: During high-threat conditions, firewall automatically restricts data exports.",
    "non_technical_guidance": "1) Define operational states (normal, heightened alert, incident response). 2) Document information flow policies for each state. 3) Identify triggers for state transitions (e.g., IDS alert, failed login attempts). 4) Implement automation to apply appropriate flow policies when state changes. 5) Test state transitions quarterly. 6) Maintain audit log of all policy changes.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-4",
      "AC-2",
      "SI-4"
    ],
    "supplemental_guidance": "Organizational policies regarding dynamic information flow control include allowing or disallowing information flows based on changing conditions or mission or operational considerations. Changing conditions include changes in risk tolerance due to changes in the immediacy of mission or business success, changes in the threat environment, and detection of potentially harmful or adverse events. Organizations can specify which system components or individuals are authorized to change the information flow enforcement policies based on assessed risk levels, vulnerability assessments, or other characteristics associated with mission or business circumstances.",
    "implementation_scripts": {
      "linux": {
        "firewalld": "firewall-cmd --panic-on  # Emergency mode blocks all traffic",
        "automation": "#!/bin/bash\nif [ $(cat /var/log/threat_level) == 'HIGH' ]; then firewall-cmd --zone=public --remove-service=http; fi"
      },
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-20T00:00:00.000000+00:00",
      "has_scripts": false,
      "stig_id": "RHEL-08-040003"
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-20T00:00:00.000000+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": false,
      "implementation_guidance": "Requires custom automation and integration with security monitoring systems. No pre-built CAC content available. Organizations must develop policies and scripts tailored to their operational requirements."
    },
    "rationale": "Dynamic information flow control allows the system to adjust data flow rules in real-time based on changing threat conditions or operational states. This enables rapid response to emerging threats without manual intervention.",
    "ai_guidance": "Automatically block data transfers if the system detects a threat or security level change. Like a smart gate that closes automatically when danger is detected.",
    "stig_id": "RHEL-08-040003"
  },
  {
    "control_id": "AC-4.4",
    "control_name": "Flow Control of Encrypted Information",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Prevent encrypted information from bypassing [Assignment: organization-defined information flow control mechanisms] by [Selection (one or more): decrypting the information; blocking the flow of the encrypted information; terminating communications sessions attempting to pass encrypted information; [Assignment: organization-defined procedure or method]].",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Don't let people use encryption to sneak data past your content filters. Either decrypt and inspect the data, or block encrypted transfers entirely. Attackers often use encryption (HTTPS, VPN tunnels) to hide malicious data from inspection tools.",
    "example_implementation": "Deploy SSL/TLS inspection proxies to decrypt and inspect HTTPS traffic. Configure firewalls to block non-approved VPN protocols. Implement Data Loss Prevention (DLP) with SSL inspection capabilities. Use endpoint encryption controls that integrate with DLP. Example: Corporate proxy decrypts outbound HTTPS, scans for confidential data, re-encrypts before forwarding.",
    "non_technical_guidance": "1) Document which encryption protocols are approved for business use. 2) Deploy SSL/TLS inspection at network boundaries. 3) Configure DLP tools to inspect encrypted communications. 4) Block unapproved encryption protocols (Tor, personal VPNs). 5) Implement certificate pinning for internal applications. 6) Educate users that corporate traffic inspection is authorized. 7) Document privacy protections and legal review.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-4",
      "SC-8",
      "SC-13",
      "SI-4"
    ],
    "supplemental_guidance": "Flow control mechanisms include content checking, security policy filters, and data type identifiers. The term encryption is extended to cover encoded data not recognized by filtering mechanisms. An organization-defined procedure or method can address the situation where the inability to decrypt the information is due to the unavailability of an effective decryption key. Encrypted information that is sent to or from information systems is encrypted in accordance with established encryption standards and subjected to decryption prior to being examined by content checking, security policy filters, or data type identifiers.",
    "implementation_scripts": {
      "linux": {
        "squid_ssl_bump": "# Squid proxy with SSL interception\nhttp_port 3128 ssl-bump cert=/etc/squid/ssl_cert/proxy.pem\nsslcrtd_program /usr/lib64/squid/ssl_crtd -s /var/lib/ssl_db -M 4MB\nssl_bump server-first all"
      },
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-20T00:00:00.000000+00:00",
      "has_scripts": false,
      "stig_id": "NET-08-040004"
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-20T00:00:00.000000+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": false,
      "implementation_guidance": "Requires deployment of SSL/TLS inspection proxies (Squid, BlueCoat, Palo Alto) and Data Loss Prevention systems. No pre-built CAC rules available. Consult organizational legal and privacy teams before implementing."
    },
    "rationale": "Encryption can be used to bypass content inspection and data loss prevention controls. Malicious actors commonly use encryption to exfiltrate sensitive data or deliver malware. SSL/TLS inspection is necessary to maintain visibility into encrypted traffic.",
    "ai_guidance": "Don't let encryption be used to hide bad stuff. Either decrypt and check what's inside, or block it entirely if you can't inspect it.",
    "stig_id": "NET-08-040004"
  },
  {
    "control_id": "AC-4.5",
    "control_name": "Embedded Data Types",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Enforce [Assignment: organization-defined limitations] on embedding data types within other data types.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Prevent people from hiding one type of file inside another (like hiding an executable inside a PDF). Attackers use this technique to bypass file type restrictions. Limit how deeply data types can be nested (e.g., no ZIPs inside ZIPs inside ZIPs).",
    "example_implementation": "Configure email gateways to reject emails with multiple levels of nested attachments. Deploy file sanitization tools that unwrap and inspect embedded content. Implement content filtering rules that scan for executables hidden in documents. Use deep packet inspection to detect embedded payloads. Example: Block PDFs containing embedded JavaScript or executables.",
    "non_technical_guidance": "1) Document acceptable embedding practices (e.g., images in Word docs allowed, executables in PDFs prohibited). 2) Configure email and web gateways to enforce embedding limits. 3) Scan incoming files for prohibited embedded data types. 4) Limit nesting depth (e.g., max 2 levels of compression). 5) Quarantine suspicious nested files. 6) Train users on risks of embedded malware.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-4",
      "SI-3",
      "SC-7"
    ],
    "supplemental_guidance": "Embedding data types within other data types can result in reduced effectiveness of information flow enforcement mechanisms. Data type embedding includes inserting files as objects within other files and using compressed or archived data types that may include multiple embedded data types. Limitations on data type embedding consider the levels of embedding and prohibit levels of data type embedding that are beyond the capability of the inspection tools.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-20T00:00:00.000000+00:00",
      "has_scripts": false,
      "stig_id": "NET-08-040005"
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-20T00:00:00.000000+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": false,
      "implementation_guidance": "Requires deployment of advanced content inspection tools (email gateways, web proxies, DLP). No pre-built CAC rules available. Organizations should configure policies in their security appliances."
    },
    "rationale": "Embedding data types enables attackers to bypass file type restrictions and deliver malware. By limiting embedding depth and scanning nested content, organizations can detect and block sophisticated attack techniques.",
    "ai_guidance": "Don't let people hide dangerous files inside innocent-looking files. Like preventing someone from hiding a knife inside a gift box.",
    "stig_id": "NET-08-040005"
  },
  {
    "control_id": "AC-4.6",
    "control_name": "Metadata",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Enforce information flow control based on [metadata constraints].",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Enforce information flow control based on [metadata constraints].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142101+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040006"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:44.615043+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Metadata according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040006"
  },
  {
    "control_id": "AC-4.7",
    "control_name": "One-way Flow Mechanisms",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Enforce one-way information flows through hardware-based flow control mechanisms.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Enforce one-way information flows through hardware-based flow control mechanisms.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142114+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040007"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:46.263412+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce One-way Flow Mechanisms according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040007"
  },
  {
    "control_id": "AC-4.8",
    "control_name": "Security and Privacy Policy Filters",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142128+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-040008"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:47.839165+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Security and privacy policy filters enforce granular rules on data content (e.g., blocking PII) rather than just connection metadata.",
    "ai_guidance": "Use filters to stop specific types of data (like credit card numbers) from leaving the network.",
    "stig_id": "RHEL-08-040008"
  },
  {
    "control_id": "AC-4.9",
    "control_name": "Human Reviews",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Enforce the use of human reviews for [human review] under the following conditions: [release authority].",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Enforce the use of human reviews for [human review] under the following conditions: [release authority].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142142+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040009"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:49.629376+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Human Reviews according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040009"
  },
  {
    "control_id": "AC-4.10",
    "control_name": "Enable and Disable Security or Privacy Policy Filters",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Provide the capability for privileged administrators to enable and disable [filtered data types] under the following conditions: [action (e.g., block, quarantine)].",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Provide the capability for privileged administrators to enable and disable [filtered data types] under the following conditions: [action (e.g., block, quarantine)].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141730+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040010"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:01.371259+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Enable and Disable Security or Privacy Policy Filters according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040010"
  },
  {
    "control_id": "AC-4.11",
    "control_name": "Configuration of Security or Privacy Policy Filters",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Provide the capability for privileged administrators to configure [configuration management] to support different security or privacy policies.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Provide the capability for privileged administrators to configure [configuration management] to support different security or privacy policies.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141744+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040011"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:02.963469+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Configuration of Security or Privacy Policy Filters according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040011"
  },
  {
    "control_id": "AC-4.12",
    "control_name": "Data Type Identifiers",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, use [data type] to validate data essential for information flow decisions.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, use [data type] to validate data essential for information flow decisions.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141758+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040012"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:04.642899+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Data Type Identifiers according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040012"
  },
  {
    "control_id": "AC-4.13",
    "control_name": "Decomposition into Policy-relevant Subcomponents",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, decompose information into [code execution rules] for submission to policy enforcement mechanisms.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, decompose information into [code execution rules] for submission to policy enforcement mechanisms.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141773+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040013"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:06.201865+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Decomposition into Policy-relevant Subcomponents according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040013"
  },
  {
    "control_id": "AC-4.14",
    "control_name": "Security or Privacy Policy Filter Constraints",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, implement [signed content] requiring fully enumerated formats that restrict data structure and content.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, implement [signed content] requiring fully enumerated formats that restrict data structure and content.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141787+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040014"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:07.777877+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Security or Privacy Policy Filter Constraints according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040014"
  },
  {
    "control_id": "AC-4.15",
    "control_name": "Detection of Unsanctioned Information",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, examine the information for the presence of [format verification] and prohibit the transfer of such information in accordance with the [action (e.g., block)].",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, examine the information for the presence of [format verification] and prohibit the transfer of such information in accordance with the [action (e.g., block)].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141799+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040015"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:09.323599+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Detection of Unsanctioned Information according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040015"
  },
  {
    "control_id": "AC-4.16",
    "control_name": "Information Transfers on Interconnected Systems",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141813+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-040016"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:10.866477+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Information flow enforcement must consider metadata (e.g., classification labels) to prevent data leakage across security domains.",
    "ai_guidance": "Tag data with labels (like 'Confidential') and make sure the network respects those tags.",
    "stig_id": "RHEL-08-040016"
  },
  {
    "control_id": "AC-4.17",
    "control_name": "Domain Authentication",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Uniquely identify and authenticate source and destination points by [domain isolation] for information transfer.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Uniquely identify and authenticate source and destination points by [domain isolation] for information transfer.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141828+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040017"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:12.446904+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Domain Authentication according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040017"
  },
  {
    "control_id": "AC-4.18",
    "control_name": "Security Attribute Binding",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141842+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-040018"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:14.040235+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Security attributes must be bound to information to ensure that access control decisions persist as data moves through the system.",
    "ai_guidance": "Bind security tags to the data file itself so the protection travels with the file.",
    "stig_id": "RHEL-08-040018"
  },
  {
    "control_id": "AC-4.19",
    "control_name": "Validation of Metadata",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, implement [validation mechanism] on metadata.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, implement [validation mechanism] on metadata.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141854+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040019"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:15.632390+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Validation of Metadata according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040019"
  },
  {
    "control_id": "AC-4.20",
    "control_name": "Approved Solutions",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Employ [approved solutions] to control the flow of [policy enforcement] across security domains.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Employ [approved solutions] to control the flow of [policy enforcement] across security domains.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141882+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040020"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:18.762894+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Approved Solutions according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040020"
  },
  {
    "control_id": "AC-4.21",
    "control_name": "Physical or Logical Separation of Information Flows",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Separate information flows logically or physically using [physical connection type] to accomplish [physical separation].",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Separate information flows logically or physically using [physical connection type] to accomplish [physical separation].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141897+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040021"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:20.320251+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Physical or Logical Separation of Information Flows according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040021"
  },
  {
    "control_id": "AC-4.22",
    "control_name": "Access Only",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Provide access from a single device to computing platforms, applications, or data residing in multiple different security domains, while preventing information flow between the different security domains.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Provide access from a single device to computing platforms, applications, or data residing in multiple different security domains, while preventing information flow between the different security domains.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141911+00:00",
      "has_scripts": true,
      "stig_id": "NET-08-040022"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:21.864912+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Access Only according to organization policies to ensure access is strictly controlled.",
    "stig_id": "NET-08-040022"
  },
  {
    "control_id": "AC-4.23",
    "control_name": "Modify Non-releasable Information",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, modify non-releasable information by implementing [origin authentication].",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, modify non-releasable information by implementing [origin authentication].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141925+00:00",
      "has_scripts": true,
      "stig_id": "GEN-AC-4-23"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:23.413597+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Modify Non-releasable Information according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-AC-4-23"
  },
  {
    "control_id": "AC-4.24",
    "control_name": "Internal Normalized Format",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, parse incoming data into an internal normalized format and regenerate the data to be consistent with its intended specification.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, parse incoming data into an internal normalized format and regenerate the data to be consistent with its intended specification.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141937+00:00",
      "has_scripts": true,
      "stig_id": "GEN-AC-4-24"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:24.948163+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Internal Normalized Format according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-AC-4-24"
  },
  {
    "control_id": "AC-4.25",
    "control_name": "Data Sanitization",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, sanitize data to minimize [data set] in accordance with [marking rules].",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, sanitize data to minimize [data set] in accordance with [marking rules].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141952+00:00",
      "has_scripts": true,
      "stig_id": "GEN-AC-4-25"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:26.490363+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Data Sanitization according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-AC-4-25"
  },
  {
    "control_id": "AC-4.26",
    "control_name": "Audit Filtering Actions",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, record and audit content filtering actions and results for the information being filtered.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, record and audit content filtering actions and results for the information being filtered.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141966+00:00",
      "has_scripts": true,
      "stig_id": "GEN-AC-4-26"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:28.075194+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Audit Filtering Actions according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-AC-4-26"
  },
  {
    "control_id": "AC-4.27",
    "control_name": "Redundant/Independent Filtering Mechanisms",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, implement content filtering solutions that provide redundant and independent filtering mechanisms for each data type.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, implement content filtering solutions that provide redundant and independent filtering mechanisms for each data type.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141979+00:00",
      "has_scripts": true,
      "stig_id": "GEN-AC-4-27"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:29.801436+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Redundant/Independent Filtering Mechanisms according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-AC-4-27"
  },
  {
    "control_id": "AC-4.28",
    "control_name": "Linear Filter Pipelines",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, implement a linear content filter pipeline that is enforced with discretionary and mandatory access controls.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, implement a linear content filter pipeline that is enforced with discretionary and mandatory access controls.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141992+00:00",
      "has_scripts": true,
      "stig_id": "GEN-AC-4-28"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:31.459092+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Linear Filter Pipelines according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-AC-4-28"
  },
  {
    "control_id": "AC-4.29",
    "control_name": "Filter Orchestration Engines",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, employ content filter orchestration engines to ensure that:",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, employ content filter orchestration engines to ensure that:",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142005+00:00",
      "has_scripts": true,
      "stig_id": "GEN-AC-4-29"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:33.058793+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Filter Orchestration Engines according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-AC-4-29"
  },
  {
    "control_id": "AC-4.30",
    "control_name": "Filter Mechanisms Using Multiple Processes",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, implement content filtering mechanisms using multiple processes.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, implement content filtering mechanisms using multiple processes.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142033+00:00",
      "has_scripts": true,
      "stig_id": "GEN-AC-4-30"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:36.566227+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Filter Mechanisms Using Multiple Processes according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-AC-4-30"
  },
  {
    "control_id": "AC-4.31",
    "control_name": "Failed Content Transfer Prevention",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, prevent the transfer of failed content to the receiving domain.",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, prevent the transfer of failed content to the receiving domain.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142046+00:00",
      "has_scripts": true,
      "stig_id": "GEN-AC-4-31"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:38.163142+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Failed Content Transfer Prevention according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-AC-4-31"
  },
  {
    "control_id": "AC-4.32",
    "control_name": "Process Requirements for Information Transfer",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "When transferring information between different security domains, the process that transfers information between filter pipelines:",
    "parent_control": "ac-4",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "When transferring information between different security domains, the process that transfers information between filter pipelines:",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142060+00:00",
      "has_scripts": true,
      "stig_id": "GEN-AC-4-32"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:39.797794+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Process Requirements for Information Transfer according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-AC-4-32"
  },
  {
    "control_id": "AC-5",
    "control_name": "Separation of Duties",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Separation of Duties ensures that no one person has complete control over a process or system, reducing the risk of errors or fraud.",
    "example_implementation": "This script assigns different responsibilities to different team members, such as having one person approve changes and another person implement them, to ensure proper separation of duties.",
    "non_technical_guidance": "This plan to implement the Separation of Duties control (ac-5) in a non-technical manner, follow these steps:\n\n1. Identify the different roles and responsibilities within your organization related to IT security and operations.\n2. Clearly define and document the specific duties and tasks assigned to each role.\n3. Ensure that no single individual has the ability to perform conflicting duties that could lead to a security risk or conflict of interest.\n4. Implement a process for oversight and monitoring to ensure that the separation of duties is maintained.\n5. Regularly review and update the roles and responsibilities as needed to adapt to changes in the organization or technology environment.\n6. Provide training and awareness to employees on the importance of separation of duties and the potential risks of not adhering to this control.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-09T21:34:53.460078+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010050"
    },
    "cac_metadata": {
      "implementation_type": "administrative",
      "last_analyzed": "2025-11-10T09:39:51.212621+00:00",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires organizational policy documentation and procedures. No technical automation available."
    },
    "ai_guidance": "Implement and enforce Separation of Duties according to organization policies to ensure access is strictly controlled.",
    "implementation_guidance": "This control is implemented via organizational policy and architectural design. Refer to the Policy Guidance tab.",
    "stig_id": "RHEL-08-010050"
  },
  {
    "control_id": "AC-6",
    "control_name": "Least Privilege",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Employ the principle of least privilege, allowing only authorized accesses for users (or processes acting on behalf of users) that are necessary to accomplish assigned organizational tasks.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Only give users and processes the minimum permissions required to complete their authorized tasks. No user should have more access than absolutely necessary.",
    "example_implementation": "Implement role-based access control (RBAC). Regularly audit user permissions. Remove sudo access from users who don't need it. Disable unnecessary SUID/SGID programs. Use SELinux or AppArmor to enforce process-level restrictions.",
    "non_technical_guidance": "Conduct quarterly access reviews. Document why each privileged account exists. Train administrators on least privilege principles. Implement approval workflows for elevated access requests. Monitor and log all privileged activity.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "ac-6.1",
        "title": "Authorize Access to Security Functions",
        "official_text": "Authorize access for [organization-defined individuals and roles] to [organization-defined security functions in hardware, software, firmware] and [organization-defined security-relevant information].",
        "rationale": "Restricting access to security functions (e.g., audit logs, account management, firewall rules, security configuration) prevents unauthorized users from disabling defenses or covering tracks after compromise.",
        "metadata": {
          "stig_id": "RHEL-08-010371"
        },
        "ai_guidance": "Only designated security administrators should access audit logs, security configurations, and account management tools. Regular users must not modify firewall rules or security policies."
      },
      {
        "id": "ac-6.2",
        "title": "Non-privileged Access for Nonsecurity Functions",
        "official_text": "Require users with accounts/roles accessing [organization-defined security functions or security-relevant information] to use non-privileged accounts when performing nonsecurity functions.",
        "rationale": "Administrators should use unprivileged accounts for daily tasks (email, web browsing, document editing) and only elevate to privileged accounts when performing security-specific duties. This reduces the attack surface for credential theft and limits the impact of user errors.",
        "metadata": {
          "stig_id": "RHEL-08-010372"
        },
        "ai_guidance": "System administrators must have TWO accounts: a regular user account for normal work and a separate admin account only for system administration. Never browse the internet or read email using an admin account."
      },
      {
        "id": "ac-6.3",
        "title": "Network Access to Privileged Commands",
        "official_text": "Authorize network access to [organization-defined privileged commands] only for [organization-defined compelling operational needs]; document rationale in security plan.",
        "rationale": "Remote privileged command execution expands the attack surface. Limiting network-accessible privileged commands to documented operational needs (e.g., emergency recovery) reduces risk of remote exploitation. All remote admin access should use encrypted channels with MFA.",
        "metadata": {
          "stig_id": "RHEL-08-010373"
        },
        "ai_guidance": "Disable remote root login via SSH. Require users to SSH as unprivileged accounts, then use sudo locally. Document and justify any exceptions. Use bastion hosts for privileged remote access."
      },
      {
        "id": "ac-6.4",
        "title": "Separate Processing Domains",
        "official_text": "Provide separate processing domains enabling finer-grained user privilege allocation.",
        "rationale": "Isolation mechanisms (containers, VMs, SELinux domains, namespaces) prevent privilege escalation between security contexts. Separating workloads limits lateral movement after compromise.",
        "metadata": {
          "stig_id": "RHEL-08-010374"
        },
        "ai_guidance": "Use containers or VMs to isolate sensitive workloads. Enable SELinux in enforcing mode. Use Linux namespaces to separate process trees. Run each service with its own dedicated user account."
      },
      {
        "id": "ac-6.5",
        "title": "Privileged Accounts",
        "official_text": "Restrict privileged accounts to [organization-defined personnel or roles].",
        "rationale": "Limiting privileged account distribution reduces insider threat risk and limits the number of targets for credential theft. Each privileged account represents a potential complete system compromise.",
        "metadata": {
          "stig_id": "RHEL-08-010375"
        },
        "ai_guidance": "Maintain an authoritative list of who has sudo access. Remove sudo rights immediately when personnel change roles or leave. Limit the 'wheel' or 'sudo' group to 3-5 administrators maximum."
      },
      {
        "id": "ac-6.6",
        "title": "Privileged Access by Non-organizational Users",
        "official_text": "Prohibit non-organizational users from obtaining privileged system access.",
        "rationale": "Contractors, vendors, and third parties pose elevated risk due to limited oversight. Privileged access by external users should be prohibited or heavily restricted, monitored, and time-limited.",
        "metadata": {
          "stig_id": "RHEL-08-010376"
        },
        "ai_guidance": "Never give sudo access to contractors or vendors. If vendor access is absolutely required, use time-limited jump boxes, screen recording, and require MFA. Revoke access immediately after work completion."
      },
      {
        "id": "ac-6.7",
        "title": "Review of User Privileges",
        "official_text": "Review [organization-defined frequency] privileges assigned to [organization-defined roles/classes]; reassign or remove as necessary to reflect organizational needs.",
        "rationale": "Regular privilege reviews prevent 'privilege creep,' where users accumulate access rights over time that they no longer need. Quarterly or semi-annual reviews ensure least privilege remains enforced as job roles change.",
        "metadata": {
          "stig_id": "RHEL-08-010377"
        },
        "ai_guidance": "Review every privileged account quarterly. Ask: Does this person still need sudo? Have they changed roles? Create a checklist and require manager sign-off. Automate reports of who has sudo access."
      },
      {
        "id": "ac-6.8",
        "title": "Privilege Levels for Code Execution",
        "official_text": "Prevent [organization-defined software] from executing at privilege levels exceeding those of executing users.",
        "rationale": "SUID/SGID binaries allow unprivileged users to execute code with elevated privileges. Unnecessary SUID/SGID bits are prime targets for privilege escalation exploits. Restricting execution to user privilege levels limits attack vectors.",
        "metadata": {
          "stig_id": "RHEL-08-010378"
        },
        "ai_guidance": "Find all SUID/SGID files: 'find / -perm /6000 -type f'. Remove SUID/SGID bits from unnecessary programs. Audit remaining SUID binaries monthly. Use capabilities instead of SUID when possible."
      },
      {
        "id": "ac-6.9",
        "title": "Log Use of Privileged Functions",
        "official_text": "Log execution of privileged functions.",
        "rationale": "Logging privileged function execution provides a critical audit trail for detecting insider threats, misuse of administrative power, and unauthorized privilege escalation. Without logs, privileged abuse goes undetected.",
        "metadata": {
          "stig_id": "RHEL-08-030361"
        },
        "ai_guidance": "Log every sudo command, su usage, and SUID program execution. Configure auditd to capture privileged syscalls. Centralize logs to SIEM. Alert on suspicious patterns (e.g., sudo at 3 AM)."
      },
      {
        "id": "ac-6.10",
        "title": "Prohibit Non-privileged Users from Executing Privileged Functions",
        "official_text": "Prevent non-privileged users from executing privileged functions.",
        "rationale": "This control enforces the fundamental principle that users without authorization cannot perform administrative tasks, disable security controls, bypass access restrictions, or modify system configurations. Critical for preventing unauthorized system changes.",
        "metadata": {
          "stig_id": "RHEL-08-010379"
        },
        "ai_guidance": "Remove ALL users from sudo group except authorized admins. Configure sudoers to require passwords (no NOPASSWD). Disable direct root login. Audit /etc/sudoers and /etc/sudoers.d/ for overly permissive rules."
      }
    ],
    "related_controls": [
      "AC-2",
      "AC-3",
      "AC-5",
      "AU-2",
      "AU-6",
      "CM-5",
      "CM-11",
      "IA-2"
    ],
    "supplemental_guidance": "Least privilege is a fundamental security principle limiting users and processes to only the access required for legitimate purposes. This applies to users, applications, processes, and system components. Organizations should employ architectural approaches, configuration management, and explicit authorization mechanisms to enforce least privilege. Periodic review of privileges ensures entitlements remain appropriate as organizational needs evolve. Technologies supporting least privilege include role-based access control (RBAC), mandatory access control (MAC), attribute-based access control (ABAC), and privileged account management (PAM) solutions.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-6 Least Privilege - Comprehensive Implementation\n# Description: Enforce least privilege through kernel sysctls, sudo restrictions, and SUID auditing\n\necho \"[*] AC-6: Implementing Least Privilege Controls\"\n\n# 1. Kernel-level privilege restrictions\necho \"[*] Configuring kernel privilege restrictions...\"\ncat <<EOF > /etc/sysctl.d/99-least-privilege.conf\n# Disable kernel profiling by unprivileged users (AC-6)\nkernel.perf_event_paranoid = 2\n\n# Disable BPF for unprivileged users (AC-6)\nkernel.unprivileged_bpf_disabled = 1\n\n# Restrict access to kernel logs\nkernel.dmesg_restrict = 1\n\n# Restrict kernel pointer exposure\nkernel.kptr_restrict = 2\nEOF\nsysctl --system\n\n# 2. Sudo configuration hardening\necho \"[*] Hardening sudo configuration...\"\n\n# Ensure sudo package is installed\nif ! rpm -q sudo &>/dev/null; then\n    dnf install -y sudo\nfi\n\n# Remove NOPASSWD directives\nfor file in /etc/sudoers /etc/sudoers.d/*; do\n    if [ -f \"$file\" ]; then\n        sed -i 's/^\\(.*NOPASSWD.*\\)/#\\1 # Disabled by AC-6/' \"$file\"\n    fi\ndone\n\n# Remove !authenticate directives  \nfor file in /etc/sudoers /etc/sudoers.d/*; do\n    if [ -f \"$file\" ]; then\n        sed -i 's/^\\(.*!authenticate.*\\)/#\\1 # Disabled by AC-6/' \"$file\"\n    fi\ndone\n\n# Remove overly permissive ALL=(ALL) ALL rules\nfor file in /etc/sudoers /etc/sudoers.d/*; do\n    if [ -f \"$file\" ]; then\n        sed -i 's/^\\s*ALL\\s\\+ALL=(ALL)\\s\\+ALL\\s*$/#&  # Disabled by AC-6 - Too permissive/' \"$file\"\n        sed -i 's/^\\s*ALL\\s\\+ALL=(ALL:ALL)\\s\\+ALL\\s*$/#&  # Disabled by AC-6 - Too permissive/' \"$file\"\n    fi\ndone\n\n# Add recommended sudo defaults\ncat <<EOF > /etc/sudoers.d/99-ac6-defaults\n# AC-6 Least Privilege - Sudo Hardening\nDefaults use_pty\nDefaults env_reset\nDefaults !visiblepw\nDefaults always_set_home\nDefaults requiretty\nDefaults passwd_timeout=5\nDefaults timestamp_timeout=5\nDefaults umask=0077\nEOF\nchmod 0440 /etc/sudoers.d/99-ac6-defaults\n\n# 3. Configure PAM to prevent sudo bypass\necho \"[*] Configuring PAM for sudo authentication...\"\nif [ -f /etc/pam.d/sudo ]; then\n    # Remove pam_succeed_if lines that could bypass authentication\n    sed -i '/pam_succeed_if/d' /etc/pam.d/sudo\nfi\n\n# 4. Audit SUID/SGID binaries\necho \"[*] Auditing SUID/SGID programs...\"\nfind / -xdev \\( -perm -4000 -o -perm -2000 \\) -type f 2>/dev/null > /var/log/suid_sgid_audit.log\necho \"[*] SUID/SGID binaries logged to /var/log/suid_sgid_audit.log\"\necho \"[*] Review this file and remove unnecessary SUID/SGID bits\"\n\n# 5. Configure file permissions on sudo configuration\necho \"[*] Setting secure permissions on sudo files...\"\nchown root:root /etc/sudoers\nchmod 0440 /etc/sudoers\nif [ -d /etc/sudoers.d ]; then\n    chown root:root /etc/sudoers.d\n    chmod 0750 /etc/sudoers.d\n    find /etc/sudoers.d -type f -exec chmod 0440 {} \\;\n    find /etc/sudoers.d -type f -exec chown root:root {} \\;\nfi\n\n# 6. Validate sudoers file syntax\nvisudo -c -f /etc/sudoers\nif [ $? -ne 0 ]; then\n    echo \"[ERROR] /etc/sudoers syntax validation failed!\"\n    exit 1\nfi\n\necho \"[*] AC-6 Least Privilege implementation complete\"\necho \"[*] MANUAL STEPS REQUIRED:\"\necho \"    1. Review /etc/group and verify 'wheel' membership\"\necho \"    2. Review /var/log/suid_sgid_audit.log for unnecessary SUID binaries\"\necho \"    3. Document all accounts with sudo access in security plan\"\necho \"    4. Schedule quarterly privilege access reviews\"\n",
        "ansible": "---\n# AC-6 Least Privilege - Comprehensive Implementation\n# Description: Ansible playbook for enforcing least privilege controls\n\n- name: AC-6 Least Privilege Implementation\n  hosts: all\n  become: yes\n  tasks:\n\n    # Kernel-level restrictions\n    - name: Configure kernel privilege restrictions\n      ansible.posix.sysctl:\n        name: \"{{ item.key }}\"\n        value: \"{{ item.value }}\"\n        state: present\n        sysctl_file: /etc/sysctl.d/99-least-privilege.conf\n        reload: yes\n      loop:\n        - { key: 'kernel.perf_event_paranoid', value: '2' }\n        - { key: 'kernel.unprivileged_bpf_disabled', value: '1' }\n        - { key: 'kernel.dmesg_restrict', value: '1' }\n        - { key: 'kernel.kptr_restrict', value: '2' }\n\n    # Sudo package installation\n    - name: Ensure sudo is installed\n      ansible.builtin.package:\n        name: sudo\n        state: present\n\n    # Remove NOPASSWD directives\n    - name: Find sudoers files\n      ansible.builtin.find:\n        paths:\n          - /etc/sudoers.d\n        patterns: '*'\n        file_type: file\n      register: sudoers_files\n\n    - name: Remove NOPASSWD from /etc/sudoers\n      ansible.builtin.replace:\n        path: /etc/sudoers\n        regexp: '^(.*)NOPASSWD(.*)$'\n        replace: '#\\1NOPASSWD\\2  # Disabled by AC-6'\n        validate: '/usr/sbin/visudo -cf %s'\n\n    - name: Remove NOPASSWD from sudoers.d files\n      ansible.builtin.replace:\n        path: \"{{ item.path }}\"\n        regexp: '^(.*)NOPASSWD(.*)$'\n        replace: '#\\1NOPASSWD\\2  # Disabled by AC-6'\n        validate: '/usr/sbin/visudo -cf %s'\n      loop: \"{{ sudoers_files.files }}\"\n      when: sudoers_files.files | length > 0\n\n    # Remove !authenticate directives\n    - name: Remove !authenticate from /etc/sudoers\n      ansible.builtin.replace:\n        path: /etc/sudoers\n        regexp: '^(.*)!authenticate(.*)$'\n        replace: '#\\1!authenticate\\2  # Disabled by AC-6'\n        validate: '/usr/sbin/visudo -cf %s'\n\n    # Remove overly permissive rules\n    - name: Remove ALL ALL=(ALL) ALL from /etc/sudoers\n      ansible.builtin.replace:\n        path: /etc/sudoers\n        regexp: '^\\s*ALL\\s+ALL=\\(ALL\\)\\s+ALL\\s*$'\n        replace: '#&  # Disabled by AC-6'\n        validate: '/usr/sbin/visudo -cf %s'\n\n    - name: Remove ALL ALL=(ALL:ALL) ALL from /etc/sudoers\n      ansible.builtin.replace:\n        path: /etc/sudoers\n        regexp: '^\\s*ALL\\s+ALL=\\(ALL:ALL\\)\\s+ALL\\s*$'\n        replace: '#&  # Disabled by AC-6'\n        validate: '/usr/sbin/visudo -cf %s'\n\n    # Configure sudo defaults\n    - name: Add secure sudo defaults\n      ansible.builtin.copy:\n        dest: /etc/sudoers.d/99-ac6-defaults\n        content: |\n          # AC-6 Least Privilege - Sudo Hardening\n          Defaults use_pty\n          Defaults env_reset\n          Defaults !visiblepw\n          Defaults always_set_home\n          Defaults requiretty\n          Defaults passwd_timeout=5\n          Defaults timestamp_timeout=5\n          Defaults umask=0077\n        owner: root\n        group: root\n        mode: '0440'\n        validate: '/usr/sbin/visudo -cf %s'\n\n    # PAM configuration\n    - name: Remove pam_succeed_if from sudo PAM config\n      ansible.builtin.lineinfile:\n        path: /etc/pam.d/sudo\n        regexp: '.*pam_succeed_if.*'\n        state: absent\n      when: ansible_facts['os_family'] == 'RedHat'\n\n    # Audit SUID/SGID programs\n    - name: Find SUID/SGID programs\n      ansible.builtin.shell:\n        cmd: find / -xdev \\( -perm -4000 -o -perm -2000 \\) -type f 2>/dev/null\n      register: suid_sgid_files\n      changed_when: false\n\n    - name: Log SUID/SGID programs for review\n      ansible.builtin.copy:\n        content: \"{{ suid_sgid_files.stdout }}\"\n        dest: /var/log/suid_sgid_audit.log\n        owner: root\n        group: root\n        mode: '0600'\n\n    # Secure sudoers file permissions\n    - name: Set secure permissions on /etc/sudoers\n      ansible.builtin.file:\n        path: /etc/sudoers\n        owner: root\n        group: root\n        mode: '0440'\n\n    - name: Set secure permissions on /etc/sudoers.d\n      ansible.builtin.file:\n        path: /etc/sudoers.d\n        owner: root\n        group: root\n        mode: '0750'\n        state: directory\n\n    - name: Set secure permissions on sudoers.d files\n      ansible.builtin.file:\n        path: \"{{ item.path }}\"\n        owner: root\n        group: root\n        mode: '0440'\n      loop: \"{{ sudoers_files.files }}\"\n      when: sudoers_files.files | length > 0\n\n    # Final validation\n    - name: Validate sudoers configuration\n      ansible.builtin.command:\n        cmd: visudo -c -f /etc/sudoers\n      register: visudo_check\n      failed_when: visudo_check.rc != 0\n      changed_when: false\n\n    - name: Display SUID/SGID audit results\n      ansible.builtin.debug:\n        msg:\n          - \"AC-6 Least Privilege controls applied successfully\"\n          - \"SUID/SGID audit: {{ suid_sgid_files.stdout_lines | length }} binaries found\"\n          - \"Review /var/log/suid_sgid_audit.log on each host\"\n          - \"MANUAL ACTIONS REQUIRED:\"\n          - \"1. Review wheel/sudo group membership: getent group wheel\"\n          - \"2. Review and remove unnecessary SUID/SGID bits\"\n          - \"3. Document privileged accounts in security plan\"\n          - \"4. Schedule quarterly privilege reviews\"\n"
      },
      "windows": {
        "powershell": "# AC-6 Least Privilege - Windows Implementation\n# Description: Enforce least privilege on Windows systems\n\nWrite-Host \"[*] AC-6: Implementing Least Privilege Controls (Windows)\"\n\n# 1. Audit local administrators\nWrite-Host \"[*] Auditing local Administrators group...\"\n$admins = Get-LocalGroupMember -Group \"Administrators\"\n$admins | Format-Table Name, PrincipalSource\n$admins | Export-Csv -Path \"C:\\Windows\\Logs\\admin_audit.csv\" -NoTypeInformation\n\n# 2. Disable unnecessary privileged accounts\nWrite-Host \"[*] Checking for unnecessary privileged accounts...\"\n$unnecessaryAccounts = @('Guest', 'DefaultAccount')\nforeach ($account in $unnecessaryAccounts) {\n    try {\n        $user = Get-LocalUser -Name $account -ErrorAction SilentlyContinue\n        if ($user -and $user.Enabled) {\n            Disable-LocalUser -Name $account\n            Write-Host \"[+] Disabled account: $account\"\n        }\n    } catch {\n        Write-Host \"[-] Account not found or already disabled: $account\"\n    }\n}\n\n# 3. Configure UAC to maximum\nWrite-Host \"[*] Configuring User Account Control (UAC)...\"\nSet-ItemProperty -Path \"REGISTRY::HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" -Name \"ConsentPromptBehaviorAdmin\" -Value 2\nSet-ItemProperty -Path \"REGISTRY::HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" -Name \"EnableLUA\" -Value 1\nSet-ItemProperty -Path \"REGISTRY::HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\" -Name \"PromptOnSecureDesktop\" -Value 1\n\n# 4. Restrict remote privileged access\nWrite-Host \"[*] Restricting remote privileged access...\"\n# Limit remote connections to authenticated users\nSet-ItemProperty -Path \"REGISTRY::HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Terminal Server\" -Name \"fDenyTSConnections\" -Value 0\nSet-ItemProperty -Path \"REGISTRY::HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" -Name \"UserAuthentication\" -Value 1\n\n# 5. Enable privilege auditing\nWrite-Host \"[*] Enabling privilege use auditing...\"\nauditpol /set /subcategory:\"Sensitive Privilege Use\" /success:enable /failure:enable\nauditpol /set /subcategory:\"Non Sensitive Privilege Use\" /success:enable /failure:enable\n\nWrite-Host \"[*] AC-6 Least Privilege implementation complete\"\nWrite-Host \"[*] MANUAL STEPS REQUIRED:\"\nWrite-Host \"    1. Review C:\\Windows\\Logs\\admin_audit.csv for unnecessary admin accounts\"\nWrite-Host \"    2. Remove users from Administrators group who don't require it\"\nWrite-Host \"    3. Implement separate admin accounts for privileged users\"\nWrite-Host \"    4. Schedule quarterly privilege access reviews\"\n"
      }
    },
    "metadata": {
      "status": "enhanced",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "stig_id": "RHEL-08-010370",
      "cac_rules_integrated": 29,
      "script_sources": [
        "ComplianceAsCode sudo rules",
        "STIG RHEL-08-010370 through RHEL-08-010379",
        "Kernel hardening best practices"
      ]
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode + NIST SP 800-53 Rev 5",
      "rules_integrated": [
        "sudo_require_authentication",
        "sudo_remove_nopasswd",
        "sudo_remove_no_authenticate",
        "sudo_restrict_privilege_elevation_to_authorized",
        "disallow_bypass_password_sudo",
        "ensure_sudo_group_restricted",
        "file_permissions_etc_sudoers",
        "directory_permissions_etc_sudoersd",
        "sysctl_kernel_perf_event_paranoid",
        "sysctl_kernel_unprivileged_bpf_disabled"
      ]
    },
    "rationale": "Least privilege is fundamental to defense-in-depth security architecture. By limiting access rights for users, accounts, and processes to only what is strictly required, organizations minimize the attack surface available to malicious actors. If an account is compromised, the damage is limited to that account's privileges. Least privilege prevents lateral movement, reduces insider threat risk, and limits the scope of security incidents.",
    "ai_guidance": "Treat every user account as potentially compromised. Grant the absolute minimum access needed. If unsure whether someone needs sudo, they don't need it. Review quarterly and remove unused privileges ruthlessly.",
    "stig_id": "RHEL-08-010370"
  },
  {
    "control_id": "AC-6.1",
    "control_name": "Authorize Access to Security Functions",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Authorize access for [authorized individuals] to:",
    "parent_control": "ac-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Authorize access for [authorized individuals] to:",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-6(1) Authorize Access to Security Functions\n# Description: Verify that only authorized users are in the 'wheel' group or sudoers.\n\necho \"Checking 'wheel' group membership...\"\ngrep '^wheel' /etc/group\n\necho \"Checking sudoers configuration...\"\ngrep -v '^#' /etc/sudoers | grep -v '^$'\n\necho \"Manual Review Required: Ensure only authorized administrators are listed above.\"\n",
        "ansible": "---\n- name: AC-6(1) Authorize Access to Security Functions\n  hosts: all\n  tasks:\n    - name: Ensure only authorized users are in the wheel group\n      ansible.builtin.group:\n        name: wheel\n        state: present\n      register: wheel_group\n\n    - name: Display wheel group members\n      debug:\n        var: wheel_group\n"
      },
      "_note": "Replaced generic audit dump with targeted privileged access checks.",
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-10T23:03:47.642866",
      "has_scripts": true,
      "migration_source": "CAC_AC6_family_migration",
      "stig_id": "RHEL-08-010371"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:54.680892+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Restricting access to security functions (e.g., audit logs, account management) prevents unauthorized users from disabling defenses.",
    "ai_guidance": "Don't let regular users touch security settings or audit logs. Only admins should do that.",
    "stig_id": "RHEL-08-010371"
  },
  {
    "control_id": "AC-6.2",
    "control_name": "Non-privileged Access for Nonsecurity Functions",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Require that users of system accounts (or roles) with access to [non-privileged access] use non-privileged accounts or roles, when accessing nonsecurity functions.",
    "parent_control": "ac-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Require that users of system accounts (or roles) with access to [non-privileged access] use non-privileged accounts or roles, when accessing nonsecurity functions.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142212+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010372"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:57.844409+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Non-privileged Access for Nonsecurity Functions according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010372"
  },
  {
    "control_id": "AC-6.3",
    "control_name": "Network Access to Privileged Commands",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Authorize network access to [network access] only for [privileged commands] and document the rationale for such access in the security plan for the system.",
    "parent_control": "ac-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Authorize network access to [network access] only for [privileged commands] and document the rationale for such access in the security plan for the system.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142226+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010373"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:59.461985+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Network Access to Privileged Commands according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010373"
  },
  {
    "control_id": "AC-6.4",
    "control_name": "Separate Processing Domains",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Provide separate processing domains to enable finer-grained allocation of user privileges.",
    "parent_control": "ac-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Provide separate processing domains to enable finer-grained allocation of user privileges.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142241+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010374"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:40:01.038392+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Separate Processing Domains according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010374"
  },
  {
    "control_id": "AC-6.5",
    "control_name": "Privileged Accounts",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Restrict privileged accounts on the system to [privileged accounts].",
    "parent_control": "ac-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Restrict privileged accounts on the system to [privileged accounts].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142255+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010375"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:40:02.645079+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Privileged Accounts according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010375"
  },
  {
    "control_id": "AC-6.6",
    "control_name": "Privileged Access by Non-organizational Users",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Prohibit privileged access to the system by non-organizational users.",
    "parent_control": "ac-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Prohibit privileged access to the system by non-organizational users.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142269+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010376"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:40:04.220942+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Privileged Access by Non-organizational Users according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010376"
  },
  {
    "control_id": "AC-6.7",
    "control_name": "Review of User Privileges",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "parent_control": "ac-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142282+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010377"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:40:05.774185+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Regular privilege reviews prevent 'privilege creep,' where users accumulate access rights over time that they no longer need.",
    "ai_guidance": "Review everyone's access rights once a year. Remove access they don't need anymore.",
    "stig_id": "RHEL-08-010377"
  },
  {
    "control_id": "AC-6.8",
    "control_name": "Privilege Levels for Code Execution",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Prevent the following software from executing at higher privilege levels than users executing the software: [privilege level].",
    "parent_control": "ac-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Prevent the following software from executing at higher privilege levels than users executing the software: [privilege level].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142295+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010378"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:40:07.370043+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Privilege Levels for Code Execution according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010378"
  },
  {
    "control_id": "AC-6.9",
    "control_name": "Log Use of Privileged Functions",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Log the execution of privileged functions.",
    "parent_control": "ac-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Log the execution of privileged functions.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-6(9) Log Use of Privileged Functions\n# Description: Configure auditd to log execution of privileged commands (sudo, su)\n\nAUDIT_FILE=\"/etc/audit/rules.d/privileged_actions.rules\"\n\necho \"Configuring audit rules for privileged functions...\"\n\ncat <<EOF > \"$AUDIT_FILE\"\n-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged\n-a always,exit -F path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged\n-a always,exit -F path=/usr/bin/pkexec -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged\nEOF\n\nchmod 0600 \"$AUDIT_FILE\"\naugenrules --load\n\necho \"Audit rules loaded. Check with 'auditctl -l'.\"\n",
        "ansible": "---\n- name: AC-6(9) Log Use of Privileged Functions\n  hosts: all\n  become: yes\n  tasks:\n    - name: Configure audit rules for privileged commands\n      ansible.builtin.lineinfile:\n        path: /etc/audit/rules.d/privileged_actions.rules\n        line: \"{{ item }}\"\n        create: yes\n        mode: '0600'\n      loop:\n        - \"-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged\"\n        - \"-a always,exit -F path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged\"\n      notify: Reload Auditd\n\n  handlers:\n    - name: Reload Auditd\n      service:\n        name: auditd\n        state: restarted\n"
      },
      "_note": "Replaced 62k line dump with targeted privileged function auditing.",
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-10T23:03:47.642881",
      "has_scripts": true,
      "migration_source": "CAC_AC6_family_migration",
      "stig_id": "RHEL-08-030361"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:40:08.920075+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "rationale": "Logging privileged function execution provides a critical audit trail for detecting insider threats and misuse of administrative power.",
    "ai_guidance": "Log every time someone uses a 'sudo' or admin command. You need to know who did what.",
    "stig_id": "RHEL-08-030361"
  },
  {
    "control_id": "AC-6.10",
    "control_name": "Prohibit Non-privileged Users from Executing Privileged Functions",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Prevent non-privileged users from executing privileged functions.",
    "parent_control": "ac-6",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Prevent non-privileged users from executing privileged functions.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142198+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010379"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:39:56.230811+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Prohibit Non-privileged Users from Executing Privileged Functions according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010379"
  },
  {
    "control_id": "AC-7",
    "control_name": "Unsuccessful Logon Attempts",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "a. Enforce a limit of [Assignment: organization-defined number: 3] consecutive invalid logon attempts by a user during a [Assignment: organization-defined time period: 15 minutes]; and\nb. Automatically [Selection (one or more): lock the account or node for an [Assignment: organization-defined time period: 15 minutes]; lock the account or node until released by an administrator; delay next logon prompt per [Assignment: organization-defined delay algorithm]; notify system administrator; take other [Assignment: organization-defined action]] when the maximum number of unsuccessful attempts is exceeded.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "The system must lock user accounts after 3 failed login attempts within 15 minutes to prevent brute-force password guessing attacks. The account remains locked for 15 minutes or until an administrator unlocks it.",
    "example_implementation": "Configure PAM faillock module with: deny=3 (maximum attempts), fail_interval=900 (15 minute window), unlock_time=900 (15 minute lockout duration). Use /etc/security/faillock.conf for centralized configuration.",
    "non_technical_guidance": "If someone tries to log in with the wrong password 3 times in 15 minutes, their account gets locked for 15 minutes. This stops hackers from trying thousands of password combinations.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "ac-7.2",
        "title": "Purge or Wipe Mobile Device",
        "official_text": "Purge or wipe information from [Assignment: organization-defined mobile devices] based on [Assignment: organization-defined purging or wiping requirements and techniques] after [Assignment: organization-defined number: 10] consecutive, unsuccessful device logon attempts.",
        "metadata": {
          "stig_id": "RHEL-08-020022"
        },
        "ai_guidance": "After 10 failed unlock attempts on a mobile device, automatically erase all data to protect against theft or loss.",
        "discussion": "A mobile device is a computing device that has a small form factor such that it can be carried by a single individual; is designed to operate without a physical connection; possesses local, non-removable or removable data storage; and includes a self-contained power source. Purging or wiping the device applies only to mobile devices for which the organization has management control and authority."
      },
      {
        "id": "ac-7.3",
        "title": "Biometric Attempt Limiting",
        "official_text": "Limit the number of unsuccessful biometric logon attempts to [Assignment: organization-defined number: 5].",
        "metadata": {
          "stig_id": "RHEL-08-020023"
        },
        "ai_guidance": "Limit fingerprint or face recognition login attempts to 5 failures before requiring password authentication.",
        "discussion": "Biometrics are probabilistic in nature. The ability to successfully authenticate can be impacted by factors including matching performance and presentation attack detection mechanisms. Organizations can define different thresholds for biometric authentication attempts than for password-based attempts."
      },
      {
        "id": "ac-7.4",
        "title": "Use of Alternate Authentication Factor",
        "official_text": "a. Allow the use of [Assignment: organization-defined authentication factors: hardware token, SMS code, authenticator app] that are different from the primary authentication factors after the number of [Assignment: organization-defined number: 3] consecutive invalid logon attempts have been exceeded; and\nb. Enforce a limit of [Assignment: organization-defined number: 3] consecutive invalid logon attempts through use of the alternative factors by a user during a [Assignment: organization-defined time period: 15 minutes].",
        "rationale": "Using an alternate authentication factor after failures allows legitimate users to recover access while blocking automated attacks. The alternate factor must also be rate-limited to prevent abuse.",
        "metadata": {
          "stig_id": "RHEL-08-020024"
        },
        "ai_guidance": "If someone locks their account with failed passwords, let them unlock it using a different method like a phone code or hardware token. But limit those attempts too."
      }
    ],
    "related_controls": [
      "AC-2",
      "AC-9",
      "AU-2",
      "AU-6",
      "IA-5"
    ],
    "supplemental_guidance": "The implementation of this control should align with organizational incident response procedures. Account lockouts may represent security incidents and should be logged and monitored. Consider excluding emergency or break-glass accounts from automatic lockout policies.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-7 Unsuccessful Logon Attempts - PAM Faillock Configuration\n# Implements NIST SP 800-53 Rev 5 AC-7(a) and AC-7(b)\n# STIG ID: RHEL-08-020020\n\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\n\n# Backup existing configuration\ncp \"$FAILLOCK_CONF\" \"${FAILLOCK_CONF}.backup-$(date +%Y%m%d-%H%M%S)\"\n\n# Configure faillock parameters per CAC guidance\n# deny: Maximum consecutive failed attempts (AC-7a)\nsed -i 's/^#\\?deny =.*/deny = 3/' \"$FAILLOCK_CONF\"\n\n# fail_interval: Time window for counting attempts in seconds (AC-7a)\nsed -i 's/^#\\?fail_interval =.*/fail_interval = 900/' \"$FAILLOCK_CONF\"\n\n# unlock_time: Account lockout duration in seconds (AC-7b)\nsed -i 's/^#\\?unlock_time =.*/unlock_time = 900/' \"$FAILLOCK_CONF\"\n\n# Verify configuration\necho \"Faillock configuration applied:\"\ngrep -E '^(deny|fail_interval|unlock_time) =' \"$FAILLOCK_CONF\"\n\n# Enable faillock in PAM if using authselect\nif command -v authselect &> /dev/null; then\n    authselect enable-feature with-faillock\n    echo \"Authselect faillock feature enabled\"\nfi\n\necho \"AC-7 implementation complete. Accounts will lock after 3 failed attempts within 15 minutes for 15 minutes.\"\n",
        "ansible": "---\n- name: AC-7 Unsuccessful Logon Attempts - NIST SP 800-53 Rev 5\n  hosts: all\n  become: yes\n  vars:\n    # CAC-validated parameters for RHEL 8/9\n    faillock_deny: 3           # Maximum attempts (AC-7a)\n    faillock_interval: 900     # 15 minutes in seconds (AC-7a)\n    faillock_unlock: 900       # 15 minutes lockout (AC-7b)\n  \n  tasks:\n    - name: Ensure PAM is installed\n      package:\n        name: pam\n        state: present\n\n    - name: Configure faillock deny parameter\n      lineinfile:\n        path: /etc/security/faillock.conf\n        regexp: '^#?deny ='\n        line: 'deny = {{ faillock_deny }}'\n        create: yes\n\n    - name: Configure faillock fail_interval parameter\n      lineinfile:\n        path: /etc/security/faillock.conf\n        regexp: '^#?fail_interval ='\n        line: 'fail_interval = {{ faillock_interval }}'\n\n    - name: Configure faillock unlock_time parameter\n      lineinfile:\n        path: /etc/security/faillock.conf\n        regexp: '^#?unlock_time ='\n        line: 'unlock_time = {{ faillock_unlock }}'\n\n    - name: Enable faillock feature with authselect (RHEL 8+)\n      command: authselect enable-feature with-faillock\n      when: ansible_distribution_major_version | int >= 8\n      register: authselect_result\n      changed_when: \"'already enabled' not in authselect_result.stderr\"\n      failed_when: false\n\n    - name: Verify faillock configuration\n      command: grep -E '^(deny|fail_interval|unlock_time) =' /etc/security/faillock.conf\n      register: verify_config\n      changed_when: false\n\n    - name: Display faillock configuration\n      debug:\n        msg: \"{{ verify_config.stdout_lines }}\"\n"
      },
      "windows": {
        "powershell": "# AC-7 Unsuccessful Logon Attempts - Windows Configuration\n# Implements NIST SP 800-53 Rev 5 AC-7(a) and AC-7(b)\n\n# Set account lockout threshold (AC-7a)\nnet accounts /lockoutthreshold:3\n\n# Set lockout duration to 15 minutes (AC-7b)\nnet accounts /lockoutduration:15\n\n# Set lockout observation window to 15 minutes (AC-7a)\nnet accounts /lockoutwindow:15\n\n# Verify configuration\nnet accounts\n\nWrite-Host \"AC-7 implementation complete. Accounts will lock after 3 failed attempts within 15 minutes for 15 minutes.\"\n"
      },
      "_note": "Scripts implement CAC-validated parameters: deny=3, fail_interval=900, unlock_time=900. References: STIG RHEL-08-020011, RHEL-08-020013, RHEL-08-020015."
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000",
      "has_scripts": true,
      "migration_source": "CAC_AC7_LOVELESS_audit",
      "stig_id": "RHEL-08-020020",
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "qa_agent": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000",
      "source": "ComplianceAsCode",
      "cac_rules_referenced": [
        "accounts_passwords_pam_faillock_deny",
        "accounts_passwords_pam_faillock_interval",
        "accounts_passwords_pam_faillock_unlock_time"
      ],
      "cac_rule_files": [
        "cac/linux_os/guide/system/accounts/accounts-pam/locking_out_password_attempts/accounts_passwords_pam_faillock_deny/rule.yml",
        "cac/linux_os/guide/system/accounts/accounts-pam/locking_out_password_attempts/accounts_passwords_pam_faillock_interval/rule.yml",
        "cac/linux_os/guide/system/accounts/accounts-pam/locking_out_password_attempts/accounts_passwords_pam_faillock_unlock_time/rule.yml"
      ]
    },
    "discussion": "By limiting the number of failed logon attempts, the risk of unauthorized system access via user password guessing, also known as brute-forcing, is reduced. Automatic lockout is enforced after the maximum number of unsuccessful attempts is exceeded. Organizations can select from multiple lockout actions: time-based lockout, administrator-required unlock, progressive delay algorithms, or other custom actions. The faillock module tracks attempts per user and resets the counter after successful authentication or when the fail_interval expires.",
    "ai_guidance": "Lock the account if someone guesses the password wrong 3 times in 15 minutes. Keep it locked for 15 minutes or until admin unlocks it. This stops brute-force attacks.",
    "stig_id": "RHEL-08-020020"
  },
  {
    "control_id": "AC-7.1",
    "control_name": "Automatic Account Lock [WITHDRAWN]",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "WITHDRAWN: Incorporated into AC-7 base control in NIST SP 800-53 Revision 5.",
    "parent_control": "ac-7",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This control enhancement was withdrawn in NIST SP 800-53 Revision 5 and its functionality was incorporated into the base AC-7 control. Organizations should implement AC-7 base control instead.",
    "example_implementation": "See AC-7 base control for implementation guidance.",
    "non_technical_guidance": "This control no longer exists separately. Follow the main AC-7 control instead.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-7"
    ],
    "supplemental_guidance": "Historical reference: This enhancement previously required automatic account locking after a specified number of unsuccessful logon attempts. This functionality is now part of AC-7(b) which specifies automatic actions to take when the maximum number of unsuccessful attempts is exceeded.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "withdrawn",
      "last_updated": "2025-11-20T00:00:00.000000",
      "has_scripts": false,
      "migration_source": "CAC_AC7_LOVELESS_audit",
      "stig_id": "RHEL-08-020021",
      "withdrawal_date": "2020-09-23",
      "withdrawal_notice": "Incorporated into AC-7 base control in NIST SP 800-53 Rev 5",
      "superseded_by": "AC-7",
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "qa_agent": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "withdrawn",
      "last_analyzed": "2025-11-20T00:00:00.000000",
      "source": "NIST SP 800-53 Rev 5",
      "implementation_guidance": "This control was withdrawn. Implement AC-7 base control which includes automatic lockout functionality."
    },
    "rationale": "This control was withdrawn because its requirements are now mandatory as part of AC-7(b), which requires organizations to automatically take action when unsuccessful attempt limits are exceeded. Organizations must select at least one automatic action, making separate enhancement unnecessary.",
    "ai_guidance": "This control was removed in the 2020 update of NIST 800-53. Use the main AC-7 control instead, which now includes automatic locking.",
    "stig_id": "RHEL-08-020021"
  },
  {
    "control_id": "AC-7.2",
    "control_name": "Purge or Wipe Mobile Device",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Purge or wipe information from [Assignment: organization-defined mobile devices] based on [Assignment: organization-defined purging or wiping requirements and techniques] after [Assignment: organization-defined number: 10] consecutive, unsuccessful device logon attempts.",
    "parent_control": "ac-7",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "If someone tries to unlock a mobile device (phone, tablet, laptop) 10 times incorrectly, the device automatically erases all its data. This protects sensitive information if the device is stolen or lost.",
    "example_implementation": "Configure Mobile Device Management (MDM) system to issue remote wipe command after 10 failed device authentication attempts. For iOS devices, enable 'Erase Data' option in Settings > Face ID & Passcode. For Android Enterprise, configure device policy through managed configuration.",
    "non_technical_guidance": "Your organization's phones and tablets should be set up to automatically delete everything if someone enters the wrong password or PIN 10 times. This protects company data if a device is stolen.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-7",
      "AC-19",
      "MP-5",
      "MP-6"
    ],
    "supplemental_guidance": "A mobile device is a computing device that has a small form factor such that it can be carried by a single individual; is designed to operate without a physical connection; possesses local, non-removable or removable data storage; and includes a self-contained power source. Purging or wiping the device applies only to mobile devices for which the organization has management control and authority. Organizations may choose cryptographic wipe (destroying encryption keys) or physical wipe (overwriting all sectors). The number of attempts may be configurable based on data sensitivity.",
    "implementation_scripts": {
      "linux": {},
      "windows": {},
      "_note": "Mobile device wiping requires Mobile Device Management (MDM) solution such as Microsoft Intune, VMware Workspace ONE, or MobileIron. Implementation is platform-specific and managed through MDM console, not operating system scripts."
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-20T00:00:00.000000",
      "has_scripts": false,
      "migration_source": "CAC_AC7_LOVELESS_audit",
      "stig_id": "RHEL-08-020022",
      "implementation_note": "Requires Mobile Device Management (MDM) solution",
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "qa_agent": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "manual",
      "last_analyzed": "2025-11-20T00:00:00.000000",
      "source": "NIST SP 800-53 Rev 5",
      "implementation_guidance": "Mobile device management is outside the scope of Linux PAM configuration. Organizations must implement through dedicated MDM solutions that support remote wipe capabilities."
    },
    "discussion": "This control is applicable to organizational mobile devices where loss or theft represents a significant risk to sensitive information. The wipe threshold should be high enough to prevent accidental data loss (e.g., child playing with device) but low enough to prevent brute-force attacks. Organizations should ensure users understand this policy and maintain proper backups. Remote wipe capabilities should also be available through MDM for lost/stolen devices independent of the automatic threshold.",
    "ai_guidance": "After 10 failed unlock attempts on a mobile device, automatically erase all data to protect against theft or loss. Requires mobile device management system.",
    "stig_id": "RHEL-08-020022"
  },
  {
    "control_id": "AC-7.3",
    "control_name": "Biometric Attempt Limiting",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Limit the number of unsuccessful biometric logon attempts to [Assignment: organization-defined number: 5].",
    "parent_control": "ac-7",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "If biometric authentication (fingerprint, facial recognition, iris scan) fails 5 times in a row, the system must require password authentication instead. This prevents someone from making unlimited attempts to bypass biometric security.",
    "example_implementation": "Configure biometric authentication systems to track consecutive failed attempts per user. After 5 failures, disable biometric authentication for that session and require password/PIN authentication. On Windows Hello for Business, this is configured via Group Policy. For Linux PAM with fingerprint readers, configure pam_fprintd with max_tries=5 and fallback to password authentication.",
    "non_technical_guidance": "If fingerprint or face recognition fails 5 times, the system should ask for a password instead. This stops attackers from trying to fool the fingerprint reader over and over.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-7",
      "IA-3"
    ],
    "supplemental_guidance": "Biometrics are probabilistic in nature. The ability to successfully authenticate can be impacted by factors including matching performance, environmental conditions, sensor quality, and presentation attack detection mechanisms. Organizations can define different thresholds for biometric authentication attempts than for password-based attempts. A lower threshold (5 attempts) may be appropriate given the different attack surface. After exceeding the threshold, the system should fallback to an alternative authentication method, typically password or PIN. The attempt counter should reset after successful authentication or after a time period.",
    "implementation_scripts": {
      "linux": {},
      "windows": {},
      "_note": "Biometric authentication limiting requires biometric hardware and supporting authentication frameworks (Windows Hello, Linux PAM fprintd, macOS Touch ID). Implementation is platform-specific and hardware-dependent."
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-20T00:00:00.000000",
      "has_scripts": false,
      "migration_source": "CAC_AC7_LOVELESS_audit",
      "stig_id": "RHEL-08-020023",
      "implementation_note": "Requires biometric hardware and platform-specific authentication framework",
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "qa_agent": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "manual",
      "last_analyzed": "2025-11-20T00:00:00.000000",
      "source": "NIST SP 800-53 Rev 5",
      "implementation_guidance": "Biometric authentication rate limiting is hardware and platform specific. Linux PAM supports fingerprint authentication via pam_fprintd module with configurable max_tries parameter. Windows systems use Windows Hello for Business with Group Policy controls."
    },
    "discussion": "Biometric systems have different failure characteristics than password-based systems. False rejection (legitimate user rejected) occurs at rates depending on sensor quality and environmental conditions. Organizations should set attempt limits that balance security with usability. Biometric systems should implement liveness detection to prevent presentation attacks (photos, masks, artificial fingerprints). After exhausting biometric attempts, users must authenticate via an alternative factor, preventing unlimited biometric guess attempts.",
    "ai_guidance": "Limit fingerprint or face recognition login attempts to 5 failures before requiring password authentication. Biometrics can fail legitimately, so allow more attempts than passwords, but still prevent unlimited tries.",
    "stig_id": "RHEL-08-020023"
  },
  {
    "control_id": "AC-7.4",
    "control_name": "Use of Alternate Authentication Factor",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "a. Allow the use of [Assignment: organization-defined authentication factors: hardware token, SMS code, authenticator app] that are different from the primary authentication factors after the number of [Assignment: organization-defined number: 3] consecutive invalid logon attempts have been exceeded; and\nb. Enforce a limit of [Assignment: organization-defined number: 3] consecutive invalid logon attempts through use of the alternative factors by a user during a [Assignment: organization-defined time period: 15 minutes].",
    "parent_control": "ac-7",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "After 3 failed password attempts, allow users to authenticate using a different method like a hardware security key, phone app code, or SMS code. However, also limit those alternative attempts to 3 failures within 15 minutes to prevent abuse.",
    "example_implementation": "Implement multi-factor authentication system that activates alternative authentication methods after primary authentication failures. For example, after 3 failed password attempts, present options to authenticate via: FIDO2 hardware token, TOTP authenticator app code, or SMS verification code. Track attempts for alternative methods separately and enforce same failure thresholds (3 attempts per 15 minutes).",
    "non_technical_guidance": "If legitimate users forget their password and get locked out after 3 tries, they can still get in using a backup method like a code from their phone or a security key. But those backup methods also have attempt limits to stop attackers from exploiting them.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-7",
      "IA-2",
      "IA-5",
      "IA-8"
    ],
    "supplemental_guidance": "This control helps balance security with availability for legitimate users. When primary authentication fails repeatedly (possibly due to forgotten password), alternative authentication factors provide account recovery without administrator intervention. However, alternative factors must also be rate-limited to prevent attackers from simply switching to attack the alternative factor. Alternative factors should be cryptographically stronger or phishing-resistant (e.g., FIDO2 hardware tokens, push-based authentication, or TOTP codes) rather than weaker methods. Organizations should log all alternative factor usage for security monitoring.",
    "implementation_scripts": {
      "linux": {},
      "windows": {},
      "_note": "Alternative authentication factor implementation requires multi-factor authentication infrastructure such as Duo Security, Okta, Azure MFA, or open-source solutions like privacyIDEA or FreeOTP. Implementation varies by MFA solution and organizational authentication architecture."
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-20T00:00:00.000000",
      "has_scripts": false,
      "migration_source": "CAC_AC7_LOVELESS_audit",
      "stig_id": "RHEL-08-020024",
      "implementation_note": "Requires multi-factor authentication infrastructure with alternative factor support",
      "qa_verified": true,
      "qa_verification_date": "2025-11-20",
      "qa_agent": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "manual",
      "last_analyzed": "2025-11-20T00:00:00.000000",
      "source": "NIST SP 800-53 Rev 5",
      "implementation_guidance": "Alternative authentication factors require integration with multi-factor authentication systems. Linux PAM can integrate with MFA solutions via pam_duo, pam_oath, or pam_google_authenticator modules. Windows environments typically use Azure MFA or third-party MFA solutions integrated with Active Directory Federation Services."
    },
    "rationale": "Using an alternate authentication factor after failures allows legitimate users to recover access while blocking automated attacks. The alternate factor must also be rate-limited to prevent abuse. This control improves availability for legitimate users while maintaining security against credential stuffing and brute-force attacks. The alternative factor serves as both account recovery mechanism and defense-in-depth measure.",
    "discussion": "Alternative factors should be established during account provisioning or self-service enrollment. Common alternative factors include hardware security keys (FIDO2/U2F), time-based one-time passwords (TOTP from authenticator apps), SMS codes (least secure, susceptible to SIM swapping), push notifications to registered mobile devices, or backup codes. Organizations should avoid using security questions as alternative factors due to their weakness. Alternative factors should be monitored for suspicious patterns (e.g., repeated failed alternative factor attempts from same IP may indicate account takeover attempt).",
    "ai_guidance": "If someone locks their account with failed passwords, let them unlock it using a different method like a phone code or hardware token. But limit those attempts too (3 failures in 15 minutes) so attackers can't just switch to attacking the backup method instead.",
    "stig_id": "RHEL-08-020024"
  },
  {
    "control_id": "AC-8",
    "control_name": "System Use Notification",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "a. Display [Assignment: organization-defined system use notification message or banner] to users before granting access to the system that provides privacy and security notices consistent with applicable laws, Executive Orders, directives, regulations, policies, standards, and guidelines and state that: (1) Users are accessing a U.S. Government system; (2) System usage may be monitored, recorded, and subject to audit; (3) Unauthorized use of the system is prohibited and subject to criminal and civil penalties; and (4) Use of the system indicates consent to monitoring and recording;\nb. Retain the notification message or banner on the screen until users acknowledge the usage conditions and take explicit actions to log on to or further access the system; and\nc. For publicly accessible systems: (1) Display system use information [Assignment: organization-defined conditions], before granting further access to the publicly accessible system; (2) Display references, if any, to monitoring, recording, or auditing that are consistent with privacy accommodations for such systems that generally prohibit those activities; and (3) Include a description of the authorized uses of the system.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Display a system use notification banner before users log in that: (1) warns they're accessing a U.S. Government system, (2) notifies that activity may be monitored and audited, (3) states unauthorized use is prohibited with criminal/civil penalties, and (4) indicates using the system means consenting to monitoring. The banner must remain visible until the user acknowledges it and takes explicit action to proceed. For publicly accessible systems, display appropriate authorized use and monitoring information.",
    "example_implementation": "Configure login banners in /etc/issue, /etc/issue.net, and /etc/motd with DoD-required text. For GUI systems, configure gdm/lightdm banner settings. Ensure banner text includes all four required elements: USG system warning, monitoring notification, penalty warning, and consent statement. Banner must be displayed before authentication and require explicit acknowledgment.",
    "non_technical_guidance": "Develop and publish an official system use notification policy that meets DoD requirements. The notification must inform users they are accessing a U.S. Government system, all activities may be monitored and recorded, unauthorized use is subject to criminal and civil penalties, and continued use constitutes consent to monitoring. Work with legal counsel and privacy office to approve banner text. Train system administrators to properly configure banners on all access points including SSH, console, and GUI logins. For web applications and publicly accessible systems, implement appropriate consent mechanisms compliant with privacy requirements.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "AC-14",
      "PL-4",
      "SI-4"
    ],
    "supplemental_guidance": "System use notifications are implemented using messages or warning banners displayed before individuals log in to systems. System use notifications are used only for access via logon interfaces with human users and are not required when such human interfaces do not exist. Based on an assessment of risk, organizations consider whether or not a secondary system use notification is needed to access applications or other system resources after the initial network logon. Organizations consider system use notification messages or banners displayed in multiple languages based on organizational needs and the demographics of system users. Organizations consult with the privacy office for input regarding privacy messaging and the Office of the General Counsel or organizational equivalent for legal review and approval of warning banner content.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-8 System Use Notification (Linux)\n# Description: Configure DoD-compliant system use notification banners\n# References: NIST SP 800-53 Rev 5 AC-8, STIG RHEL-08-010030\n# Files: /etc/issue, /etc/issue.net, /etc/motd\n\n# DoD-required banner text (full version - 1300 chars)\nBANNER_TEXT=\"You are accessing a U.S. Government (USG) Information System (IS) that is provided for USG-authorized use only. By using this IS (which includes any device attached to this IS), you consent to the following conditions:\n\n-The USG routinely intercepts and monitors communications on this IS for purposes including, but not limited to, penetration testing, COMSEC monitoring, network operations and defense, personnel misconduct (PM), law enforcement (LE), and counterintelligence (CI) investigations.\n\n-At any time, the USG may inspect and seize data stored on this IS.\n\n-Communications using, or data stored on, this IS are not private, are subject to routine monitoring, interception, and search, and may be disclosed or used for any USG-authorized purpose.\n\n-This IS includes security measures (e.g., authentication and access controls) to protect USG interests--not for your personal benefit or privacy.\n\n-Notwithstanding the above, using this IS does not constitute consent to PM, LE or CI investigative searching or monitoring of the content of privileged communications, or work product, related to personal representation or services by attorneys, psychotherapists, or clergy, and their assistants. Such communications and work product are private and confidential. See User Agreement for details.\"\n\n# Alternative short banner for limited display devices (50 chars)\n# BANNER_TEXT=\"I've read & consent to terms in IS user agreem't.\"\n\necho \"[AC-8] Configuring system use notification banners...\"\n\n# Backup existing files\nfor file in /etc/issue /etc/issue.net /etc/motd; do\n    if [ -f \"$file\" ]; then\n        cp \"$file\" \"${file}.backup.$(date +%Y%m%d_%H%M%S)\"\n        echo \"  Backed up $file\"\n    fi\ndone\n\n# Configure banners\necho \"$BANNER_TEXT\" > /etc/issue\necho \"  Configured /etc/issue\"\n\necho \"$BANNER_TEXT\" > /etc/issue.net\necho \"  Configured /etc/issue.net\"\n\necho \"$BANNER_TEXT\" > /etc/motd\necho \"  Configured /etc/motd\"\n\n# Set proper permissions\nchmod 644 /etc/issue /etc/issue.net /etc/motd\nchown root:root /etc/issue /etc/issue.net /etc/motd\n\necho \"[AC-8] System use notification banners configured successfully.\"\necho \"[AC-8] Verification: cat /etc/issue\"\n",
        "ansible": "---\n- name: AC-8 System Use Notification - DoD Compliance\n  hosts: all\n  become: yes\n  vars:\n    # DoD-required banner text (full version)\n    dod_banner_text: |\n      You are accessing a U.S. Government (USG) Information System (IS) that is provided for USG-authorized use only. By using this IS (which includes any device attached to this IS), you consent to the following conditions:\n\n      -The USG routinely intercepts and monitors communications on this IS for purposes including, but not limited to, penetration testing, COMSEC monitoring, network operations and defense, personnel misconduct (PM), law enforcement (LE), and counterintelligence (CI) investigations.\n\n      -At any time, the USG may inspect and seize data stored on this IS.\n\n      -Communications using, or data stored on, this IS are not private, are subject to routine monitoring, interception, and search, and may be disclosed or used for any USG-authorized purpose.\n\n      -This IS includes security measures (e.g., authentication and access controls) to protect USG interests--not for your personal benefit or privacy.\n\n      -Notwithstanding the above, using this IS does not constitute consent to PM, LE or CI investigative searching or monitoring of the content of privileged communications, or work product, related to personal representation or services by attorneys, psychotherapists, or clergy, and their assistants. Such communications and work product are private and confidential. See User Agreement for details.\n\n  tasks:\n    - name: Backup existing banner files\n      copy:\n        src: \"{{ item }}\"\n        dest: \"{{ item }}.backup.{{ ansible_date_time.epoch }}\"\n        remote_src: yes\n      loop:\n        - /etc/issue\n        - /etc/issue.net\n        - /etc/motd\n      ignore_errors: yes\n      tags:\n        - ac-8\n        - backup\n\n    - name: Configure /etc/issue with DoD banner\n      copy:\n        content: \"{{ dod_banner_text }}\"\n        dest: /etc/issue\n        owner: root\n        group: root\n        mode: '0644'\n      tags:\n        - ac-8\n        - banner\n\n    - name: Configure /etc/issue.net with DoD banner\n      copy:\n        content: \"{{ dod_banner_text }}\"\n        dest: /etc/issue.net\n        owner: root\n        group: root\n        mode: '0644'\n      tags:\n        - ac-8\n        - banner\n\n    - name: Configure /etc/motd with DoD banner\n      copy:\n        content: \"{{ dod_banner_text }}\"\n        dest: /etc/motd\n        owner: root\n        group: root\n        mode: '0644'\n      tags:\n        - ac-8\n        - banner\n\n    - name: Verify banner configuration\n      command: cat /etc/issue\n      register: banner_check\n      changed_when: false\n      tags:\n        - ac-8\n        - verify\n\n    - name: Display banner verification\n      debug:\n        msg: \"Banner configured successfully. Length: {{ banner_check.stdout | length }} characters\"\n      tags:\n        - ac-8\n        - verify\n",
        "verification": "#!/bin/bash\n# AC-8 Verification Script\n# Validates system use notification banner compliance\n\necho \"[AC-8 VERIFICATION] Checking system use notification banners...\"\necho \"\"\n\nERRORS=0\n\n# Required files\nFILES=(\"/etc/issue\" \"/etc/issue.net\" \"/etc/motd\")\n\n# Required text elements (all must be present)\nREQUIRED_ELEMENTS=(\n    \"U.S. Government\"\n    \"USG-authorized use only\"\n    \"consent to the following conditions\"\n    \"monitors communications\"\n    \"inspect and seize data\"\n    \"not private\"\n    \"subject to routine monitoring\"\n    \"criminal and civil penalties\"\n)\n\nfor file in \"${FILES[@]}\"; do\n    echo \"Checking $file...\"\n    \n    if [ ! -f \"$file\" ]; then\n        echo \"  [FAIL] File does not exist\"\n        ((ERRORS++))\n        continue\n    fi\n    \n    # Check permissions\n    PERMS=$(stat -c \"%a\" \"$file\")\n    if [ \"$PERMS\" != \"644\" ]; then\n        echo \"  [WARN] Incorrect permissions: $PERMS (expected 644)\"\n    fi\n    \n    # Check ownership\n    OWNER=$(stat -c \"%U:%G\" \"$file\")\n    if [ \"$OWNER\" != \"root:root\" ]; then\n        echo \"  [WARN] Incorrect ownership: $OWNER (expected root:root)\"\n    fi\n    \n    # Check for required text elements\n    MISSING=0\n    for element in \"${REQUIRED_ELEMENTS[@]}\"; do\n        if ! grep -q \"$element\" \"$file\"; then\n            echo \"  [FAIL] Missing required text: '$element'\"\n            ((ERRORS++))\n            ((MISSING++))\n        fi\n    done\n    \n    if [ $MISSING -eq 0 ]; then\n        echo \"  [PASS] All required elements present\"\n    fi\n    \n    # Check length (DoD full banner should be ~1300 chars)\n    LENGTH=$(wc -c < \"$file\")\n    echo \"  Banner length: $LENGTH characters\"\n    \n    if [ $LENGTH -lt 100 ]; then\n        echo \"  [WARN] Banner appears too short (< 100 chars)\"\n    fi\n    \n    echo \"\"\ndone\n\nif [ $ERRORS -eq 0 ]; then\n    echo \"[AC-8 VERIFICATION] PASSED - All checks successful\"\n    exit 0\nelse\n    echo \"[AC-8 VERIFICATION] FAILED - $ERRORS error(s) found\"\n    exit 1\nfi\n"
      },
      "windows": {},
      "_note": "DoD-compliant banner configuration per NIST SP 800-53 Rev 5 AC-8 and STIG RHEL-08-010030. Banner text includes all four required elements: USG system notification, monitoring disclosure, penalty warning, and consent statement. Verification script included to validate compliance."
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00.000000+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010030",
      "cce_id": "CCE-80763-6"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-20T00:00:00.000000+00:00",
      "source": "ComplianceAsCode",
      "cac_rules": [
        "banner_etc_issue",
        "banner_etc_issue_net",
        "banner_etc_motd"
      ],
      "verification_method": "Script validates presence of all required DoD banner elements in /etc/issue, /etc/issue.net, and /etc/motd"
    },
    "ai_guidance": "Configure system login banners with the complete DoD-required notification text that includes: (1) U.S. Government system warning, (2) monitoring and recording notification, (3) unauthorized use penalties, and (4) consent to monitoring statement. The banner must be displayed before granting access and remain visible until the user takes explicit action to proceed. Use the provided bash or ansible scripts to configure /etc/issue, /etc/issue.net, and /etc/motd with the complete 1300-character DoD banner text. For space-constrained systems, use the short form: 'I've read & consent to terms in IS user agreem't.' Run the verification script to validate compliance.",
    "stig_id": "RHEL-08-010030"
  },
  {
    "control_id": "AC-9",
    "control_name": "Previous Logon Notification",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Notify the user, upon successful logon to the system, of the date and time of the last logon.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Let users know when they last logged into the system after they successfully log in.",
    "example_implementation": "This script sets up automated notifications or alerts to inform users of their previous logon date and time whenever they access the system.",
    "non_technical_guidance": "This plan to implement the \"Previous Logon Notification\" control for NIST 800-53 compliance, you can create a policy that requires users to be notified upon successful logon to the system of the date and time of their last logon. This can be achieved through user training and awareness programs to inform them of the importance of this notification and to encourage them to pay attention to it. Additionally, you can establish procedures for system administrators to manually provide this information to users upon request. Regularly review logs and monitor user logon activities to ensure compliance with this control.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "ac-9.1",
        "title": "Unsuccessful Logons",
        "official_text": "Notify the user, upon successful logon, of the number of unsuccessful logon attempts since the last successful logon.",
        "metadata": {
          "stig_id": "RHEL-08-010091"
        },
        "ai_guidance": "Enhance security by applying specific controls for Unsuccessful Logons."
      },
      {
        "id": "ac-9.2",
        "title": "Successful and Unsuccessful Logons",
        "official_text": "Notify the user, upon successful logon, of the number of [notification message] during [time period].",
        "metadata": {
          "stig_id": "RHEL-08-010092"
        },
        "ai_guidance": "Enhance security by applying specific controls for Successful and Unsuccessful Logons."
      },
      {
        "id": "ac-9.3",
        "title": "Notification of Account Changes",
        "official_text": "Notify the user, upon successful logon, of changes to [re-authentication] during [time period].",
        "metadata": {
          "stig_id": "RHEL-08-010093"
        },
        "ai_guidance": "Enhance security by applying specific controls for Notification of Account Changes."
      },
      {
        "id": "ac-9.4",
        "title": "Additional Logon Information",
        "official_text": "Notify the user, upon successful logon, of the following additional information: [additional authentication].",
        "metadata": {
          "stig_id": "RHEL-08-010094"
        },
        "ai_guidance": "Enhance security by applying specific controls for Additional Logon Information."
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-09T21:34:53.460144+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010090"
    },
    "cac_metadata": {
      "implementation_type": "administrative",
      "last_analyzed": "2025-11-10T09:40:19.991251+00:00",
      "source": "ComplianceAsCode",
      "implementation_guidance": "This control requires manual implementation and verification. Automated scripts not applicable."
    },
    "ai_guidance": "Implement and enforce Previous Logon Notification according to organization policies to ensure access is strictly controlled.",
    "implementation_guidance": "This control is implemented via organizational policy and architectural design. Refer to the Policy Guidance tab.",
    "stig_id": "RHEL-08-010090"
  },
  {
    "control_id": "AC-9.1",
    "control_name": "Unsuccessful Logons",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Notify the user, upon successful logon, of the number of unsuccessful logon attempts since the last successful logon.",
    "parent_control": "ac-9",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Notify the user, upon successful logon, of the number of unsuccessful logon attempts since the last successful logon.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142423+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010091"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:40:21.527053+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Unsuccessful Logons according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010091"
  },
  {
    "control_id": "AC-9.2",
    "control_name": "Successful and Unsuccessful Logons",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Notify the user, upon successful logon, of the number of [notification message] during [time period].",
    "parent_control": "ac-9",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Notify the user, upon successful logon, of the number of [notification message] during [time period].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142436+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010092"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:40:23.095975+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Successful and Unsuccessful Logons according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010092"
  },
  {
    "control_id": "AC-9.3",
    "control_name": "Notification of Account Changes",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Notify the user, upon successful logon, of changes to [re-authentication] during [time period].",
    "parent_control": "ac-9",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Notify the user, upon successful logon, of changes to [re-authentication] during [time period].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142450+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010093"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:40:24.783200+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Notification of Account Changes according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010093"
  },
  {
    "control_id": "AC-9.4",
    "control_name": "Additional Logon Information",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Notify the user, upon successful logon, of the following additional information: [additional authentication].",
    "parent_control": "ac-9",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Notify the user, upon successful logon, of the following additional information: [additional authentication].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.142464+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010094"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:40:26.398886+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Additional Logon Information according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010094"
  },
  {
    "control_id": "AC-10",
    "control_name": "Concurrent Session Control",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Limit the number of concurrent sessions for each [Assignment: organization-defined account and/or account type] to [Assignment: organization-defined number].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "This control limits how many simultaneous login sessions a user can have active at the same time. Organizations define maximum session counts per account type (e.g., administrators may be limited to 3 sessions, regular users to 2). This prevents resource exhaustion from excessive concurrent logins and reduces attack surface by limiting lateral movement opportunities.",
    "example_implementation": "On Linux systems, configure the PAM limits module by editing /etc/security/limits.conf or creating a file in /etc/security/limits.d/. Add the line: '* hard maxlogins 10' to limit all users to 10 concurrent sessions. For privileged accounts, create separate entries like 'admin hard maxlogins 3' to restrict administrators to 3 sessions. The system enforces these limits through the pam_limits.so module during authentication. Verify configuration with: grep -r maxlogins /etc/security/limits.conf /etc/security/limits.d/",
    "non_technical_guidance": "To comply with AC-10:\n1. Define organizational policy for maximum concurrent sessions per account type (e.g., administrators: 3 sessions, standard users: 10 sessions, service accounts: 1 session).\n2. Document these limits in your access control policy with business justification.\n3. Configure operating systems to enforce these technical limits using PAM (Linux) or Group Policy (Windows).\n4. Monitor session usage patterns to detect anomalies (e.g., users consistently hitting limits may indicate compromised credentials).\n5. Review and adjust limits quarterly based on operational needs and security incidents.\n6. Train users on why session limits exist and how to properly manage their active sessions.\n7. Implement automated alerts when users approach or exceed session limits.\n8. Audit configuration quarterly to ensure technical controls match documented policy.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "SC-23",
      "AC-2",
      "AC-3",
      "AC-6",
      "IA-2"
    ],
    "supplemental_guidance": "Organizations may define the maximum number of concurrent sessions for system accounts globally, by account type (e.g., privileged user, non-privileged user, domain, specific application), by account, or a combination. For example, organizations may limit the number of concurrent sessions for system administrators or individuals working in particularly sensitive domains or mission-critical applications. This control addresses concurrent sessions for system accounts and does not address concurrent sessions by single users via multiple system accounts. Session limits help prevent denial-of-service conditions caused by excessive login attempts and reduce the attack surface available to compromised credentials.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# Platform: Red Hat Virtualization 4, multi_platform_ol, multi_platform_rhel, multi_platform_ubuntu, multi_platform_sle, multi_platform_slmicro, multi_platform_almalinux\n# Set the maximum number of concurrent login sessions per user\n# Default value: 10 (adjust as needed)\n\nVAR_ACCOUNTS_MAX_CONCURRENT_LOGIN_SESSIONS=10\n\n# Check if maxlogins is configured in /etc/security/limits.d/*.conf\nif grep -q '^[^#]*\\<maxlogins\\>' /etc/security/limits.d/*.conf 2>/dev/null; then\n    sed -i \"/^[^#]*\\<maxlogins\\>/ s/maxlogins.*/maxlogins $VAR_ACCOUNTS_MAX_CONCURRENT_LOGIN_SESSIONS/\" /etc/security/limits.d/*.conf\n    echo \"Updated maxlogins in /etc/security/limits.d/*.conf\"\nelif grep -q '^[^#]*\\<maxlogins\\>' /etc/security/limits.conf 2>/dev/null; then\n    sed -i \"/^[^#]*\\<maxlogins\\>/ s/maxlogins.*/maxlogins $VAR_ACCOUNTS_MAX_CONCURRENT_LOGIN_SESSIONS/\" /etc/security/limits.conf\n    echo \"Updated maxlogins in /etc/security/limits.conf\"\nelse\n    echo \"*    hard    maxlogins    $VAR_ACCOUNTS_MAX_CONCURRENT_LOGIN_SESSIONS\" >> /etc/security/limits.conf\n    echo \"Added maxlogins to /etc/security/limits.conf\"\nfi\n\n# Verify configuration\necho \"\\nVerifying configuration:\"\ngrep -r '^[^#]*maxlogins' /etc/security/limits.conf /etc/security/limits.d/*.conf 2>/dev/null || echo \"Configuration not found\"\n\n# Note: Changes take effect on next login",
        "ansible": "---\n# Platform: Red Hat Virtualization 4, multi_platform_fedora, multi_platform_ol, multi_platform_rhel, multi_platform_sle, multi_platform_slmicro, multi_platform_almalinux\n# Reboot: false\n# Strategy: restrict\n# Complexity: low\n# Disruption: low\n\n- name: Set maximum concurrent login sessions variable\n  set_fact:\n    var_accounts_max_concurrent_login_sessions: 10\n\n- name: Find /etc/security/limits.d files containing maxlogins configuration\n  ansible.builtin.find:\n    paths: \"/etc/security/limits.d\"\n    contains: '^[\\s]*\\*[\\s]+(?:(?:hard)|(?:-))[\\s]+maxlogins'\n    patterns: \"*.conf\"\n  register: maxlogins_files\n\n- name: Limit concurrent sessions in limits.d files\n  ansible.builtin.replace:\n    dest: \"{{ item.path }}\"\n    regexp: \"^#?\\\\*.*maxlogins.*\"\n    replace: \"*          hard    maxlogins     {{ var_accounts_max_concurrent_login_sessions }}\"\n  with_items:\n    - \"{{ maxlogins_files.files }}\"\n  when: maxlogins_files.matched > 0\n\n- name: Limit concurrent sessions in limits.conf\n  ansible.builtin.lineinfile:\n    state: present\n    dest: /etc/security/limits.conf\n    insertbefore: \"^# End of file\"\n    regexp: \"^#?\\\\*.*maxlogins\"\n    line: \"*          hard    maxlogins     {{ var_accounts_max_concurrent_login_sessions }}\"\n    create: yes\n  when: maxlogins_files.matched == 0\n\n- name: Verify maxlogins configuration\n  ansible.builtin.shell: |\n    grep -r '^[^#]*maxlogins' /etc/security/limits.conf /etc/security/limits.d/*.conf 2>/dev/null\n  register: verification\n  changed_when: false\n  failed_when: false\n\n- name: Display configuration\n  ansible.builtin.debug:\n    msg: \"{{ verification.stdout_lines }}\""
      },
      "windows": {}
    },
    "metadata": {
      "status": "automated",
      "last_updated": "2025-11-20T00:00:00+00:00",
      "has_scripts": true,
      "stig_id": "OL08-00-020024",
      "severity": "low",
      "cce_identifiers": {
        "rhel8": "CCE-80955-8",
        "rhel9": "CCE-83641-1",
        "rhel10": "CCE-90751-9",
        "sle12": "CCE-83065-3",
        "sle15": "CCE-85555-1"
      }
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T00:00:00+00:00",
      "source": "ComplianceAsCode",
      "rule_id": "accounts_max_concurrent_login_sessions",
      "srg_mapping": "SRG-OS-000027-GPOS-00008",
      "platforms": [
        "package[pam]",
        "system_with_kernel"
      ],
      "supported_os": [
        "Red Hat Enterprise Linux 8",
        "Red Hat Enterprise Linux 9",
        "Red Hat Enterprise Linux 10",
        "Ubuntu 22.04",
        "Ubuntu 24.04",
        "SUSE Linux Enterprise 12",
        "SUSE Linux Enterprise 15",
        "Oracle Linux 7",
        "Oracle Linux 8",
        "AlmaLinux 9"
      ],
      "implementation_guidance": "Configure /etc/security/limits.conf or /etc/security/limits.d/*.conf with 'maxlogins' parameter. The pam_limits.so module must be enabled in PAM configuration. Recommended value: 10 for general users, 3 for privileged accounts.",
      "validation_method": "OVAL check verifies maxlogins parameter in limits configuration files and ensures value is at or below defined maximum.",
      "remediation_complexity": "low",
      "remediation_disruption": "low",
      "requires_reboot": false
    },
    "rationale": "Limiting simultaneous user logins can insulate the system from denial of service problems caused by excessive logins. Automated login processes operating improperly or maliciously may result in an exceptional number of simultaneous login sessions. By restricting concurrent sessions, organizations reduce the attack surface available to compromised credentials and limit the potential for lateral movement within the network. This control is particularly important for privileged accounts where concurrent sessions may indicate credential sharing or compromise.",
    "ai_guidance": "Set /etc/security/limits.conf to limit user sessions with '* hard maxlogins 10'. Adjust the number based on account type - administrators get 3, regular users get 10.",
    "compliance_mappings": {
      "nist": [
        "AC-10",
        "CM-6(a)"
      ],
      "srg": [
        "SRG-OS-000027-GPOS-00008"
      ],
      "cjis": [
        "5.5.2.2"
      ],
      "nerc_cip": [
        "CIP-007-3 R5.1",
        "CIP-007-3 R5.1.2"
      ],
      "iso27001_2013": [
        "A.13.1.1",
        "A.13.1.3",
        "A.13.2.1",
        "A.14.1.2",
        "A.14.1.3"
      ],
      "cis_csc": [
        "14",
        "15",
        "18",
        "9"
      ],
      "cobit5": [
        "DSS01.05",
        "DSS05.02"
      ],
      "isa_62443_2009": [
        "4.3.3.4"
      ],
      "isa_62443_2013": [
        "SR 3.1",
        "SR 3.8"
      ],
      "nist_csf": [
        "PR.AC-5"
      ]
    },
    "test_scenarios": {
      "pass": [
        "maxlogins set to 1 in limits.conf",
        "maxlogins set to 10 in limits.d/custom.conf",
        "maxlogins set to value <= organizational maximum"
      ],
      "fail": [
        "maxlogins not configured",
        "maxlogins set to 1000 (exceeds reasonable limit)",
        "maxlogins commented out in configuration files"
      ]
    },
    "operational_considerations": {
      "default_value": 10,
      "recommended_values": {
        "privileged_users": 3,
        "non_privileged_users": 10,
        "service_accounts": 1,
        "administrators": 3
      },
      "monitoring": "Monitor PAM logs for 'maxlogins' rejections in /var/log/secure or /var/log/auth.log. Excessive rejections may indicate compromised credentials or legitimate users needing limit adjustment.",
      "exceptions": "Service accounts requiring high availability may need higher limits. Document exceptions with business justification and compensating controls.",
      "testing": "Test with: 'su - testuser' multiple times from different terminals. Verify that logins beyond the limit are rejected with 'Too many logins for user' message."
    },
    "stig_id": "OL08-00-020024"
  },
  {
    "control_id": "AC-11",
    "control_name": "Device Lock",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Device Lock ensures that devices automatically lock after a period of inactivity to prevent unauthorized access.",
    "example_implementation": "This script sets up screen lock settings on all devices and require users to use strong passwords or biometric authentication to unlock them. Regularly review and enforce this policy to ensure compliance.",
    "non_technical_guidance": "This plan to ensure compliance with Control ID ac-11 (Device Lock), you should implement the following steps:\n1. Set the screensaver lock delay to a specified time (e.g., 5 minutes) to prompt for a password after the screensaver activates.\n2. Enable the screensaver lock to require a password to unlock the device.\n3. Communicate and enforce the policy of locking devices when not in use to all employees.\n4. Regularly monitor and audit compliance with the device lock policy to ensure effectiveness.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "ac-11.1",
        "title": "Pattern-hiding Displays",
        "official_text": "Conceal, via the device lock, information previously visible on the display with a publicly viewable image.",
        "metadata": {
          "stig_id": "RHEL-08-010111"
        },
        "ai_guidance": "Enhance security by applying specific controls for Pattern-hiding Displays."
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {
        "powershell": "# AC-11 Session Lock (Windows)\n# Description: Configure screen saver timeout to 15 minutes (900 seconds) and require password.\n\n$Path = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n$Name = \"InactivityTimeoutSecs\"\n$Value = 900\n\nif (!(Test-Path $Path)) {\n    New-Item -Path $Path -Force\n}\n\nSet-ItemProperty -Path $Path -Name $Name -Value $Value -Force\n\nWrite-Host \"Session lock timeout set to $Value seconds.\"\n"
      },
      "_note": "Added screen lock registry config."
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-09T12:31:24.140408+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010110"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-10T09:36:42.845879+00:00",
      "source": "ComplianceAsCode"
    },
    "ai_guidance": "Implement and enforce Device Lock according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010110"
  },
  {
    "control_id": "AC-11.1",
    "control_name": "Pattern-hiding Displays",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Conceal, via the device lock, information previously visible on the display with a publicly viewable image.",
    "parent_control": "ac-11",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Conceal, via the device lock, information previously visible on the display with a publicly viewable image.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {
        "powershell": "# AC-11(1) Pattern-Hiding Displays\n# Description: Ensure screen saver is secure and password protected\n\n# Enable screen saver\nSet-ItemProperty -Path \"HKCU:\\Control Panel\\Desktop\" -Name \"ScreenSaveActive\" -Value \"1\"\n\n# Enable password protection\nSet-ItemProperty -Path \"HKCU:\\Control Panel\\Desktop\" -Name \"ScreenSaverIsSecure\" -Value \"1\"\n\nWrite-Host \"Screen saver security configured.\"\n"
      }
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140430+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010111"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:36:44.371507+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Pattern-hiding Displays according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010111"
  },
  {
    "control_id": "AC-12",
    "control_name": "Session Termination",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Automatically terminate a user session after [session termination timeout (e.g., 15m)].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Automatically log out users after a certain period of inactivity.",
    "example_implementation": "This script sets up a system that will automatically log out users after a specified amount of time of inactivity to ensure that sessions are not left open and vulnerable to unauthorized access.",
    "non_technical_guidance": "This plan to comply with Control ID ac-12, you can set the session timeout for user sessions to automatically terminate after a specified period of inactivity. This can help reduce the risk of unauthorized access to systems and sensitive information. To implement this control, you can configure the session timeout settings in the operating system's configuration files. For Linux systems, you can edit the /etc/profile file and add the line \"TMOUT={{ insert: param, ac-12_odp }}\" to set the session timeout. For Windows systems, you can use the Registry Editor to create a new DWORD value named \"InactivityTimeoutSecs\" under HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\System and set the value to the desired timeout period in seconds. Regularly review and update the session timeout settings to ensure continued compliance with this control.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "ac-12.1",
        "title": "User-initiated Logouts",
        "official_text": "Provide a logout capability for user-initiated communications sessions whenever authentication is used to gain access to [user-initiated logout].",
        "metadata": {
          "stig_id": "RHEL-08-010121"
        },
        "ai_guidance": "Enhance security by applying specific controls for User-initiated Logouts."
      },
      {
        "id": "ac-12.2",
        "title": "Termination Message",
        "official_text": "Display an explicit logout message to users indicating the termination of authenticated communications sessions.",
        "metadata": {
          "stig_id": "RHEL-08-010122"
        },
        "ai_guidance": "Enhance security by applying specific controls for Termination Message."
      },
      {
        "id": "ac-12.3",
        "title": "Timeout Warning Message",
        "official_text": "Display an explicit message to users indicating that the session will end in [logout message].",
        "metadata": {
          "stig_id": "RHEL-08-010123"
        },
        "ai_guidance": "Enhance security by applying specific controls for Timeout Warning Message."
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-12 Session Termination (Linux)\n# Description: Configure shell timeout (TMOUT) to 15 minutes.\n\nPROFILE_D_FILE=\"/etc/profile.d/tmout.sh\"\n\necho \"Configuring TMOUT...\"\n\necho \"readonly TMOUT=900\" > \"$PROFILE_D_FILE\"\necho \"export TMOUT\" >> \"$PROFILE_D_FILE\"\nchmod 644 \"$PROFILE_D_FILE\"\n\necho \"Session termination configured.\"\n",
        "ansible": "---\n- name: AC-12 Session Termination\n  hosts: all\n  tasks:\n    - name: Configure TMOUT in /etc/profile.d\n      copy:\n        dest: /etc/profile.d/tmout.sh\n        content: |\n          readonly TMOUT=900\n          export TMOUT\n        mode: '0644'\n"
      },
      "windows": {},
      "_note": "Added TMOUT configuration."
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-10T23:32:37.968482",
      "has_scripts": true,
      "migration_source": "CAC_AC12_AC17_family_migration",
      "stig_id": "RHEL-08-010120"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:36:45.925706+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Session Termination according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010120"
  },
  {
    "control_id": "AC-12.1",
    "control_name": "User-initiated Logouts",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Provide a logout capability for user-initiated communications sessions whenever authentication is used to gain access to [user-initiated logout].",
    "parent_control": "ac-12",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Provide a logout capability for user-initiated communications sessions whenever authentication is used to gain access to [user-initiated logout].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140465+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010121"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:36:47.465724+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce User-initiated Logouts according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010121"
  },
  {
    "control_id": "AC-12.2",
    "control_name": "Termination Message",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Display an explicit logout message to users indicating the termination of authenticated communications sessions.",
    "parent_control": "ac-12",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Display an explicit logout message to users indicating the termination of authenticated communications sessions.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140480+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010122"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:36:48.986502+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Termination Message according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010122"
  },
  {
    "control_id": "AC-12.3",
    "control_name": "Timeout Warning Message",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Display an explicit message to users indicating that the session will end in [logout message].",
    "parent_control": "ac-12",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Display an explicit message to users indicating that the session will end in [logout message].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140494+00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-010123"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:36:50.512760+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Timeout Warning Message according to organization policies to ensure access is strictly controlled.",
    "stig_id": "RHEL-08-010123"
  },
  {
    "control_id": "AC-14",
    "control_name": "Permitted Actions Without Identification or Authentication",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "a. Identify [Assignment: organization-defined user actions] that can be performed on the system without identification or authentication consistent with organizational mission and business functions; and\n\nb. Document and provide supporting rationale in the security plan for the system, user actions not requiring identification or authentication.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This control requires organizations to explicitly identify and document which actions (if any) users can perform on a system without logging in. Examples might include viewing a public website or accessing a publicly available knowledge base. The organization must document these permitted unauthenticated actions and explain why authentication is not required for them. Organizations may determine that NO actions should be permitted without authentication, in which case the assignment value would be 'none'.",
    "example_implementation": "1. Create an organizational policy document listing all permitted unauthenticated actions (e.g., 'Public website viewing on www.example.gov', 'Access to public FAQs', or 'None - all actions require authentication').\n2. Document the business justification for each permitted action in the system security plan.\n3. Configure systems to disable guest accounts and anonymous access mechanisms unless explicitly authorized:\n   - Disable GDM guest login (TimedLoginEnable=false)\n   - Disable SELinux guest_exec_content boolean\n   - Remove R-services trust files that permit unauthenticated access\n   - Restrict anonymous FTP access\n4. Implement technical controls to enforce the documented policy.\n5. Review and update the permitted actions list annually or when mission changes.",
    "non_technical_guidance": "To comply with AC-14, organizations must:\n1. Conduct a mission analysis to determine if any user actions should be permitted without authentication (e.g., public website access, emergency information hotlines).\n2. Document each permitted unauthenticated action with clear business justification in the system security plan.\n3. If no actions warrant unauthenticated access, explicitly document 'None' as the assignment value.\n4. Ensure technical controls prevent any unauthenticated actions not explicitly documented and approved.\n5. Establish a review process to reassess permitted unauthenticated actions annually.\n6. Train administrators on the difference between public access and bypassing authentication for organizational users.\n7. Coordinate with legal and privacy teams to ensure public access compliance with applicable regulations.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-8",
      "IA-2",
      "PL-2"
    ],
    "supplemental_guidance": "Organizations may permit limited user actions without identification or authentication when organizational determination indicates that identification and authentication are not required for specified user actions. Organizations identify actions that normally require identification or authentication but may, under certain circumstances, allow identification or authentication mechanisms to be bypassed. Examples include when individuals access public websites or other publicly accessible federal information systems, when individuals use mobile phones to receive calls, or when facsimiles are received. Organizations may also decide to bypass identification or authentication via software-readable physical switch that commands bypass of the logon functionality and is protected from accidental or unmonitored use. This control addresses situations where identification and authentication have not yet occurred and is not intended to apply to situations where identification and authentication have already occurred and are subsequently bypassed. Organizations may determine that there are no user actions that can be performed on organizational systems without identification and authentication, and therefore, the value for the assignment operation can be 'none.'",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-14: Permitted Actions Without Identification or Authentication\n# Purpose: Verify guest accounts and anonymous access mechanisms are disabled\n# unless explicitly documented in organizational policy\n\necho \"=== AC-14 Compliance Check ===\"\necho \"\"\n\n# Check 1: GDM Guest Login Status\necho \"[CHECK 1] GDM Guest Login Configuration\"\nif [ -f /etc/gdm/custom.conf ]; then\n    if grep -Pzoi \"^\\[daemon]\\nTimedLoginEnable=false\" /etc/gdm/custom.conf > /dev/null; then\n        echo \"  [PASS] GDM guest/timed login is disabled\"\n    else\n        echo \"  [FAIL] GDM guest/timed login may be enabled\"\n        echo \"  ACTION: Set TimedLoginEnable=false in /etc/gdm/custom.conf\"\n    fi\nelse\n    echo \"  [INFO] GDM not installed or custom.conf not found\"\nfi\necho \"\"\n\n# Check 2: SELinux Guest Execution Boolean\necho \"[CHECK 2] SELinux Guest Execution Control\"\nif command -v getsebool > /dev/null 2>&1; then\n    GUEST_EXEC=$(getsebool guest_exec_content 2>/dev/null | awk '{print $3}')\n    if [ \"$GUEST_EXEC\" = \"off\" ]; then\n        echo \"  [PASS] SELinux guest_exec_content is disabled\"\n    else\n        echo \"  [FAIL] SELinux guest_exec_content is enabled\"\n        echo \"  ACTION: Run 'setsebool -P guest_exec_content off'\"\n    fi\nelse\n    echo \"  [INFO] SELinux not available or not enforcing\"\nfi\necho \"\"\n\n# Check 3: R-Services Trust Files (permit unauthenticated access)\necho \"[CHECK 3] R-Services Unauthenticated Access Files\"\nRHOSTS_COUNT=$(find /home -name .rhosts 2>/dev/null | wc -l)\nif [ -f /etc/hosts.equiv ]; then\n    echo \"  [FAIL] /etc/hosts.equiv exists (permits unauthenticated rsh access)\"\n    echo \"  ACTION: Remove with 'sudo rm /etc/hosts.equiv'\"\nelif [ $RHOSTS_COUNT -gt 0 ]; then\n    echo \"  [FAIL] Found $RHOSTS_COUNT .rhosts files in user home directories\"\n    echo \"  ACTION: Remove all .rhosts files\"\nelse\n    echo \"  [PASS] No R-services trust files found\"\nfi\necho \"\"\n\n# Check 4: Anonymous FTP (if vsftpd installed)\necho \"[CHECK 4] Anonymous FTP Access\"\nif [ -f /etc/vsftpd/vsftpd.conf ]; then\n    ANON_ENABLED=$(grep -i \"^anonymous_enable\" /etc/vsftpd/vsftpd.conf 2>/dev/null | grep -i \"YES\")\n    if [ -z \"$ANON_ENABLED\" ]; then\n        echo \"  [PASS] Anonymous FTP appears disabled\"\n    else\n        echo \"  [WARN] Anonymous FTP is enabled\"\n        echo \"  ACTION: Verify this is documented in organizational AC-14 policy\"\n    fi\nelse\n    echo \"  [INFO] vsftpd not installed\"\nfi\necho \"\"\n\n# Summary\necho \"=== AC-14 POLICY REMINDER ===\"\necho \"Organizations MUST document all permitted unauthenticated actions.\"\necho \"If no actions are permitted without authentication, document 'None'.\"\necho \"Review organizational security plan to verify AC-14 compliance.\"\necho \"\"\n",
        "ansible": "---\n# AC-14: Permitted Actions Without Identification or Authentication\n# Purpose: Enforce restriction of guest accounts and anonymous access\n- name: AC-14 Compliance Enforcement\n  hosts: all\n  become: yes\n  tasks:\n\n    - name: Disable GDM guest/timed login\n      lineinfile:\n        path: /etc/gdm/custom.conf\n        regexp: '^TimedLoginEnable='\n        line: 'TimedLoginEnable=false'\n        insertafter: '\\[daemon\\]'\n        create: no\n      when: ansible_facts['os_family'] == 'RedHat'\n      notify: Restart GDM\n\n    - name: Disable SELinux guest_exec_content boolean\n      seboolean:\n        name: guest_exec_content\n        state: no\n        persistent: yes\n      when: ansible_selinux.status == 'enabled'\n\n    - name: Remove R-services trust files - /etc/hosts.equiv\n      file:\n        path: /etc/hosts.equiv\n        state: absent\n\n    - name: Find and remove user .rhosts files\n      find:\n        paths: /home\n        patterns: '.rhosts'\n        hidden: yes\n        recurse: no\n      register: rhosts_files\n\n    - name: Remove found .rhosts files\n      file:\n        path: \"{{ item.path }}\"\n        state: absent\n      loop: \"{{ rhosts_files.files }}\"\n      when: rhosts_files.matched > 0\n\n    - name: Verify vsftpd anonymous access disabled\n      lineinfile:\n        path: /etc/vsftpd/vsftpd.conf\n        regexp: '^anonymous_enable'\n        line: 'anonymous_enable=NO'\n        state: present\n      when: \"'vsftpd' in ansible_facts.packages\"\n      notify: Restart vsftpd\n\n  handlers:\n    - name: Restart GDM\n      service:\n        name: gdm\n        state: restarted\n\n    - name: Restart vsftpd\n      service:\n        name: vsftpd\n        state: restarted\n"
      },
      "windows": {
        "powershell": "# AC-14: Permitted Actions Without Identification or Authentication\n# Purpose: Verify guest accounts are disabled on Windows systems\n\nWrite-Host \"=== AC-14 Compliance Check (Windows) ===\" -ForegroundColor Cyan\nWrite-Host \"\"\n\n# Check Guest Account Status\nWrite-Host \"[CHECK] Guest Account Status\" -ForegroundColor Yellow\n$GuestAccount = Get-LocalUser -Name \"Guest\" -ErrorAction SilentlyContinue\nif ($GuestAccount) {\n    if ($GuestAccount.Enabled) {\n        Write-Host \"  [FAIL] Guest account is ENABLED\" -ForegroundColor Red\n        Write-Host \"  ACTION: Disable with 'Disable-LocalUser -Name Guest'\" -ForegroundColor Red\n    } else {\n        Write-Host \"  [PASS] Guest account is disabled\" -ForegroundColor Green\n    }\n} else {\n    Write-Host \"  [INFO] Guest account not found\" -ForegroundColor Gray\n}\nWrite-Host \"\"\n\n# Check Anonymous Logon Restrictions\nWrite-Host \"[CHECK] Anonymous Logon Security Policy\" -ForegroundColor Yellow\n$SecPolicy = secedit /export /cfg \"$env:TEMP\\secpol.cfg\" 2>&1\n$AnonSID = Select-String -Path \"$env:TEMP\\secpol.cfg\" -Pattern \"SeNetworkLogonRight\" | Select-String \"S-1-5-7\"\nif ($AnonSID) {\n    Write-Host \"  [WARN] Anonymous SID has network logon rights\" -ForegroundColor Yellow\n    Write-Host \"  ACTION: Review and restrict via Local Security Policy\" -ForegroundColor Yellow\n} else {\n    Write-Host \"  [PASS] Anonymous logon appears restricted\" -ForegroundColor Green\n}\nRemove-Item \"$env:TEMP\\secpol.cfg\" -Force -ErrorAction SilentlyContinue\nWrite-Host \"\"\n\nWrite-Host \"=== AC-14 POLICY REMINDER ===\" -ForegroundColor Cyan\nWrite-Host \"Document all permitted unauthenticated actions in the security plan.\"\nWrite-Host \"If no actions are permitted, document assignment value as 'None'.\"\nWrite-Host \"\"\n"
      }
    },
    "metadata": {
      "status": "verified",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": true,
      "stig_id": "RHEL-08-010450",
      "verification_authority": "LOVELESS_QA",
      "confidence_score": 0.98
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "cac_status": "mapped",
      "cac_planned": true,
      "implementation_guidance": "Technical enforcement via guest account restrictions (gnome_gdm_disable_guest_login, sebool_guest_exec_content), R-services trust file removal (no_rsh_trust_files), and anonymous access controls. Organizations must document permitted actions in security plan per control requirement b.",
      "cac_rules_mapped": [
        "gnome_gdm_disable_guest_login",
        "sebool_guest_exec_content",
        "no_rsh_trust_files",
        "ftp_restrict_users (if applicable)"
      ]
    },
    "ai_guidance": "AC-14 requires explicit documentation of permitted unauthenticated actions. Default posture should be 'none' unless business mission requires public access. Technical controls must prevent any undocumented anonymous access. Review CAC rules for guest account restrictions and ensure organizational policy document exists defining assignment parameters.",
    "stig_id": "RHEL-08-010450"
  },
  {
    "control_id": "AC-15",
    "control_name": "Automated Marking",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Automated Marking ensures that sensitive information is properly marked and classified in an automated manner.",
    "example_implementation": "This script utilize software tools that can automatically classify and mark sensitive information based on predetermined rules and policies to ensure consistent and accurate labeling.",
    "non_technical_guidance": "This plan to ensure compliance with control ac-15 for Automated Marking, the following non-technical implementation plan can be followed:\n\n1. Identify the appropriate marking tools or scripts that can automate the marking process.\n2. Develop a standard operating procedure (SOP) for using these automated marking tools.\n3. Train personnel on how to use the automated marking tools effectively.\n4. Regularly review and update the automated marking process to ensure it remains effective and meets compliance requirements.\n5. Conduct periodic audits to verify that automated marking is being used correctly and consistently.\n6. Document all activities related to automated marking for audit and compliance purposes.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-09T12:31:24.140525+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000150"
    },
    "cac_metadata": {
      "implementation_type": "administrative",
      "last_analyzed": "2025-11-10T09:36:53.547943+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Automated Marking according to organization policies to ensure access is strictly controlled.",
    "implementation_guidance": "This control is implemented via organizational policy and architectural design. Refer to the Policy Guidance tab.",
    "stig_id": "GEN-00-000150"
  },
  {
    "control_id": "AC-16",
    "control_name": "Security and Privacy Attributes",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Ensure that security and privacy attributes are identified and incorporated into information systems.",
    "example_implementation": "This script develop a checklist or template to document and track the security and privacy attributes of information systems during development and maintenance processes.",
    "non_technical_guidance": "This plan to comply with control AC-16 - Security and Privacy Attributes, you should ensure that all security and privacy attributes are clearly defined and documented for the information system. This includes attributes such as sensitivity, criticality, privacy, and integrity requirements. \n\nTo implement this control, you can follow these steps:\n1. Identify all the security and privacy attributes relevant to your information system.\n2. Document these attributes in a formal policy or document that is easily accessible to all relevant personnel.\n3. Regularly review and update these attributes as needed to ensure they remain accurate and up-to-date.\n4. Train all personnel on the importance of these attributes and how they should be taken into consideration in all aspects of system design, development, and operation.\n\nBy following these steps, you can ensure that your information system complies with control AC-16 and effectively manages security and privacy attributes.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "ac-16.1",
        "title": "Dynamic Attribute Association",
        "official_text": "Dynamically associate security and privacy attributes with [attribute level] in accordance with the following security and privacy policies as information is created and combined: [attribute type].",
        "metadata": {
          "stig_id": "GEN-00-000161"
        },
        "ai_guidance": "Enhance security by applying specific controls for Dynamic Attribute Association.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-16.2",
        "title": "Attribute Value Changes by Authorized Individuals",
        "official_text": "Provide authorized individuals (or processes acting on behalf of individuals) the capability to define or change the value of associated security and privacy attributes.",
        "metadata": {
          "stig_id": "GEN-00-000162"
        },
        "ai_guidance": "Enhance security by applying specific controls for Attribute Value Changes by Authorized Individuals.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-16.3",
        "title": "Maintenance of Attribute Associations by System",
        "official_text": "Maintain the association and integrity of [attribute association] to [information system].",
        "metadata": {
          "stig_id": "GEN-00-000163"
        },
        "ai_guidance": "Enhance security by applying specific controls for Maintenance of Attribute Associations by System.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-16.4",
        "title": "Association of Attributes by Authorized Individuals",
        "official_text": "Provide the capability to associate [authorized attributes] with [attribute authority] by authorized individuals (or processes acting on behalf of individuals).",
        "metadata": {
          "stig_id": "GEN-00-000164"
        },
        "ai_guidance": "Enhance security by applying specific controls for Association of Attributes by Authorized Individuals.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-16.5",
        "title": "Attribute Displays on Objects to Be Output",
        "official_text": "Display security and privacy attributes in human-readable form on each object that the system transmits to output devices to identify [security attributes] using [subjects/objects].",
        "metadata": {
          "stig_id": "GEN-00-000165"
        },
        "ai_guidance": "Enhance security by applying specific controls for Attribute Displays on Objects to Be Output.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-16.6",
        "title": "Maintenance of Attribute Association",
        "official_text": "Require personnel to associate and maintain the association of [attribute type] with [attribute value] in accordance with [action].",
        "metadata": {
          "stig_id": "GEN-00-000166"
        },
        "ai_guidance": "Enhance security by applying specific controls for Maintenance of Attribute Association.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-16.7",
        "title": "Consistent Attribute Interpretation",
        "official_text": "Provide a consistent interpretation of security and privacy attributes transmitted between distributed system components.",
        "metadata": {
          "stig_id": "GEN-00-000167"
        },
        "ai_guidance": "Enhance security by applying specific controls for Consistent Attribute Interpretation.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-16.8",
        "title": "Association Techniques and Technologies",
        "official_text": "Implement [association type] in associating security and privacy attributes to information.",
        "metadata": {
          "stig_id": "GEN-00-000168"
        },
        "ai_guidance": "Enhance security by applying specific controls for Association Techniques and Technologies.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-16.9",
        "title": "Attribute Reassignment  Regrading Mechanisms",
        "official_text": "Change security and privacy attributes associated with information only via regrading mechanisms validated using [attribute type].",
        "metadata": {
          "stig_id": "GEN-00-000169"
        },
        "ai_guidance": "Enhance security by applying specific controls for Attribute Reassignment  Regrading Mechanisms.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-16.10",
        "title": "Attribute Configuration by Authorized Individuals",
        "official_text": "Provide authorized individuals the capability to define or change the type and value of security and privacy attributes available for association with subjects and objects.",
        "metadata": {
          "stig_id": "GEN-00-000170"
        },
        "ai_guidance": "Enhance security by applying specific controls for Attribute Configuration by Authorized Individuals.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-09T12:31:24.140538+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000160"
    },
    "cac_metadata": {
      "implementation_type": "administrative",
      "last_analyzed": "2025-11-10T09:36:55.061500+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Security and Privacy Attributes according to organization policies to ensure access is strictly controlled.",
    "implementation_guidance": "This control is implemented via organizational policy and architectural design. Refer to the Policy Guidance tab.",
    "stig_id": "GEN-00-000160"
  },
  {
    "control_id": "AC-16.1",
    "control_name": "Dynamic Attribute Association",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Dynamically associate security and privacy attributes with [attribute level] in accordance with the following security and privacy policies as information is created and combined: [attribute type].",
    "parent_control": "ac-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Dynamically associate security and privacy attributes with [attribute level] in accordance with the following security and privacy policies as information is created and combined: [attribute type].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140551+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000161"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:36:56.586449+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Dynamic Attribute Association according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000161"
  },
  {
    "control_id": "AC-16.2",
    "control_name": "Attribute Value Changes by Authorized Individuals",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Provide authorized individuals (or processes acting on behalf of individuals) the capability to define or change the value of associated security and privacy attributes.",
    "parent_control": "ac-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Provide authorized individuals (or processes acting on behalf of individuals) the capability to define or change the value of associated security and privacy attributes.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140578+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000162"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:36:59.643513+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Attribute Value Changes by Authorized Individuals according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000162"
  },
  {
    "control_id": "AC-16.3",
    "control_name": "Maintenance of Attribute Associations by System",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Maintain the association and integrity of [attribute association] to [information system].",
    "parent_control": "ac-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Maintain the association and integrity of [attribute association] to [information system].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140591+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000163"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:01.208166+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Maintenance of Attribute Associations by System according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000163"
  },
  {
    "control_id": "AC-16.4",
    "control_name": "Association of Attributes by Authorized Individuals",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Provide the capability to associate [authorized attributes] with [attribute authority] by authorized individuals (or processes acting on behalf of individuals).",
    "parent_control": "ac-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Provide the capability to associate [authorized attributes] with [attribute authority] by authorized individuals (or processes acting on behalf of individuals).",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140603+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000164"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:02.746133+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Association of Attributes by Authorized Individuals according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000164"
  },
  {
    "control_id": "AC-16.5",
    "control_name": "Attribute Displays on Objects to Be Output",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Display security and privacy attributes in human-readable form on each object that the system transmits to output devices to identify [security attributes] using [subjects/objects].",
    "parent_control": "ac-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Display security and privacy attributes in human-readable form on each object that the system transmits to output devices to identify [security attributes] using [subjects/objects].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140615+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000165"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:04.279970+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Attribute Displays on Objects to Be Output according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000165"
  },
  {
    "control_id": "AC-16.6",
    "control_name": "Maintenance of Attribute Association",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Require personnel to associate and maintain the association of [attribute type] with [attribute value] in accordance with [action].",
    "parent_control": "ac-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Require personnel to associate and maintain the association of [attribute type] with [attribute value] in accordance with [action].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140630+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000166"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:05.814748+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Maintenance of Attribute Association according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000166"
  },
  {
    "control_id": "AC-16.7",
    "control_name": "Consistent Attribute Interpretation",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Provide a consistent interpretation of security and privacy attributes transmitted between distributed system components.",
    "parent_control": "ac-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Provide a consistent interpretation of security and privacy attributes transmitted between distributed system components.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140642+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000167"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:07.335240+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Consistent Attribute Interpretation according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000167"
  },
  {
    "control_id": "AC-16.8",
    "control_name": "Association Techniques and Technologies",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Implement [association type] in associating security and privacy attributes to information.",
    "parent_control": "ac-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Implement [association type] in associating security and privacy attributes to information.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140657+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000168"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:08.860122+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Association Techniques and Technologies according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000168"
  },
  {
    "control_id": "AC-16.9",
    "control_name": "Attribute Reassignment  Regrading Mechanisms",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Change security and privacy attributes associated with information only via regrading mechanisms validated using [attribute type].",
    "parent_control": "ac-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Change security and privacy attributes associated with information only via regrading mechanisms validated using [attribute type].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140671+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000169"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:37:10.366062+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Attribute Reassignment  Regrading Mechanisms according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000169"
  },
  {
    "control_id": "AC-16.10",
    "control_name": "Attribute Configuration by Authorized Individuals",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Provide authorized individuals the capability to define or change the type and value of security and privacy attributes available for association with subjects and objects.",
    "parent_control": "ac-16",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Provide authorized individuals the capability to define or change the type and value of security and privacy attributes available for association with subjects and objects.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.140565+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000170"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:36:58.100397+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Attribute Configuration by Authorized Individuals according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000170"
  },
  {
    "control_id": "AC-17",
    "control_name": "Remote Access",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This control ensures that remote access to the organization's systems and data is secure and only granted to authorized users.",
    "example_implementation": "This script implement strong authentication methods such as multi-factor authentication for remote access to enhance security and prevent unauthorized access.",
    "non_technical_guidance": "This plan to comply with control AC-17 (Remote Access), the following non-technical implementation plan should be followed:\n1. Implement a remote access policy that clearly defines who is allowed remote access, under what circumstances, and how access is granted.\n2. Utilize multi-factor authentication for remote access to strengthen security measures.\n3. Regularly review and update remote access permissions to ensure only authorized individuals have access.\n4. Monitor remote access logs for any suspicious activity and investigate any anomalies promptly.\n5. Provide training to employees on the importance of secure remote access practices to prevent unauthorized access.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "ac-17.1",
        "title": "Monitoring and Control",
        "official_text": "Employ automated mechanisms to monitor and control remote access methods.",
        "metadata": {
          "stig_id": "RHEL-08-040161"
        },
        "ai_guidance": "Enhance security by applying specific controls for Monitoring and Control."
      },
      {
        "id": "ac-17.2",
        "title": "Protection of Confidentiality and Integrity Using Encryption",
        "official_text": "Implement cryptographic mechanisms to protect the confidentiality and integrity of remote access sessions.",
        "metadata": {
          "stig_id": "RHEL-08-040162"
        },
        "ai_guidance": "Enhance security by applying specific controls for Protection of Confidentiality and Integrity Using Encryption."
      },
      {
        "id": "ac-17.3",
        "title": "Managed Access Control Points",
        "official_text": "Route remote accesses through authorized and managed network access control points.",
        "metadata": {
          "stig_id": "RHEL-08-040163"
        },
        "ai_guidance": "Enhance security by applying specific controls for Managed Access Control Points."
      },
      {
        "id": "ac-17.4",
        "title": "Privileged Commands and Access",
        "official_text": "",
        "rationale": "Privileged remote access is a high-risk activity. Requiring assessable evidence (recordings, detailed logs) ensures accountability.",
        "metadata": {
          "stig_id": "RHEL-08-040164"
        },
        "ai_guidance": "Record or heavily log all remote admin sessions. It's high risk."
      },
      {
        "id": "ac-17.5",
        "title": "Monitoring for Unauthorized Connections",
        "official_text": "",
        "rationale": "Monitoring and controlling remote access sessions allows security operations to detect and terminate suspicious activities in real-time.",
        "metadata": {
          "stig_id": "RHEL-08-040165"
        },
        "ai_guidance": "Watch remote connections in real-time so you can cut the cord if something looks wrong."
      },
      {
        "id": "ac-17.6",
        "title": "Protection of Mechanism Information",
        "official_text": "Protect information about remote access mechanisms from unauthorized use and disclosure.",
        "metadata": {
          "stig_id": "RHEL-08-040166"
        },
        "ai_guidance": "Enhance security by applying specific controls for Protection of Mechanism Information."
      },
      {
        "id": "ac-17.7",
        "title": "Additional Protection for Security Function Access",
        "official_text": "",
        "rationale": "Additional protection mechanisms (e.g., bastion hosts, jump servers) provide a choke point to inspect and secure remote administrative traffic.",
        "metadata": {
          "stig_id": "RHEL-08-040167"
        },
        "ai_guidance": "Use a 'jump box' or bastion host. Don't let people connect directly to critical servers from home."
      },
      {
        "id": "ac-17.8",
        "title": "Disable Nonsecure Network Protocols",
        "official_text": "",
        "rationale": "Disabling remote access capabilities when not operationally required reduces the attack surface.",
        "metadata": {
          "stig_id": "RHEL-08-040168"
        },
        "ai_guidance": "Turn off remote access features if you aren't using them."
      },
      {
        "id": "ac-17.9",
        "title": "Disconnect or Disable Access",
        "official_text": "Provide the capability to disconnect or disable remote access to the system within [disconnect capability].",
        "metadata": {
          "stig_id": "RHEL-08-040169"
        },
        "ai_guidance": "Enhance security by applying specific controls for Disconnect or Disable Access."
      },
      {
        "id": "ac-17.10",
        "title": "Authenticate Remote Commands",
        "official_text": "Implement [configuration settings] to authenticate [remote access type].",
        "metadata": {
          "stig_id": "RHEL-08-040170"
        },
        "ai_guidance": "Enhance security by applying specific controls for Authenticate Remote Commands."
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-17 Remote Access\n# Description: Configure SSH for secure remote access (Protocol 2, No Root Login)\n\nSSHD_CONFIG=\"/etc/ssh/sshd_config\"\n\necho \"Hardening SSH configuration...\"\n\n# Ensure Protocol 2\nif grep -q \"^Protocol\" \"$SSHD_CONFIG\"; then\n  sed -i 's/^Protocol.*/Protocol 2/' \"$SSHD_CONFIG\"\nelse\n  echo \"Protocol 2\" >> \"$SSHD_CONFIG\"\nfi\n\n# Disable Root Login\nif grep -q \"^PermitRootLogin\" \"$SSHD_CONFIG\"; then\n  sed -i 's/^PermitRootLogin.*/PermitRootLogin no/' \"$SSHD_CONFIG\"\nelse\n  echo \"PermitRootLogin no\" >> \"$SSHD_CONFIG\"\nfi\n\nsystemctl reload sshd\necho \"SSH configuration updated.\"\n",
        "ansible": "---\n- name: AC-17 Remote Access Configuration\n  hosts: all\n  become: yes\n  tasks:\n    - name: Ensure SSH Protocol 2 is set\n      lineinfile:\n        path: /etc/ssh/sshd_config\n        regexp: '^Protocol'\n        line: 'Protocol 2'\n    \n    - name: Disable SSH Root Login\n      lineinfile:\n        path: /etc/ssh/sshd_config\n        regexp: '^PermitRootLogin'\n        line: 'PermitRootLogin no'\n      notify: Restart SSH\n\n  handlers:\n    - name: Restart SSH\n      service:\n        name: sshd\n        state: restarted\n"
      },
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-10T23:32:37.968501",
      "has_scripts": true,
      "migration_source": "CAC_AC12_AC17_family_migration",
      "stig_id": "RHEL-08-040160"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-10T09:37:11.892388+00:00",
      "source": "ComplianceAsCode",
      "last_updated": "2025-11-10T09:37:12.002190+00:00",
      "platform": "rhcos4",
      "rule_count": 12,
      "certification": "Government-certified"
    },
    "ai_guidance": "Secure remote connections (VPN/SSH). Don't let people connect from just anywhere without protection.",
    "stig_id": "RHEL-08-040160"
  },
  {
    "control_id": "AC-17.1",
    "control_name": "Monitoring and Control",
    "enhancement_title": "Automated Monitoring and Control",
    "official_text": "Employ automated mechanisms to monitor and control remote access methods.",
    "rationale": "Automated mechanisms provide consistent, continuous monitoring of remote access sessions that human operators cannot sustain. Automation enables real-time detection of unauthorized access attempts, policy violations, and anomalous behavior across all remote access channels.",
    "metadata": {
      "stig_id": "RHEL-08-040161",
      "baseline": [
        "moderate",
        "high"
      ]
    },
    "plain_english_explanation": "Organizations must use automated tools to continuously watch and manage remote access connections. This includes monitoring SSH sessions, VPN connections, and other remote access methods for suspicious activity.",
    "example_implementation": "Deploy SIEM (Security Information and Event Management) system to automatically collect and analyze SSH logs. Configure auditd to track remote access events. Set up automated alerts for failed login attempts (more than 5 in 10 minutes). Use fail2ban to automatically block IPs with repeated failed attempts. Enable verbose SSH logging.",
    "technical_implementation": {
      "linux": {
        "description": "Configure SSH verbose logging for automated monitoring",
        "cac_rules": [
          "sshd_set_loglevel_verbose",
          "auditd_audispd_configure_remote_server",
          "rsyslog_remote_access_monitoring"
        ],
        "validation": "grep -i 'LogLevel VERBOSE' /etc/ssh/sshd_config && systemctl status auditd"
      }
    },
    "ai_guidance": "Use computer programs to watch your remote connections 24/7 instead of having a person stare at logs all day. Set up automatic alerts when someone tries to break in.",
    "stig_id": "RHEL-08-040161"
  },
  {
    "control_id": "AC-17.2",
    "control_name": "Protection of Confidentiality and Integrity Using Encryption",
    "enhancement_title": "Cryptographic Protection",
    "official_text": "Implement cryptographic mechanisms to protect the confidentiality and integrity of remote access sessions.",
    "rationale": "Cryptographic protection prevents eavesdropping and tampering of remote sessions traversing untrusted networks. Strong ciphers, MACs, and key exchange algorithms ensure data cannot be intercepted or modified by attackers monitoring network traffic. Weak or outdated cryptographic algorithms have known vulnerabilities that sophisticated attackers can exploit.",
    "metadata": {
      "stig_id": "RHEL-08-040162",
      "baseline": [
        "moderate",
        "high"
      ]
    },
    "plain_english_explanation": "All remote access sessions must use strong encryption to prevent unauthorized parties from reading or modifying the data being transmitted. This applies to SSH, VPN, and other remote access technologies.",
    "example_implementation": "Configure SSH to use only strong ciphers (AES-256-GCM, ChaCha20-Poly1305), strong MACs (HMAC-SHA2-512, HMAC-SHA2-256), and approved key exchange algorithms (ECDH-SHA2-NISTP521, Diffie-Hellman Group 16/18 with SHA-512). Disable weak algorithms like 3DES, MD5, SHA1. Configure VPN with AES-256-GCM encryption.",
    "technical_implementation": {
      "linux": {
        "description": "Configure SSH with FIPS 140-2 approved cryptographic algorithms",
        "cac_rules": [
          "sshd_use_approved_ciphers_ordered_stig",
          "sshd_use_approved_macs_ordered_stig",
          "sshd_use_approved_kex_ordered_stig",
          "sshd_use_strong_ciphers",
          "sshd_use_strong_macs",
          "sshd_use_strong_kex",
          "sshd_rekey_limit",
          "ssh_client_rekey_limit"
        ],
        "configuration": {
          "ciphers": "chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr",
          "macs": "hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256",
          "kex_algorithms": "ecdh-sha2-nistp521,ecdh-sha2-nistp384,ecdh-sha2-nistp256,diffie-hellman-group-exchange-sha256"
        },
        "validation": "sshd -T | grep -E '(ciphers|macs|kexalgorithms)'"
      }
    },
    "ai_guidance": "Encrypt everything. Use the strongest locks (AES-256) on your remote connections so hackers can't read your data even if they intercept it. Think of it like putting your message in an unbreakable safe before sending it.",
    "stig_id": "RHEL-08-040162"
  },
  {
    "control_id": "AC-17.3",
    "control_name": "Managed Access Control Points",
    "enhancement_title": "Route Through Managed Points",
    "official_text": "Route remote accesses through authorized and managed network access control points.",
    "rationale": "Centralized routing of remote access through managed control points (such as VPN concentrators, bastion hosts, or secure gateways) provides a single enforcement point for security policies, monitoring, and logging. This architecture prevents users from bypassing security controls by establishing direct connections to internal systems.",
    "metadata": {
      "stig_id": "RHEL-08-040163",
      "baseline": [
        "moderate",
        "high"
      ]
    },
    "plain_english_explanation": "All remote access must go through specific, controlled entry points rather than allowing direct connections to internal systems. This is like requiring all visitors to enter through the front desk rather than allowing them to come in through any window.",
    "example_implementation": "Deploy VPN concentrator as single entry point for remote access. Configure firewall to block direct SSH connections from external networks - all SSH must route through bastion host. Implement jump server architecture where administrators must first connect to hardened jump box before accessing production systems. Disable split-tunneling on VPN to ensure all traffic routes through security controls.",
    "technical_implementation": {
      "linux": {
        "description": "Configure firewall to restrict SSH access through managed control points only",
        "cac_rules": [
          "firewalld_sshd_port_enabled",
          "firewalld_sshd_disabled"
        ],
        "organizational": true,
        "architecture_requirement": "Bastion host / jump server / VPN concentrator"
      }
    },
    "ai_guidance": "Make everyone come in through the front door (bastion host or VPN gateway) where you have guards (security controls) checking them. Don't let people climb through windows (direct connections) to get inside.",
    "stig_id": "RHEL-08-040163"
  },
  {
    "control_id": "AC-17.4",
    "control_name": "Privileged Commands and Access",
    "enhancement_title": "Authorization and Logging of Privileged Remote Access",
    "official_text": "Authorize the execution of privileged commands and access to security-relevant information via remote access only in a format that provides assessable evidence and is approved by designated organizational officials.",
    "rationale": "Privileged remote access represents the highest risk activity - an attacker with privileged access can completely compromise a system. Requiring assessable evidence (such as session recordings, detailed audit logs) ensures accountability and enables forensic investigation. Documented authorization ensures management awareness and approval of high-risk access.",
    "metadata": {
      "stig_id": "RHEL-08-040164",
      "baseline": [
        "moderate",
        "high"
      ]
    },
    "plain_english_explanation": "When administrators use remote access to execute privileged commands (like root/sudo access), organizations must record detailed evidence of those sessions and obtain management approval. This ensures accountability for high-risk administrative actions.",
    "example_implementation": "Implement session recording for all privileged SSH sessions using tools like tlog or script. Configure auditd to log all sudo command executions with full command-line arguments. Require written authorization from CISO for privileged remote access accounts. Deploy privileged access management (PAM) solution that records video of privileged sessions. Enable syslog forwarding of all authentication and authorization events to centralized logging server.",
    "technical_implementation": {
      "linux": {
        "description": "Enable comprehensive auditing of privileged remote access",
        "cac_rules": [
          "sshd_set_loglevel_verbose",
          "audit_rules_privileged_commands",
          "audit_rules_suid_privilege_function"
        ],
        "additional_controls": [
          "Session recording via tlog/script",
          "Sudo logging to syslog",
          "Management authorization workflow"
        ]
      }
    },
    "ai_guidance": "Record or heavily log all remote admin sessions. It's high risk. Like having security cameras on the bank vault - if someone with the keys does something bad, you need video evidence.",
    "stig_id": "RHEL-08-040164"
  },
  {
    "control_id": "AC-17.5",
    "control_name": "Monitoring for Unauthorized Connections",
    "enhancement_title": "Detect Unauthorized Remote Access",
    "official_text": "Monitor for unauthorized remote access connections and take appropriate action if an unauthorized connection is discovered.",
    "rationale": "Monitoring and controlling remote access sessions allows security operations to detect and terminate suspicious activities in real-time. Unauthorized connections may indicate compromised credentials, insider threats, or external attacks. Rapid detection and response minimize potential damage.",
    "metadata": {
      "stig_id": "RHEL-08-040165",
      "baseline": []
    },
    "plain_english_explanation": "Organizations must actively watch for remote connections that shouldn't be happening and immediately respond to terminate them. This includes monitoring for connections from unexpected locations, at unusual times, or by unauthorized users.",
    "example_implementation": "Deploy IDS/IPS to monitor for SSH connections from blacklisted IP addresses. Configure SIEM alerts for remote access outside business hours or from foreign countries. Implement geofencing to block VPN connections from high-risk countries. Monitor failed authentication attempts and automatically block after threshold. Use behavioral analytics to detect anomalous remote access patterns (user normally connects from NYC suddenly connecting from China).",
    "technical_implementation": {
      "linux": {
        "description": "Real-time monitoring of remote access connections",
        "cac_rules": [
          "sshd_set_loglevel_verbose",
          "rsyslog_remote_access_monitoring"
        ],
        "additional_tools": [
          "fail2ban for automated blocking",
          "SIEM for correlation and alerting",
          "IDS/IPS for network-level monitoring"
        ]
      }
    },
    "ai_guidance": "Watch remote connections in real-time so you can cut the cord if something looks wrong. Like a security guard who can immediately lock the door if someone suspicious tries to enter.",
    "stig_id": "RHEL-08-040165"
  },
  {
    "control_id": "AC-17.6",
    "control_name": "Protection of Mechanism Information",
    "enhancement_title": "Protect Remote Access Configuration Information",
    "official_text": "Protect information about remote access mechanisms from unauthorized use and disclosure.",
    "rationale": "Information about remote access mechanisms (VPN configuration details, SSH ports, authentication methods, IP addresses of VPN concentrators) provides attackers with valuable reconnaissance data. Protecting this information reduces the attack surface and makes it harder for adversaries to identify and exploit remote access entry points.",
    "metadata": {
      "stig_id": "RHEL-08-040166",
      "baseline": []
    },
    "plain_english_explanation": "Keep details about your remote access systems secret. Don't publicly disclose which ports SSH runs on, IP addresses of VPN servers, or specific configuration details that attackers could use to plan attacks.",
    "example_implementation": "Use non-standard SSH ports (not 22). Implement port knocking to hide SSH service until proper sequence is detected. Redact VPN server IP addresses from public documentation. Restrict access to remote access configuration files (sshd_config, VPN configs) to authorized administrators only. Use DNS-based discovery instead of publishing static IP addresses. Implement certificate-based authentication instead of password authentication.",
    "technical_implementation": {
      "linux": {
        "description": "Protect SSH configuration files from unauthorized access",
        "cac_rules": [
          "file_permissions_sshd_config",
          "file_owner_sshd_config",
          "file_groupowner_sshd_config",
          "directory_permissions_sshd_config_d",
          "file_permissions_sshd_private_key"
        ],
        "configuration": {
          "sshd_config_permissions": "0600",
          "sshd_config_owner": "root:root",
          "private_key_permissions": "0600"
        }
      }
    },
    "ai_guidance": "Don't advertise how people can remotely connect to your systems. It's like not publishing the combination to your safe - even if someone breaks into your house, they still can't open the safe if they don't know the combination.",
    "stig_id": "RHEL-08-040166"
  },
  {
    "control_id": "AC-17.7",
    "control_name": "Additional Protection for Security Function Access",
    "enhancement_title": "Additional Mechanisms for Privileged Functions",
    "official_text": "Employ additional mechanisms for authentication to security functions via remote access.",
    "rationale": "Additional protection mechanisms (such as bastion hosts, jump servers, or multi-factor authentication) provide a choke point to inspect and secure remote administrative traffic. These architectural controls create defense-in-depth by adding extra layers of authentication and authorization before granting access to security-critical functions.",
    "metadata": {
      "stig_id": "RHEL-08-040167",
      "baseline": []
    },
    "plain_english_explanation": "When accessing security-critical systems remotely (like security consoles, audit systems, or privileged accounts), organizations must implement extra security measures beyond standard remote access controls.",
    "example_implementation": "Deploy hardened bastion host / jump server that all privileged SSH connections must route through. Implement hardware tokens (YubiKey) for MFA on privileged accounts. Use separate VPN with stronger authentication for administrative access vs. regular user access. Require authentication from separate identity provider for security function access. Implement time-based access controls where privileged remote access expires after defined period.",
    "technical_implementation": {
      "linux": {
        "description": "Implement bastion host architecture for privileged remote access",
        "cac_rules": [
          "sshd_enable_pubkey_auth",
          "sshd_disable_root_login"
        ],
        "architecture": "Bastion host with port forwarding, jump server",
        "additional_controls": [
          "MFA enforcement via PAM",
          "Separate VPN for privileged access",
          "Certificate-based SSH authentication"
        ]
      }
    },
    "ai_guidance": "Use a 'jump box' or bastion host. Don't let people connect directly to critical servers from home. Make them hop through a super-secure middle server first, like having two locked doors instead of one.",
    "stig_id": "RHEL-08-040167"
  },
  {
    "control_id": "AC-17.8",
    "control_name": "Disable Nonsecure Network Protocols",
    "enhancement_title": "Disable Remote Access When Not in Use",
    "official_text": "Disable, or if not technically feasible, restrict nonsecure remote access protocols with an organization-defined frequency.",
    "rationale": "Disabling remote access capabilities when not operationally required reduces the attack surface by eliminating unnecessary entry points. Unused remote access services represent dormant vulnerabilities that attackers can exploit. Restricting nonsecure protocols (like Telnet, FTP, RSH) forces use of secure alternatives (SSH, SFTP, FTPS).",
    "metadata": {
      "stig_id": "RHEL-08-040168",
      "baseline": []
    },
    "plain_english_explanation": "Turn off remote access features if you're not using them. If remote access is needed, disable old insecure protocols (Telnet, FTP, RSH) and only allow secure modern protocols (SSH, SFTP).",
    "example_implementation": "Disable SSH service on systems that don't require remote administration. Remove Telnet package entirely. Disable FTP and deploy SFTP instead. Remove RSH/rlogin services. Implement automated policy to disable remote access during non-business hours for non-critical systems. Use firewall rules to restrict SSH access to specific source IP ranges. Disable SSH password authentication and require key-based authentication only.",
    "technical_implementation": {
      "linux": {
        "description": "Disable insecure remote access protocols and unnecessary services",
        "cac_rules": [
          "service_telnet_disabled",
          "package_telnet-server_removed",
          "service_rsh_disabled",
          "package_rsh-server_removed",
          "sshd_disable_rhosts",
          "sshd_disable_rhosts_rsa",
          "sshd_disable_empty_passwords",
          "sshd_disable_root_password_login"
        ],
        "remove_packages": [
          "telnet-server",
          "rsh-server",
          "vsftpd"
        ],
        "disable_services": [
          "telnet",
          "rsh",
          "rlogin",
          "ftp"
        ]
      }
    },
    "ai_guidance": "Turn off remote access features if you aren't using them. Like locking your back door when you only use the front door - why leave extra entry points open?",
    "stig_id": "RHEL-08-040168"
  },
  {
    "control_id": "AC-17.9",
    "control_name": "Disconnect or Disable Access",
    "enhancement_title": "Remote Disconnect Capability",
    "official_text": "Provide the capability to disconnect or disable remote access to the system within an organization-defined time period.",
    "rationale": "The ability to rapidly disconnect remote access provides emergency response capability when security incidents are detected. During active attacks, immediate termination of remote connections can contain damage and prevent further compromise. Disabling remote access during maintenance windows or emergencies reduces risk.",
    "metadata": {
      "stig_id": "RHEL-08-040169",
      "baseline": []
    },
    "plain_english_explanation": "Organizations must have the ability to quickly cut off all remote connections in an emergency, such as during an active cyber attack. This includes both terminating active sessions and disabling the ability to establish new remote connections.",
    "example_implementation": "Document procedure to disable SSH service system-wide ('systemctl stop sshd'). Configure firewall with pre-defined rule to block all inbound SSH traffic that can be activated with single command. Deploy kill-switch capability in VPN infrastructure. Implement automated script that terminates all active SSH sessions when triggered. Train security operations team on emergency remote access shutdown procedures. Set maximum session timeout (ClientAliveInterval + ClientAliveCountMax) to auto-disconnect idle sessions.",
    "technical_implementation": {
      "linux": {
        "description": "Capability to rapidly disconnect remote access",
        "cac_rules": [
          "sshd_set_idle_timeout",
          "sshd_set_keepalive",
          "firewalld_sshd_disabled"
        ],
        "emergency_procedures": [
          "systemctl stop sshd",
          "iptables -A INPUT -p tcp --dport 22 -j DROP",
          "kill -HUP <sshd_pid> to disconnect sessions"
        ],
        "configuration": {
          "ClientAliveInterval": "600",
          "ClientAliveCountMax": "0"
        }
      }
    },
    "ai_guidance": "Have a big red emergency button that instantly cuts all remote connections. Like a circuit breaker that kills power to the whole house if there's an electrical fire.",
    "stig_id": "RHEL-08-040169"
  },
  {
    "control_id": "AC-17.10",
    "control_name": "Authenticate Remote Commands",
    "enhancement_title": "Command Authentication Mechanisms",
    "official_text": "Implement mechanisms to authenticate organization-defined remote commands.",
    "rationale": "Authentication of remote commands ensures that commands executed over remote channels originate from authorized sources and have not been tampered with during transmission. This is critical for automated systems, APIs, and management protocols where commands are executed without direct human interaction. Digital signatures or cryptographic authentication prevents command injection and man-in-the-middle attacks.",
    "metadata": {
      "stig_id": "RHEL-08-040170",
      "baseline": []
    },
    "plain_english_explanation": "When systems accept commands remotely (such as through APIs, management protocols, or automation tools), organizations must implement authentication to verify the commands are legitimate and haven't been modified by attackers.",
    "example_implementation": "Implement SSH certificate-based authentication for command execution. Use signed API requests with HMAC-SHA256 signatures. Deploy Ansible with GPG-signed playbooks. Configure Salt/Puppet with certificate-based authentication. Implement HMAC authentication for remote management protocols. Use TLS client certificates for authenticated API access. Deploy signed container images for remote deployment commands.",
    "technical_implementation": {
      "linux": {
        "description": "Implement cryptographic authentication for remote commands",
        "cac_rules": [
          "sshd_enable_pubkey_auth",
          "sshd_disable_empty_passwords",
          "ssh_keys_passphrase_protected",
          "file_permissions_sshd_private_key"
        ],
        "mechanisms": [
          "SSH public key authentication with passphrase-protected keys",
          "Certificate-based SSH authentication",
          "API request signing (HMAC-SHA256)",
          "TLS mutual authentication for management APIs"
        ],
        "configuration": {
          "PubkeyAuthentication": "yes",
          "PasswordAuthentication": "no",
          "ChallengeResponseAuthentication": "no"
        }
      }
    },
    "ai_guidance": "Verify that remote commands are actually coming from who they claim to be. Like requiring a signature on a check - anyone can write 'Pay $1000', but only the account owner's signature makes it valid.",
    "stig_id": "RHEL-08-040170"
  },
  {
    "control_id": "AC-18",
    "control_name": "Wireless Access",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This control ensures that wireless access to the network is secure and monitored.",
    "example_implementation": "This script implement strong encryption protocols like WPA2 for wireless access points and regularly monitor wireless network traffic for any unauthorized devices.",
    "non_technical_guidance": "This plan to comply with control AC-18 regarding Wireless Access, the following non-technical implementation plan can be followed:\n\n1. Implement a policy that prohibits the use of unauthorized wireless access points within the organization.\n2. Regularly scan the premises for unauthorized wireless networks and take immediate action to disable them.\n3. Ensure that all authorized wireless access points are securely configured with strong encryption and authentication mechanisms.\n4. Enforce the use of strong passwords for accessing wireless networks and regularly update these passwords.\n5. Educate employees on the risks associated with connecting to unsecured wireless networks and the importance of following the organization's wireless access policies.\n6. Monitor network traffic for any suspicious activity related to wireless access and investigate any anomalies promptly.\n7. Conduct regular security audits and assessments to ensure compliance with wireless access control measures.",
    "is_technical": true,
    "enhancements": [
      {
        "id": "ac-18.1",
        "title": "Authentication and Encryption",
        "official_text": "Protect wireless access to the system using authentication of [authentication mechanism] and encryption.",
        "metadata": {
          "stig_id": "RHEL-08-040171"
        },
        "ai_guidance": "Enhance security by applying specific controls for Authentication and Encryption."
      },
      {
        "id": "ac-18.2",
        "title": "Monitoring Unauthorized Connections",
        "official_text": "",
        "rationale": "Continuous monitoring for unauthorized wireless signals identifies rogue access points or ad-hoc networks that could bypass perimeter defenses.",
        "metadata": {
          "stig_id": "RHEL-08-040172"
        },
        "ai_guidance": "Scan for rogue Wi-Fi access points that employees might have plugged in without permission."
      },
      {
        "id": "ac-18.3",
        "title": "Disable Wireless Networking",
        "official_text": "Disable, when not intended for use, wireless networking capabilities embedded within system components prior to issuance and deployment.",
        "rationale": "Disabling wireless hardware on servers and sensitive endpoints prevents accidental or unauthorized bridging of air gaps.",
        "metadata": {
          "stig_id": "RHEL-08-040173"
        },
        "ai_guidance": "If a server doesn't need Wi-Fi, turn the Wi-Fi chip off completely."
      },
      {
        "id": "ac-18.4",
        "title": "Restrict Configurations by Users",
        "official_text": "Identify and explicitly authorize users allowed to independently configure wireless networking capabilities.",
        "rationale": "Restricting who can configure wireless settings prevents users from accidentally connecting to insecure networks or creating rogue access points.",
        "metadata": {
          "stig_id": "RHEL-08-040174"
        },
        "ai_guidance": "Don't let regular users change Wi-Fi settings. Lock that configuration down."
      },
      {
        "id": "ac-18.5",
        "title": "Antennas and Transmission Power Levels",
        "official_text": "Select radio antennas and calibrate transmission power levels to reduce the probability that signals from wireless access points can be received outside of organization-controlled boundaries.",
        "metadata": {
          "stig_id": "RHEL-08-040175"
        },
        "ai_guidance": "Enhance security by applying specific controls for Antennas and Transmission Power Levels."
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {
        "bash": "# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro,multi_platform_debian\n# reboot = true\n# strategy = disable\n# complexity = low\n# disruption = medium\nif LC_ALL=C grep -q -m 1 \"^install \" /etc/modprobe.d/.conf ; then\n\t{}\n\tsed -i 's#^install .*#install  /bin/false#g' /etc/modprobe.d/.conf\nelse\n\techo -e \"\\n# Disable per security requirements\" >> /etc/modprobe.d/.conf\n\techo \"install  /bin/false\" >> /etc/modprobe.d/.conf\nfi\n\nif ! LC_ALL=C grep -q -m 1 \"^blacklist $\" /etc/modprobe.d/.conf ; then\n\techo \"blacklist \" >> /etc/modprobe.d/.conf\nfi\n",
        "ansible": "---\n# Source: ComplianceAsCode/content\n# Generated from CAC template\n\n# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro\n# reboot = true\n# strategy = disable\n# complexity = low\n# disruption = medium\n- name: Ensure kernel module '' is disabled\n  ansible.builtin.lineinfile:\n    create: yes\n    dest: \"/etc/modprobe.d/.conf\"\n    regexp: 'install\\s+'\n    line: \"install  /bin/false\"\n\n- name: Ensure kernel module '' is blacklisted\n  ansible.builtin.lineinfile:\n    create: yes\n    dest: \"/etc/modprobe.d/.conf\"\n    regexp: '^blacklist $'\n    line: \"blacklist \"\n"
      },
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-10T21:48:54.740139",
      "has_scripts": true,
      "migration_source": "CAC_AC18_series_migration",
      "stig_id": "RHEL-08-040170"
    },
    "cac_metadata": {
      "implementation_type": "automated",
      "last_analyzed": "2025-11-10T09:37:28.984728+00:00",
      "source": "ComplianceAsCode",
      "last_updated": "2025-11-10T09:37:29.034959+00:00",
      "platform": "rhcos4",
      "rule_count": 1,
      "certification": "Government-certified"
    },
    "ai_guidance": "Secure your Wi-Fi. Don't use weak passwords or old encryption.",
    "stig_id": "RHEL-08-040170"
  },
  {
    "control_id": "AC-18.1",
    "control_name": "Authentication and Encryption",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Protect wireless access to the system using authentication of [Assignment: organization-defined users and/or devices] and encryption.",
    "parent_control": "ac-18",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "All wireless connections to systems must use strong authentication (verifying who/what is connecting) and encryption (protecting data in transit). This applies to WiFi, Bluetooth, and other wireless technologies.",
    "example_implementation": "Configure enterprise WiFi with WPA3-Enterprise using 802.1X authentication with certificates or strong EAP methods. Require AES-256 encryption. For Bluetooth, use Secure Simple Pairing with encryption enabled. Disable legacy protocols like WEP and WPA-TKIP.",
    "non_technical_guidance": "For all wireless networks:\n1. Require strong authentication - users must prove their identity\n2. Use latest encryption standards (WPA3 for WiFi)\n3. Never use open/unencrypted wireless networks\n4. Disable older insecure protocols (WEP, WPA with TKIP)\n5. Use certificate-based authentication where possible instead of just passwords\n6. Regularly update wireless security configurations as new standards emerge",
    "is_technical": true,
    "supplemental_guidance": "Authentication mechanisms include users, devices, or both. Encryption protects confidentiality and integrity of wireless transmissions. Organizations select appropriate authentication and encryption mechanisms based on mission/business requirements and risk assessments.",
    "related_controls": [
      "AC-18",
      "IA-2",
      "IA-3",
      "SC-8",
      "SC-13"
    ],
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-18(1) Authentication and Encryption\n# NOTE: This control is primarily organizational/network infrastructure\n# This script validates that wireless interfaces enforce encryption\n\necho \"Checking wireless interface encryption settings...\"\n\nfor iface in $(iw dev | awk '/Interface/ {print $2}'); do\n  echo \"Checking interface: $iface\"\n  \n  # Check if interface is connected\n  if iw dev $iface link | grep -q 'Connected'; then\n    # Get encryption info\n    encryption=$(iw dev $iface link | grep -E 'CCMP|TKIP|WEP')\n    \n    if echo \"$encryption\" | grep -q 'CCMP'; then\n      echo \"[PASS] $iface using strong encryption (AES-CCMP)\"\n    elif echo \"$encryption\" | grep -q 'TKIP'; then\n      echo \"[WARN] $iface using weak encryption (TKIP) - upgrade to WPA3/WPA2-AES\"\n    elif echo \"$encryption\" | grep -q 'WEP'; then\n      echo \"[FAIL] $iface using insecure encryption (WEP) - MUST upgrade\"\n    else\n      echo \"[WARN] $iface encryption status unknown\"\n    fi\n  else\n    echo \"$iface not connected\"\n  fi\ndone\n\necho \"\\nNote: Wireless authentication and encryption are primarily configured\"\necho \"at the access point and authentication server (RADIUS/802.1X).\"\n",
        "ansible": "---\n- name: AC-18(1) Authentication and Encryption Validation\n  hosts: all\n  tasks:\n    - name: Check for wireless interfaces\n      ansible.builtin.shell: iw dev | awk '/Interface/ {print $2}'\n      register: wireless_interfaces\n      failed_when: false\n      changed_when: false\n\n    - name: Validate wireless encryption for each interface\n      ansible.builtin.shell: |\n        iw dev {{ item }} link | grep -E 'CCMP|TKIP|WEP' || echo 'No encryption info'\n      loop: \"{{ wireless_interfaces.stdout_lines }}\"\n      register: encryption_check\n      failed_when: false\n      changed_when: false\n\n    - name: Report encryption findings\n      ansible.builtin.debug:\n        msg: \"{{ encryption_check.results }}\"\n"
      },
      "windows": {
        "powershell": "# AC-18(1) Authentication and Encryption for Windows\n# Validate wireless profiles use strong authentication and encryption\n\nWrite-Host \"Checking wireless profile security settings...\"\n\n$profiles = netsh wlan show profiles | Select-String 'All User Profile' | ForEach-Object { ($_ -split ':')[1].Trim() }\n\nforeach ($profile in $profiles) {\n    Write-Host \"\\nProfile: $profile\"\n    $details = netsh wlan show profile name=\"$profile\" key=clear\n    \n    # Check authentication\n    $auth = $details | Select-String 'Authentication'\n    Write-Host \"$auth\"\n    \n    # Check encryption\n    $cipher = $details | Select-String 'Cipher'\n    Write-Host \"$cipher\"\n    \n    # Validate security\n    if ($details -match 'WPA3|WPA2' -and $details -match 'AES|CCMP') {\n        Write-Host \"[PASS] Strong authentication and encryption\" -ForegroundColor Green\n    } elseif ($details -match 'WPA' -and $details -match 'TKIP') {\n        Write-Host \"[WARN] Weak encryption (TKIP) - upgrade to WPA2/WPA3 with AES\" -ForegroundColor Yellow\n    } elseif ($details -match 'WEP|Open') {\n        Write-Host \"[FAIL] Insecure encryption - MUST upgrade\" -ForegroundColor Red\n    }\n}\n"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-040171",
      "validation_status": "PASS",
      "notes": "Primary implementation occurs at network infrastructure level (access points, RADIUS servers). Client-side validation scripts provided."
    },
    "ai_guidance": "Authentication and encryption are non-negotiable for wireless. Use WPA3-Enterprise with 802.1X/EAP-TLS (certificate-based). Minimum WPA2-AES if WPA3 not available. Disable WEP, WPA-TKIP, and open networks entirely. Consider per-user VPN for additional protection on guest wireless.",
    "stig_id": "RHEL-08-040171"
  },
  {
    "control_id": "AC-18.2",
    "control_name": "Monitoring Unauthorized Connections [WITHDRAWN]",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "WITHDRAWN: Incorporated into SI-4.",
    "parent_control": "ac-18",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "withdrawal_notice": {
      "status": "WITHDRAWN",
      "revision": "NIST SP 800-53 Rev 5",
      "incorporated_into": "SI-4 (System Monitoring)",
      "effective_date": "2020-09-23",
      "rationale": "Monitoring unauthorized wireless connections is more appropriately addressed as part of comprehensive system and network monitoring under SI-4 rather than as a separate access control enhancement.",
      "migration_guidance": "Organizations should implement wireless monitoring capabilities as part of their SI-4 system monitoring program. This includes continuous monitoring for rogue access points, unauthorized wireless devices, and anomalous wireless traffic patterns."
    },
    "plain_english_explanation": "This control has been withdrawn from NIST 800-53 Revision 5. The requirement to monitor for unauthorized wireless connections is now covered under SI-4 (System Monitoring).",
    "example_implementation": "NOT APPLICABLE - See SI-4 for implementation requirements",
    "non_technical_guidance": "This control is no longer active. Organizations should implement wireless monitoring as part of their overall system monitoring strategy under control SI-4, which covers detection of unauthorized access, devices, and connections across all system components including wireless.",
    "is_technical": false,
    "supplemental_guidance": "This enhancement was incorporated into SI-4 to provide unified monitoring requirements. Organizations implementing SI-4 should ensure wireless monitoring capabilities include: detection of rogue access points, identification of unauthorized wireless clients, analysis of wireless traffic for anomalies, and alerts for policy violations.",
    "related_controls": [
      "SI-4",
      "AC-18"
    ],
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "withdrawn",
      "last_updated": "2025-11-20T00:00:00",
      "has_scripts": false,
      "stig_id": "N/A",
      "validation_status": "PASS",
      "notes": "Control withdrawn in Rev 5. Previously STIG ID RHEL-08-040172 may reference legacy Rev 4 implementation."
    },
    "ai_guidance": "DO NOT implement as separate control. Wireless monitoring requirements are now part of SI-4. Use wireless intrusion detection systems (WIDS), regular wireless surveys for rogue APs, and network access control (NAC) solutions. Focus implementation efforts on SI-4 comprehensive monitoring.",
    "stig_id": "N/A"
  },
  {
    "control_id": "AC-18.3",
    "control_name": "Disable Wireless Networking",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Disable, when not intended for use, wireless networking capabilities embedded within system components prior to issuance and deployment.",
    "parent_control": "ac-18",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "If a device has wireless capabilities (WiFi, Bluetooth) but doesn't need them for its intended purpose, disable the wireless hardware before giving the device to users or putting it into production.",
    "example_implementation": "Before deploying servers or sensitive workstations, disable wireless adapters in BIOS/UEFI, blacklist wireless kernel modules, disable wireless services, and physically remove wireless cards if possible. Document which systems have wireless disabled and maintain inventory.",
    "non_technical_guidance": "For systems that don't need wireless:\n1. Disable wireless in computer BIOS/firmware settings before deployment\n2. Remove wireless hardware if feasible (especially for servers)\n3. Use software controls to block wireless kernel modules/drivers\n4. Disable Bluetooth if not needed\n5. Document all systems with disabled wireless\n6. Include wireless status in system inventory\n7. Verify disabled status during periodic security audits",
    "is_technical": true,
    "supplemental_guidance": "Wireless capabilities are typically embedded in laptops, tablets, and mobile devices. For servers and desktop workstations where wireless is not required, disabling provides defense-in-depth against wireless-based attacks. Methods include BIOS settings, kernel module blacklisting, driver removal, or physical removal of wireless cards.",
    "related_controls": [
      "AC-18",
      "AC-19",
      "CM-7",
      "MP-7",
      "SC-15"
    ],
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-18(3) Disable Wireless Networking\n# Comprehensive wireless disabling for Linux systems\n\nset -e\n\necho \"[AC-18(3)] Disabling wireless networking capabilities...\"\n\n# Create modprobe configuration directory if not exists\nmkdir -p /etc/modprobe.d\n\n# Disable 802.11 wireless modules\necho \"Disabling 802.11 wireless kernel modules...\"\ncat > /etc/modprobe.d/disable-wireless.conf << 'EOF'\n# AC-18(3) Disable Wireless Networking\ninstall cfg80211 /bin/false\ninstall mac80211 /bin/false\ninstall iwlwifi /bin/false\ninstall iwlmvm /bin/false\ninstall iwldvm /bin/false\ninstall ath9k /bin/false\ninstall ath10k_core /bin/false\nblacklist cfg80211\nblacklist mac80211\nblacklist iwlwifi\nblacklist iwlmvm\nblacklist iwldvm\nblacklist ath9k\nblacklist ath10k_core\nEOF\n\n# Disable Bluetooth\necho \"Disabling Bluetooth...\"\ncat > /etc/modprobe.d/disable-bluetooth.conf << 'EOF'\n# AC-18(3) Disable Bluetooth\ninstall bluetooth /bin/false\ninstall btusb /bin/false\nblacklist bluetooth\nblacklist btusb\nEOF\n\n# Unload currently loaded wireless modules\necho \"Unloading active wireless modules...\"\nfor module in iwlwifi iwlmvm iwldvm cfg80211 mac80211 bluetooth btusb; do\n  if lsmod | grep -q \"^$module\"; then\n    echo \"  Removing module: $module\"\n    rmmod $module 2>/dev/null || echo \"    (module has dependencies, will be removed on reboot)\"\n  fi\ndone\n\n# Disable wireless via rfkill if available\nif command -v rfkill &> /dev/null; then\n  echo \"Blocking wireless via rfkill...\"\n  rfkill block wifi\n  rfkill block bluetooth\n  rfkill list\nfi\n\n# Disable wireless via NetworkManager if available\nif command -v nmcli &> /dev/null; then\n  echo \"Disabling wireless via NetworkManager...\"\n  nmcli radio wifi off 2>/dev/null || true\n  nmcli radio all off 2>/dev/null || true\nfi\n\n# Disable Bluetooth service\nif systemctl list-unit-files | grep -q bluetooth.service; then\n  echo \"Disabling Bluetooth service...\"\n  systemctl stop bluetooth.service 2>/dev/null || true\n  systemctl disable bluetooth.service 2>/dev/null || true\n  systemctl mask bluetooth.service 2>/dev/null || true\nfi\n\necho\necho \"[SUCCESS] Wireless networking capabilities disabled.\"\necho \"NOTE: A system reboot is required for kernel module changes to take full effect.\"\necho\necho \"Verification commands:\"\necho \"  lsmod | grep -E 'wifi|bluetooth|80211'\"\necho \"  rfkill list\"\necho \"  nmcli radio\"\n",
        "ansible": "---\n- name: AC-18(3) Disable Wireless Networking\n  hosts: all\n  become: yes\n  tasks:\n    - name: Create modprobe.d directory\n      ansible.builtin.file:\n        path: /etc/modprobe.d\n        state: directory\n        mode: '0755'\n\n    - name: Disable 802.11 wireless kernel modules\n      ansible.builtin.copy:\n        dest: /etc/modprobe.d/disable-wireless.conf\n        content: |\n          # AC-18(3) Disable Wireless Networking\n          install cfg80211 /bin/false\n          install mac80211 /bin/false\n          install iwlwifi /bin/false\n          install iwlmvm /bin/false\n          install iwldvm /bin/false\n          install ath9k /bin/false\n          install ath10k_core /bin/false\n          blacklist cfg80211\n          blacklist mac80211\n          blacklist iwlwifi\n          blacklist iwlmvm\n          blacklist iwldvm\n          blacklist ath9k\n          blacklist ath10k_core\n        mode: '0644'\n\n    - name: Disable Bluetooth kernel modules\n      ansible.builtin.copy:\n        dest: /etc/modprobe.d/disable-bluetooth.conf\n        content: |\n          # AC-18(3) Disable Bluetooth\n          install bluetooth /bin/false\n          install btusb /bin/false\n          blacklist bluetooth\n          blacklist btusb\n        mode: '0644'\n\n    - name: Block wireless via rfkill\n      ansible.builtin.command: rfkill block {{ item }}\n      loop:\n        - wifi\n        - bluetooth\n      failed_when: false\n      changed_when: false\n\n    - name: Disable wireless via NetworkManager\n      ansible.builtin.command: nmcli radio {{ item }} off\n      loop:\n        - wifi\n        - all\n      when: ansible_facts.packages['NetworkManager'] is defined\n      failed_when: false\n      changed_when: false\n\n    - name: Stop and disable Bluetooth service\n      ansible.builtin.systemd:\n        name: bluetooth.service\n        state: stopped\n        enabled: no\n        masked: yes\n      failed_when: false\n\n    - name: Unload wireless kernel modules\n      ansible.builtin.command: modprobe -r {{ item }}\n      loop:\n        - iwlmvm\n        - iwlwifi\n        - cfg80211\n        - mac80211\n        - bluetooth\n        - btusb\n      failed_when: false\n      changed_when: false\n\n    - name: Set reboot required flag\n      ansible.builtin.debug:\n        msg: \"REBOOT REQUIRED for wireless disabling to take full effect\"\n"
      },
      "windows": {
        "powershell": "# AC-18(3) Disable Wireless Networking for Windows\n# Requires Administrator privileges\n\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Error \"This script must be run as Administrator\"\n    exit 1\n}\n\nWrite-Host \"[AC-18(3)] Disabling wireless networking capabilities...\" -ForegroundColor Cyan\n\n# Disable WiFi adapters\nWrite-Host \"`nDisabling WiFi adapters...\"\n$wifiAdapters = Get-NetAdapter | Where-Object { $_.InterfaceDescription -match 'Wireless|Wi-Fi|802.11' -and $_.Status -ne 'Disabled' }\nif ($wifiAdapters) {\n    foreach ($adapter in $wifiAdapters) {\n        Write-Host \"  Disabling: $($adapter.Name) - $($adapter.InterfaceDescription)\"\n        Disable-NetAdapter -Name $adapter.Name -Confirm:$false\n    }\n    Write-Host \"  [SUCCESS] WiFi adapters disabled\" -ForegroundColor Green\n} else {\n    Write-Host \"  No active WiFi adapters found\" -ForegroundColor Gray\n}\n\n# Disable Bluetooth adapters\nWrite-Host \"`nDisabling Bluetooth adapters...\"\n$bluetoothDevices = Get-PnpDevice -Class Bluetooth | Where-Object { $_.Status -eq 'OK' }\nif ($bluetoothDevices) {\n    foreach ($device in $bluetoothDevices) {\n        Write-Host \"  Disabling: $($device.FriendlyName)\"\n        Disable-PnpDevice -InstanceId $device.InstanceId -Confirm:$false\n    }\n    Write-Host \"  [SUCCESS] Bluetooth adapters disabled\" -ForegroundColor Green\n} else {\n    Write-Host \"  No active Bluetooth adapters found\" -ForegroundColor Gray\n}\n\n# Stop and disable wireless services\nWrite-Host \"`nDisabling wireless services...\"\n$wirelessServices = @('WlanSvc', 'bthserv')\nforeach ($service in $wirelessServices) {\n    $svc = Get-Service -Name $service -ErrorAction SilentlyContinue\n    if ($svc) {\n        Write-Host \"  Stopping and disabling: $($svc.DisplayName)\"\n        Stop-Service -Name $service -Force -ErrorAction SilentlyContinue\n        Set-Service -Name $service -StartupType Disabled\n    }\n}\n\n# Use Group Policy to prevent wireless re-enabling (requires GPO)\nWrite-Host \"`nConfiguring Group Policy...\"\nWrite-Host \"  Note: Use Group Policy Editor (gpedit.msc) to enforce:\"\nWrite-Host \"    Computer Config > Admin Templates > Network > Windows Connect Now\"\nWrite-Host \"    - Prohibit access to Windows Connect Now wizards: Enabled\"\nWrite-Host \"    Computer Config > Admin Templates > Network > WLAN Service\"\nWrite-Host \"    - Allow Windows to automatically connect to suggested open hotspots: Disabled\"\n\nWrite-Host \"`n[SUCCESS] Wireless networking capabilities disabled.\" -ForegroundColor Green\nWrite-Host \"Recommendation: Configure BIOS/UEFI to disable wireless hardware for additional protection.\" -ForegroundColor Yellow\n\n# Verification\nWrite-Host \"`nVerification:\"\nGet-NetAdapter | Where-Object { $_.InterfaceDescription -match 'Wireless|Wi-Fi|Bluetooth' } | Format-Table Name, InterfaceDescription, Status -AutoSize\n"
      }
    },
    "cac_rules": [
      "wireless_disable_in_bios",
      "kernel_module_bluetooth_disabled",
      "kernel_module_iwlmvm_disabled",
      "kernel_module_iwlwifi_disabled",
      "kernel_module_cfg80211_disabled",
      "kernel_module_mac80211_disabled",
      "service_bluetooth_disabled",
      "wireless_disable_interfaces"
    ],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-040173",
      "validation_status": "PASS",
      "cac_issue": "https://issues.redhat.com/browse/CMP-148"
    },
    "ai_guidance": "This is the most effective wireless security control for systems that don't need wireless. Disable in BIOS first (prevents OS-level bypasses), then use OS-level controls (kernel modules, services) for defense-in-depth. Include physical removal of wireless cards for highest-security environments (SCIF, air-gapped networks).",
    "stig_id": "RHEL-08-040173"
  },
  {
    "control_id": "AC-18.4",
    "control_name": "Restrict Configurations by Users",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Identify and explicitly authorize users allowed to independently configure wireless networking capabilities.",
    "parent_control": "ac-18",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Only specific authorized users (typically administrators or network engineers) should be allowed to change wireless network settings. Regular users should not be able to connect to arbitrary WiFi networks or modify wireless configurations.",
    "example_implementation": "Use PolicyKit/polkit on Linux to restrict NetworkManager wireless configuration to administrators only. On Windows, use Group Policy to prevent standard users from adding WiFi networks or changing wireless settings. Maintain list of authorized wireless administrators.",
    "non_technical_guidance": "Prevent unauthorized wireless configuration:\n1. Create list of users authorized to configure wireless (typically IT staff only)\n2. Configure systems so regular users cannot:\n   - Add new WiFi networks\n   - Change WiFi passwords\n   - Modify wireless security settings\n   - Enable/disable wireless adapters\n3. Regular users can only connect to pre-configured approved networks\n4. Review authorized user list quarterly\n5. Audit wireless configuration changes\n6. Train users that attempting to bypass restrictions violates policy",
    "is_technical": true,
    "supplemental_guidance": "Organizations enforce restrictions through technical and administrative controls. Technical controls include PolicyKit, Group Policy, and mobile device management (MDM) solutions. Administrative controls include security policies, user agreements, and security awareness training.",
    "related_controls": [
      "AC-3",
      "AC-6",
      "AC-18",
      "CM-6",
      "SC-15"
    ],
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-18(4) Restrict Configurations by Users\n# Restrict wireless configuration to authorized administrators only\n\nset -e\n\necho \"[AC-18(4)] Restricting wireless configuration to administrators...\"\n\n# Create PolicyKit rule to restrict NetworkManager wireless configuration\nPOLKIT_DIR=\"/etc/polkit-1/localauthority/50-local.d\"\nmkdir -p \"$POLKIT_DIR\"\n\ncat > \"$POLKIT_DIR/10-restrict-wireless-config.pkla\" << 'EOF'\n# AC-18(4) Restrict Wireless Configuration by Users\n# Only administrators (wheel group) can configure wireless networking\n\n[Restrict NetworkManager wireless configuration]\nIdentity=unix-group:*;unix-user:*\nAction=org.freedesktop.NetworkManager.settings.modify.system;org.freedesktop.NetworkManager.settings.modify.own;org.freedesktop.NetworkManager.enable-disable-network;org.freedesktop.NetworkManager.enable-disable-wifi;org.freedesktop.NetworkManager.network-control\nResultAny=no\nResultInactive=no\nResultActive=no\n\n[Allow administrators to configure wireless]\nIdentity=unix-group:wheel\nAction=org.freedesktop.NetworkManager.settings.modify.system;org.freedesktop.NetworkManager.settings.modify.own;org.freedesktop.NetworkManager.enable-disable-network;org.freedesktop.NetworkManager.enable-disable-wifi;org.freedesktop.NetworkManager.network-control\nResultAny=auth_admin\nResultInactive=auth_admin\nResultActive=auth_admin\nEOF\n\nchmod 644 \"$POLKIT_DIR/10-restrict-wireless-config.pkla\"\n\necho \"PolicyKit rules created: $POLKIT_DIR/10-restrict-wireless-config.pkla\"\n\n# For systems using polkit .rules (newer format)\nPOLKIT_RULES_DIR=\"/etc/polkit-1/rules.d\"\nif [ -d \"$POLKIT_RULES_DIR\" ]; then\n  cat > \"$POLKIT_RULES_DIR/10-restrict-wireless-config.rules\" << 'EOF'\n// AC-18(4) Restrict Wireless Configuration by Users\n// Only members of 'wheel' group can configure wireless\n\npolkit.addRule(function(action, subject) {\n    if (action.id.match(\"org.freedesktop.NetworkManager\")) {\n        if (subject.isInGroup(\"wheel\")) {\n            return polkit.Result.AUTH_ADMIN;\n        } else {\n            return polkit.Result.NO;\n        }\n    }\n});\nEOF\n  chmod 644 \"$POLKIT_RULES_DIR/10-restrict-wireless-config.rules\"\n  echo \"PolicyKit rules created: $POLKIT_RULES_DIR/10-restrict-wireless-config.rules\"\nfi\n\n# Restart polkit to apply changes\nif systemctl is-active polkit.service &>/dev/null; then\n  echo \"Restarting polkit service...\"\n  systemctl restart polkit.service\nfi\n\necho\necho \"[SUCCESS] Wireless configuration restricted to administrators (wheel group).\"\necho\necho \"Authorized wireless administrators must be members of: wheel group\"\necho \"To add user to wheel: usermod -aG wheel <username>\"\necho\necho \"Verification: Non-admin users should not be able to add/modify WiFi networks via NetworkManager GUI.\"\n",
        "ansible": "---\n- name: AC-18(4) Restrict Wireless Configuration by Users\n  hosts: all\n  become: yes\n  tasks:\n    - name: Create PolicyKit local authority directory\n      ansible.builtin.file:\n        path: /etc/polkit-1/localauthority/50-local.d\n        state: directory\n        mode: '0755'\n\n    - name: Create PolicyKit rule to restrict wireless configuration (.pkla format)\n      ansible.builtin.copy:\n        dest: /etc/polkit-1/localauthority/50-local.d/10-restrict-wireless-config.pkla\n        content: |\n          # AC-18(4) Restrict Wireless Configuration by Users\n          \n          [Restrict NetworkManager wireless configuration]\n          Identity=unix-group:*;unix-user:*\n          Action=org.freedesktop.NetworkManager.settings.modify.system;org.freedesktop.NetworkManager.settings.modify.own;org.freedesktop.NetworkManager.enable-disable-network;org.freedesktop.NetworkManager.enable-disable-wifi;org.freedesktop.NetworkManager.network-control\n          ResultAny=no\n          ResultInactive=no\n          ResultActive=no\n          \n          [Allow administrators to configure wireless]\n          Identity=unix-group:wheel\n          Action=org.freedesktop.NetworkManager.settings.modify.system;org.freedesktop.NetworkManager.settings.modify.own;org.freedesktop.NetworkManager.enable-disable-network;org.freedesktop.NetworkManager.enable-disable-wifi;org.freedesktop.NetworkManager.network-control\n          ResultAny=auth_admin\n          ResultInactive=auth_admin\n          ResultActive=auth_admin\n        mode: '0644'\n\n    - name: Create PolicyKit rules directory\n      ansible.builtin.file:\n        path: /etc/polkit-1/rules.d\n        state: directory\n        mode: '0755'\n\n    - name: Create PolicyKit rule to restrict wireless configuration (.rules format)\n      ansible.builtin.copy:\n        dest: /etc/polkit-1/rules.d/10-restrict-wireless-config.rules\n        content: |\n          // AC-18(4) Restrict Wireless Configuration by Users\n          \n          polkit.addRule(function(action, subject) {\n              if (action.id.match(\"org.freedesktop.NetworkManager\")) {\n                  if (subject.isInGroup(\"wheel\")) {\n                      return polkit.Result.AUTH_ADMIN;\n                  } else {\n                      return polkit.Result.NO;\n                  }\n              }\n          });\n        mode: '0644'\n\n    - name: Restart polkit service\n      ansible.builtin.systemd:\n        name: polkit.service\n        state: restarted\n      when: ansible_facts.services['polkit.service'] is defined\n      failed_when: false\n\n    - name: Display authorized administrators group\n      ansible.builtin.debug:\n        msg: \"Wireless configuration restricted to members of 'wheel' group. Use 'usermod -aG wheel <user>' to authorize.\"\n"
      },
      "windows": {
        "powershell": "# AC-18(4) Restrict Wireless Configuration by Users\n# Use Group Policy to prevent standard users from configuring wireless\n\nif (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {\n    Write-Error \"This script must be run as Administrator\"\n    exit 1\n}\n\nWrite-Host \"[AC-18(4)] Restricting wireless configuration to administrators...\" -ForegroundColor Cyan\n\n# Registry-based restrictions (applies immediately, but GPO preferred for enterprise)\n$regPath = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\NetworkConnectivityStatusIndicator\"\n\nWrite-Host \"`nApplying registry-based wireless restrictions...\"\nif (-not (Test-Path $regPath)) {\n    New-Item -Path $regPath -Force | Out-Null\n}\n\n# Prevent users from configuring wireless networks\nSet-ItemProperty -Path $regPath -Name \"NoActiveProbe\" -Value 1 -Type DWord\n\n# Additional registry restrictions\n$wlanPath = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\"\nif (-not (Test-Path $wlanPath)) {\n    New-Item -Path $wlanPath -Force | Out-Null\n}\nSet-ItemProperty -Path $wlanPath -Name \"DontDisplayNetworkSelectionUI\" -Value 1 -Type DWord\n\nWrite-Host \"  Registry restrictions applied\" -ForegroundColor Green\n\n# Remove permissions for standard users to modify WLAN profiles\nWrite-Host \"`nRestricting WLAN profile permissions...\"\n$wlanProfilePath = \"$env:ProgramData\\Microsoft\\Wlansvc\\Profiles\\Interfaces\"\nif (Test-Path $wlanProfilePath) {\n    Get-ChildItem -Path $wlanProfilePath -Recurse -Filter \"*.xml\" | ForEach-Object {\n        $acl = Get-Acl $_.FullName\n        # Remove Users group write permissions\n        $acl.SetAccessRuleProtection($true, $false)\n        $adminRule = New-Object System.Security.AccessControl.FileSystemAccessRule(\"Administrators\", \"FullControl\", \"Allow\")\n        $systemRule = New-Object System.Security.AccessControl.FileSystemAccessRule(\"SYSTEM\", \"FullControl\", \"Allow\")\n        $acl.SetAccessRule($adminRule)\n        $acl.SetAccessRule($systemRule)\n        Set-Acl -Path $_.FullName -AclObject $acl\n    }\n    Write-Host \"  WLAN profile permissions restricted to Administrators\" -ForegroundColor Green\n}\n\nWrite-Host \"`n[SUCCESS] Wireless configuration restricted.\" -ForegroundColor Green\nWrite-Host \"`nRECOMMENDED: Deploy Group Policy settings:\" -ForegroundColor Yellow\nWrite-Host \"  Computer Config > Admin Templates > Network > Windows Connection Manager\"\nWrite-Host \"    - Minimize the number of simultaneous connections: Enabled\"\nWrite-Host \"    - Prohibit connection to non-domain networks: Enabled\"\nWrite-Host \"  Computer Config > Admin Templates > Network > WLAN Service\"\nWrite-Host \"    - Allow Windows to automatically connect to suggested open hotspots: Disabled\"\nWrite-Host \"`n  User Config > Admin Templates > Network > Network Connections\"\nWrite-Host \"    - Prohibit access to properties of components of LAN connection: Enabled\"\nWrite-Host \"    - Ability to change properties of all-user remote access connection: Disabled\"\n\nWrite-Host \"`nNote: Administrators group members can configure wireless. Restrict group membership accordingly.\"\n"
      }
    },
    "cac_rules": [
      "wireless_disable_in_bios",
      "kernel_module_bluetooth_disabled",
      "service_bluetooth_disabled",
      "wireless_disable_interfaces",
      "kernel_module_iwlmvm_disabled",
      "kernel_module_iwlwifi_disabled",
      "kernel_module_cfg80211_disabled",
      "kernel_module_mac80211_disabled",
      "dconf_gnome_disable_wifi_create"
    ],
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-040174",
      "validation_status": "PASS"
    },
    "ai_guidance": "Use PolicyKit/polkit on Linux and Group Policy on Windows to lock down wireless configuration. Only designated administrators should modify WiFi settings. For high-security environments, combine with AC-18(3) to disable wireless entirely. Audit wireless configuration changes and maintain explicit list of authorized wireless administrators.",
    "stig_id": "RHEL-08-040174"
  },
  {
    "control_id": "AC-18.5",
    "control_name": "Antennas and Transmission Power Levels",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Select radio antennas and calibrate transmission power levels to reduce the probability that signals from wireless access points can be received outside of organization-controlled boundaries.",
    "parent_control": "ac-18",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": true
    },
    "plain_english_explanation": "Choose wireless antenna types and adjust transmission power so that your WiFi signal doesn't extend beyond your physical premises. This prevents unauthorized users outside your building from accessing your wireless networks.",
    "example_implementation": "Conduct wireless site survey to map signal coverage. Use directional antennas in perimeter areas pointing inward. Reduce access point transmission power to minimize signal leakage beyond building boundaries. Test coverage quarterly to verify signals don't extend to parking lots or public areas.",
    "non_technical_guidance": "Control wireless signal propagation:\n1. Work with wireless vendor/consultant to perform site survey\n2. Map where wireless signals can be detected outside your building\n3. Adjust access point power settings to minimize external coverage\n4. Use directional antennas in perimeter rooms pointing toward interior\n5. Shield walls/windows if necessary to contain signals\n6. Regularly test wireless coverage from parking lots and adjacent buildings\n7. Document power levels and antenna configurations\n8. Re-survey after facility changes or new access point installations",
    "is_technical": true,
    "supplemental_guidance": "Organizations can use low gain antennas, reduce transmitter power, or employ RF shielding to limit wireless signal propagation beyond controlled areas. Periodic wireless site surveys verify signals remain contained. This control is primarily physical/environmental and applies to wireless access point infrastructure, not endpoint devices.",
    "related_controls": [
      "AC-18",
      "PE-3",
      "PE-18",
      "PE-19",
      "SC-7"
    ],
    "implementation_scripts": {
      "linux": {
        "note": "This control applies to wireless access point infrastructure configuration, not endpoint systems. Implementation requires wireless controller/AP management tools.",
        "bash": "#!/bin/bash\n# AC-18(5) Antennas and Transmission Power Levels\n# Endpoint validation script - reports current transmission power\n\necho \"[AC-18(5)] Checking wireless transmission power levels...\"\necho \"Note: This control primarily applies to access point infrastructure.\"\necho\n\nif ! command -v iw &> /dev/null; then\n  echo \"iw command not found. Install iw package to check wireless power levels.\"\n  exit 1\nfi\n\nfor iface in $(iw dev | awk '/Interface/ {print $2}'); do\n  echo \"Interface: $iface\"\n  echo \"  Current TX Power:\"\n  iw dev $iface info | grep txpower\n  echo\n  echo \"  Supported TX Power Levels:\"\n  iw phy$(iw dev $iface info | grep wiphy | awk '{print $2}') info | grep -A 10 'Frequencies:' | grep 'dBm'\n  echo\ndone\n\necho \"To reduce transmission power (example):\"\necho \"  iw dev <interface> set txpower fixed <mBm>\"\necho \"  Example: iw dev wlan0 set txpower fixed 1500  (15 dBm)\"\necho\necho \"For enterprise networks, configure power levels on wireless controllers/APs.\"\n",
        "ansible": "---\n- name: AC-18(5) Antennas and Transmission Power Levels - Endpoint Report\n  hosts: all\n  tasks:\n    - name: Check for wireless interfaces\n      ansible.builtin.shell: iw dev | awk '/Interface/ {print $2}'\n      register: wireless_interfaces\n      failed_when: false\n      changed_when: false\n\n    - name: Get current transmission power for each interface\n      ansible.builtin.shell: iw dev {{ item }} info | grep txpower\n      loop: \"{{ wireless_interfaces.stdout_lines }}\"\n      register: tx_power\n      failed_when: false\n      changed_when: false\n\n    - name: Report transmission power levels\n      ansible.builtin.debug:\n        msg: \"{{ tx_power.results }}\"\n\n    - name: Display guidance\n      ansible.builtin.debug:\n        msg: |\n          AC-18(5) applies primarily to wireless access point infrastructure.\n          Configure transmission power and antenna selection on wireless controllers.\n          Endpoint devices: Power levels shown above. Adjust if device acts as AP.\n"
      },
      "windows": {
        "note": "This control applies to wireless access point infrastructure, not Windows endpoints. Script reports current adapter power settings.",
        "powershell": "# AC-18(5) Antennas and Transmission Power Levels\n# Endpoint reporting script for Windows\n\nWrite-Host \"[AC-18(5)] Checking wireless adapter power settings...\" -ForegroundColor Cyan\nWrite-Host \"Note: This control primarily applies to access point infrastructure.`n\"\n\n$adapters = Get-NetAdapter | Where-Object { $_.InterfaceDescription -match 'Wireless|Wi-Fi' -and $_.Status -eq 'Up' }\n\nif (-not $adapters) {\n    Write-Host \"No active wireless adapters found.\" -ForegroundColor Gray\n    exit 0\n}\n\nforeach ($adapter in $adapters) {\n    Write-Host \"Adapter: $($adapter.Name) - $($adapter.InterfaceDescription)\" -ForegroundColor Yellow\n    \n    # Check current power settings\n    $powerConfig = Get-NetAdapterPowerManagement -Name $adapter.Name\n    Write-Host \"  Power Management:\"\n    Write-Host \"    Allow computer to turn off: $($powerConfig.AllowComputerToTurnOffDevice)\"\n    Write-Host \"    Wake on Magic Packet: $($powerConfig.WakeOnMagicPacket)\"\n    \n    # Check advanced adapter settings\n    Write-Host \"`n  Advanced Settings:\"\n    $advSettings = Get-NetAdapterAdvancedProperty -Name $adapter.Name | Where-Object { $_.RegistryKeyword -match 'Power|Transmit' }\n    foreach ($setting in $advSettings) {\n        Write-Host \"    $($setting.DisplayName): $($setting.DisplayValue)\"\n    }\n    \n    Write-Host \"\"\n}\n\nWrite-Host \"Enterprise Implementation Guidance:\" -ForegroundColor Green\nWrite-Host \"  1. Conduct wireless site survey using tools like NetSpot, Ekahau, or Metageek inSSIDer\"\nWrite-Host \"  2. Access wireless controller/AP management interface\"\nWrite-Host \"  3. Configure power levels per-AP to minimize signal outside boundaries\"\nWrite-Host \"  4. Use directional antennas in perimeter areas\"\nWrite-Host \"  5. Document baseline and re-survey quarterly\"\nWrite-Host \"`nCommon Controller Interfaces:\"\nWrite-Host \"  - Cisco WLC: Wireless > Access Points > Radio > 802.11 > Transmit Power Levels\"\nWrite-Host \"  - Aruba Controller: Configuration > AP Configuration > Radio Settings\"\nWrite-Host \"  - Ubiquiti UniFi: Settings > Wireless Networks > [SSID] > Advanced > Transmit Power\"\n"
      }
    },
    "metadata": {
      "status": "not_applicable",
      "last_updated": "2025-11-20T00:00:00",
      "has_scripts": true,
      "stig_id": "RHEL-08-040175",
      "validation_status": "PASS",
      "notes": "This control applies primarily to wireless access point infrastructure configuration, not endpoint systems. Implementation requires wireless controller, site survey tools, and physical facility access. Scripts provided for endpoint reporting only."
    },
    "ai_guidance": "Physical infrastructure control. Requires wireless site survey and AP configuration. Not automatable via endpoint scripts. Perform quarterly surveys to verify signal containment. Critical for facilities with sensitive operations (SCIF, research labs, financial institutions). Consider RF shielding for high-security areas. Combine with strong authentication (AC-18.1) since signal leakage is never 100% preventable.",
    "stig_id": "RHEL-08-040175"
  },
  {
    "control_id": "AC-19",
    "control_name": "Access Control for Mobile Devices",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "a. Establish configuration requirements, connection requirements, and implementation guidance for organization-controlled mobile devices, to include when such devices are outside of controlled areas; and\nb. Authorize the connection of mobile devices to organizational systems.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must create comprehensive policies and procedures for managing mobile devices (smartphones, tablets, laptops) that connect to organizational systems. This includes defining security configurations (encryption, authentication, antivirus software), connection requirements (VPN usage, network access rules), and implementation guidance for when devices operate outside secure facilities. Organizations must also establish an authorization process before allowing any mobile device to access organizational systems.",
    "example_implementation": "Develop a Mobile Device Management (MDM) policy that defines: (1) Required security configurations (minimum OS version, mandatory encryption, screen lock timeout), (2) Connection requirements (VPN mandatory for remote access, certificate-based authentication), (3) Approved device models and operating systems, (4) Authorization workflow (IT approval, device registration, security assessment), (5) User responsibilities (reporting lost devices, maintaining updates), (6) Different requirement sets for devices inside vs. outside organizational facilities.",
    "non_technical_guidance": "To ensure compliance with AC-19:\n1. Create a mobile device security policy covering all organization-controlled mobile devices (company-issued smartphones, tablets, laptops).\n2. Define what constitutes a 'controlled area' (e.g., organizational facilities with physical security) vs. outside areas (public spaces, home offices).\n3. Establish stricter requirements for devices outside controlled areas (mandatory VPN, automatic screen lock after 5 minutes, enhanced encryption).\n4. Create an authorization process: users must request permission before connecting personal devices to organizational systems, IT must approve and register each device.\n5. Implement Mobile Device Management (MDM) software to enforce security configurations remotely.\n6. Train users on mobile device security responsibilities and consequences of policy violations.\n7. Regularly audit authorized devices and revoke access for non-compliant or compromised devices.\n8. Document all policies and procedures, review annually or when significant changes occur.",
    "is_technical": true,
    "enhancements": [
      "AC-19(1)",
      "AC-19(2)",
      "AC-19(3)",
      "AC-19(4)",
      "AC-19(5)"
    ],
    "related_controls": [
      "AC-3",
      "AC-7",
      "AC-18",
      "AC-20",
      "CA-9",
      "CM-2",
      "IA-2",
      "IA-3",
      "MP-2",
      "MP-4",
      "MP-5",
      "PL-4",
      "SC-7",
      "SC-43",
      "SI-3",
      "SI-4"
    ],
    "supplemental_guidance": "A mobile device is a computing device that: (i) has a small form factor such that it can easily be carried by a single individual; (ii) is designed to operate without a physical connection; (iii) possesses local, non-removable or removable data storage; and (iv) includes a self-contained power source. Mobile device functionality may include voice communication capabilities, on-board sensors for capturing information, and built-in features for synchronizing local data with remote locations. Examples include smartphones, tablets, and e-readers. Protection and control of mobile devices is behavior or policy-based, requiring users to take physical action to protect devices when outside controlled areas. Usage restrictions and implementation guidance for mobile devices include: configuration management, device identification and authentication, implementation of mandatory protective software (e.g., malicious code detection, firewall), scanning devices for malicious code, updating virus protection software, scanning for critical software updates and patches, conducting primary operating system (and possibly other resident software) integrity checks, and disabling unnecessary hardware (e.g., wireless, infrared). Organizations should recognize that adequate security for mobile devices goes beyond the requirements in this control. Many safeguards and countermeasures for mobile devices are reflected in other security controls. AC-20 addresses mobile devices that are not organization-controlled.",
    "implementation_scripts": {
      "linux": {
        "audit": "#!/bin/bash\n# Audit mobile device connections and configurations\necho 'Checking for Mobile Device Management agents...'\nif systemctl is-active --quiet mdm-agent 2>/dev/null; then\n    echo 'PASS: MDM agent is running'\nelse\n    echo 'FAIL: MDM agent not found or not running'\nfi\n\necho 'Checking VPN configuration for remote access...'\nif [ -d /etc/openvpn ] || [ -d /etc/wireguard ]; then\n    echo 'PASS: VPN configuration found'\nelse\n    echo 'WARNING: No VPN configuration detected'\nfi\n\necho 'Checking Bluetooth device connections...'\nif command -v bluetoothctl &>/dev/null; then\n    bluetoothctl devices | grep -q 'Device' && echo 'INFO: Bluetooth devices detected' || echo 'INFO: No Bluetooth devices'\nfi\n\necho 'Checking USB device authorization (USBGuard)...'\nif systemctl is-active --quiet usbguard 2>/dev/null; then\n    echo 'PASS: USBGuard is active (related to AC-19 mobile device control)'\nelse\n    echo 'INFO: USBGuard not active (consider for portable storage control)'\nfi",
        "remediation": "#!/bin/bash\n# Implement basic mobile device connection controls\necho 'Implementing mobile device security controls...'\n\n# Install USBGuard for portable storage control (supports AC-19 enhancements)\nif ! rpm -q usbguard &>/dev/null && ! dpkg -l | grep -q usbguard 2>/dev/null; then\n    echo 'Installing USBGuard...'\n    if [ -f /etc/redhat-release ]; then\n        yum install -y usbguard\n    elif [ -f /etc/debian_version ]; then\n        apt-get update && apt-get install -y usbguard\n    fi\nfi\n\n# Enable USBGuard service\nsystemctl enable usbguard\nsystemctl start usbguard\n\n# Configure screen lock timeout (15 minutes for workstations acting as mobile-connected systems)\nif [ -f /etc/dconf/db/local.d/00-screensaver ]; then\n    echo 'Screen lock already configured'\nelse\n    mkdir -p /etc/dconf/db/local.d/\n    cat > /etc/dconf/db/local.d/00-screensaver <<'EOF'\n[org/gnome/desktop/session]\nidle-delay=uint32 900\n\n[org/gnome/desktop/screensaver]\nlock-enabled=true\nlock-delay=uint32 0\nEOF\n    dconf update\nfi\n\necho 'Mobile device controls implemented. Configure MDM solution separately.'"
      },
      "windows": {
        "audit": "$ErrorActionPreference = 'SilentlyContinue'\nWrite-Host 'Checking Mobile Device Management (MDM) enrollment...'\n$mdmEnrolled = Get-WmiObject -Namespace root\\cimv2\\mdm\\dmmap -Class MDM_EnterpriseModernAppManagement_AppManagement01\nif ($mdmEnrolled) {\n    Write-Host 'PASS: System is MDM enrolled'\n} else {\n    Write-Host 'FAIL: System is not MDM enrolled'\n}\n\nWrite-Host 'Checking BitLocker encryption (related to AC-19(5))...'\n$bitlockerStatus = Get-BitLockerVolume -MountPoint C:\nif ($bitlockerStatus.ProtectionStatus -eq 'On') {\n    Write-Host 'PASS: BitLocker is enabled on system drive'\n} else {\n    Write-Host 'WARNING: BitLocker is not enabled (required for AC-19(5))'\n}\n\nWrite-Host 'Checking VPN client installation...'\n$vpnConnections = Get-VpnConnection\nif ($vpnConnections) {\n    Write-Host 'PASS: VPN connections configured'\n} else {\n    Write-Host 'WARNING: No VPN connections found'\n}\n\nWrite-Host 'Checking Windows Defender status...'\n$defenderStatus = Get-MpComputerStatus\nif ($defenderStatus.AntivirusEnabled) {\n    Write-Host 'PASS: Antivirus is enabled'\n} else {\n    Write-Host 'FAIL: Antivirus is not enabled'\n}",
        "remediation": "$ErrorActionPreference = 'Stop'\nWrite-Host 'Implementing mobile device security controls...'\n\n# Enable Windows Defender\nWrite-Host 'Enabling Windows Defender...'\nSet-MpPreference -DisableRealtimeMonitoring $false\n\n# Configure screen lock timeout (15 minutes)\nWrite-Host 'Configuring screen lock timeout...'\npowercfg -change -monitor-timeout-ac 15\npowercfg -change -monitor-timeout-dc 10\n\n# Enable BitLocker if TPM is available (supports AC-19(5))\nWrite-Host 'Checking BitLocker capability...'\n$tpm = Get-Tpm\nif ($tpm.TpmPresent -and $tpm.TpmReady) {\n    Write-Host 'TPM available. Enable BitLocker via Group Policy or:'\n    Write-Host 'Enable-BitLocker -MountPoint C: -EncryptionMethod XtsAes256 -TpmProtector'\n} else {\n    Write-Host 'WARNING: TPM not available. BitLocker requires manual configuration.'\n}\n\nWrite-Host 'Configure MDM enrollment separately via Settings > Accounts > Access work or school'"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00+00:00",
      "has_scripts": true,
      "created_by": "LOVELESS",
      "notes": "Created from NIST SP 800-53 Rev 5 authoritative sources. MDM solution required for full compliance."
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "last_analyzed": "2025-11-20T00:00:00+00:00",
      "source": "NIST SP 800-53 Rev 5 + ComplianceAsCode USBGuard rules",
      "implementation_guidance": "Requires organizational policy (Mobile Device Management policy) and technical controls (MDM software, VPN, device authentication). USBGuard rules in CAC support portable storage aspects (AC-19 enhancements)."
    },
    "rationale": "Mobile devices present significant security risks due to their portability, wireless capabilities, and operation in untrusted environments. Without proper access controls, mobile devices can: (1) Introduce malware to organizational networks, (2) Exfiltrate sensitive data if lost or stolen, (3) Provide unauthorized network access, (4) Bypass physical security controls. Establishing configuration and connection requirements ensures mobile devices meet minimum security standards before accessing organizational resources. Authorization requirements prevent rogue or non-compliant devices from connecting to organizational systems.",
    "ai_guidance": "Create a Mobile Device Management (MDM) policy. Define security settings for phones and laptops (encryption, passwords, VPN). Get IT approval before connecting devices to company systems. Use MDM software to enforce these settings automatically."
  },
  {
    "control_id": "AC-19.1",
    "control_name": "Use of Writable and Portable Storage Devices",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Prohibit the use of writable and portable storage devices in organizational systems when such devices have no identifiable owner.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must prevent employees from using USB flash drives, external hard drives, SD cards, or other portable storage devices if the organization cannot identify who owns the device. This prevents unknown or untrusted storage media from introducing malware or being used to steal data. Only registered, organization-approved portable storage devices with known owners should be permitted on organizational systems.",
    "example_implementation": "Implement USBGuard on Linux systems to create a whitelist of approved USB device IDs. Configure Windows systems with Group Policy to block removable storage devices except those explicitly authorized. Establish a portable storage device registration process where employees must register USB drives with IT, receive approval, and have the device serial number added to the whitelist. Any unregistered USB device attempting to connect is automatically blocked and an alert sent to security personnel.",
    "non_technical_guidance": "To ensure compliance with AC-19(1):\n1. Create a policy requiring all portable storage devices to be registered with IT before use.\n2. Establish a registration process: employees submit device information (brand, model, serial number), IT security reviews and approves, device added to approved list.\n3. Implement technical controls that automatically block unregistered USB devices from connecting to organizational computers.\n4. Train employees on the risks of unidentified portable storage (malware, data theft) and the importance of using only approved devices.\n5. Conduct periodic audits to ensure compliance and identify any unauthorized device connection attempts.\n6. Define disciplinary measures for employees who attempt to use unregistered portable storage.\n7. Consider alternatives to portable storage: cloud storage, secure file transfer protocols, encrypted email for data transfer needs.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-19",
      "MP-7",
      "MP-7(1)"
    ],
    "supplemental_guidance": "Requiring identifiable owners for writable and portable storage devices reduces the risk of using such devices by: (1) Establishing accountability, (2) Enabling security tracking and auditing, (3) Facilitating incident response if a device is lost or compromised. Portable storage devices with no identifiable owner can be used as attack vectors to introduce malware or exfiltrate data. Organizations should implement both technical controls (USBGuard, device whitelisting, Group Policy) and organizational controls (registration process, acceptable use policy, training). This enhancement applies to organization-controlled systems; it does not extend to external systems.",
    "implementation_scripts": {
      "linux": {
        "audit": "#!/bin/bash\n# Audit USBGuard configuration for AC-19(1) compliance\necho 'AC-19(1): Checking portable storage device controls...'\n\n# Check if USBGuard is installed\nif rpm -q usbguard &>/dev/null || dpkg -l | grep -q usbguard 2>/dev/null; then\n    echo 'PASS: USBGuard package is installed'\nelse\n    echo 'FAIL: USBGuard package is not installed'\n    exit 1\nfi\n\n# Check if USBGuard service is enabled and running\nif systemctl is-enabled usbguard &>/dev/null; then\n    echo 'PASS: USBGuard service is enabled'\nelse\n    echo 'FAIL: USBGuard service is not enabled'\nfi\n\nif systemctl is-active usbguard &>/dev/null; then\n    echo 'PASS: USBGuard service is running'\nelse\n    echo 'FAIL: USBGuard service is not running'\nfi\n\n# Check USBGuard configuration\nif [ -f /etc/usbguard/usbguard-daemon.conf ]; then\n    echo 'PASS: USBGuard configuration file exists'\n    \n    # Check audit backend\n    if grep -q '^AuditBackend=LinuxAudit' /etc/usbguard/usbguard-daemon.conf; then\n        echo 'PASS: USBGuard audit backend is configured for Linux Audit'\n    else\n        echo 'WARNING: USBGuard audit backend not configured for Linux Audit'\n    fi\nelse\n    echo 'FAIL: USBGuard configuration file not found'\nfi\n\n# Check USBGuard rules\nif [ -f /etc/usbguard/rules.conf ]; then\n    echo 'INFO: USBGuard rules configuration exists'\n    rule_count=$(grep -c '^allow' /etc/usbguard/rules.conf 2>/dev/null || echo 0)\n    echo \"INFO: Found $rule_count allow rules (approved devices)\"\n    \n    # Check for HID and hub allowance\n    if grep -q 'allow with-interface match-all { 03:\\*:\\* 09:00:\\* }' /etc/usbguard/rules.conf; then\n        echo 'PASS: HID devices and USB hubs are allowed (required for keyboard/mouse)'\n    else\n        echo 'WARNING: HID/hub allow rule not found (may prevent keyboard/mouse usage)'\n    fi\nelse\n    echo 'WARNING: USBGuard rules file not found (default deny-all may be active)'\nfi\n\necho 'Listing currently connected USB devices:'\nusbguard list-devices 2>/dev/null | head -20 || echo 'Unable to list devices'",
        "remediation": "#!/bin/bash\n# Implement AC-19(1): Portable Storage Device Control via USBGuard\nset -e\n\necho 'Implementing AC-19(1) compliance via USBGuard...'\n\n# Install USBGuard\nif ! rpm -q usbguard &>/dev/null && ! dpkg -l | grep -q usbguard 2>/dev/null; then\n    echo 'Installing USBGuard...'\n    if [ -f /etc/redhat-release ]; then\n        yum install -y usbguard\n    elif [ -f /etc/debian_version ]; then\n        apt-get update && apt-get install -y usbguard\n    else\n        echo 'ERROR: Unsupported distribution'\n        exit 1\n    fi\nfi\n\n# Configure USBGuard daemon\necho 'Configuring USBGuard daemon...'\nif [ ! -f /etc/usbguard/usbguard-daemon.conf ]; then\n    echo 'ERROR: USBGuard configuration file not found'\n    exit 1\nfi\n\n# Set audit backend to Linux Audit\nsed -i 's/^AuditBackend=.*/AuditBackend=LinuxAudit/' /etc/usbguard/usbguard-daemon.conf || \\\n    echo 'AuditBackend=LinuxAudit' >> /etc/usbguard/usbguard-daemon.conf\n\necho 'Audit backend configured for Linux Audit'\n\n# Generate initial policy based on currently connected devices\nif [ ! -f /etc/usbguard/rules.conf ] || [ ! -s /etc/usbguard/rules.conf ]; then\n    echo 'Generating initial USBGuard policy from currently connected devices...'\n    usbguard generate-policy > /etc/usbguard/rules.conf\n    echo 'Initial policy generated'\nfi\n\n# Ensure HID devices and hubs are allowed (for keyboard/mouse/monitor hubs)\nif ! grep -q 'allow with-interface match-all { 03:\\*:\\* 09:00:\\* }' /etc/usbguard/rules.conf; then\n    echo 'Adding HID and USB hub allow rule...'\n    sed -i '1i allow with-interface match-all { 03:*:* 09:00:* }' /etc/usbguard/rules.conf\nfi\n\necho 'USBGuard rules configuration:'\nhead -10 /etc/usbguard/rules.conf\n\n# Enable and start USBGuard service\necho 'Enabling USBGuard service...'\nsystemctl enable usbguard\nsystemctl restart usbguard\n\nif systemctl is-active usbguard &>/dev/null; then\n    echo 'SUCCESS: USBGuard is now active and enforcing portable storage device controls'\n    echo ''\n    echo 'IMPORTANT: To authorize a new USB device:'\n    echo '  1. Connect the device'\n    echo '  2. Run: usbguard list-devices'\n    echo '  3. Find the device ID number'\n    echo '  4. Run: usbguard allow-device <ID>'\n    echo '  5. To make permanent: usbguard allow-device <ID> -p'\nelse\n    echo 'ERROR: USBGuard failed to start'\n    systemctl status usbguard\n    exit 1\nfi\n\necho ''\necho 'AC-19(1) implementation complete. All unregistered USB devices are now blocked.'"
      },
      "windows": {
        "audit": "$ErrorActionPreference = 'SilentlyContinue'\nWrite-Host 'AC-19(1): Checking portable storage device controls...'\n\n# Check if removable storage is restricted via Group Policy\n$regPath = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices'\nif (Test-Path $regPath) {\n    $denyRead = Get-ItemProperty -Path \"$regPath\\{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}\" -Name 'Deny_Read' -ErrorAction SilentlyContinue\n    $denyWrite = Get-ItemProperty -Path \"$regPath\\{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}\" -Name 'Deny_Write' -ErrorAction SilentlyContinue\n    \n    if ($denyWrite.Deny_Write -eq 1) {\n        Write-Host 'PASS: Removable storage write access is denied by policy'\n    } else {\n        Write-Host 'FAIL: Removable storage write access is not restricted'\n    }\n    \n    if ($denyRead.Deny_Read -eq 1) {\n        Write-Host 'INFO: Removable storage read access is denied by policy (very restrictive)'\n    } else {\n        Write-Host 'INFO: Removable storage read access is allowed'\n    }\n} else {\n    Write-Host 'FAIL: Removable storage device policies not configured'\n}\n\n# Check BitLocker To Go (encryption for removable storage)\n$bitlockerReg = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\FVE'\nif (Test-Path $bitlockerReg) {\n    $rdvRequired = Get-ItemProperty -Path $bitlockerReg -Name 'RDVDenyWriteAccess' -ErrorAction SilentlyContinue\n    if ($rdvRequired.RDVDenyWriteAccess -eq 1) {\n        Write-Host 'PASS: BitLocker To Go encryption required for removable drives'\n    } else {\n        Write-Host 'INFO: BitLocker To Go not enforced for removable drives'\n    }\n} else {\n    Write-Host 'INFO: BitLocker To Go policies not configured'\n}\n\n# List currently connected removable storage devices\nWrite-Host ''\nWrite-Host 'Currently connected removable storage devices:'\nGet-PnpDevice -Class 'USB','DiskDrive' | Where-Object {$_.Status -eq 'OK'} | Format-Table -AutoSize",
        "remediation": "$ErrorActionPreference = 'Stop'\nWrite-Host 'Implementing AC-19(1) compliance via Group Policy...'\n\n# Create registry path for removable storage policies\n$regPath = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices'\n$usbStorageGUID = '{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}'\n$fullPath = \"$regPath\\$usbStorageGUID\"\n\nif (-not (Test-Path $regPath)) {\n    New-Item -Path $regPath -Force | Out-Null\n    Write-Host 'Created removable storage policy registry path'\n}\n\nif (-not (Test-Path $fullPath)) {\n    New-Item -Path $fullPath -Force | Out-Null\n}\n\n# Deny write access to all removable storage (default deny, allow via exception)\nSet-ItemProperty -Path $fullPath -Name 'Deny_Write' -Value 1 -Type DWord\nWrite-Host 'CONFIGURED: Write access to removable storage is now denied by default'\n\n# Optional: Also deny read access for maximum security (uncomment if required)\n# Set-ItemProperty -Path $fullPath -Name 'Deny_Read' -Value 1 -Type DWord\n# Write-Host 'CONFIGURED: Read access to removable storage is now denied'\n\nWrite-Host ''\nWrite-Host 'IMPORTANT: To allow specific approved USB devices:'\nWrite-Host '1. Identify device Hardware IDs: Get-PnpDevice -Class USB | Select-Object FriendlyName, InstanceId'\nWrite-Host '2. Create exemption via Group Policy: Computer Configuration > Administrative Templates >'\nWrite-Host '   System > Removable Storage Access > Add device to allow list'\nWrite-Host ''\nWrite-Host 'Alternative: Use BitLocker To Go to require encryption on all removable storage'\nWrite-Host 'Configure via: Computer Configuration > Administrative Templates > Windows Components >'\nWrite-Host 'BitLocker Drive Encryption > Removable Data Drives'\n\n# Configure BitLocker To Go requirement (requires Enterprise edition)\n$bitlockerReg = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\FVE'\nif (-not (Test-Path $bitlockerReg)) {\n    New-Item -Path $bitlockerReg -Force | Out-Null\n}\n\nSet-ItemProperty -Path $bitlockerReg -Name 'RDVDenyWriteAccess' -Value 1 -Type DWord\nWrite-Host 'CONFIGURED: BitLocker To Go encryption required for removable drives (Enterprise edition)'\n\nWrite-Host ''\nWrite-Host 'AC-19(1) implementation complete. Group Policy update may require system restart.'\nWrite-Host 'Run \"gpupdate /force\" to apply immediately.'"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00+00:00",
      "has_scripts": true,
      "created_by": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T00:00:00+00:00",
      "source": "ComplianceAsCode",
      "related_cac_rules": [
        "linux_os/guide/services/usbguard/package_usbguard_installed",
        "linux_os/guide/services/usbguard/service_usbguard_enabled",
        "linux_os/guide/services/usbguard/configure_usbguard_auditbackend",
        "linux_os/guide/services/usbguard/usbguard_allow_hid_and_hub"
      ],
      "implementation_guidance": "Fully automated via USBGuard on Linux systems. Windows requires Group Policy configuration. CAC rules provide complete Linux implementation."
    },
    "rationale": "Portable storage devices with no identifiable owner pose significant security risks: (1) Unknown devices may contain malware designed to compromise systems, (2) Employees may use untrusted devices to exfiltrate sensitive data, (3) Lost or stolen devices with organizational data cannot be tracked to responsible parties, (4) Incident response is hindered without device ownership information. By requiring identifiable owners, organizations establish accountability and can implement whitelisting controls that only permit registered, approved devices. This significantly reduces the attack surface from portable storage threats.",
    "ai_guidance": "Block USB drives and external storage unless IT has registered them. Use USBGuard on Linux or Group Policy on Windows to automatically block unknown USB devices. Employees must register USB drives with IT before use."
  },
  {
    "control_id": "AC-19.2",
    "control_name": "Use of Personally Owned Portable Storage Devices",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Restrict the use of organization-controlled portable storage devices by authorized individuals on external systems using [Assignment: organization-defined restrictions].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must limit how employees use company-issued USB drives and portable storage on non-organizational systems (like home computers or contractor systems). Example restrictions include: requiring encryption on all organizational portable storage, prohibiting use on external systems entirely, limiting to read-only access, or requiring antivirus scans before reconnecting to organizational systems. This prevents organizational data from being exposed or compromised on uncontrolled external systems that may lack adequate security.",
    "example_implementation": "Require all organization-issued USB drives to use BitLocker To Go (Windows) or LUKS encryption (Linux) with AES-256. Establish policy prohibiting use of organizational portable storage on personal computers. For approved exceptions (employees working from home), require: (1) VPN connection to organizational network before accessing encrypted storage, (2) Full antivirus scan of external computer before connecting organizational storage, (3) Mandatory malware scan of portable storage before reconnecting to organizational systems, (4) Immediate reporting if device is used on compromised system.",
    "non_technical_guidance": "To ensure compliance with AC-19(2):\n1. Identify all organization-controlled portable storage devices issued to employees.\n2. Define 'external systems' (home computers, contractor systems, public computers, hotel business centers).\n3. Establish restrictions for using organizational portable storage on external systems, such as: (a) Prohibit entirely (most secure), (b) Allow only encrypted portable storage, (c) Require VPN connection, (d) Mandate antivirus scan before/after use, (e) Limit to read-only access.\n4. Configure all organizational portable storage with encryption by default.\n5. Train employees on restrictions and risks of using organizational storage on untrusted systems.\n6. Implement technical monitoring: require portable storage to be scanned for malware when reconnected to organizational systems.\n7. Establish incident response procedures if organizational storage is used on compromised external system.\n8. Periodically audit compliance with restrictions.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-19",
      "AC-19(1)",
      "AC-20",
      "MP-7",
      "SC-34"
    ],
    "supplemental_guidance": "Even organization-controlled portable storage devices pose risks when used on external systems that may not meet organizational security standards. External systems (home computers, contractor systems, partner organizations) may: (1) Lack current antivirus protection, (2) Be infected with malware, (3) Have inadequate access controls, (4) Lack audit logging. Organizational restrictions may include: requiring full-device encryption on portable storage, prohibiting use on external systems except under specific conditions, limiting to read-only access, requiring antivirus scans before reconnection to organizational systems, or mandating VPN connection while accessing data on external systems. Organizations should balance security requirements with operational needs (e.g., remote workers requiring local data access).",
    "implementation_scripts": {
      "linux": {
        "audit": "#!/bin/bash\n# Audit organizational portable storage encryption and controls\necho 'AC-19(2): Checking organizational portable storage restrictions...'\n\n# Check for LUKS encrypted volumes (organizational portable storage should use LUKS)\necho 'Checking for LUKS encrypted removable devices...'\nif command -v lsblk &>/dev/null; then\n    lsblk -o NAME,FSTYPE,MOUNTPOINT,SIZE | grep -i 'crypto_LUKS' && \\\n        echo 'PASS: LUKS encrypted volumes detected' || \\\n        echo 'INFO: No LUKS encrypted removable storage currently connected'\nfi\n\n# Check for ClamAV (antivirus for scanning portable storage)\nif rpm -q clamav &>/dev/null || dpkg -l | grep -q clamav 2>/dev/null; then\n    echo 'PASS: ClamAV antivirus is installed (can scan portable storage)'\n    \n    # Check if virus definitions are up to date\n    if [ -f /var/lib/clamav/daily.cvd ] || [ -f /var/lib/clamav/daily.cld ]; then\n        echo 'PASS: ClamAV virus definitions are present'\n    else\n        echo 'WARNING: ClamAV definitions not found or outdated'\n    fi\nelse\n    echo 'WARNING: ClamAV not installed (recommended for scanning portable storage)'\nfi\n\n# Check USBGuard for portable storage monitoring\nif systemctl is-active usbguard &>/dev/null; then\n    echo 'PASS: USBGuard is active (monitors portable storage connections)'\nelse\n    echo 'INFO: USBGuard not active'\nfi\n\necho ''\necho 'Currently mounted removable storage:'\nlsblk -o NAME,FSTYPE,MOUNTPOINT,SIZE | grep -E '(sd[b-z]|mmcblk)' || echo 'No removable storage detected'",
        "remediation": "#!/bin/bash\n# Implement AC-19(2): Organizational portable storage restrictions\nset -e\n\necho 'Implementing AC-19(2) organizational portable storage controls...'\n\n# Install ClamAV for scanning portable storage before use\nif ! rpm -q clamav &>/dev/null && ! dpkg -l | grep -q clamav 2>/dev/null; then\n    echo 'Installing ClamAV antivirus...'\n    if [ -f /etc/redhat-release ]; then\n        yum install -y clamav clamav-update\n    elif [ -f /etc/debian_version ]; then\n        apt-get update && apt-get install -y clamav clamav-daemon\n    fi\nfi\n\n# Update ClamAV virus definitions\necho 'Updating ClamAV virus definitions...'\nfreshclam || echo 'WARNING: freshclam update may have failed'\n\n# Create portable storage scan script\ncat > /usr/local/bin/scan-portable-storage.sh <<'SCANSCRIPT'\n#!/bin/bash\n# Scan portable storage before use on organizational system\nif [ -z \"$1\" ]; then\n    echo \"Usage: $0 /path/to/mountpoint\"\n    echo \"Example: $0 /media/usb\"\n    exit 1\nfi\n\nMOUNTPOINT=\"$1\"\nif [ ! -d \"$MOUNTPOINT\" ]; then\n    echo \"ERROR: $MOUNTPOINT does not exist or is not mounted\"\n    exit 1\nfi\n\necho \"Scanning $MOUNTPOINT for malware...\"\nclamscan -r -i \"$MOUNTPOINT\"\n\nif [ $? -eq 0 ]; then\n    echo \"PASS: No malware detected on portable storage\"\n    exit 0\nelse\n    echo \"WARNING: Malware detected or scan failed. Do not use this device.\"\n    exit 1\nfi\nSCANSCRIPT\n\nchmod +x /usr/local/bin/scan-portable-storage.sh\necho 'Created portable storage scanning script: /usr/local/bin/scan-portable-storage.sh'\n\n# Create documentation for encrypted portable storage creation\ncat > /usr/local/share/create-encrypted-usb.txt <<'ENCRYPTDOC'\nHow to Create LUKS Encrypted Organizational Portable Storage:\n\n1. Identify USB device: lsblk\n   (Example: /dev/sdb)\n\n2. BACKUP ANY DATA - THIS WILL ERASE THE DEVICE\n\n3. Create LUKS encrypted volume:\n   sudo cryptsetup luksFormat --type luks2 /dev/sdb1\n   (Enter strong passphrase when prompted)\n\n4. Open encrypted volume:\n   sudo cryptsetup luksOpen /dev/sdb1 encrypted_usb\n\n5. Create filesystem:\n   sudo mkfs.ext4 /dev/mapper/encrypted_usb\n   sudo e2label /dev/mapper/encrypted_usb \"ORG_ENCRYPTED\"\n\n6. Mount and use:\n   sudo mount /dev/mapper/encrypted_usb /mnt/encrypted_usb\n\n7. After use, unmount and close:\n   sudo umount /mnt/encrypted_usb\n   sudo cryptsetup luksClose encrypted_usb\n\nIMPORTANT RESTRICTIONS:\n- Do NOT use organizational encrypted storage on untrusted external systems\n- If use on external system is required (home office), scan with antivirus first\n- Always run /usr/local/bin/scan-portable-storage.sh before reconnecting to organizational systems\n- Report any suspected compromise immediately to IT Security\nENCRYPTDOC\n\necho 'Created encrypted USB documentation: /usr/local/share/create-encrypted-usb.txt'\n\necho ''\necho 'AC-19(2) implementation complete.'\necho 'Users must:'\necho '1. Encrypt all organizational portable storage with LUKS'\necho '2. Scan portable storage with: /usr/local/bin/scan-portable-storage.sh /path/to/mount'\necho '3. Follow restrictions in /usr/local/share/create-encrypted-usb.txt'"
      },
      "windows": {
        "audit": "$ErrorActionPreference = 'SilentlyContinue'\nWrite-Host 'AC-19(2): Checking organizational portable storage restrictions...'\n\n# Check if BitLocker To Go is enforced\n$regPath = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\FVE'\nif (Test-Path $regPath) {\n    $rdvEncryption = Get-ItemProperty -Path $regPath -Name 'RDVDenyWriteAccess' -ErrorAction SilentlyContinue\n    \n    if ($rdvEncryption.RDVDenyWriteAccess -eq 1) {\n        Write-Host 'PASS: BitLocker To Go encryption is required for removable drives'\n    } else {\n        Write-Host 'FAIL: BitLocker To Go encryption is not enforced'\n    }\n} else {\n    Write-Host 'FAIL: BitLocker To Go policies not configured'\n}\n\n# Check for Windows Defender\n$defenderStatus = Get-MpComputerStatus\nif ($defenderStatus.AntivirusEnabled) {\n    Write-Host 'PASS: Windows Defender is enabled (can scan portable storage)'\n    \n    if ($defenderStatus.AntivirusSignatureLastUpdated -gt (Get-Date).AddDays(-7)) {\n        Write-Host 'PASS: Antivirus definitions are up to date'\n    } else {\n        Write-Host 'WARNING: Antivirus definitions may be outdated'\n    }\n} else {\n    Write-Host 'FAIL: Windows Defender is not enabled'\n}\n\n# List BitLocker encrypted removable drives\nWrite-Host ''\nWrite-Host 'BitLocker encrypted removable drives:'\nGet-BitLockerVolume | Where-Object {$_.VolumeType -eq 'Data'} | Format-Table MountPoint, EncryptionMethod, ProtectionStatus -AutoSize",
        "remediation": "$ErrorActionPreference = 'Stop'\nWrite-Host 'Implementing AC-19(2): Organizational portable storage restrictions...'\n\n# Enforce BitLocker To Go for removable drives\n$regPath = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\FVE'\nif (-not (Test-Path $regPath)) {\n    New-Item -Path $regPath -Force | Out-Null\n}\n\n# Deny write access to unencrypted removable drives\nSet-ItemProperty -Path $regPath -Name 'RDVDenyWriteAccess' -Value 1 -Type DWord\nWrite-Host 'CONFIGURED: Write access denied to unencrypted removable drives'\n\n# Require BitLocker To Go encryption\nSet-ItemProperty -Path $regPath -Name 'RDVHideRecoveryPage' -Value 0 -Type DWord\nSet-ItemProperty -Path $regPath -Name 'RDVRequireActiveDirectoryBackup' -Value 0 -Type DWord\nSet-ItemProperty -Path $regPath -Name 'RDVActiveDirectoryBackup' -Value 1 -Type DWord\nWrite-Host 'CONFIGURED: BitLocker To Go policies enabled'\n\n# Enable Windows Defender if not already enabled\nSet-MpPreference -DisableRealtimeMonitoring $false\nWrite-Host 'CONFIGURED: Windows Defender enabled'\n\n# Update Windows Defender definitions\nWrite-Host 'Updating Windows Defender definitions...'\nUpdate-MpSignature\n\n# Create portable storage scan script\n$scanScript = @'\n# Scan removable drive before use\nparam(\n    [Parameter(Mandatory=$true)]\n    [string]$DriveLetter\n)\n\n$ErrorActionPreference = 'Stop'\n\nif (-not (Test-Path \"$DriveLetter\\\")) {\n    Write-Host \"ERROR: Drive $DriveLetter does not exist\"\n    exit 1\n}\n\nWrite-Host \"Scanning $DriveLetter for malware...\"\n$scanResult = Start-MpScan -ScanPath \"$DriveLetter\\\" -ScanType CustomScan\n\nif ($?) {\n    Write-Host \"PASS: Scan completed successfully\"\n    Get-MpThreatDetection | Where-Object {$_.Resources -like \"$DriveLetter*\"}\n} else {\n    Write-Host \"WARNING: Scan failed or threats detected\"\n    exit 1\n}\n'@\n\n$scanScript | Out-File -FilePath 'C:\\Windows\\System32\\Scan-PortableStorage.ps1' -Encoding UTF8\nWrite-Host 'Created scanning script: C:\\Windows\\System32\\Scan-PortableStorage.ps1'\n\nWrite-Host ''\nWrite-Host 'AC-19(2) implementation complete.'\nWrite-Host ''\nWrite-Host 'To encrypt organizational USB drive with BitLocker To Go:'\nWrite-Host '1. Insert USB drive'\nWrite-Host '2. Right-click drive in Explorer > Turn on BitLocker'\nWrite-Host '3. Choose password and save recovery key'\nWrite-Host ''\nWrite-Host 'To scan removable storage:'\nWrite-Host 'PowerShell: .\\Scan-PortableStorage.ps1 -DriveLetter E:'\nWrite-Host ''\nWrite-Host 'Run \"gpupdate /force\" to apply Group Policy changes.'"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00+00:00",
      "has_scripts": true,
      "created_by": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "last_analyzed": "2025-11-20T00:00:00+00:00",
      "source": "NIST SP 800-53 Rev 5",
      "related_cac_rules": [
        "linux_os/guide/services/usbguard/package_usbguard_installed",
        "linux_os/guide/services/usbguard/service_usbguard_enabled"
      ],
      "implementation_guidance": "Requires organizational policy (portable storage usage restrictions) and technical controls (encryption enforcement, antivirus scanning). Partial technical automation via encryption and scanning tools."
    },
    "rationale": "Organization-controlled portable storage used on external systems introduces risks: (1) External systems may be infected with malware that spreads to portable storage and subsequently to organizational systems, (2) External systems may lack encryption, allowing data exposure if device is lost, (3) Data on portable storage may be copied or exfiltrated on untrusted external systems, (4) External systems may have inadequate access controls, exposing organizational data to unauthorized users. By restricting use on external systems and requiring encryption and antivirus scanning, organizations mitigate these risks while still enabling legitimate remote work scenarios.",
    "ai_guidance": "Require encryption (BitLocker To Go or LUKS) on all company USB drives. Prohibit using company USB drives on personal computers unless approved. Scan USB drives with antivirus before reconnecting to company systems."
  },
  {
    "control_id": "AC-19.3",
    "control_name": "Use of Portable Storage Devices with No Identifiable Owner",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Restrict the use of portable storage devices when such devices have no identifiable owner on [Assignment: organization-defined systems].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must prevent use of USB drives and other portable storage devices without clear ownership identification on specific critical organizational systems. This is similar to AC-19(1) but allows organizations to selectively apply restrictions to high-value systems (financial systems, HR databases, classified systems) rather than organization-wide. Lower-value systems may have less restrictive policies, while critical systems enforce strict portable storage controls.",
    "example_implementation": "Classify organizational systems as High/Moderate/Low value. High-value systems (financial database servers, HR systems with PII, classified systems): Implement strict USBGuard whitelisting, block all portable storage except explicitly approved devices. Moderate-value systems (general workstations): Allow registered organizational portable storage, block unknown devices. Low-value systems (training labs, public kiosks): Monitor-only mode with audit logging but no blocking. This risk-based approach focuses strongest controls on systems with highest data sensitivity.",
    "non_technical_guidance": "To ensure compliance with AC-19(3):\n1. Classify organizational systems by value/sensitivity: High (critical infrastructure, financial systems, PII databases), Moderate (general workstations, department servers), Low (training systems, public kiosks).\n2. Define portable storage restrictions per classification: High systems prohibit all unregistered portable storage, Moderate systems allow organizational devices only, Low systems monitor but allow with warnings.\n3. Implement technical controls appropriate to each classification tier.\n4. Document system classifications and corresponding portable storage policies.\n5. Train system administrators on classification criteria and enforcement.\n6. Periodically review system classifications (as data sensitivity changes).\n7. Audit compliance with classification-based restrictions.\n8. Establish exception process for legitimate business needs on High-value systems.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-19",
      "AC-19(1)",
      "MP-7",
      "MP-7(1)"
    ],
    "supplemental_guidance": "This enhancement provides flexibility to apply controls based on system criticality and data sensitivity. Not all organizational systems warrant the same level of portable storage restrictions. High-value systems (financial, classified, personally identifiable information) should have the strictest controls. Moderate-value systems may allow organizational portable storage with monitoring. Low-value systems (development, training) may use monitoring-only approaches. Organizations define system classifications and corresponding restrictions. Implementation typically involves USB device whitelisting on critical systems via USBGuard (Linux) or Group Policy (Windows), while less critical systems use audit-only modes with centralized logging and alerting.",
    "implementation_scripts": {
      "linux": {
        "audit": "#!/bin/bash\n# Audit system-specific portable storage restrictions (AC-19(3))\necho 'AC-19(3): Checking system classification and portable storage restrictions...'\n\n# Check for system classification file (custom organizational implementation)\nif [ -f /etc/system-classification ]; then\n    CLASSIFICATION=$(cat /etc/system-classification)\n    echo \"PASS: System classification is defined: $CLASSIFICATION\"\nelse\n    echo 'WARNING: System classification not defined (/etc/system-classification missing)'\n    echo 'Recommended: Create /etc/system-classification with HIGH, MODERATE, or LOW'\n    CLASSIFICATION='UNDEFINED'\nfi\n\n# Check USBGuard configuration based on classification\nif systemctl is-active usbguard &>/dev/null; then\n    echo 'PASS: USBGuard is active'\n    \n    # Analyze USBGuard policy strictness\n    if [ -f /etc/usbguard/rules.conf ]; then\n        allow_count=$(grep -c '^allow' /etc/usbguard/rules.conf 2>/dev/null || echo 0)\n        block_count=$(grep -c '^block' /etc/usbguard/rules.conf 2>/dev/null || echo 0)\n        reject_count=$(grep -c '^reject' /etc/usbguard/rules.conf 2>/dev/null || echo 0)\n        \n        echo \"INFO: USBGuard policy - Allow rules: $allow_count, Block rules: $block_count, Reject rules: $reject_count\"\n        \n        case $CLASSIFICATION in\n            HIGH)\n                if [ \"$allow_count\" -le 5 ]; then\n                    echo 'PASS: Restrictive policy appropriate for HIGH classification (minimal allow rules)'\n                else\n                    echo 'WARNING: Policy may be too permissive for HIGH classification system'\n                fi\n                ;;\n            MODERATE)\n                if [ \"$allow_count\" -le 20 ]; then\n                    echo 'PASS: Policy appropriate for MODERATE classification'\n                else\n                    echo 'WARNING: Policy may be too permissive for MODERATE classification'\n                fi\n                ;;\n            LOW)\n                echo 'INFO: LOW classification system - monitoring-only may be appropriate'\n                ;;\n        esac\n    fi\nelse\n    echo 'FAIL: USBGuard is not active (required for enforcing portable storage restrictions)'\nfi\n\n# Check audit logging\nif systemctl is-active auditd &>/dev/null; then\n    echo 'PASS: Audit daemon is active (USB events will be logged)'\nelse\n    echo 'WARNING: Audit daemon not active (USB events may not be logged)'\nfi\n\necho ''\necho 'Classification-based recommendations:'\necho 'HIGH: Whitelist only keyboard/mouse/monitor hubs, block all portable storage'\necho 'MODERATE: Allow registered organizational portable storage, block unknown'\necho 'LOW: Monitor-only mode with audit logging'",
        "remediation": "#!/bin/bash\n# Implement AC-19(3): System-specific portable storage restrictions\nset -e\n\necho 'Implementing AC-19(3) classification-based portable storage controls...'\n\n# Prompt for system classification if not defined\nif [ ! -f /etc/system-classification ]; then\n    echo 'System classification not defined.'\n    echo 'Please enter system classification (HIGH/MODERATE/LOW):'\n    read -r CLASSIFICATION\n    echo \"$CLASSIFICATION\" > /etc/system-classification\n    echo \"System classified as: $CLASSIFICATION\"\nelse\n    CLASSIFICATION=$(cat /etc/system-classification)\n    echo \"Existing classification: $CLASSIFICATION\"\nfi\n\n# Ensure USBGuard is installed\nif ! rpm -q usbguard &>/dev/null && ! dpkg -l | grep -q usbguard 2>/dev/null; then\n    echo 'Installing USBGuard...'\n    if [ -f /etc/redhat-release ]; then\n        yum install -y usbguard\n    elif [ -f /etc/debian_version ]; then\n        apt-get update && apt-get install -y usbguard\n    fi\nfi\n\n# Configure USBGuard based on classification\ncase $CLASSIFICATION in\n    HIGH)\n        echo 'Configuring STRICT policy for HIGH classification system...'\n        \n        # Generate restrictive policy: Only allow HID and hubs\n        cat > /etc/usbguard/rules.conf <<'HIGHPOLICY'\n# HIGH CLASSIFICATION SYSTEM - STRICT PORTABLE STORAGE RESTRICTIONS\n# Only allow Human Interface Devices (keyboards, mice) and USB hubs\nallow with-interface match-all { 03:*:* 09:00:* }\n\n# Block all other USB devices (including portable storage)\nblock with-interface one-of { 08:*:* }\n\n# Reject any device not matching above rules\nreject\nHIGHPOLICY\n        echo 'HIGH classification policy: Only HID and hubs allowed, all portable storage blocked'\n        ;;\n        \n    MODERATE)\n        echo 'Configuring MODERATE policy for MODERATE classification system...'\n        \n        # Generate moderate policy from currently connected devices\n        if [ ! -f /etc/usbguard/rules.conf ] || [ ! -s /etc/usbguard/rules.conf ]; then\n            usbguard generate-policy > /etc/usbguard/rules.conf\n        fi\n        \n        # Ensure HID and hubs are allowed\n        if ! grep -q 'allow with-interface match-all { 03:\\*:\\* 09:00:\\* }' /etc/usbguard/rules.conf; then\n            sed -i '1i allow with-interface match-all { 03:*:* 09:00:* }' /etc/usbguard/rules.conf\n        fi\n        \n        echo 'MODERATE classification policy: Registered devices allowed, unknown devices blocked'\n        ;;\n        \n    LOW)\n        echo 'Configuring PERMISSIVE policy for LOW classification system...'\n        \n        # Generate permissive policy: Allow all currently connected, log rejections\n        usbguard generate-policy > /etc/usbguard/rules.conf\n        \n        # Add default allow at end (monitor-only mode)\n        echo 'allow' >> /etc/usbguard/rules.conf\n        \n        echo 'LOW classification policy: Monitor-only mode, all devices allowed with logging'\n        ;;\n        \n    *)\n        echo 'ERROR: Invalid classification. Must be HIGH, MODERATE, or LOW'\n        exit 1\n        ;;\nesac\n\n# Configure audit backend\nsed -i 's/^AuditBackend=.*/AuditBackend=LinuxAudit/' /etc/usbguard/usbguard-daemon.conf || \\\n    echo 'AuditBackend=LinuxAudit' >> /etc/usbguard/usbguard-daemon.conf\n\n# Enable and start USBGuard\nsystemctl enable usbguard\nsystemctl restart usbguard\n\nif systemctl is-active usbguard &>/dev/null; then\n    echo 'SUCCESS: USBGuard is active with classification-based policy'\nelse\n    echo 'ERROR: USBGuard failed to start'\n    exit 1\nfi\n\necho ''\necho 'AC-19(3) implementation complete.'\necho \"System classification: $CLASSIFICATION\"\necho 'Policy enforced per classification level.'\necho 'To view current policy: cat /etc/usbguard/rules.conf'\necho 'To authorize new device: usbguard allow-device <ID> -p'"
      },
      "windows": {
        "audit": "$ErrorActionPreference = 'SilentlyContinue'\nWrite-Host 'AC-19(3): Checking system classification and portable storage restrictions...'\n\n# Check for system classification (custom implementation via registry)\n$classificationReg = 'HKLM:\\SOFTWARE\\Organization\\SystemClassification'\nif (Test-Path $classificationReg) {\n    $classification = Get-ItemProperty -Path $classificationReg -Name 'Level' -ErrorAction SilentlyContinue\n    if ($classification) {\n        Write-Host \"PASS: System classification is defined: $($classification.Level)\"\n    } else {\n        Write-Host 'WARNING: System classification registry key exists but Level not set'\n    }\n} else {\n    Write-Host 'WARNING: System classification not defined'\n    Write-Host 'Recommended: Create registry key HKLM:\\SOFTWARE\\Organization\\SystemClassification'\n    Write-Host 'Set Level value to: HIGH, MODERATE, or LOW'\n}\n\n# Check removable storage policy\n$regPath = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices'\nif (Test-Path $regPath) {\n    $usbStorageGUID = '{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}'\n    $fullPath = \"$regPath\\$usbStorageGUID\"\n    \n    $denyWrite = Get-ItemProperty -Path $fullPath -Name 'Deny_Write' -ErrorAction SilentlyContinue\n    $denyRead = Get-ItemProperty -Path $fullPath -Name 'Deny_Read' -ErrorAction SilentlyContinue\n    \n    if ($denyWrite.Deny_Write -eq 1) {\n        Write-Host 'PASS: Removable storage write access is restricted'\n    } else {\n        Write-Host 'INFO: Removable storage write access is not restricted'\n    }\n    \n    if ($denyRead.Deny_Read -eq 1) {\n        Write-Host 'PASS: Removable storage read access is restricted (HIGH security)'\n    } else {\n        Write-Host 'INFO: Removable storage read access is allowed'\n    }\n} else {\n    Write-Host 'INFO: Removable storage device policies not configured'\n}\n\nWrite-Host ''\nWrite-Host 'Classification-based recommendations:'\nWrite-Host 'HIGH: Deny both read and write to all removable storage'\nWrite-Host 'MODERATE: Deny write, allow read (or require BitLocker To Go)'\nWrite-Host 'LOW: Monitor-only with audit logging'",
        "remediation": "$ErrorActionPreference = 'Stop'\nWrite-Host 'Implementing AC-19(3): Classification-based portable storage restrictions...'\n\n# Prompt for system classification if not defined\n$classificationReg = 'HKLM:\\SOFTWARE\\Organization\\SystemClassification'\nif (-not (Test-Path $classificationReg)) {\n    New-Item -Path 'HKLM:\\SOFTWARE\\Organization' -Force | Out-Null\n    New-Item -Path $classificationReg -Force | Out-Null\n}\n\n$existingClassification = Get-ItemProperty -Path $classificationReg -Name 'Level' -ErrorAction SilentlyContinue\nif (-not $existingClassification) {\n    Write-Host 'System classification not defined.'\n    Write-Host 'Enter system classification (HIGH/MODERATE/LOW):'\n    $classification = Read-Host\n    Set-ItemProperty -Path $classificationReg -Name 'Level' -Value $classification\n    Write-Host \"System classified as: $classification\"\n} else {\n    $classification = $existingClassification.Level\n    Write-Host \"Existing classification: $classification\"\n}\n\n# Configure removable storage policies based on classification\n$regPath = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices'\n$usbStorageGUID = '{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}'\n$fullPath = \"$regPath\\$usbStorageGUID\"\n\nif (-not (Test-Path $regPath)) {\n    New-Item -Path $regPath -Force | Out-Null\n}\nif (-not (Test-Path $fullPath)) {\n    New-Item -Path $fullPath -Force | Out-Null\n}\n\nswitch ($classification.ToUpper()) {\n    'HIGH' {\n        Write-Host 'Configuring STRICT policy for HIGH classification...'\n        Set-ItemProperty -Path $fullPath -Name 'Deny_Write' -Value 1 -Type DWord\n        Set-ItemProperty -Path $fullPath -Name 'Deny_Read' -Value 1 -Type DWord\n        Write-Host 'HIGH: Both read and write access to removable storage DENIED'\n    }\n    'MODERATE' {\n        Write-Host 'Configuring MODERATE policy for MODERATE classification...'\n        Set-ItemProperty -Path $fullPath -Name 'Deny_Write' -Value 1 -Type DWord\n        Set-ItemProperty -Path $fullPath -Name 'Deny_Read' -Value 0 -Type DWord\n        \n        # Require BitLocker To Go\n        $bitlockerReg = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\FVE'\n        if (-not (Test-Path $bitlockerReg)) {\n            New-Item -Path $bitlockerReg -Force | Out-Null\n        }\n        Set-ItemProperty -Path $bitlockerReg -Name 'RDVDenyWriteAccess' -Value 1 -Type DWord\n        \n        Write-Host 'MODERATE: Write access denied, read allowed, BitLocker To Go required'\n    }\n    'LOW' {\n        Write-Host 'Configuring PERMISSIVE policy for LOW classification...'\n        Set-ItemProperty -Path $fullPath -Name 'Deny_Write' -Value 0 -Type DWord\n        Set-ItemProperty -Path $fullPath -Name 'Deny_Read' -Value 0 -Type DWord\n        Write-Host 'LOW: Read and write allowed (monitor-only mode)'\n        Write-Host 'Configure audit logging separately for monitoring'\n    }\n    default {\n        Write-Host 'ERROR: Invalid classification. Must be HIGH, MODERATE, or LOW'\n        exit 1\n    }\n}\n\nWrite-Host ''\nWrite-Host 'AC-19(3) implementation complete.'\nWrite-Host \"System classification: $classification\"\nWrite-Host 'Policy enforced per classification level.'\nWrite-Host 'Run \"gpupdate /force\" to apply Group Policy changes immediately.'"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00+00:00",
      "has_scripts": true,
      "created_by": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T00:00:00+00:00",
      "source": "NIST SP 800-53 Rev 5",
      "related_cac_rules": [
        "linux_os/guide/services/usbguard/package_usbguard_installed",
        "linux_os/guide/services/usbguard/service_usbguard_enabled",
        "linux_os/guide/services/usbguard/usbguard_generate_policy"
      ],
      "implementation_guidance": "Requires system classification scheme (HIGH/MODERATE/LOW) and classification-based USBGuard policies. Fully automated once classification is defined."
    },
    "rationale": "Different organizational systems have different data sensitivity levels and risk profiles. High-value systems (financial databases, classified systems, HR systems with PII) warrant the strictest portable storage controls because compromise would have severe consequences. Moderate-value systems (general workstations) require reasonable controls balancing security and usability. Low-value systems (training labs, development systems) may use monitoring-only approaches. This risk-based approach allows organizations to focus strongest controls where they matter most, while avoiding unnecessary restrictions on lower-risk systems. It also provides flexibility for operational needs while maintaining security on critical systems.",
    "ai_guidance": "Classify systems by criticality (HIGH/MODERATE/LOW). HIGH systems: block all USB storage except keyboards/mice. MODERATE systems: allow registered company USB drives only. LOW systems: monitor but allow USB usage. Use USBGuard or Group Policy to enforce per system."
  },
  {
    "control_id": "AC-19.4",
    "control_name": "Restrictions for Classified Information",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Prohibit the use of unclassified mobile devices in facilities containing systems processing, storing, or transmitting classified information unless specifically authorized for such use; and\nEnforce the following restrictions on individuals permitted to use unclassified mobile devices in such facilities: [Assignment: organization-defined restrictions].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "In facilities that handle classified information, personal smartphones, tablets, cameras, and other unclassified mobile devices are prohibited unless specifically approved by security personnel. Even approved devices must follow strict restrictions: cameras/microphones physically removed or disabled, wireless capabilities disabled, regular security inspections, no classified network connections. This prevents classified information from being photographed, recorded, or transmitted via unauthorized devices. Mobile device lockers are typically provided at facility entry points.",
    "example_implementation": "At classified facility entrance: (1) Post signs prohibiting mobile devices, (2) Install RF detection systems to identify wireless transmissions, (3) Provide secure lockers for mobile device storage, (4) Security guards verify no devices enter facility, (5) Conduct random inspections for unauthorized devices. For specifically authorized devices (government-issued laptops, approved cameras): Remove or physically disable cameras/microphones, disable WiFi/Bluetooth hardware, apply tamper-evident seals, conduct monthly security inspections, maintain device registry, enforce disciplinary action for violations.",
    "non_technical_guidance": "To ensure compliance with AC-19(4):\n1. Identify all facilities containing classified information systems.\n2. Establish policy prohibiting unclassified mobile devices in these facilities.\n3. Install physical security controls: mobile device lockers at entry, signage, security guard verification.\n4. Create exception process for specifically authorized devices (criteria: government-issued, mission necessity, compensating controls).\n5. Define restrictions for authorized devices: cameras/microphones disabled, wireless disabled, tamper seals, inspection schedule.\n6. Implement RF detection systems to identify unauthorized wireless transmissions.\n7. Train all personnel on policy, restrictions, and reporting requirements.\n8. Conduct random inspections and audits.\n9. Define disciplinary actions for violations (security clearance revocation, termination).\n10. Document all authorized device exceptions and maintain registry.",
    "is_technical": false,
    "enhancements": [],
    "related_controls": [
      "AC-19",
      "AC-19(5)",
      "PE-2",
      "PE-3",
      "MP-7",
      "SC-7",
      "SC-8"
    ],
    "supplemental_guidance": "Mobile devices in classified environments present significant risks: built-in cameras can photograph classified displays, microphones can record conversations, wireless capabilities can transmit data outside secure perimeter, compromised devices can introduce malware. Unclassified devices present even greater risk due to lack of government security controls. Organizations must implement multilayered controls: physical security (lockers, guards, inspections), technical controls (RF detection, network isolation), and policy enforcement (training, audits, discipline). Restrictions for authorized devices typically include: physical removal of cameras/microphones, disabling of wireless hardware, government-approved security configurations, tamper-evident seals, regular inspections, and strict accountability. Some classified facilities prohibit ALL mobile devices regardless of authorization. This is primarily an organizational and physical security control with limited technical automation.",
    "implementation_scripts": {
      "linux": {
        "audit": "#!/bin/bash\n# Audit mobile device restrictions for classified environments (AC-19(4))\necho 'AC-19(4): Checking mobile device restrictions for classified facilities...'\necho 'NOTE: This is primarily an organizational/physical security control.'\necho ''\n\n# Check for wireless hardware disable (if system is in classified facility)\necho 'Checking wireless hardware status...'\n\n# Check WiFi status\nif command -v nmcli &>/dev/null; then\n    wifi_status=$(nmcli radio wifi)\n    if [ \"$wifi_status\" = \"disabled\" ]; then\n        echo 'PASS: WiFi hardware is disabled'\n    else\n        echo 'WARNING: WiFi hardware is enabled (should be disabled in classified facility)'\n    fi\nfi\n\n# Check Bluetooth status\nif command -v bluetoothctl &>/dev/null; then\n    bt_status=$(bluetoothctl show 2>/dev/null | grep 'Powered:' | awk '{print $2}')\n    if [ \"$bt_status\" = \"no\" ]; then\n        echo 'PASS: Bluetooth is disabled'\n    else\n        echo 'WARNING: Bluetooth is enabled (should be disabled in classified facility)'\n    fi\nfi\n\n# Check for camera/microphone device presence\necho ''\necho 'Checking for camera/microphone devices...'\nif command -v lsusb &>/dev/null; then\n    camera_count=$(lsusb | grep -i 'camera\\|webcam' | wc -l)\n    audio_count=$(lsusb | grep -i 'audio\\|microphone' | wc -l)\n    \n    if [ \"$camera_count\" -gt 0 ]; then\n        echo \"WARNING: $camera_count camera device(s) detected\"\n        lsusb | grep -i 'camera\\|webcam'\n    else\n        echo 'PASS: No camera devices detected'\n    fi\n    \n    if [ \"$audio_count\" -gt 0 ]; then\n        echo \"INFO: $audio_count audio device(s) detected (may include microphones)\"\n    fi\nfi\n\necho ''\necho 'IMPORTANT: AC-19(4) requires organizational controls:'\necho '- Mobile device prohibition policy for classified facilities'\necho '- Physical security controls (lockers, RF detection, guards)'\necho '- Exception process for specifically authorized devices'\necho '- Regular security inspections and audits'\necho '- Disciplinary measures for policy violations'",
        "remediation": "#!/bin/bash\n# Implement AC-19(4): Disable wireless/camera for classified facility use\nset -e\n\necho 'Implementing AC-19(4): Classified facility mobile device restrictions...'\necho 'WARNING: This will disable wireless hardware on this system.'\necho ''\n\nread -p 'Is this system authorized for classified facility use? (yes/no): ' confirm\nif [ \"$confirm\" != \"yes\" ]; then\n    echo 'Aborted. This script should only be run on authorized systems.'\n    exit 1\nfi\n\necho 'Disabling wireless hardware...'\n\n# Disable WiFi\nif command -v nmcli &>/dev/null; then\n    nmcli radio wifi off\n    echo 'WiFi disabled via NetworkManager'\nfi\n\n# Disable Bluetooth\nif command -v bluetoothctl &>/dev/null; then\n    bluetoothctl power off 2>/dev/null || true\n    echo 'Bluetooth disabled'\nfi\n\n# Blacklist wireless kernel modules to prevent re-enabling\ncat > /etc/modprobe.d/classified-facility-wireless-blacklist.conf <<'BLACKLIST'\n# AC-19(4): Disable wireless hardware for classified facility use\n# Created: $(date)\n\n# Blacklist WiFi modules\nblacklist iwlwifi\nblacklist iwlmvm\nblacklist ath9k\nblacklist ath10k_pci\nblacklist brcmfmac\nblacklist wl\n\n# Blacklist Bluetooth modules\nblacklist btusb\nblacklist bluetooth\n\n# Blacklist camera modules (optional - may affect legitimate video conferencing)\n# blacklist uvcvideo\nBLACKLIST\n\necho 'Wireless module blacklist created: /etc/modprobe.d/classified-facility-wireless-blacklist.conf'\n\n# Update initramfs to apply blacklist at boot\nif command -v update-initramfs &>/dev/null; then\n    update-initramfs -u\n    echo 'Initramfs updated with blacklists'\nelif command -v dracut &>/dev/null; then\n    dracut -f\n    echo 'Initramfs updated with blacklists'\nfi\n\necho ''\necho 'AC-19(4) technical implementation complete.'\necho ''\necho 'REMAINING ORGANIZATIONAL REQUIREMENTS:'\necho '1. Physical camera/microphone removal (if hardware present)'\necho '2. Apply tamper-evident seals to device'\necho '3. Register device in authorized device inventory'\necho '4. Schedule regular security inspections'\necho '5. Train user on classified facility restrictions'\necho '6. Document authorization and restrictions'\necho ''\necho 'REBOOT REQUIRED for wireless blacklist to take full effect.'"
      },
      "windows": {
        "audit": "$ErrorActionPreference = 'SilentlyContinue'\nWrite-Host 'AC-19(4): Checking mobile device restrictions for classified facilities...'\nWrite-Host 'NOTE: This is primarily an organizational/physical security control.'\nWrite-Host ''\n\n# Check WiFi status\nWrite-Host 'Checking wireless hardware status...'\n$wifiAdapters = Get-NetAdapter | Where-Object {$_.InterfaceDescription -like '*wireless*' -or $_.InterfaceDescription -like '*Wi-Fi*'}\nif ($wifiAdapters) {\n    $enabledWifi = $wifiAdapters | Where-Object {$_.Status -eq 'Up'}\n    if ($enabledWifi) {\n        Write-Host 'WARNING: WiFi adapter(s) are enabled (should be disabled in classified facility)'\n        $enabledWifi | Format-Table Name, Status, InterfaceDescription\n    } else {\n        Write-Host 'PASS: WiFi adapters are disabled'\n    }\n} else {\n    Write-Host 'PASS: No WiFi adapters detected'\n}\n\n# Check Bluetooth status\n$bluetoothDevices = Get-PnpDevice -Class 'Bluetooth' | Where-Object {$_.Status -eq 'OK'}\nif ($bluetoothDevices) {\n    Write-Host 'WARNING: Bluetooth devices detected and enabled'\n    $bluetoothDevices | Format-Table FriendlyName, Status\n} else {\n    Write-Host 'PASS: No active Bluetooth devices detected'\n}\n\n# Check for camera devices\n$cameraDevices = Get-PnpDevice -Class 'Camera','Image' | Where-Object {$_.Status -eq 'OK'}\nif ($cameraDevices) {\n    Write-Host \"WARNING: $($cameraDevices.Count) camera device(s) detected\"\n    $cameraDevices | Format-Table FriendlyName, Status\n} else {\n    Write-Host 'PASS: No camera devices detected'\n}\n\n# Check for audio recording devices\n$audioDevices = Get-PnpDevice -Class 'AudioEndpoint','Media' | Where-Object {$_.FriendlyName -like '*microphone*'}\nif ($audioDevices) {\n    Write-Host \"INFO: $($audioDevices.Count) microphone device(s) detected\"\n}\n\nWrite-Host ''\nWrite-Host 'IMPORTANT: AC-19(4) requires organizational controls:'\nWrite-Host '- Mobile device prohibition policy for classified facilities'\nWrite-Host '- Physical security controls (lockers, RF detection, guards)'\nWrite-Host '- Exception process for specifically authorized devices'\nWrite-Host '- Regular security inspections and audits'\nWrite-Host '- Disciplinary measures for policy violations'",
        "remediation": "$ErrorActionPreference = 'Stop'\nWrite-Host 'Implementing AC-19(4): Classified facility mobile device restrictions...'\nWrite-Host 'WARNING: This will disable wireless hardware on this system.'\nWrite-Host ''\n\n$confirm = Read-Host 'Is this system authorized for classified facility use? (yes/no)'\nif ($confirm -ne 'yes') {\n    Write-Host 'Aborted. This script should only be run on authorized systems.'\n    exit 1\n}\n\nWrite-Host 'Disabling wireless hardware...'\n\n# Disable all WiFi adapters\n$wifiAdapters = Get-NetAdapter | Where-Object {$_.InterfaceDescription -like '*wireless*' -or $_.InterfaceDescription -like '*Wi-Fi*'}\nif ($wifiAdapters) {\n    foreach ($adapter in $wifiAdapters) {\n        Disable-NetAdapter -Name $adapter.Name -Confirm:$false\n        Write-Host \"Disabled WiFi adapter: $($adapter.Name)\"\n    }\n} else {\n    Write-Host 'No WiFi adapters found'\n}\n\n# Disable Bluetooth devices\n$bluetoothDevices = Get-PnpDevice -Class 'Bluetooth' | Where-Object {$_.Status -eq 'OK'}\nif ($bluetoothDevices) {\n    foreach ($device in $bluetoothDevices) {\n        Disable-PnpDevice -InstanceId $device.InstanceId -Confirm:$false\n        Write-Host \"Disabled Bluetooth: $($device.FriendlyName)\"\n    }\n} else {\n    Write-Host 'No Bluetooth devices found'\n}\n\n# Disable camera devices (optional - may affect legitimate video conferencing)\n$confirmCamera = Read-Host 'Disable camera devices? (yes/no)'\nif ($confirmCamera -eq 'yes') {\n    $cameraDevices = Get-PnpDevice -Class 'Camera','Image' | Where-Object {$_.Status -eq 'OK'}\n    if ($cameraDevices) {\n        foreach ($camera in $cameraDevices) {\n            Disable-PnpDevice -InstanceId $camera.InstanceId -Confirm:$false\n            Write-Host \"Disabled camera: $($camera.FriendlyName)\"\n        }\n    }\n}\n\n# Create Group Policy to prevent re-enabling wireless\n$regPath = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\NetworkConnectivityStatusIndicator'\nif (-not (Test-Path $regPath)) {\n    New-Item -Path $regPath -Force | Out-Null\n}\nSet-ItemProperty -Path $regPath -Name 'NoActiveProbe' -Value 1 -Type DWord\n\nWrite-Host ''\nWrite-Host 'AC-19(4) technical implementation complete.'\nWrite-Host ''\nWrite-Host 'REMAINING ORGANIZATIONAL REQUIREMENTS:'\nWrite-Host '1. Physical camera/microphone removal (if hardware present)'\nWrite-Host '2. Apply tamper-evident seals to device'\nWrite-Host '3. Register device in authorized device inventory'\nWrite-Host '4. Schedule regular security inspections'\nWrite-Host '5. Train user on classified facility restrictions'\nWrite-Host '6. Document authorization and restrictions'\nWrite-Host ''\nWrite-Host 'REBOOT RECOMMENDED to ensure all hardware is fully disabled.'"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00+00:00",
      "has_scripts": true,
      "created_by": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "organizational",
      "last_analyzed": "2025-11-20T00:00:00+00:00",
      "source": "NIST SP 800-53 Rev 5",
      "related_cac_rules": [],
      "implementation_guidance": "Primarily organizational and physical security control. Limited technical automation (wireless disable scripts). Requires facility-level physical security implementation (lockers, RF detection, guards, inspections)."
    },
    "rationale": "Classified information systems require extraordinary protection due to potential national security impact if compromised. Mobile devices in classified facilities present multiple vectors for compromise: (1) Cameras can photograph classified displays or documents, (2) Microphones can record classified conversations, (3) Wireless capabilities can exfiltrate data outside secure perimeter, (4) Unclassified devices lack government security controls and may be compromised, (5) Mobile devices can be used to introduce malware via malicious USB connections. Prohibiting unclassified mobile devices and enforcing strict restrictions on authorized devices (camera/microphone removal, wireless disable, inspections) significantly reduces these risks. This control is essential for facilities handling Secret, Top Secret, or Special Access Program information.",
    "ai_guidance": "Ban personal phones/cameras in classified buildings. Provide lockers at entrance. For approved government devices: physically remove cameras/microphones, disable WiFi/Bluetooth, inspect regularly. Use guards and RF detectors to enforce."
  },
  {
    "control_id": "AC-19.5",
    "control_name": "Full Device or Container-based Encryption",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Employ [Assignment: full-device encryption OR container-based encryption] to protect the confidentiality and integrity of information on [Assignment: organization-defined mobile devices].",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Organizations must use encryption on mobile devices to protect sensitive information if devices are lost, stolen, or physically compromised. Full-device encryption (BitLocker for Windows, FileVault for macOS, LUKS for Linux, native encryption for iOS/Android) encrypts the entire device storage. Container-based encryption (encrypted folders, apps, or partitions) encrypts only specific data while leaving the rest of the device functional. This ensures that even if an attacker has physical possession of a device, they cannot access the encrypted data without the decryption key. This control is REQUIRED for Moderate and High baseline systems.",
    "example_implementation": "Windows laptops: Enable BitLocker with TPM + PIN, escrow recovery keys to Active Directory. macOS: Enable FileVault 2, store institutional recovery key. Linux: Use LUKS full-disk encryption during installation. iOS/Android smartphones: Enforce device encryption via Mobile Device Management (MDM) policy, require strong passcode (12+ characters). Tablets: Same as smartphones. For container approach: Use encrypted volumes (VeraCrypt) for sensitive data folders, or application-level encryption for specific apps containing organizational data. Deploy MDM solution to verify encryption compliance and remotely wipe non-compliant devices.",
    "non_technical_guidance": "To ensure compliance with AC-19(5):\n1. Identify all mobile devices that store or access organizational data (laptops, smartphones, tablets, USB drives).\n2. Choose encryption approach: Full-device (encrypts everything, most secure, slight performance impact) vs. Container (encrypts only sensitive data, better performance, requires user discipline).\n3. Full-device encryption is recommended for laptops and required for devices accessing CUI/PII.\n4. Define encryption standards: AES-256, approved cryptographic modules (FIPS 140-2 validated).\n5. Implement encryption on all organizational mobile devices: Windows (BitLocker), macOS (FileVault), Linux (LUKS), iOS/Android (native encryption enabled).\n6. Establish key management procedures: recovery key escrow, user passphrase requirements, key rotation.\n7. Deploy Mobile Device Management (MDM) to enforce encryption policies and verify compliance.\n8. Train users on encryption (why it matters, how to use, what to do if locked out).\n9. Create key recovery process for locked devices.\n10. Implement remote wipe capability for lost/stolen devices.\n11. Audit encryption compliance monthly.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-19",
      "SC-12",
      "SC-13",
      "SC-28",
      "MP-5"
    ],
    "supplemental_guidance": "Container-based encryption provides granular protection for specific data structures (files, records, individual fields) rather than encrypting entire device storage. This approach may be preferable when: (1) Organizational data is clearly compartmentalized, (2) Full-device encryption impacts performance unacceptably, (3) Users need unrestricted access to personal data on BYOD devices while protecting organizational data. Container encryption examples: encrypted folders (VeraCrypt), encrypted application sandboxes (iOS/Android work profiles), database-level encryption, file-level encryption. Organizations must consider: encryption key management (generation, storage, backup, rotation, destruction), performance impact, user experience, recovery mechanisms for lost keys, and remote wipe capabilities. Mobile Device Management (MDM) solutions can enforce encryption policies and verify compliance. For devices processing CUI, PII, or classified information, full-device encryption is typically required. Encryption must use FIPS 140-2 validated cryptographic modules with AES-256 or equivalent.",
    "implementation_scripts": {
      "linux": {
        "audit": "#!/bin/bash\n# Audit full-device encryption compliance (AC-19(5))\necho 'AC-19(5): Checking mobile device encryption...'\necho ''\n\n# Check for LUKS encrypted root partition\necho 'Checking for LUKS full-disk encryption...'\nroot_device=$(df / | tail -1 | awk '{print $1}')\necho \"Root device: $root_device\"\n\nif echo \"$root_device\" | grep -q '/dev/mapper/'; then\n    # Root is on mapped device, likely encrypted\n    mapper_name=$(echo \"$root_device\" | sed 's#/dev/mapper/##')\n    \n    if cryptsetup status \"$mapper_name\" &>/dev/null; then\n        echo 'PASS: Root filesystem is LUKS encrypted'\n        \n        # Check encryption details\n        echo 'Encryption details:'\n        cryptsetup status \"$mapper_name\" | grep -E '(type|cipher|keysize)'\n        \n        # Verify using strong cipher\n        cipher=$(cryptsetup status \"$mapper_name\" | grep 'cipher:' | awk '{print $2}')\n        if echo \"$cipher\" | grep -q 'aes'; then\n            echo 'PASS: Using AES cipher'\n        else\n            echo 'WARNING: Not using AES cipher'\n        fi\n        \n        keysize=$(cryptsetup status \"$mapper_name\" | grep 'keysize:' | awk '{print $2}')\n        if [ \"$keysize\" -ge 256 ]; then\n            echo 'PASS: Key size is adequate (>= 256 bits)'\n        else\n            echo 'WARNING: Key size may be inadequate (< 256 bits)'\n        fi\n    else\n        echo 'INFO: Root is on mapped device but not LUKS encrypted (may use other encryption)'\n    fi\nelse\n    echo 'FAIL: Root filesystem does not appear to be encrypted'\n    echo 'LUKS full-disk encryption should be enabled during OS installation'\nfi\n\n# Check for encrypted home directory (alternative container approach)\necho ''\necho 'Checking for encrypted home directory...'\nif [ -d \"$HOME/.ecryptfs\" ]; then\n    echo 'PASS: eCryptfs encrypted home directory detected'\nelif mount | grep -q 'ecryptfs'; then\n    echo 'PASS: eCryptfs encryption is active'\nelse\n    echo 'INFO: No eCryptfs encrypted home directory detected'\nfi\n\n# Check for encrypted swap\necho ''\necho 'Checking encrypted swap...'\nif swapon --show | grep -q '/dev/mapper/'; then\n    echo 'PASS: Swap partition is encrypted'\nelse\n    swap_devices=$(swapon --show | tail -n +2)\n    if [ -n \"$swap_devices\" ]; then\n        echo 'WARNING: Unencrypted swap detected (may leak sensitive data to disk)'\n    else\n        echo 'INFO: No swap partition configured'\n    fi\nfi\n\necho ''\necho 'RECOMMENDATION: For AC-19(5) compliance, use LUKS full-disk encryption'\necho 'Best practice: Enable during OS installation with strong passphrase'\necho 'Alternative: Use eCryptfs for home directory encryption (container approach)'",
        "remediation": "#!/bin/bash\n# Implement AC-19(5): Full-device encryption guidance\necho 'AC-19(5): Full-device encryption implementation...'\necho ''\necho 'WARNING: Full-disk encryption must be implemented during OS installation.'\necho 'This script provides guidance for NEW installations and post-install container encryption.'\necho ''\n\necho '=== LUKS FULL-DISK ENCRYPTION (Recommended) ==='\necho 'For new installations:'\necho '1. Boot from installer media'\necho '2. During partitioning, select \"Use entire disk with encryption\"'\necho '3. Enter strong encryption passphrase (16+ characters, mixed case, numbers, symbols)'\necho '4. Complete installation'\necho '5. On first boot, enter passphrase to unlock encrypted disk'\necho ''\necho 'Manual LUKS setup (advanced):'\necho '# Encrypt partition'\necho 'cryptsetup luksFormat --type luks2 --cipher aes-xts-plain64 --key-size 512 /dev/sdX1'\necho '# Open encrypted partition'\necho 'cryptsetup luksOpen /dev/sdX1 luks-root'\necho '# Create filesystem'\necho 'mkfs.ext4 /dev/mapper/luks-root'\necho '# Update /etc/crypttab and /etc/fstab'\necho '# Update initramfs'\necho ''\n\necho '=== ECRYPTFS HOME DIRECTORY ENCRYPTION (Container approach) ==='\necho 'For existing installations without full-disk encryption:'\nread -p 'Install eCryptfs for home directory encryption? (yes/no): ' install_ecryptfs\n\nif [ \"$install_ecryptfs\" = \"yes\" ]; then\n    # Install eCryptfs\n    if [ -f /etc/redhat-release ]; then\n        yum install -y ecryptfs-utils\n    elif [ -f /etc/debian_version ]; then\n        apt-get update && apt-get install -y ecryptfs-utils\n    else\n        echo 'ERROR: Unsupported distribution'\n        exit 1\n    fi\n    \n    echo 'eCryptfs installed.'\n    echo ''\n    echo 'To encrypt existing home directory:'\n    echo '1. Logout of all sessions for target user'\n    echo '2. As root: ecryptfs-migrate-home -u <username>'\n    echo '3. Login as user to complete migration'\n    echo '4. Verify encryption: mount | grep ecryptfs'\n    echo '5. Remove unencrypted backup after verification'\n    echo ''\n    echo 'For new users:'\n    echo 'adduser --encrypt-home <username>'\nfi\n\necho ''\necho '=== VERACRYPT ENCRYPTED CONTAINERS (Alternative) ==='\necho 'For encrypting specific folders/files:'\necho '1. Install VeraCrypt: https://www.veracrypt.fr/'\necho '2. Create encrypted container: veracrypt --create /path/to/container'\necho '3. Mount when needed: veracrypt /path/to/container /mnt/encrypted'\necho '4. Unmount after use: veracrypt --dismount /mnt/encrypted'\necho ''\n\necho '=== KEY MANAGEMENT RECOMMENDATIONS ==='\necho '- Use strong passphrases (16+ characters, avoid dictionary words)'\necho '- Store recovery keys securely (offline, encrypted backup)'\necho '- Document key recovery procedures'\necho '- Consider TPM integration for automated boot unlocking (LUKS with Clevis)'\necho '- Implement remote wipe capability via MDM for lost devices'\necho ''\necho 'AC-19(5) guidance complete.'\necho 'For Moderate/High baselines: Full-disk encryption (LUKS) is REQUIRED.'"
      },
      "windows": {
        "audit": "$ErrorActionPreference = 'SilentlyContinue'\nWrite-Host 'AC-19(5): Checking mobile device encryption...'\nWrite-Host ''\n\n# Check BitLocker status on all drives\nWrite-Host 'Checking BitLocker encryption status...'\n$allVolumes = Get-BitLockerVolume\n\nif ($allVolumes) {\n    foreach ($volume in $allVolumes) {\n        Write-Host \"Drive: $($volume.MountPoint)\"\n        Write-Host \"  Volume Status: $($volume.VolumeStatus)\"\n        Write-Host \"  Protection Status: $($volume.ProtectionStatus)\"\n        Write-Host \"  Encryption Method: $($volume.EncryptionMethod)\"\n        Write-Host \"  Encryption Percentage: $($volume.EncryptionPercentage)%\"\n        \n        if ($volume.MountPoint -eq 'C:' -and $volume.ProtectionStatus -eq 'On') {\n            Write-Host '  PASS: System drive (C:) is BitLocker encrypted'\n        } elseif ($volume.MountPoint -eq 'C:') {\n            Write-Host '  FAIL: System drive (C:) is NOT encrypted (REQUIRED for AC-19(5))'\n        }\n        \n        # Check encryption method strength\n        if ($volume.EncryptionMethod -like '*Aes256*' -or $volume.EncryptionMethod -like '*XtsAes256*') {\n            Write-Host '  PASS: Using AES-256 encryption (strong)'\n        } elseif ($volume.EncryptionMethod -like '*Aes128*' -or $volume.EncryptionMethod -like '*XtsAes128*') {\n            Write-Host '  WARNING: Using AES-128 (acceptable but AES-256 preferred)'\n        } elseif ($volume.ProtectionStatus -eq 'On') {\n            Write-Host '  WARNING: Encryption method may be weak'\n        }\n        \n        Write-Host ''\n    }\n} else {\n    Write-Host 'FAIL: Unable to query BitLocker status (BitLocker may not be available)'\n}\n\n# Check TPM status\nWrite-Host 'Checking TPM (Trusted Platform Module) status...'\n$tpm = Get-Tpm\nif ($tpm.TpmPresent) {\n    Write-Host 'PASS: TPM is present'\n    if ($tpm.TpmReady) {\n        Write-Host 'PASS: TPM is ready for BitLocker'\n    } else {\n        Write-Host 'WARNING: TPM is present but not ready (may need initialization)'\n    }\n    if ($tpm.TpmEnabled) {\n        Write-Host 'PASS: TPM is enabled'\n    } else {\n        Write-Host 'WARNING: TPM is disabled'\n    }\n} else {\n    Write-Host 'WARNING: TPM not present (BitLocker can use password-only, less secure)'\n}\n\nWrite-Host ''\nWrite-Host 'RECOMMENDATION: For AC-19(5) compliance (Moderate/High baselines):'\nWrite-Host '- Enable BitLocker on all fixed drives with AES-256'\nWrite-Host '- Use TPM + PIN for system drive protection'\nWrite-Host '- Escrow recovery keys to Active Directory or secure backup'\nWrite-Host '- For removable drives: Use BitLocker To Go'",
        "remediation": "$ErrorActionPreference = 'Stop'\nWrite-Host 'Implementing AC-19(5): Full-device encryption with BitLocker...'\nWrite-Host ''\n\n# Check if BitLocker is available\nif (-not (Get-Command Get-BitLockerVolume -ErrorAction SilentlyContinue)) {\n    Write-Host 'ERROR: BitLocker is not available on this Windows edition'\n    Write-Host 'BitLocker requires Windows Pro, Enterprise, or Education edition'\n    exit 1\n}\n\n# Check TPM\n$tpm = Get-Tpm\nif (-not $tpm.TpmPresent) {\n    Write-Host 'WARNING: No TPM detected. BitLocker will use password-only protection.'\n    Write-Host 'This is less secure than TPM + PIN but acceptable if no TPM available.'\n    $usePIN = $false\n} elseif (-not $tpm.TpmReady) {\n    Write-Host 'WARNING: TPM is present but not ready. Attempting to initialize...'\n    Initialize-Tpm\n    $usePIN = $true\n} else {\n    Write-Host 'PASS: TPM is ready for BitLocker'\n    $usePIN = $true\n}\n\n# Check if C: is already encrypted\n$systemVolume = Get-BitLockerVolume -MountPoint 'C:'\nif ($systemVolume.ProtectionStatus -eq 'On') {\n    Write-Host 'INFO: System drive (C:) is already BitLocker encrypted'\n    Write-Host \"  Encryption Method: $($systemVolume.EncryptionMethod)\"\n    Write-Host \"  Protection Status: $($systemVolume.ProtectionStatus)\"\n    \n    # Check if using strong encryption\n    if ($systemVolume.EncryptionMethod -notlike '*Aes256*') {\n        Write-Host 'WARNING: Not using AES-256. Consider upgrading encryption method.'\n    }\n} else {\n    Write-Host 'System drive (C:) is not encrypted. Enabling BitLocker...'\n    \n    if ($usePIN) {\n        # Enable BitLocker with TPM + PIN (most secure)\n        Write-Host 'Enabling BitLocker with TPM + PIN protection...'\n        Write-Host 'You will be prompted to set a PIN (6-20 digits)'\n        \n        # Enable BitLocker with TPM and PIN\n        Enable-BitLocker -MountPoint 'C:' `\n            -EncryptionMethod XtsAes256 `\n            -TpmAndPinProtector `\n            -SkipHardwareTest\n    } else {\n        # Enable BitLocker with password only (no TPM)\n        Write-Host 'Enabling BitLocker with password protection (no TPM available)...'\n        Write-Host 'You will be prompted to create a password'\n        \n        $password = Read-Host -AsSecureString 'Enter BitLocker password (16+ characters)'\n        Enable-BitLocker -MountPoint 'C:' `\n            -EncryptionMethod XtsAes256 `\n            -PasswordProtector `\n            -Password $password `\n            -SkipHardwareTest\n    }\n    \n    Write-Host 'BitLocker encryption initiated. This may take several hours for full encryption.'\nfi\n\n# Generate and backup recovery key\nWrite-Host ''\nWrite-Host 'Generating BitLocker recovery key...'\n$recoveryKey = (Get-BitLockerVolume -MountPoint 'C:').KeyProtector | Where-Object {$_.KeyProtectorType -eq 'RecoveryPassword'}\n\nif (-not $recoveryKey) {\n    # Add recovery password protector if not present\n    Add-BitLockerKeyProtector -MountPoint 'C:' -RecoveryPasswordProtector\n    $recoveryKey = (Get-BitLockerVolume -MountPoint 'C:').KeyProtector | Where-Object {$_.KeyProtectorType -eq 'RecoveryPassword'}\nfi\n\nif ($recoveryKey) {\n    Write-Host 'CRITICAL: BitLocker Recovery Key:'\n    Write-Host $recoveryKey.RecoveryPassword\n    Write-Host ''\n    Write-Host 'SAVE THIS RECOVERY KEY IN A SECURE LOCATION!'\n    Write-Host 'You will need it if you forget your PIN/password or TPM fails.'\n    \n    # Optionally backup to file\n    $backupPath = \"$env:USERPROFILE\\Desktop\\BitLocker-Recovery-C-$(Get-Date -Format 'yyyyMMdd').txt\"\n    $recoveryKey.RecoveryPassword | Out-File -FilePath $backupPath\n    Write-Host \"Recovery key saved to: $backupPath\"\n    Write-Host 'Move this file to secure offline storage and delete from Desktop'\nfi\n\nWrite-Host ''\nWrite-Host 'AC-19(5) implementation complete.'\nWrite-Host ''\nWrite-Host 'NEXT STEPS:'\nWrite-Host '1. Save recovery key to secure location (offline backup, password manager)'\nWrite-Host '2. Consider backing up recovery key to Active Directory: Backup-BitLockerKeyProtector'\nWrite-Host '3. Encrypt additional drives with Enable-BitLocker -MountPoint <drive>'\nWrite-Host '4. For removable drives: Use BitLocker To Go'\nWrite-Host '5. Configure Group Policy to enforce BitLocker on all devices'\nWrite-Host '6. Monitor encryption status with Get-BitLockerVolume'\nWrite-Host ''\nWrite-Host 'REBOOT to complete BitLocker setup and begin full-disk encryption.'"
      }
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00+00:00",
      "has_scripts": true,
      "created_by": "LOVELESS"
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T00:00:00+00:00",
      "source": "NIST SP 800-53 Rev 5",
      "related_cac_rules": [],
      "implementation_guidance": "Fully automated via BitLocker (Windows), FileVault (macOS), LUKS (Linux). MDM solutions can enforce and verify compliance. No direct CAC rules but encryption is foundational security control."
    },
    "rationale": "Mobile devices are frequently lost, stolen, or physically compromised. Without encryption, an attacker with physical access to a device can extract sensitive data by booting from external media, removing the storage device, or using forensic tools. Full-device or container encryption renders data unreadable without the decryption key, protecting confidentiality and integrity even if physical security is breached. This is especially critical for devices containing CUI (Controlled Unclassified Information), PII (Personally Identifiable Information), financial data, or intellectual property. AC-19(5) is REQUIRED for Moderate and High baseline systems per NIST SP 800-53. Encryption must use FIPS 140-2 validated cryptographic modules and strong algorithms (AES-256). Organizations must also implement key management procedures (secure key storage, recovery mechanisms, key rotation) to ensure encryption effectiveness without losing access to encrypted data.",
    "ai_guidance": "Encrypt all laptops, phones, and tablets. Windows: Enable BitLocker. macOS: Enable FileVault. Linux: Use LUKS. iOS/Android: Enable device encryption. Use AES-256. Save recovery keys safely. Required for Moderate/High security systems."
  },
  {
    "control_id": "AC-20",
    "control_name": "Use of External Systems",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This control ensures that external systems used by the organization are secure and do not pose a risk to the organization's information.",
    "example_implementation": "This script conduct regular security assessments and audits of external systems to ensure they meet security requirements and do not introduce vulnerabilities to the organization's network.",
    "non_technical_guidance": "This plan to comply with this control, the organization should establish a process for monitoring the use of external systems. This process should include regular audits of external systems connected to the information system, ensuring that only authorized systems are connected. Access control policies should be clearly defined and enforced to authorize the connection of external systems. Additionally, measures should be in place to protect the confidentiality, integrity, and availability of information system resources when external systems are connected. Regular training and awareness programs for employees on the risks associated with external systems can also help in compliance with this control.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "ac-20.1",
        "title": "Limits on Authorized Use",
        "official_text": "Permit authorized individuals to use an external system to access the system or to process, store, or transmit organization-controlled information only after:",
        "metadata": {
          "stig_id": "GEN-00-000201"
        },
        "ai_guidance": "Enhance security by applying specific controls for Limits on Authorized Use.",
        "rationale": "Limits the use of external information systems by organizational personnel to ensuring that terms of service and security policies are in place.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-20.2",
        "title": "Portable Storage Devices  Restricted Use",
        "official_text": "Restrict the use of organization-controlled portable storage devices by authorized individuals on external systems using [portable storage devices].",
        "metadata": {
          "stig_id": "GEN-00-000202"
        },
        "ai_guidance": "Enhance security by applying specific controls for Portable Storage Devices  Restricted Use.",
        "rationale": "Restricts the use of organization-controlled portable storage devices (e.g., USB drives) on external systems to prevent malware introduction.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-20.3",
        "title": "Non-organizationally Owned Systems  Restricted Use",
        "official_text": "Restrict the use of non-organizationally owned systems or system components to process, store, or transmit organizational information using [non-organizational devices].",
        "metadata": {
          "stig_id": "GEN-00-000203"
        },
        "ai_guidance": "Enhance security by applying specific controls for Non-organizationally Owned Systems  Restricted Use.",
        "rationale": "Prohibits the use of non-organizationally owned portable storage devices on organizational systems to maintain a secure perimeter.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-20.4",
        "title": "Network Accessible Storage Devices  Prohibited Use",
        "official_text": "Prohibit the use of [network components] in external systems.",
        "metadata": {
          "stig_id": "GEN-00-000204"
        },
        "ai_guidance": "Enhance security by applying specific controls for Network Accessible Storage Devices  Prohibited Use.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-20.5",
        "title": "Portable Storage Devices  Prohibited Use",
        "official_text": "Prohibit the use of organization-controlled portable storage devices by authorized individuals on external systems.",
        "metadata": {
          "stig_id": "GEN-00-000205"
        },
        "ai_guidance": "Enhance security by applying specific controls for Portable Storage Devices  Prohibited Use.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-20 Use of External Systems\n# Description: Check for mounted external storage or unauthorized network connections.\n\necho \"Checking for mounted external storage...\"\nmount | grep -E '/media|/mnt'\n\necho \"Checking for established connections to known public DNS (example check)...\"\nnetstat -ant | grep ':53'\n\necho \"Manual Review: Ensure external system usage complies with organizational policy.\"\n",
        "ansible": "---\n- name: AC-20 Use of External Systems Checks\n  hosts: all\n  tasks:\n    - name: Check for mounted external media\n      command: mount\n      register: mounted_volumes\n      changed_when: false\n\n    - name: Warn if external media found\n      debug:\n        msg: \"External media found mounted at {{ item }}\"\n      loop: \"{{ mounted_volumes.stdout_lines }}\"\n      when: \"'/media' in item or '/mnt' in item\"\n"
      },
      "_note": "Added checks for external storage and network connections.",
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-09T12:31:24.141224+00:00",
      "has_scripts": true,
      "stig_id": "GEN000000-GEN00"
    },
    "cac_metadata": {
      "implementation_type": "administrative",
      "last_analyzed": "2025-11-10T09:38:09.334800+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Use of External Systems according to organization policies to ensure access is strictly controlled.",
    "implementation_guidance": "This control is implemented via organizational policy and architectural design. Refer to the Policy Guidance tab.",
    "stig_id": "GEN000000-GEN00"
  },
  {
    "control_id": "AC-20.1",
    "control_name": "Limits on Authorized Use",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Permit authorized individuals to use an external system to access the system or to process, store, or transmit organization-controlled information only after:",
    "parent_control": "ac-20",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Permit authorized individuals to use an external system to access the system or to process, store, or transmit organization-controlled information only after:",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141238+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000201"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:10.865894+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Limits on Authorized Use according to organization policies to ensure access is strictly controlled.",
    "rationale": "Limits the use of external information systems by organizational personnel to ensuring that terms of service and security policies are in place.",
    "stig_id": "GEN-00-000201"
  },
  {
    "control_id": "AC-20.2",
    "control_name": "Portable Storage Devices  Restricted Use",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Restrict the use of organization-controlled portable storage devices by authorized individuals on external systems using [portable storage devices].",
    "parent_control": "ac-20",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "Restrict the use of organization-controlled portable storage devices by authorized individuals on external systems using [portable storage devices].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141252+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000202"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:12.475946+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Portable Storage Devices  Restricted Use according to organization policies to ensure access is strictly controlled.",
    "rationale": "Restricts the use of organization-controlled portable storage devices (e.g., USB drives) on external systems to prevent malware introduction.",
    "stig_id": "GEN-00-000202"
  },
  {
    "control_id": "AC-20.3",
    "control_name": "Non-organizationally Owned Systems  Restricted Use",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Restrict the use of non-organizationally owned systems or system components to process, store, or transmit organizational information using [non-organizational devices].",
    "parent_control": "ac-20",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Restrict the use of non-organizationally owned systems or system components to process, store, or transmit organizational information using [non-organizational devices].",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141266+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000203"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:14.018808+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Non-organizationally Owned Systems  Restricted Use according to organization policies to ensure access is strictly controlled.",
    "rationale": "Prohibits the use of non-organizationally owned portable storage devices on organizational systems to maintain a secure perimeter.",
    "stig_id": "GEN-00-000203"
  },
  {
    "control_id": "AC-20.4",
    "control_name": "Network Accessible Storage Devices  Prohibited Use",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Prohibit the use of [network components] in external systems.",
    "parent_control": "ac-20",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Prohibit the use of [network components] in external systems.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141279+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000204"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:15.563493+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Network Accessible Storage Devices  Prohibited Use according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000204"
  },
  {
    "control_id": "AC-20.5",
    "control_name": "Portable Storage Devices  Prohibited Use",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Prohibit the use of organization-controlled portable storage devices by authorized individuals on external systems.",
    "parent_control": "ac-20",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Prohibit the use of organization-controlled portable storage devices by authorized individuals on external systems.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141293+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000205"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:17.121924+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Portable Storage Devices  Prohibited Use according to organization policies to ensure access is strictly controlled.",
    "stig_id": "GEN-00-000205"
  },
  {
    "control_id": "AC-21",
    "control_name": "Information Sharing",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "a. Enable authorized users to determine whether access authorizations assigned to a sharing partner match the information's access and use restrictions for [Assignment: organization-defined information sharing circumstances] where user discretion is required; and\nb. Employ [Assignment: organization-defined automated mechanisms] to assist users in making information sharing and collaboration decisions.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": true,
      "high": true
    },
    "plain_english_explanation": "This control requires organizations to help authorized users verify that sharing partners have appropriate access rights before sharing information, and to provide automated tools that assist users in making secure information sharing decisions. This applies to sensitive information like classified data, proprietary information, personally identifiable information (PII), and contract-sensitive materials.",
    "example_implementation": "Implement an information sharing platform that displays sharing partner clearance levels and access authorizations alongside information classification labels. Deploy automated decision support tools (such as Data Loss Prevention systems or Attribute-Based Access Control mechanisms) that alert users when attempting to share information with partners lacking appropriate authorizations. For file sharing services like Samba or NFS, configure access control lists that restrict sharing based on user groups and network locations.",
    "non_technical_guidance": "Establish policies defining information sharing circumstances requiring user discretion (e.g., sharing classified information, PII, proprietary data). Document procedures for users to verify sharing partner authorizations before sharing. Deploy automated tools that help users make sharing decisions by displaying relevant access restrictions and partner authorization levels. Train users on information sharing protocols and decision-making processes. Regularly audit information sharing activities to ensure compliance with policies.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-3",
      "AC-4",
      "AC-16",
      "PT-2",
      "PT-7",
      "RA-3",
      "SC-15"
    ],
    "supplemental_guidance": "This control addresses information that may be restricted based on formal or administrative determinations. Examples include contract-sensitive information, classified information related to special access programs or compartments, privileged information, proprietary information, and personally identifiable information. Sharing partners may be defined at the individual, group, or organizational level. Information may be defined by content, type, security category, or special access program/compartment. Security and privacy risk assessments, as well as applicable laws, regulations, and policies, inform sharing determinations. Information flow techniques and security attributes may be used to provide automated assistance to users making sharing and collaboration decisions.",
    "implementation_scripts": {
      "linux": {
        "bash": "#!/bin/bash\n# AC-21 Information Sharing - Verification Script\n# Checks file sharing services, access controls, and sharing configurations\n\necho \"[AC-21] Checking Information Sharing Controls...\"\necho \"\"\n\n# Check NFS exports and restrictions\necho \"=== NFS Export Configuration ===\"\nif [ -f /etc/exports ]; then\n    echo \"NFS exports configured:\"\n    cat /etc/exports\n    echo \"VERIFY: Ensure exports restrict access to authorized networks/hosts only\"\nelse\n    echo \"No NFS exports configured\"\nfi\necho \"\"\n\n# Check Samba sharing configuration\necho \"=== Samba Sharing Configuration ===\"\nif [ -f /etc/samba/smb.conf ]; then\n    echo \"Checking Samba access controls:\"\n    grep -E \"valid users|hosts allow|hosts deny|read list|write list\" /etc/samba/smb.conf || echo \"No explicit access controls found\"\n    echo \"VERIFY: Ensure Samba shares restrict access to authorized users/networks only\"\nelse\n    echo \"Samba not configured\"\nfi\necho \"\"\n\n# Check for file sharing services status\necho \"=== File Sharing Service Status ===\"\nfor service in nfs-server smb; do\n    if systemctl is-active --quiet $service 2>/dev/null; then\n        echo \"$service: ACTIVE - Review sharing restrictions\"\n    else\n        echo \"$service: inactive\"\n    fi\ndone\necho \"\"\n\necho \"[AC-21] MANUAL REVIEW REQUIRED:\"\necho \"1. Verify information classification and labeling system is implemented\"\necho \"2. Confirm automated decision support tools (DLP, ABAC) are deployed\"\necho \"3. Review user training on information sharing authorization verification\"\necho \"4. Audit sharing partner access authorization documentation\"\n",
        "ansible": "---\n- name: AC-21 Information Sharing Configuration Verification\n  hosts: all\n  tasks:\n    - name: Check NFS exports configuration\n      command: cat /etc/exports\n      register: nfs_exports\n      changed_when: false\n      failed_when: false\n\n    - name: Display NFS exports\n      debug:\n        msg: \"NFS Exports: {{ nfs_exports.stdout_lines }}\"\n      when: nfs_exports.rc == 0\n\n    - name: Check Samba configuration for access controls\n      shell: grep -E \"valid users|hosts allow|hosts deny\" /etc/samba/smb.conf\n      register: smb_access\n      changed_when: false\n      failed_when: false\n\n    - name: Display Samba access controls\n      debug:\n        msg: \"Samba Access Controls: {{ smb_access.stdout_lines }}\"\n      when: smb_access.rc == 0\n\n    - name: Verify file sharing services are controlled\n      service_facts:\n      register: services\n\n    - name: Report on information sharing services\n      debug:\n        msg: \"AC-21 requires manual verification of sharing partner authorization mechanisms and automated decision support tools\"\n"
      },
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T13:01:04.303376Z",
      "has_scripts": true,
      "stig_id": "GEN000000-GEN00"
    },
    "cac_metadata": {
      "implementation_type": "hybrid",
      "last_analyzed": "2025-11-20T13:01:04.303401Z",
      "source": "ComplianceAsCode",
      "cac_status": "partial",
      "cac_planned": true,
      "implementation_guidance": "Partial technical implementation available for file sharing services. Organizational policy and automated decision support tools require separate implementation."
    },
    "ai_guidance": "Implement systems that let users verify sharing partner authorizations before sharing sensitive information. Deploy automated tools like Data Loss Prevention (DLP) or Attribute-Based Access Control (ABAC) to assist users in making secure sharing decisions.",
    "rationale": "Information sharing decisions require careful consideration of both the sensitivity of information and the authorizations of sharing partners. Unauthorized information disclosure can result in significant harm to organizational operations, assets, individuals, and the nation. Automated mechanisms help users make correct sharing decisions by presenting relevant authorization and restriction information at decision time, reducing human error in complex sharing scenarios.",
    "implementation_guidance": "This control requires both organizational policy (defining sharing circumstances and procedures) and technical mechanisms (access control systems, decision support tools). Implement information classification and labeling systems, deploy automated authorization verification tools, and train users on sharing protocols.",
    "stig_id": "GEN000000-GEN00"
  },
  {
    "control_id": "AC-21.1",
    "control_name": "Automated Decision Support",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Employ [Assignment: organization-defined automated mechanisms] to enforce information-sharing decisions by authorized users based on access authorizations of sharing partners and access restrictions on information to be shared.",
    "parent_control": "ac-21",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This enhancement requires automated systems to enforce (not just assist with) information sharing decisions. Unlike the base AC-21 control which helps users make decisions, AC-21(1) requires automated mechanisms that actively prevent unauthorized information sharing by blocking transfers that violate access restrictions or sharing partner authorization levels.",
    "example_implementation": "Deploy Data Loss Prevention (DLP) tools that automatically block file transfers or emails when recipient clearance levels do not match document classification labels. Implement Attribute-Based Access Control (ABAC) systems that enforce sharing policies based on user attributes, information attributes, and environmental conditions. Configure cross-domain solutions (CDS) that automatically enforce information flow restrictions between networks of different classification levels. Use enterprise rights management systems that prevent unauthorized sharing of protected documents even after download.",
    "non_technical_guidance": "Define the automated mechanisms to be used for enforcing information sharing decisions (e.g., DLP systems, ABAC platforms, rights management tools). Configure these mechanisms with organizational policies regarding access restrictions and sharing partner authorization requirements. Test enforcement mechanisms regularly to ensure they correctly block unauthorized sharing attempts while allowing legitimate information sharing. Document enforcement actions in audit logs for compliance review.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-3",
      "AC-4",
      "AC-16",
      "AU-2",
      "AU-12"
    ],
    "supplemental_guidance": "This control enhancement requires enforcement automation, moving beyond the decision assistance provided in the base control. Automated mechanisms may include Data Loss Prevention systems, Attribute-Based Access Control platforms, cross-domain solutions, enterprise rights management systems, or information flow enforcement tools. These mechanisms must have access to information classification labels, user authorization levels, and sharing partner access rights to make enforcement decisions. The automation reduces reliance on user judgment and prevents inadvertent or intentional unauthorized sharing.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-20T13:01:04.303413Z",
      "has_scripts": false,
      "stig_id": "GEN-00-000211"
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T13:01:04.303420Z",
      "source": "ComplianceAsCode",
      "cac_status": "not_available",
      "cac_planned": false,
      "implementation_guidance": "This enhancement requires application-layer enforcement mechanisms (DLP, ABAC, rights management) not available in OS-level ComplianceAsCode repository. Implementation requires third-party or custom security tools."
    },
    "ai_guidance": "Deploy automated systems that actively block unauthorized information sharing. Examples: DLP tools that prevent emailing classified documents to uncleared recipients, ABAC systems that deny file share access based on user attributes, or rights management that prevents forwarding protected documents.",
    "rationale": "While the base AC-21 control assists users in making sharing decisions, this enhancement enforces those decisions through automation. This significantly reduces the risk of unauthorized disclosure due to user error, malicious insider activity, or social engineering. Automated enforcement is essential for high-value information and environments where sharing decisions are complex or high-risk.",
    "implementation_guidance": "Requires deployment of enforcement automation tools such as DLP platforms, ABAC systems, cross-domain solutions, or enterprise rights management. These tools must integrate with information classification systems and identity/authorization directories to make enforcement decisions. OS-level controls alone are insufficient.",
    "stig_id": "GEN-00-000211"
  },
  {
    "control_id": "AC-21.2",
    "control_name": "Information Search and Retrieval",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Implement information search and retrieval services that enforce [Assignment: organization-defined information-sharing restrictions].",
    "parent_control": "ac-21",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "This enhancement requires search and retrieval systems (such as enterprise search engines, document management systems, knowledge bases, or file indexing services) to enforce information sharing restrictions by only returning search results that the user is authorized to access. Users should not be able to discover the existence of information they are not authorized to view.",
    "example_implementation": "Configure SharePoint or other document management systems to filter search results based on user permissions, ensuring classified or restricted documents do not appear in search results for unauthorized users. Implement Elasticsearch or similar search engines with security plugins that apply access control filters to search queries based on user authorization levels. Deploy knowledge management systems that enforce information classification labels in search results, hiding sensitive content from users lacking appropriate clearances. Configure enterprise search tools to respect file system ACLs and directory permissions when indexing and returning results.",
    "non_technical_guidance": "Define information-sharing restrictions that search and retrieval services must enforce (e.g., classification levels, need-to-know restrictions, project-specific access controls). Configure all enterprise search tools, document management systems, and knowledge bases to enforce these restrictions by filtering search results based on user authorization levels. Test search functionality regularly to verify that restricted information is not discoverable by unauthorized users. Document search service configurations and access control implementations.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-3",
      "AC-4",
      "AC-16",
      "SC-7"
    ],
    "supplemental_guidance": "Information search and retrieval services identify information system resources relevant to an information need. This control enhancement ensures these services respect information sharing restrictions, preventing users from discovering information they are not authorized to access. This includes enterprise search engines, document management systems, knowledge bases, file indexing services, and database query interfaces. Implementation requires integration between search services and authorization systems to filter results based on user access rights, information classification labels, and organizational sharing policies.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-20T13:01:04.303428Z",
      "has_scripts": false,
      "stig_id": "GEN-00-000212"
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T13:01:04.303434Z",
      "source": "ComplianceAsCode",
      "cac_status": "not_available",
      "cac_planned": false,
      "implementation_guidance": "This enhancement requires application-layer search and retrieval security controls not available in OS-level ComplianceAsCode repository. Implementation requires configuration of enterprise search engines, document management systems, and knowledge bases with appropriate access control integration."
    },
    "ai_guidance": "Ensure enterprise search tools (like SharePoint search, Elasticsearch, or document management systems) only show search results that users are authorized to access. Classified or restricted documents should not appear in search results for unauthorized users.",
    "rationale": "Search and retrieval services can inadvertently disclose the existence of information through search results, even without revealing the full content. This information leakage can compromise security by revealing that certain projects, operations, or information types exist. Enforcing sharing restrictions in search results ensures users cannot discover information beyond their authorization level, supporting both confidentiality and operational security.",
    "implementation_guidance": "Requires configuration of enterprise search engines, document management systems, and knowledge bases to integrate with authorization systems. Search services must filter results based on user access rights, information classification labels, and sharing restrictions. OS-level controls alone are insufficient.",
    "stig_id": "GEN-00-000212"
  },
  {
    "control_id": "AC-22",
    "control_name": "Publicly Accessible Content",
    "family": "Access Control",
    "family_id": "AC",
    "official_text": "a. Designate individuals authorized to make information publicly accessible;\n\nb. Train authorized individuals to ensure that publicly accessible information does not contain nonpublic information;\n\nc. Review the proposed content of information prior to posting onto the publicly accessible system to ensure that nonpublic information is not included; and\n\nd. Review the content on the publicly accessible system for nonpublic information [Assignment: organization-defined frequency] and remove such information, if discovered.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": true,
      "moderate": true,
      "high": true
    },
    "parameters": {
      "AC-22_ODP": {
        "label": "frequency",
        "description": "the frequency at which to review the content on the publicly accessible system for non-public information",
        "guidance": "Organizations should define the review frequency based on risk assessment. Common values: quarterly, monthly, or based on content update frequency.",
        "example_values": [
          "quarterly",
          "monthly",
          "at least quarterly",
          "continuously via automated monitoring"
        ]
      }
    },
    "plain_english_explanation": "This control requires organizations to manage publicly accessible content carefully to prevent unauthorized disclosure of sensitive information. Organizations must designate specific individuals who are authorized to post content on public-facing systems (such as websites, FTP servers, or public file shares), train these individuals to recognize and avoid posting nonpublic information, review all content before publication to ensure no sensitive data is included, and conduct periodic reviews of already-published content to detect and remove any nonpublic information that may have been inadvertently posted or that has become sensitive over time.",
    "example_implementation": "To implement AC-22, establish a formal process for managing public content:\n\n1. Designate authorized publishers: Create a documented list of individuals authorized to publish content to public-facing systems. Include their roles, responsibilities, and scope of authorization.\n\n2. Provide mandatory training: Develop and deliver training that covers:\n   - Classification of public vs. nonpublic information\n   - Organizational policies on data disclosure\n   - Privacy Act and proprietary information protection\n   - Consequences of unauthorized disclosure\n   - Technical controls for content review\n\n3. Implement pre-publication review workflow:\n   - Require all content to pass through a review process before publication\n   - Use automated tools to scan for sensitive data patterns (SSNs, PII, credentials)\n   - Maintain approval documentation with reviewer signatures\n   - Use staging environments for content review before production deployment\n\n4. Schedule periodic content audits:\n   - Conduct systematic reviews at the defined frequency (e.g., quarterly)\n   - Use automated scanning tools to detect sensitive information on public systems\n   - Document review findings and remediation actions\n   - Maintain audit logs of all reviews and content removals\n\n5. Technical implementation examples:\n   - Web Content Management System (CMS) with approval workflows\n   - Data Loss Prevention (DLP) tools to scan for sensitive patterns\n   - Access controls limiting who can deploy to public web servers\n   - Automated scripts to review public directories for prohibited file types\n   - Version control systems with mandatory code review for public repositories",
    "non_technical_guidance": "To ensure compliance with AC-22, organizations should:\n\n1. Establish clear policies defining what information is considered nonpublic, including:\n   - Privacy Act protected information (PII, medical records, financial data)\n   - Proprietary business information\n   - Internal-only operational data\n   - Pre-decisional or draft documents\n   - Security-sensitive configurations or credentials\n\n2. Create a formal designation process:\n   - Document who is authorized to publish content to each public-facing system\n   - Define approval chains for different content types\n   - Establish criteria for authorization (role, clearance level, training completion)\n\n3. Implement a training program:\n   - Provide initial training before granting publishing authority\n   - Conduct annual refresher training\n   - Update training materials when policies change\n   - Track training completion and maintain records\n\n4. Design pre-publication review procedures:\n   - Create checklists for reviewers to verify content appropriateness\n   - Define escalation paths for questionable content\n   - Set maximum review turnaround times\n   - Require dual approval for high-risk content\n\n5. Schedule and conduct periodic reviews:\n   - Define review frequency based on system risk level and content update frequency\n   - Assign responsibility for conducting reviews\n   - Document review findings in audit reports\n   - Establish remediation timelines for identified issues\n   - Track metrics on content removals and policy violations\n\n6. Coordinate with related processes:\n   - Integrate with incident response for unauthorized disclosures\n   - Coordinate with records management for content retention\n   - Align with privacy office requirements\n   - Connect to AU-13 (Monitoring for Information Disclosure) for automated detection",
    "implementation_guidance": {
      "part_a": {
        "requirement": "Designate individuals authorized to make information publicly accessible",
        "implementation": "Create and maintain a formal authorization document listing individuals by name, role, and scope of authority. Include approval signatures from management. Update the list whenever personnel changes occur or authorization needs change.",
        "verification": "Review the authorization list during audits. Verify that only designated individuals have technical access to publish content. Compare the list against actual system permissions."
      },
      "part_b": {
        "requirement": "Train authorized individuals to ensure publicly accessible information does not contain nonpublic information",
        "implementation": "Develop a training curriculum covering data classification, privacy laws, proprietary information protection, and organizational policies. Deliver training before granting publishing authority. Conduct annual refresher training. Track completion in training management systems.",
        "verification": "Audit training records to confirm all authorized publishers completed required training. Review training materials for currency and completeness. Test publisher knowledge through assessments."
      },
      "part_c": {
        "requirement": "Review proposed content prior to posting to ensure nonpublic information is not included",
        "implementation": "Implement a mandatory review workflow where content cannot be published without approval. Use automated scanning tools to detect sensitive data patterns. Require documented approval from designated reviewers. Maintain approval records with timestamps and reviewer identities.",
        "verification": "Sample published content and verify corresponding approval documentation exists. Review workflow logs to confirm all content passed through the review process. Test the workflow by attempting to bypass it."
      },
      "part_d": {
        "requirement": "Review content on the publicly accessible system for nonpublic information at organization-defined frequency and remove if discovered",
        "implementation": "Schedule periodic reviews (e.g., quarterly) of all content on public systems. Use automated scanning tools to detect sensitive information. Document review findings, including content examined, issues found, and remediation actions. Remove identified nonpublic information immediately upon discovery.",
        "verification": "Review audit reports showing periodic reviews were conducted at the specified frequency. Examine scan results and remediation documentation. Verify removed content is no longer accessible. Test detection capabilities by introducing test sensitive data."
      }
    },
    "related_controls": [
      {
        "control_id": "AC-3",
        "relationship": "AC-3 (Access Enforcement) provides the technical mechanisms to enforce authorization decisions regarding who can publish content to public systems, supporting AC-22 part (a)."
      },
      {
        "control_id": "AT-2",
        "relationship": "AT-2 (Literacy Training and Awareness) establishes the organization's overall security awareness program, which should include awareness of proper handling of public vs. nonpublic information, supporting AC-22 part (b)."
      },
      {
        "control_id": "AT-3",
        "relationship": "AT-3 (Role-Based Training) requires training for individuals with specific security roles, including those authorized to publish content, directly supporting AC-22 part (b)."
      },
      {
        "control_id": "AU-13",
        "relationship": "AU-13 (Monitoring for Information Disclosure) provides automated monitoring capabilities to detect nonpublic information on public systems, supporting AC-22 part (d)."
      }
    ],
    "control_enhancements": [],
    "cac_implementation_references": [
      {
        "rule_id": "httpd_remove_robots_file",
        "file": "cac/linux_os/guide/services/http/securing_httpd/httpd_secure_content/httpd_remove_robots_file/rule.yml",
        "description": "Requires removal of robots.txt files that could reveal directory structures and content intended to be protected from public indexing. Supports AC-22(c) and AC-22(d) by preventing inadvertent disclosure of protected content locations.",
        "severity": "medium"
      },
      {
        "rule_id": "httpd_public_resources_not_shared",
        "file": "cac/linux_os/guide/services/http/securing_httpd/httpd_public_resources_not_shared/rule.yml",
        "description": "Ensures public web server resources are not shared with private assets. Supports AC-22 by enforcing segregation between public and nonpublic information systems.",
        "severity": "medium"
      },
      {
        "rule_id": "httpd_configure_banner_page",
        "file": "cac/linux_os/guide/services/http/securing_httpd/httpd_secure_content/httpd_configure_banner_page/rule.yml",
        "description": "Requires configuration of login banners for websites requiring authentication. Distinguishes between publicly accessible (no authentication) and restricted access systems, supporting AC-22 scope definition.",
        "severity": "low"
      },
      {
        "rule_id": "httpd_nipr_accredited_dmz",
        "file": "cac/linux_os/guide/services/http/securing_httpd/httpd_nipr_accredited_dmz/rule.yml",
        "description": "Requires public web servers to be isolated in an accredited DMZ. Supports AC-22 by providing network-level separation between public and nonpublic systems.",
        "severity": "medium"
      },
      {
        "rule_id": "httpd_private_server_on_separate_subnet",
        "file": "cac/linux_os/guide/services/http/securing_httpd/httpd_private_server_on_separate_subnet/rule.yml",
        "description": "Requires private web servers to be on separate controlled access subnets. Supports AC-22 by ensuring nonpublic content servers are segregated from public systems.",
        "severity": "medium"
      }
    ],
    "assessment_objectives": {
      "AC-22a": "designated individuals are authorized to make information publicly accessible",
      "AC-22b": "authorized individuals are trained to ensure that publicly accessible information does not contain non-public information",
      "AC-22c": "the proposed content of information is reviewed prior to posting onto the publicly accessible system to ensure that non-public information is not included",
      "AC-22d": "the content on the publicly accessible system is reviewed for non-public information with the organization-defined frequency and such information is removed, if discovered"
    },
    "assessment_methods": [
      {
        "method": "EXAMINE",
        "objects": [
          "Access control policy",
          "Procedures for managing publicly accessible content",
          "List of designated individuals authorized to post publicly accessible content",
          "Training records for authorized individuals",
          "Records of content reviews prior to posting",
          "Records of periodic reviews of posted content",
          "Audit logs of content publication and removal activities",
          "System security plan",
          "Other relevant documents or records"
        ]
      },
      {
        "method": "INTERVIEW",
        "objects": [
          "Organizational personnel with access control responsibilities",
          "Organizational personnel with responsibilities for managing publicly accessible content",
          "Organizational personnel that review content prior to posting",
          "System/network administrators",
          "Organizational personnel with information security responsibilities"
        ]
      },
      {
        "method": "TEST",
        "objects": [
          "Automated mechanisms implementing access control policy for publicly accessible content",
          "Automated mechanisms for reviewing publicly accessible content for non-public information",
          "Workflow systems that enforce pre-publication review",
          "Data loss prevention tools that scan for sensitive information",
          "Access controls preventing unauthorized content publication"
        ]
      }
    ],
    "discussion": "In accordance with applicable laws, executive orders, directives, policies, regulations, standards, and guidelines, the public is not authorized to have access to nonpublic information, including information protected under the Privacy Act and proprietary information. Publicly accessible content addresses systems that are controlled by the organization and accessible to the public, typically without identification or authentication. Posting information on non-organizational systems (e.g., non-organizational public websites, forums, and social media) is covered by organizational policy. While organizations may have individuals who are responsible for developing and implementing policies about the information that can be made publicly accessible, publicly accessible content addresses the management of the individuals who make such information publicly accessible.",
    "stig_mapping": {
      "applicable_stigs": [
        "Web Server STIG",
        "Application Security and Development STIG"
      ],
      "related_srg_requirements": [
        "SRG-APP-000211 (The application must prevent non-privileged users from executing privileged functions)",
        "SRG-APP-000033 (The application must protect the confidentiality and integrity of transmitted information)"
      ]
    },
    "fedramp_requirements": {
      "low_baseline": true,
      "moderate_baseline": true,
      "high_baseline": true,
      "parameter_guidance": "FedRAMP requires review frequency of at least quarterly for publicly accessible content."
    }
  },
  {
    "control_id": "AC-23",
    "control_name": "Data Mining Protection",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Employ [Assignment: organization-defined data mining prevention and detection techniques] for [Assignment: organization-defined data storage objects] to detect and protect against unauthorized data mining.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Organizations must implement specific techniques to prevent and detect unauthorized data mining activities against sensitive data stores such as databases, data warehouses, and big data repositories. Data mining is an analytical process that can reveal patterns and correlations in large datasets, potentially exposing sensitive or personally identifiable information. This control requires defining which data storage objects need protection and selecting appropriate prevention and detection techniques.",
    "example_implementation": "Implement database query monitoring and rate limiting to detect abnormal patterns. Limit the types and volume of data returned by queries. Apply differential privacy techniques to protect individual records in aggregate queries. Configure alerts for atypical database access patterns such as unusual query frequency, large result sets, or queries from unexpected sources. For databases containing PII, implement query audit logging and periodic review by privacy officers.",
    "non_technical_guidance": "To implement Data Mining Protection (AC-23):\n1. Identify all data storage objects that contain sensitive information requiring protection from unauthorized mining (databases, data warehouses, analytics platforms)\n2. Define organizational policy on authorized vs unauthorized data mining activities\n3. Select prevention techniques: query rate limiting, response type restrictions, result set size limits, differential privacy\n4. Select detection techniques: anomaly detection for queries, access pattern monitoring, audit logging of database queries\n5. Train personnel on recognizing unauthorized data mining attempts\n6. Coordinate with privacy office and legal counsel on data mining requirements under applicable laws and regulations\n7. Establish notification procedures when atypical database access occurs\n8. Document all authorized data mining activities and ensure appropriate approvals\n9. Regularly review audit logs for signs of unauthorized data mining\n10. Integrate with insider threat program per EO 13587",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "PM-12",
      "PT-2",
      "AU-13"
    ],
    "supplemental_guidance": "Data mining is an analytical process that attempts to find correlations or patterns in large data sets for the purpose of data or knowledge discovery. Data storage objects include database records and database fields. Sensitive information can be extracted from data mining operations. When information is personally identifiable information, it may lead to unanticipated revelations about individuals and give rise to privacy risks. Prior to performing data mining activities, organizations determine whether such activities are authorized. Organizations may be subject to applicable laws, executive orders, directives, regulations, or policies that address data mining requirements. Organizational personnel consult with the senior agency official for privacy and legal counsel regarding such requirements.\n\nData mining prevention and detection techniques include limiting the number and frequency of database queries to increase the work factor needed to determine the contents of databases, limiting types of responses provided to database queries, applying differential privacy techniques or homomorphic encryption, and notifying personnel when atypical database queries or accesses occur. Data mining protection focuses on protecting information from data mining while such information resides in organizational data stores. In contrast, AU-13 focuses on monitoring for organizational information that may have been mined or otherwise obtained from data stores and is available as open-source information residing on external sites, such as social networking or social media websites.\n\nEO 13587 requires the establishment of an insider threat program for deterring, detecting, and mitigating insider threats, including the safeguarding of sensitive information from exploitation, compromise, or other unauthorized disclosure. Data mining protection requires organizations to identify appropriate techniques to prevent and detect unnecessary or unauthorized data mining. Data mining can be used by an insider to collect organizational information for the purpose of exfiltration.",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-20T00:00:00Z",
      "has_scripts": false,
      "stig_id": "N/A"
    },
    "cac_metadata": {
      "implementation_type": "application",
      "last_analyzed": "2025-11-20T00:00:00Z",
      "source": "ComplianceAsCode",
      "cac_status": "not_applicable",
      "cac_planned": false,
      "implementation_guidance": "AC-23 is implemented at the application and database layer, not the operating system level. While CAC includes one tangentially related rule (dconf_gnome_disable_user_list) that prevents user enumeration, comprehensive data mining protection requires database-specific controls: query rate limiting, response filtering, differential privacy, audit logging of queries, and anomaly detection. These must be configured in database systems (PostgreSQL, MySQL, Oracle, etc.) or data warehouse platforms. OS-level implementation is not applicable."
    },
    "ai_guidance": "Implement database-level query monitoring, rate limiting, and anomaly detection. Configure audit logging for all database queries. Apply differential privacy techniques where appropriate. Establish alerts for atypical access patterns. Coordinate with privacy office on PII protection requirements.",
    "implementation_guidance": "This control requires implementation at the database and application layers. Key steps:\n1. Database Configuration: Enable query logging, configure rate limiting, restrict result set sizes\n2. Monitoring: Deploy database activity monitoring (DAM) tools to detect anomalous query patterns\n3. Privacy Techniques: Implement differential privacy for analytics on PII datasets\n4. Access Controls: Enforce least privilege for database accounts, limit query privileges\n5. Alerting: Configure SIEM to alert on unusual query volume, frequency, or patterns\n6. Policy: Document authorized data mining activities and approval processes\n7. Training: Educate administrators on recognizing unauthorized data mining attempts\n\nRefer to database-specific security guides for MySQL, PostgreSQL, Oracle, SQL Server, or NoSQL systems. For GNOME-based Linux systems, also implement dconf_gnome_disable_user_list to prevent user enumeration.",
    "stig_id": "N/A"
  },
  {
    "control_id": "AC-24",
    "control_name": "Access Control Decisions",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "[access control policy] to ensure [access control decision] are applied to each access request prior to access enforcement.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Access control decisions must be made and applied to each access request before access is granted.",
    "example_implementation": "This script implement a centralized access control system that automatically evaluates and enforces access control decisions for each access request.",
    "non_technical_guidance": "This plan to ensure compliance with control AC-24, access control decisions must be made and applied to each access request before access is granted. This can be achieved through the following steps:\n\n1. Establish a clear access control policy that outlines the criteria for granting access to resources.\n2. Train personnel responsible for access control decisions on the policy and procedures to follow.\n3. Implement a process for reviewing and approving access requests based on the established criteria.\n4. Document access control decisions and the rationale behind them for auditing purposes.\n5. Regularly review and update access control decisions to ensure they align with organizational security requirements.\n\nBy following these steps and consistently applying access control decisions before granting access, organizations can effectively comply with control AC-24.",
    "is_technical": false,
    "enhancements": [
      {
        "id": "ac-24.1",
        "title": "Transmit Access Authorization Information",
        "official_text": "Transmit [documented decision] using [decision rationale] to [retention period] that enforce access control decisions.",
        "metadata": {
          "stig_id": "GEN-00-000241"
        },
        "ai_guidance": "Enhance security by applying specific controls for Transmit Access Authorization Information.",
        "rationale": "Documenting access control decisions ensures accountability and provides an audit trail for authorization.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      },
      {
        "id": "ac-24.2",
        "title": "No User or Process Identity",
        "official_text": "Enforce access control decisions based on [automated mechanism] that do not include the identity of the user or process acting on behalf of the user.",
        "metadata": {
          "stig_id": "GEN-00-000242"
        },
        "ai_guidance": "Enhance security by applying specific controls for No User or Process Identity.",
        "rationale": "Automated mechanisms for access control decisions reduce human error and improve the speed of authorization.",
        "cac_metadata": {
          "implementation_type": "administrative"
        },
        "implementation_guidance": "This enhancement relies on policy enforcement."
      }
    ],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "implemented",
      "last_updated": "2025-11-09T12:31:24.141380+00:00",
      "has_scripts": true,
      "stig_id": "GEN000000-GEN00"
    },
    "cac_metadata": {
      "implementation_type": "administrative",
      "last_analyzed": "2025-11-10T09:38:26.339922+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Access Control Decisions according to organization policies to ensure access is strictly controlled.",
    "implementation_guidance": "This control is implemented via organizational policy and architectural design. Refer to the Policy Guidance tab.",
    "stig_id": "GEN000000-GEN00"
  },
  {
    "control_id": "AC-24.1",
    "control_name": "Transmit Access Authorization Information",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Transmit [documented decision] using [decision rationale] to [retention period] that enforce access control decisions.",
    "parent_control": "ac-24",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Transmit [documented decision] using [decision rationale] to [retention period] that enforce access control decisions.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141394+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000241"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:27.884735+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce Transmit Access Authorization Information according to organization policies to ensure access is strictly controlled.",
    "rationale": "Documenting access control decisions ensures accountability and provides an audit trail for authorization.",
    "stig_id": "GEN-00-000241"
  },
  {
    "control_id": "AC-24.2",
    "control_name": "No User or Process Identity",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Enforce access control decisions based on [automated mechanism] that do not include the identity of the user or process acting on behalf of the user.",
    "parent_control": "ac-24",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "Enforce access control decisions based on [automated mechanism] that do not include the identity of the user or process acting on behalf of the user.",
    "example_implementation": "Community contribution needed",
    "non_technical_guidance": "Awaiting implementation guidance",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [],
    "supplemental_guidance": "",
    "implementation_scripts": {
      "linux": {},
      "windows": {}
    },
    "metadata": {
      "status": "pending_implementation",
      "last_updated": "2025-11-09T12:31:24.141408+00:00",
      "has_scripts": true,
      "stig_id": "GEN-00-000242"
    },
    "cac_metadata": {
      "implementation_type": "pending",
      "last_analyzed": "2025-11-10T09:38:29.488899+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "pending",
      "cac_planned": true,
      "implementation_guidance": "Automated implementation planned but not yet available in ComplianceAsCode repository."
    },
    "ai_guidance": "Implement and enforce No User or Process Identity according to organization policies to ensure access is strictly controlled.",
    "rationale": "Automated mechanisms for access control decisions reduce human error and improve the speed of authorization.",
    "stig_id": "GEN-00-000242"
  },
  {
    "control_id": "AC-25",
    "control_name": "Reference Monitor",
    "family": "Access Control",
    "family_id": "ac",
    "official_text": "Implement a reference monitor for [Assignment: organization-defined access control policies] that is tamperproof, always invoked, and small enough to be subject to analysis and testing, the completeness of which can be assured.",
    "source": "NIST SP 800-53 Rev 5",
    "baselines": {
      "low": false,
      "moderate": false,
      "high": false
    },
    "plain_english_explanation": "A reference monitor is a core security component of the operating system that enforces access control policies on all subjects (processes, users) and objects (files, resources). It must meet three critical properties: (1) tamperproof - cannot be modified or compromised by adversaries, (2) always invoked - mediates every access request without bypass, and (3) verifiable - small enough to be thoroughly analyzed and tested for completeness. In Linux systems, SELinux and AppArmor serve as reference monitors by implementing mandatory access control (MAC) at the kernel level.",
    "example_implementation": "Enable and enforce SELinux in enforcing mode with the targeted policy. Verify SELinux state: 'getenforce' returns 'Enforcing'. Configure /etc/selinux/config with 'SELINUX=enforcing' and 'SELINUXTYPE=targeted'. Ensure the libselinux package is installed. Prevent SELinux bypass via kernel parameters by removing 'selinux=0' or 'enforcing=0' from bootloader configuration (/etc/default/grub and /etc/grub.d/). Audit all modifications to MAC policy files using auditd rules monitoring /etc/selinux/ with 'perm=wa'. Run 'fixfiles onboot' and reboot to apply labels. For AppArmor systems, ensure profiles are in enforce or complain mode.",
    "non_technical_guidance": "To implement the AC-25 Reference Monitor control:\n\n1. **Enable Mandatory Access Control (MAC)**: Deploy SELinux (Red Hat/CentOS) or AppArmor (Ubuntu/Debian) as the reference validation mechanism. This provides kernel-level enforcement that cannot be bypassed by user-space processes.\n\n2. **Verify Tamperproof Property**: Ensure the MAC system runs in enforcing mode (not permissive or disabled). Protect bootloader configuration to prevent adversaries from disabling the reference monitor via kernel parameters.\n\n3. **Verify Always Invoked Property**: Confirm every access decision passes through the MAC system by reviewing audit logs and testing policy enforcement. No subjects should operate in unconfined domains unless explicitly required and documented.\n\n4. **Verify Verifiable Property**: Use well-established MAC policies (e.g., SELinux targeted policy) that have undergone extensive security analysis. Document the policy architecture and conduct periodic reviews.\n\n5. **Monitor and Audit**: Configure audit rules to detect any modifications to MAC policies, ensuring the integrity of the reference monitor is maintained.\n\n6. **Organizational Policy Definition**: Define which access control policies the reference monitor will enforce (e.g., role-based access control, multi-level security, data flow control).\n\n7. **Testing and Validation**: Regularly test the reference monitor implementation to verify it correctly enforces policies under all conditions, including edge cases and adversarial scenarios.\n\n8. **Documentation**: Maintain comprehensive documentation of the reference monitor architecture, policies enforced, and verification procedures for audit and compliance purposes.",
    "is_technical": true,
    "enhancements": [],
    "related_controls": [
      "AC-3",
      "AC-16",
      "SA-8",
      "SA-17",
      "SC-3",
      "SC-11",
      "SC-39",
      "SI-13"
    ],
    "supplemental_guidance": "The reference monitor concept, as defined in the Anderson Report (1972), is a fundamental principle of secure system design. It operates as an abstract machine that mediates all access decisions between subjects and objects according to a security policy.\n\nThe three essential properties ensure:\n- **Tamperproof**: Prevents adversaries from modifying the validation mechanism to bypass security policies. Typically achieved through kernel-level implementation with hardware protection.\n- **Always Invoked**: Prevents time-of-check-time-of-use (TOCTOU) attacks and ensures no covert channels exist to bypass the monitor. Every access path must be mediated.\n- **Verifiable**: Enables formal or rigorous analysis to prove the monitor correctly implements the security policy. Complexity is the enemy of security; smaller implementations are more analyzable.\n\nIn modern systems, Security-Enhanced Linux (SELinux) and AppArmor represent practical implementations of the reference monitor concept through kernel-level mandatory access control. These systems enforce type enforcement, role-based access control, and multi-level security policies that supplement traditional discretionary access control.\n\nOrganizations must define which access control policies the reference monitor enforces based on their security requirements. Common policies include: mandatory access control (MAC), role-based access control (RBAC), multi-level security (MLS), and information flow control.\n\nRelated architectural controls include SC-3 (Security Function Isolation) which ensures the reference monitor is isolated from other system components, and SA-8 (Security and Privacy Engineering Principles) which addresses secure design from inception.",
    "implementation_scripts": {
      "linux": {
        "selinux_state": "#!/bin/bash\n# Set SELinux to enforcing mode\n# Platform: RHEL, Fedora, CentOS, AlmaLinux, Rocky Linux\n# Reboot: Required\n# Complexity: Low\n# Disruption: Low\n\nvar_selinux_state=\"enforcing\"\n\n# Configure /etc/selinux/config\nif [ -f /etc/selinux/config ]; then\n    sed -i \"s/^SELINUX=.*/SELINUX=${var_selinux_state}/\" /etc/selinux/config\n    if ! grep -q \"^SELINUX=\" /etc/selinux/config; then\n        echo \"SELINUX=${var_selinux_state}\" >> /etc/selinux/config\n    fi\nfi\n\n# Ensure file contexts are correct on next boot\nfixfiles onboot\n\necho \"[INFO] SELinux configured to ${var_selinux_state} mode. Reboot required.\"",
        "selinux_policytype": "#!/bin/bash\n# Configure SELinux policy type\n# Platform: RHEL, Fedora, CentOS, AlmaLinux, Rocky Linux\n# Reboot: Required\n# Complexity: Low\n# Disruption: Low\n\nvar_selinux_policy_name=\"targeted\"\n\n# Configure /etc/selinux/config\nif [ -f /etc/selinux/config ]; then\n    sed -i \"s/^SELINUXTYPE=.*/SELINUXTYPE=${var_selinux_policy_name}/\" /etc/selinux/config\n    if ! grep -q \"^SELINUXTYPE=\" /etc/selinux/config; then\n        echo \"SELINUXTYPE=${var_selinux_policy_name}\" >> /etc/selinux/config\n    fi\nfi\n\necho \"[INFO] SELinux policy set to ${var_selinux_policy_name}. Reboot required.\"",
        "grub2_enable_selinux": "#!/bin/bash\n# Prevent SELinux bypass via kernel parameters\n# Platform: RHEL, Fedora, CentOS, AlmaLinux, Rocky Linux\n# Reboot: Required\n# Complexity: Low\n# Disruption: Low\n\n# Remove selinux=0 and enforcing=0 from grub configuration\nfor file in /etc/default/grub /etc/grub.d/*; do\n    if [ -f \"$file\" ]; then\n        sed -i 's/\\(selinux\\|enforcing\\)=0//g' \"$file\"\n    fi\ndone\n\n# Regenerate grub configuration\nif [ -f /etc/grub2.cfg ]; then\n    grub2-mkconfig -o /etc/grub2.cfg\nelif [ -f /boot/grub2/grub.cfg ]; then\n    grub2-mkconfig -o /boot/grub2/grub.cfg\nelif [ -f /boot/efi/EFI/*/grub.cfg ]; then\n    grub2-mkconfig -o /boot/efi/EFI/*/grub.cfg\nfi\n\necho \"[INFO] SELinux kernel bypass parameters removed. Reboot required.\"",
        "package_libselinux_installed": "#!/bin/bash\n# Install libselinux package\n# Platform: RHEL, Fedora, CentOS, AlmaLinux, Rocky Linux\n# Reboot: Not required\n# Complexity: Low\n# Disruption: Low\n\nif ! rpm -q libselinux &>/dev/null; then\n    yum install -y libselinux || dnf install -y libselinux\n    echo \"[INFO] libselinux package installed.\"\nelse\n    echo \"[INFO] libselinux package already installed.\"\nfi",
        "audit_rules_mac_modification": "#!/bin/bash\n# Audit modifications to MAC policy\n# Platform: RHEL, Fedora, CentOS, AlmaLinux, Rocky Linux\n# Reboot: Not required\n# Complexity: Low\n# Disruption: Low\n\nAUDIT_RULE=\"-w /etc/selinux/ -p wa -k MAC-policy\"\n\n# Add audit rule\nif [ -d /etc/audit/rules.d ]; then\n    echo \"$AUDIT_RULE\" > /etc/audit/rules.d/mac-policy.rules\n    service auditd restart\n    echo \"[INFO] Audit rule for MAC policy modifications added.\"\nelse\n    echo \"[ERROR] /etc/audit/rules.d not found. Install auditd.\"\n    exit 1\nfi"
      },
      "windows": {}
    },
    "metadata": {
      "status": "corrected",
      "last_updated": "2025-11-20T00:00:00+00:00",
      "has_scripts": true,
      "stig_id": "AC-25",
      "corrected_by": "LOVELESS_QA",
      "defects_found": [
        "is_technical incorrectly set to false",
        "plain_english_explanation oversimplified and missing critical properties",
        "example_implementation vague and non-technical",
        "related_controls empty (should include AC-3, SC-3, SC-11, SA-8, SA-17, SC-39, SI-13)",
        "implementation_scripts empty for Linux despite CAC availability",
        "supplemental_guidance missing entirely",
        "official_text contains placeholder instead of assignment parameter"
      ]
    },
    "cac_metadata": {
      "implementation_type": "technical",
      "last_analyzed": "2025-11-20T00:00:00+00:00",
      "source": "ComplianceAsCode",
      "cac_status": "implemented",
      "cac_planned": true,
      "implementation_guidance": "Reference monitor implemented via SELinux mandatory access control. CAC provides selinux_state, selinux_policytype, grub2_enable_selinux, package_libselinux_installed, and audit_rules_mac_modification rules.",
      "cac_rules_used": [
        "selinux_state",
        "selinux_policytype",
        "grub2_enable_selinux",
        "package_libselinux_installed",
        "package_policycoreutils_installed",
        "audit_rules_mac_modification",
        "selinux_all_devicefiles_labeled",
        "selinux_confinement_of_daemons"
      ]
    },
    "ai_guidance": "Implement SELinux in enforcing mode with targeted policy to serve as the reference monitor. Verify tamperproof property via kernel protection, always-invoked property via mandatory access control enforcement on all processes, and verifiable property via established policy analysis. Audit all MAC policy modifications.",
    "implementation_guidance": "This control is implemented via kernel-level mandatory access control using SELinux (Red Hat/CentOS/Fedora) or AppArmor (Ubuntu/Debian). Refer to the Technical Implementation tab for automated deployment scripts. Manual verification: 'getenforce' should return 'Enforcing', 'sestatus' should show 'targeted' policy loaded.",
    "stig_id": "AC-25"
  }
]